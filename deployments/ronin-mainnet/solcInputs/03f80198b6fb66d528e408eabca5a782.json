{
  "language": "Solidity",
  "sources": {
    "contracts/extensions/bridge-operator-governance/BOsGovernanceProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/consumers/SignatureConsumer.sol\";\nimport \"../../libraries/BridgeOperatorsBallot.sol\";\nimport \"../../interfaces/IRoninGovernanceAdmin.sol\";\nimport \"../../libraries/IsolatedGovernance.sol\";\n\nabstract contract BOsGovernanceProposal is SignatureConsumer, IRoninGovernanceAdmin {\n  using IsolatedGovernance for IsolatedGovernance.Vote;\n\n  /// @dev The last the brige operator set info.\n  BridgeOperatorsBallot.BridgeOperatorSet internal _lastSyncedBridgeOperatorSetInfo;\n  /// @dev Mapping from period index => epoch index => bridge operators vote\n  mapping(uint256 => mapping(uint256 => IsolatedGovernance.Vote)) internal _bridgeOperatorVote;\n  /// @dev Mapping from bridge voter address => last block that the address voted\n  mapping(address => uint256) internal _lastVotedBlock;\n  /// @dev Mapping from period index => epoch index => voter => bridge voter signatures\n  mapping(uint256 => mapping(uint256 => mapping(address => Signature))) internal _bridgeVoterSig;\n\n  /**\n   * @inheritdoc IRoninGovernanceAdmin\n   */\n  function lastVotedBlock(address _bridgeVoter) external view returns (uint256) {\n    return _lastVotedBlock[_bridgeVoter];\n  }\n\n  /**\n   * @inheritdoc IRoninGovernanceAdmin\n   */\n  function lastSyncedBridgeOperatorSetInfo() external view returns (BridgeOperatorsBallot.BridgeOperatorSet memory) {\n    return _lastSyncedBridgeOperatorSetInfo;\n  }\n\n  /**\n   * @dev Votes for a set of bridge operators by signatures.\n   *\n   * Requirements:\n   * - The period of voting is larger than the last synced period.\n   * - The arrays are not empty.\n   * - The signature signers are in order.\n   *\n   */\n  function _castBOVotesBySignatures(\n    BridgeOperatorsBallot.BridgeOperatorSet calldata _ballot,\n    Signature[] calldata _signatures,\n    uint256 _minimumVoteWeight,\n    bytes32 _domainSeperator\n  ) internal {\n    require(\n      _ballot.period >= _lastSyncedBridgeOperatorSetInfo.period &&\n        _ballot.epoch >= _lastSyncedBridgeOperatorSetInfo.epoch,\n      \"BOsGovernanceProposal: query for outdated bridge operator set\"\n    );\n    BridgeOperatorsBallot.verifyBallot(_ballot);\n    require(_signatures.length > 0, \"BOsGovernanceProposal: invalid array length\");\n\n    address _signer;\n    address _lastSigner;\n    bytes32 _hash = BridgeOperatorsBallot.hash(_ballot);\n    bytes32 _digest = ECDSA.toTypedDataHash(_domainSeperator, _hash);\n    IsolatedGovernance.Vote storage _v = _bridgeOperatorVote[_ballot.period][_ballot.epoch];\n    mapping(address => Signature) storage _sigMap = _bridgeVoterSig[_ballot.period][_ballot.epoch];\n    bool _hasValidVotes;\n\n    for (uint256 _i; _i < _signatures.length; _i++) {\n      // Avoids stack too deeps\n      {\n        Signature calldata _sig = _signatures[_i];\n        _signer = ECDSA.recover(_digest, _sig.v, _sig.r, _sig.s);\n        require(_lastSigner < _signer, \"BOsGovernanceProposal: invalid signer order\");\n        _lastSigner = _signer;\n      }\n\n      if (_isBridgeVoter(_signer)) {\n        _hasValidVotes = true;\n        _lastVotedBlock[_signer] = block.number;\n        _sigMap[_signer] = _signatures[_i];\n        _v.castVote(_signer, _hash);\n      }\n    }\n\n    require(_hasValidVotes, \"BOsGovernanceProposal: invalid signatures\");\n    address[] memory _filteredVoters = _v.filterByHash(_hash);\n    _v.syncVoteStatus(_minimumVoteWeight, _sumBridgeVoterWeights(_filteredVoters), 0, 0, _hash);\n  }\n\n  /**\n   * @dev Returns whether the address is the bridge voter.\n   */\n  function _isBridgeVoter(address) internal view virtual returns (bool);\n\n  /**\n   * @dev Returns the weight of many bridge voters.\n   */\n  function _sumBridgeVoterWeights(address[] memory _bridgeVoters) internal view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/consumers/SignatureConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface SignatureConsumer {\n  struct Signature {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n}\n"
    },
    "contracts/libraries/BridgeOperatorsBallot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nlibrary BridgeOperatorsBallot {\n  struct BridgeOperatorSet {\n    uint256 period;\n    uint256 epoch;\n    address[] operators;\n  }\n\n  // keccak256(\"BridgeOperatorsBallot(uint256 period,uint256 epoch,address[] operators)\");\n  bytes32 public constant BRIDGE_OPERATORS_BALLOT_TYPEHASH =\n    0xd679a49e9e099fa9ed83a5446aaec83e746b03ec6723d6f5efb29d37d7f0b78a;\n\n  /**\n   * @dev Verifies whether the ballot is valid or not.\n   *\n   * Requirements:\n   * - The ballot is not for an empty operator set.\n   * - The operator address list is in order.\n   *\n   */\n  function verifyBallot(BridgeOperatorSet calldata _ballot) internal pure {\n    require(_ballot.operators.length > 0, \"BridgeOperatorsBallot: invalid array length\");\n    address _addr = _ballot.operators[0];\n    for (uint _i = 1; _i < _ballot.operators.length; _i++) {\n      require(_addr < _ballot.operators[_i], \"BridgeOperatorsBallot: invalid order of bridge operators\");\n      _addr = _ballot.operators[_i];\n    }\n  }\n\n  /**\n   * @dev Returns hash of the ballot.\n   */\n  function hash(BridgeOperatorSet calldata _ballot) internal pure returns (bytes32) {\n    bytes32 _operatorsHash;\n    address[] memory _operators = _ballot.operators;\n\n    assembly {\n      _operatorsHash := keccak256(add(_operators, 32), mul(mload(_operators), 32))\n    }\n\n    return keccak256(abi.encode(BRIDGE_OPERATORS_BALLOT_TYPEHASH, _ballot.period, _ballot.epoch, _operatorsHash));\n  }\n}\n"
    },
    "contracts/interfaces/IRoninGovernanceAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../libraries/BridgeOperatorsBallot.sol\";\n\ninterface IRoninGovernanceAdmin {\n  /// @dev Emitted when the bridge operators are approved.\n  event BridgeOperatorsApproved(uint256 _period, uint256 _epoch, address[] _operators);\n  /// @dev Emitted when an emergency exit poll is created.\n  event EmergencyExitPollCreated(\n    bytes32 _voteHash,\n    address _consensusAddr,\n    address _recipientAfterUnlockedFund,\n    uint256 _requestedAt,\n    uint256 _expiredAt\n  );\n  /// @dev Emitted when an emergency exit poll is approved.\n  event EmergencyExitPollApproved(bytes32 _voteHash);\n  /// @dev Emitted when an emergency exit poll is expired.\n  event EmergencyExitPollExpired(bytes32 _voteHash);\n\n  /**\n   * @dev Returns the last voted block of the bridge voter.\n   */\n  function lastVotedBlock(address _bridgeVoter) external view returns (uint256);\n\n  /**\n   * @dev Returns the synced bridge operator set info.\n   */\n  function lastSyncedBridgeOperatorSetInfo()\n    external\n    view\n    returns (BridgeOperatorsBallot.BridgeOperatorSet memory _bridgeOperatorSetInfo);\n\n  /**\n   * @dev Create a vote to agree that an emergency exit is valid and should return the locked funds back.a\n   *\n   * Requirements:\n   * - The method caller is validator contract.\n   *\n   */\n  function createEmergencyExitPoll(\n    address _consensusAddr,\n    address _recipientAfterUnlockedFund,\n    uint256 _requestedAt,\n    uint256 _expiredAt\n  ) external;\n}\n"
    },
    "contracts/libraries/IsolatedGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../interfaces/consumers/VoteStatusConsumer.sol\";\n\nlibrary IsolatedGovernance {\n  struct Vote {\n    VoteStatusConsumer.VoteStatus status;\n    bytes32 finalHash;\n    /// @dev Mapping from voter => receipt hash\n    mapping(address => bytes32) voteHashOf;\n    /// @dev The timestamp that voting is expired (no expiration=0)\n    uint256 expiredAt;\n    /// @dev The timestamp that voting is created\n    uint256 createdAt;\n    /// @dev The list of voters\n    address[] voters;\n  }\n\n  /**\n   * @dev Casts vote for the receipt with the receipt hash `_hash`.\n   *\n   * Requirements:\n   * - The voter has not voted for the round.\n   *\n   */\n  function castVote(\n    Vote storage _v,\n    address _voter,\n    bytes32 _hash\n  ) internal {\n    if (_v.expiredAt > 0 && _v.expiredAt <= block.timestamp) {\n      _v.status = VoteStatusConsumer.VoteStatus.Expired;\n    }\n\n    if (voted(_v, _voter)) {\n      revert(\n        string(abi.encodePacked(\"IsolatedGovernance: \", Strings.toHexString(uint160(_voter), 20), \" already voted\"))\n      );\n    }\n\n    _v.voteHashOf[_voter] = _hash;\n    _v.voters.push(_voter);\n  }\n\n  /**\n   * @dev Updates vote with the requirement of minimum vote weight.\n   */\n  function syncVoteStatus(\n    Vote storage _v,\n    uint256 _minimumVoteWeight,\n    uint256 _votedWeightForHash,\n    uint256 _minimumTrustedVoteWeight,\n    uint256 _trustedVotedWeightForHash,\n    bytes32 _hash\n  ) internal returns (VoteStatusConsumer.VoteStatus _status) {\n    if (\n      _votedWeightForHash >= _minimumVoteWeight &&\n      _trustedVotedWeightForHash >= _minimumTrustedVoteWeight &&\n      _v.status == VoteStatusConsumer.VoteStatus.Pending\n    ) {\n      _v.status = VoteStatusConsumer.VoteStatus.Approved;\n      _v.finalHash = _hash;\n    }\n\n    return _v.status;\n  }\n\n  /**\n   * @dev Returns the list of vote's addresses that voted for the hash `_hash`.\n   */\n  function filterByHash(Vote storage _v, bytes32 _hash) internal view returns (address[] memory _voters) {\n    uint256 _count;\n    _voters = new address[](_v.voters.length);\n\n    for (uint _i; _i < _voters.length; _i++) {\n      address _voter = _v.voters[_i];\n      if (_v.voteHashOf[_voter] == _hash) {\n        _voters[_count++] = _voter;\n      }\n    }\n\n    assembly {\n      mstore(_voters, _count)\n    }\n  }\n\n  /**\n   * @dev Returns whether the voter casted for the proposal.\n   */\n  function voted(Vote storage _v, address _voter) internal view returns (bool) {\n    return _v.voteHashOf[_voter] != bytes32(0);\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/interfaces/consumers/VoteStatusConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VoteStatusConsumer {\n  enum VoteStatus {\n    Pending,\n    Approved,\n    Executed,\n    Rejected,\n    Expired\n  }\n}\n"
    },
    "contracts/ronin/RoninGovernanceAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../extensions/bridge-operator-governance/BOsGovernanceProposal.sol\";\nimport \"../extensions/sequential-governance/GovernanceProposal.sol\";\nimport \"../extensions/collections/HasValidatorContract.sol\";\nimport \"../extensions/GovernanceAdmin.sol\";\nimport \"../libraries/EmergencyExitBallot.sol\";\nimport \"../interfaces/IRoninGovernanceAdmin.sol\";\n\ncontract RoninGovernanceAdmin is\n  IRoninGovernanceAdmin,\n  GovernanceAdmin,\n  GovernanceProposal,\n  BOsGovernanceProposal,\n  HasValidatorContract\n{\n  using Proposal for Proposal.ProposalDetail;\n  using IsolatedGovernance for IsolatedGovernance.Vote;\n\n  /// @dev Mapping from request hash => emergency poll\n  mapping(bytes32 => IsolatedGovernance.Vote) internal _emergencyExitPoll;\n\n  modifier onlyGovernor() {\n    require(_getWeight(msg.sender) > 0, \"RoninGovernanceAdmin: sender is not governor\");\n    _;\n  }\n\n  constructor(\n    uint256 _roninChainId,\n    address _roninTrustedOrganizationContract,\n    address _bridgeContract,\n    address _validatorContract,\n    uint256 _proposalExpiryDuration\n  ) GovernanceAdmin(_roninChainId, _roninTrustedOrganizationContract, _bridgeContract, _proposalExpiryDuration) {\n    _setValidatorContract(_validatorContract);\n  }\n\n  /**\n   * @inheritdoc IHasValidatorContract\n   */\n  function setValidatorContract(address _addr) external override onlySelfCall {\n    require(_addr.code.length > 0, \"RoninGovernanceAdmin: set to non-contract\");\n    _setValidatorContract(_addr);\n  }\n\n  /**\n   * @dev Returns the voted signatures for the proposals.\n   *\n   * Note: The signatures can be empty in case the proposal is voted on the current network.\n   *\n   */\n  function getProposalSignatures(uint256 _chainId, uint256 _round)\n    external\n    view\n    returns (\n      address[] memory _voters,\n      Ballot.VoteType[] memory _supports,\n      Signature[] memory _signatures\n    )\n  {\n    ProposalVote storage _vote = vote[_chainId][_round];\n\n    uint256 _forLength = _vote.forVoteds.length;\n    uint256 _againstLength = _vote.againstVoteds.length;\n    uint256 _voterLength = _forLength + _againstLength;\n\n    _supports = new Ballot.VoteType[](_voterLength);\n    _signatures = new Signature[](_voterLength);\n    _voters = new address[](_voterLength);\n    for (uint256 _i; _i < _forLength; _i++) {\n      _supports[_i] = Ballot.VoteType.For;\n      _signatures[_i] = vote[_chainId][_round].sig[_vote.forVoteds[_i]];\n      _voters[_i] = _vote.forVoteds[_i];\n    }\n    for (uint256 _i; _i < _againstLength; _i++) {\n      _supports[_i + _forLength] = Ballot.VoteType.Against;\n      _signatures[_i + _forLength] = vote[_chainId][_round].sig[_vote.againstVoteds[_i]];\n      _voters[_i + _forLength] = _vote.againstVoteds[_i];\n    }\n  }\n\n  /**\n   * @dev Returns the voted signatures for bridge operators at a specific period.\n   */\n  function getBridgeOperatorVotingSignatures(uint256 _period, uint256 _epoch)\n    external\n    view\n    returns (address[] memory _voters, Signature[] memory _signatures)\n  {\n    mapping(address => Signature) storage _sigMap = _bridgeVoterSig[_period][_epoch];\n    _voters = _bridgeOperatorVote[_period][_epoch].voters;\n    _signatures = new Signature[](_voters.length);\n    for (uint _i; _i < _voters.length; _i++) {\n      _signatures[_i] = _sigMap[_voters[_i]];\n    }\n  }\n\n  /**\n   * @dev Returns whether the voter `_voter` casted vote for the proposal.\n   */\n  function proposalVoted(\n    uint256 _chainId,\n    uint256 _round,\n    address _voter\n  ) external view returns (bool) {\n    return _voted(vote[_chainId][_round], _voter);\n  }\n\n  /**\n   * @dev Returns whether the voter `_voter` casted vote for bridge operators at a specific period.\n   */\n  function bridgeOperatorsVoted(\n    uint256 _period,\n    uint256 _epoch,\n    address _voter\n  ) external view returns (bool) {\n    return _bridgeOperatorVote[_period][_epoch].voted(_voter);\n  }\n\n  /**\n   * @dev Returns whether the voter casted vote for emergency exit poll.\n   */\n  function emergencyPollVoted(bytes32 _voteHash, address _voter) external view returns (bool) {\n    return _emergencyExitPoll[_voteHash].voted(_voter);\n  }\n\n  /**\n   * @dev See `CoreGovernance-_proposeProposal`.\n   *\n   * Requirements:\n   * - The method caller is governor.\n   *\n   */\n  function propose(\n    uint256 _chainId,\n    uint256 _expiryTimestamp,\n    address[] calldata _targets,\n    uint256[] calldata _values,\n    bytes[] calldata _calldatas,\n    uint256[] calldata _gasAmounts\n  ) external onlyGovernor {\n    _proposeProposal(_chainId, _expiryTimestamp, _targets, _values, _calldatas, _gasAmounts, msg.sender);\n  }\n\n  /**\n   * @dev See `GovernanceProposal-_proposeProposalStructAndCastVotes`.\n   *\n   * Requirements:\n   * - The method caller is governor.\n   * - The proposal is for the current network.\n   *\n   */\n  function proposeProposalStructAndCastVotes(\n    Proposal.ProposalDetail calldata _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures\n  ) external onlyGovernor {\n    _proposeProposalStructAndCastVotes(_proposal, _supports, _signatures, DOMAIN_SEPARATOR, msg.sender);\n  }\n\n  /**\n   * @dev Proposes and casts vote for a proposal on the current network.\n   *\n   * Requirements:\n   * - The method caller is governor.\n   * - The proposal is for the current network.\n   *\n   */\n  function proposeProposalForCurrentNetwork(\n    uint256 _expiryTimestamp,\n    address[] calldata _targets,\n    uint256[] calldata _values,\n    bytes[] calldata _calldatas,\n    uint256[] calldata _gasAmounts,\n    Ballot.VoteType _support\n  ) external onlyGovernor {\n    address _voter = msg.sender;\n    Proposal.ProposalDetail memory _proposal = _proposeProposal(\n      block.chainid,\n      _expiryTimestamp,\n      _targets,\n      _values,\n      _calldatas,\n      _gasAmounts,\n      _voter\n    );\n    _castProposalVoteForCurrentNetwork(_voter, _proposal, _support);\n  }\n\n  /**\n   * @dev Casts vote for a proposal on the current network.\n   *\n   * Requirements:\n   * - The method caller is governor.\n   *\n   */\n  function castProposalVoteForCurrentNetwork(Proposal.ProposalDetail calldata _proposal, Ballot.VoteType _support)\n    external\n    onlyGovernor\n  {\n    _castProposalVoteForCurrentNetwork(msg.sender, _proposal, _support);\n  }\n\n  /**\n   * @dev See `GovernanceProposal-_castProposalBySignatures`.\n   */\n  function castProposalBySignatures(\n    Proposal.ProposalDetail calldata _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures\n  ) external {\n    _castProposalBySignatures(_proposal, _supports, _signatures, DOMAIN_SEPARATOR);\n  }\n\n  /**\n   * @dev See `CoreGovernance-_proposeGlobal`.\n   *\n   * Requirements:\n   * - The method caller is governor.\n   *\n   */\n  function proposeGlobal(\n    uint256 _expiryTimestamp,\n    GlobalProposal.TargetOption[] calldata _targetOptions,\n    uint256[] calldata _values,\n    bytes[] calldata _calldatas,\n    uint256[] calldata _gasAmounts\n  ) external onlyGovernor {\n    _proposeGlobal(\n      _expiryTimestamp,\n      _targetOptions,\n      _values,\n      _calldatas,\n      _gasAmounts,\n      roninTrustedOrganizationContract(),\n      bridgeContract(),\n      msg.sender\n    );\n  }\n\n  /**\n   * @dev See `GovernanceProposal-_proposeGlobalProposalStructAndCastVotes`.\n   *\n   * Requirements:\n   * - The method caller is governor.\n   *\n   */\n  function proposeGlobalProposalStructAndCastVotes(\n    GlobalProposal.GlobalProposalDetail calldata _globalProposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures\n  ) external onlyGovernor {\n    _proposeGlobalProposalStructAndCastVotes(\n      _globalProposal,\n      _supports,\n      _signatures,\n      DOMAIN_SEPARATOR,\n      roninTrustedOrganizationContract(),\n      bridgeContract(),\n      msg.sender\n    );\n  }\n\n  /**\n   * @dev See `GovernanceProposal-_castGlobalProposalBySignatures`.\n   */\n  function castGlobalProposalBySignatures(\n    GlobalProposal.GlobalProposalDetail calldata _globalProposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures\n  ) external {\n    _castGlobalProposalBySignatures(\n      _globalProposal,\n      _supports,\n      _signatures,\n      DOMAIN_SEPARATOR,\n      roninTrustedOrganizationContract(),\n      bridgeContract()\n    );\n  }\n\n  /**\n   * @dev Deletes the expired proposal by its chainId and nonce, without creating a new proposal.\n   *\n   * Requirements:\n   * - The proposal is already created.\n   *\n   */\n  function deleteExpired(uint256 _chainId, uint256 _round) external {\n    ProposalVote storage _vote = vote[_chainId][_round];\n    require(_vote.hash != bytes32(0), \"RoninGovernanceAdmin: query for empty voting\");\n    _tryDeleteExpiredVotingRound(_vote);\n  }\n\n  /**\n   * @dev See `BOsGovernanceProposal-_castVotesBySignatures`.\n   */\n  function voteBridgeOperatorsBySignatures(\n    BridgeOperatorsBallot.BridgeOperatorSet calldata _ballot,\n    Signature[] calldata _signatures\n  ) external {\n    _castBOVotesBySignatures(_ballot, _signatures, _getMinimumVoteWeight(), DOMAIN_SEPARATOR);\n    IsolatedGovernance.Vote storage _v = _bridgeOperatorVote[_ballot.period][_ballot.epoch];\n    if (_v.status == VoteStatus.Approved) {\n      _lastSyncedBridgeOperatorSetInfo = _ballot;\n      emit BridgeOperatorsApproved(_ballot.period, _ballot.epoch, _ballot.operators);\n      _v.status = VoteStatus.Executed;\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninGovernanceAdmin\n   */\n  function createEmergencyExitPoll(\n    address _consensusAddr,\n    address _recipientAfterUnlockedFund,\n    uint256 _requestedAt,\n    uint256 _expiredAt\n  ) external onlyValidatorContract {\n    bytes32 _hash = EmergencyExitBallot.hash(_consensusAddr, _recipientAfterUnlockedFund, _requestedAt, _expiredAt);\n    IsolatedGovernance.Vote storage _v = _emergencyExitPoll[_hash];\n    _v.createdAt = block.timestamp;\n    _v.expiredAt = _expiredAt;\n    emit EmergencyExitPollCreated(_hash, _consensusAddr, _recipientAfterUnlockedFund, _requestedAt, _expiredAt);\n  }\n\n  /**\n   * @dev Votes for an emergency exit. Executes to unlock fund for the emergency exit's requester.\n   *\n   * Requirements:\n   * - The voter is governor.\n   * - The voting is existent.\n   * - The voting is not expired yet.\n   *\n   */\n  function voteEmergencyExit(\n    bytes32 _voteHash,\n    address _consensusAddr,\n    address _recipientAfterUnlockedFund,\n    uint256 _requestedAt,\n    uint256 _expiredAt\n  ) external onlyGovernor {\n    address _voter = msg.sender;\n    bytes32 _hash = EmergencyExitBallot.hash(_consensusAddr, _recipientAfterUnlockedFund, _requestedAt, _expiredAt);\n    require(_voteHash == _hash, \"RoninGovernanceAdmin: invalid vote hash\");\n\n    IsolatedGovernance.Vote storage _v = _emergencyExitPoll[_hash];\n    require(_v.createdAt > 0, \"RoninGovernanceAdmin: query for non-existent vote\");\n    require(_v.status != VoteStatus.Expired, \"RoninGovernanceAdmin: query for expired vote\");\n\n    _v.castVote(_voter, _hash);\n    address[] memory _voters = _v.filterByHash(_hash);\n    VoteStatus _stt = _v.syncVoteStatus(_getMinimumVoteWeight(), _sumGovernorWeights(_voters), 0, 0, _hash);\n    if (_stt == VoteStatus.Approved) {\n      _execReleaseLockedFundForEmergencyExitRequest(_consensusAddr, _recipientAfterUnlockedFund);\n      emit EmergencyExitPollApproved(_hash);\n      _v.status = VoteStatus.Executed;\n    } else if (_stt == VoteStatus.Expired) {\n      emit EmergencyExitPollExpired(_hash);\n    }\n  }\n\n  /**\n   * @inheritdoc GovernanceProposal\n   */\n  function _getWeight(address _governor) internal view virtual override returns (uint256) {\n    bytes4 _selector = IRoninTrustedOrganization.getGovernorWeight.selector;\n    (bool _success, bytes memory _returndata) = roninTrustedOrganizationContract().staticcall(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector, _governor)\n      )\n    );\n    if (!_success) revert ErrProxyCallFailed(_selector);\n    return abi.decode(_returndata, (uint256));\n  }\n\n  /**\n   * @dev Returns the total weight of a list address of governors.\n   */\n  function _sumGovernorWeights(address[] memory _governors) internal view virtual returns (uint256) {\n    bytes4 _selector = IRoninTrustedOrganization.sumGovernorWeights.selector;\n    (bool _success, bytes memory _returndata) = roninTrustedOrganizationContract().staticcall(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector, _governors)\n      )\n    );\n    if (!_success) revert ErrProxyCallFailed(_selector);\n    return abi.decode(_returndata, (uint256));\n  }\n\n  /**\n   * @dev Returns the bridge voter weight.\n   */\n  function _getBridgeVoterWeight(address _governor) internal view virtual returns (uint256) {\n    bytes4 _selector = IRoninTrustedOrganization.getBridgeVoterWeight.selector;\n    (bool _success, bytes memory _returndata) = roninTrustedOrganizationContract().staticcall(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector, _governor)\n      )\n    );\n    if (!_success) revert ErrProxyCallFailed(_selector);\n    return abi.decode(_returndata, (uint256));\n  }\n\n  /**\n   * @inheritdoc BOsGovernanceProposal\n   */\n  function _isBridgeVoter(address _addr) internal view virtual override returns (bool) {\n    return _getBridgeVoterWeight(_addr) > 0;\n  }\n\n  /**\n   * @inheritdoc BOsGovernanceProposal\n   */\n  function _sumBridgeVoterWeights(address[] memory _bridgeVoters) internal view virtual override returns (uint256) {\n    bytes4 _selector = IRoninTrustedOrganization.sumBridgeVoterWeights.selector;\n    (bool _success, bytes memory _returndata) = roninTrustedOrganizationContract().staticcall(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector, _bridgeVoters)\n      )\n    );\n    if (!_success) revert ErrProxyCallFailed(_selector);\n    return abi.decode(_returndata, (uint256));\n  }\n\n  /**\n   * @dev Trigger function from validator contract to unlock fund for emeregency exit request.\n   */\n  function _execReleaseLockedFundForEmergencyExitRequest(address _consensusAddr, address _recipientAfterUnlockedFund)\n    internal\n    virtual\n  {\n    bytes4 _selector = _validatorContract.execReleaseLockedFundForEmergencyExitRequest.selector;\n    (bool _success, ) = validatorContract().call(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector, _consensusAddr, _recipientAfterUnlockedFund)\n      )\n    );\n    if (!_success) revert ErrProxyCallFailed(_selector);\n  }\n\n  /**\n   * @dev See `CoreGovernance-_getChainType`.\n   */\n  function _getChainType() internal pure override returns (ChainType) {\n    return ChainType.RoninChain;\n  }\n\n  /**\n   * @dev See `castProposalVoteForCurrentNetwork`.\n   */\n  function _castProposalVoteForCurrentNetwork(\n    address _voter,\n    Proposal.ProposalDetail memory _proposal,\n    Ballot.VoteType _support\n  ) internal {\n    require(_proposal.chainId == block.chainid, \"RoninGovernanceAdmin: invalid chain id\");\n    require(\n      vote[_proposal.chainId][_proposal.nonce].hash == _proposal.hash(),\n      \"RoninGovernanceAdmin: cast vote for invalid proposal\"\n    );\n\n    uint256 _minimumForVoteWeight = _getMinimumVoteWeight();\n    uint256 _minimumAgainstVoteWeight = _getTotalWeights() - _minimumForVoteWeight + 1;\n    Signature memory _emptySignature;\n    _castVote(\n      _proposal,\n      _support,\n      _minimumForVoteWeight,\n      _minimumAgainstVoteWeight,\n      _voter,\n      _emptySignature,\n      _getWeight(_voter)\n    );\n  }\n}\n"
    },
    "contracts/extensions/sequential-governance/GovernanceProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./CoreGovernance.sol\";\n\nabstract contract GovernanceProposal is CoreGovernance {\n  using Proposal for Proposal.ProposalDetail;\n  using GlobalProposal for GlobalProposal.GlobalProposalDetail;\n\n  /**\n   * @dev Casts votes by signatures.\n   *\n   * Note: This method does not verify the proposal hash with the vote hash. Please consider checking it before.\n   *\n   */\n  function _castVotesBySignatures(\n    Proposal.ProposalDetail memory _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures,\n    bytes32 _forDigest,\n    bytes32 _againstDigest\n  ) internal {\n    require(_supports.length > 0 && _supports.length == _signatures.length, \"GovernanceProposal: invalid array length\");\n    uint256 _minimumForVoteWeight = _getMinimumVoteWeight();\n    uint256 _minimumAgainstVoteWeight = _getTotalWeights() - _minimumForVoteWeight + 1;\n\n    address _lastSigner;\n    address _signer;\n    Signature calldata _sig;\n    bool _hasValidVotes;\n    for (uint256 _i; _i < _signatures.length; _i++) {\n      _sig = _signatures[_i];\n\n      if (_supports[_i] == Ballot.VoteType.For) {\n        _signer = ECDSA.recover(_forDigest, _sig.v, _sig.r, _sig.s);\n      } else if (_supports[_i] == Ballot.VoteType.Against) {\n        _signer = ECDSA.recover(_againstDigest, _sig.v, _sig.r, _sig.s);\n      } else {\n        revert(\"GovernanceProposal: query for unsupported vote type\");\n      }\n\n      require(_lastSigner < _signer, \"GovernanceProposal: invalid order\");\n      _lastSigner = _signer;\n\n      uint256 _weight = _getWeight(_signer);\n      if (_weight > 0) {\n        _hasValidVotes = true;\n        if (\n          _castVote(_proposal, _supports[_i], _minimumForVoteWeight, _minimumAgainstVoteWeight, _signer, _sig, _weight)\n        ) {\n          return;\n        }\n      }\n    }\n\n    require(_hasValidVotes, \"GovernanceProposal: invalid signatures\");\n  }\n\n  /**\n   * @dev Proposes a proposal struct and casts votes by signature.\n   */\n  function _proposeProposalStructAndCastVotes(\n    Proposal.ProposalDetail calldata _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures,\n    bytes32 _domainSeparator,\n    address _creator\n  ) internal {\n    _proposeProposalStruct(_proposal, _creator);\n    bytes32 _proposalHash = _proposal.hash();\n    _castVotesBySignatures(\n      _proposal,\n      _supports,\n      _signatures,\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_proposalHash, Ballot.VoteType.For)),\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_proposalHash, Ballot.VoteType.Against))\n    );\n  }\n\n  /**\n   * @dev Proposes a proposal struct and casts votes by signature.\n   */\n  function _castProposalBySignatures(\n    Proposal.ProposalDetail calldata _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures,\n    bytes32 _domainSeparator\n  ) internal {\n    bytes32 _proposalHash = _proposal.hash();\n    require(\n      vote[_proposal.chainId][_proposal.nonce].hash == _proposalHash,\n      \"GovernanceAdmin: cast vote for invalid proposal\"\n    );\n    _castVotesBySignatures(\n      _proposal,\n      _supports,\n      _signatures,\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_proposalHash, Ballot.VoteType.For)),\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_proposalHash, Ballot.VoteType.Against))\n    );\n  }\n\n  /**\n   * @dev Proposes and votes by signature.\n   */\n  function _proposeGlobalProposalStructAndCastVotes(\n    GlobalProposal.GlobalProposalDetail calldata _globalProposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures,\n    bytes32 _domainSeparator,\n    address _roninTrustedOrganizationContract,\n    address _gatewayContract,\n    address _creator\n  ) internal returns (Proposal.ProposalDetail memory _proposal) {\n    _proposal = _proposeGlobalStruct(_globalProposal, _roninTrustedOrganizationContract, _gatewayContract, _creator);\n    bytes32 _globalProposalHash = _globalProposal.hash();\n    _castVotesBySignatures(\n      _proposal,\n      _supports,\n      _signatures,\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_globalProposalHash, Ballot.VoteType.For)),\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_globalProposalHash, Ballot.VoteType.Against))\n    );\n  }\n\n  /**\n   * @dev Proposes a global proposal struct and casts votes by signature.\n   */\n  function _castGlobalProposalBySignatures(\n    GlobalProposal.GlobalProposalDetail calldata _globalProposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures,\n    bytes32 _domainSeparator,\n    address _roninTrustedOrganizationContract,\n    address _gatewayContract\n  ) internal {\n    Proposal.ProposalDetail memory _proposal = _globalProposal.into_proposal_detail(\n      _roninTrustedOrganizationContract,\n      _gatewayContract\n    );\n    bytes32 _globalProposalHash = _globalProposal.hash();\n    require(vote[0][_proposal.nonce].hash == _proposal.hash(), \"GovernanceAdmin: cast vote for invalid proposal\");\n    _castVotesBySignatures(\n      _proposal,\n      _supports,\n      _signatures,\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_globalProposalHash, Ballot.VoteType.For)),\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_globalProposalHash, Ballot.VoteType.Against))\n    );\n  }\n\n  /**\n   * @dev Returns the weight of a governor.\n   */\n  function _getWeight(address _governor) internal view virtual returns (uint256);\n}\n"
    },
    "contracts/extensions/collections/HasValidatorContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasValidatorContract.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\n\ncontract HasValidatorContract is IHasValidatorContract, HasProxyAdmin {\n  IRoninValidatorSet internal _validatorContract;\n\n  modifier onlyValidatorContract() {\n    if (validatorContract() != msg.sender) revert ErrCallerMustBeValidatorContract();\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasValidatorContract\n   */\n  function validatorContract() public view override returns (address) {\n    return address(_validatorContract);\n  }\n\n  /**\n   * @inheritdoc IHasValidatorContract\n   */\n  function setValidatorContract(address _addr) external virtual override onlyAdmin {\n    if (_addr.code.length == 0) revert ErrZeroCodeContract();\n    _setValidatorContract(_addr);\n  }\n\n  /**\n   * @dev Sets the validator contract.\n   *\n   * Emits the event `ValidatorContractUpdated`.\n   *\n   */\n  function _setValidatorContract(address _addr) internal {\n    _validatorContract = IRoninValidatorSet(_addr);\n    emit ValidatorContractUpdated(_addr);\n  }\n}\n"
    },
    "contracts/extensions/GovernanceAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../extensions/sequential-governance/CoreGovernance.sol\";\nimport \"../extensions/collections/HasRoninTrustedOrganizationContract.sol\";\nimport \"../extensions/collections/HasBridgeContract.sol\";\nimport \"../interfaces/IRoninTrustedOrganization.sol\";\n\nabstract contract GovernanceAdmin is CoreGovernance, HasRoninTrustedOrganizationContract, HasBridgeContract {\n  uint256 public roninChainId;\n  /// @dev Domain separator\n  bytes32 public DOMAIN_SEPARATOR;\n\n  error ErrProxyCallFailed(bytes4 methodSignature);\n\n  modifier onlySelfCall() {\n    require(msg.sender == address(this), \"GovernanceAdmin: only allowed self-call\");\n    _;\n  }\n\n  constructor(\n    uint256 _roninChainId,\n    address _roninTrustedOrganizationContract,\n    address _bridgeContract,\n    uint256 _proposalExpiryDuration\n  ) CoreGovernance(_proposalExpiryDuration) {\n    roninChainId = _roninChainId;\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\"EIP712Domain(string name,string version,bytes32 salt)\"),\n        keccak256(\"GovernanceAdmin\"), // name hash\n        keccak256(\"2\"), // version hash\n        keccak256(abi.encode(\"RONIN_GOVERNANCE_ADMIN\", _roninChainId)) // salt\n      )\n    );\n    _setRoninTrustedOrganizationContract(_roninTrustedOrganizationContract);\n    _setBridgeContract(_bridgeContract);\n  }\n\n  /**\n   * @inheritdoc IHasRoninTrustedOrganizationContract\n   */\n  function setRoninTrustedOrganizationContract(address _addr) external override onlySelfCall {\n    require(_addr.code.length > 0, \"GovernanceAdmin: set to non-contract\");\n    _setRoninTrustedOrganizationContract(_addr);\n  }\n\n  /**\n   * @inheritdoc IHasBridgeContract\n   */\n  function setBridgeContract(address _addr) external override onlySelfCall {\n    require(_addr.code.length > 0, \"GovernanceAdmin: set to non-contract\");\n    _setBridgeContract(_addr);\n  }\n\n  /**\n   * @dev Sets the expiry duration for a new proposal.\n   *\n   * Requirements:\n   * - Only allowing self-call to this method, since this contract does not have admin.\n   *\n   */\n  function setProposalExpiryDuration(uint256 _expiryDuration) external onlySelfCall {\n    _setProposalExpiryDuration(_expiryDuration);\n  }\n\n  /**\n   * @dev Returns the current implementation of `_proxy`.\n   *\n   * Requirements:\n   * - This contract must be the admin of `_proxy`.\n   *\n   */\n  function getProxyImplementation(address _proxy) external view returns (address) {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n    bytes4 _selector = 0x5c60da1b;\n    (bool _success, bytes memory _returndata) = _proxy.staticcall(abi.encodeWithSelector(_selector));\n    if (!_success) revert ErrProxyCallFailed(_selector);\n    return abi.decode(_returndata, (address));\n  }\n\n  /**\n   * @dev Returns the proposal expiry duration.\n   */\n  function getProposalExpiryDuration() external view returns (uint256) {\n    return super._getProposalExpiryDuration();\n  }\n\n  /**\n   * @dev Returns the current admin of `_proxy`.\n   *\n   * Requirements:\n   * - This contract must be the admin of `_proxy`.\n   *\n   */\n  function getProxyAdmin(address _proxy) external view returns (address) {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"admin()\")) == 0xf851a440\n    bytes4 _selector = 0xf851a440;\n    (bool _success, bytes memory _returndata) = _proxy.staticcall(abi.encodeWithSelector(_selector));\n    if (!_success) revert ErrProxyCallFailed(_selector);\n    return abi.decode(_returndata, (address));\n  }\n\n  /**\n   * @dev Changes the admin of `_proxy` to `newAdmin`.\n   *\n   * Requirements:\n   * - This contract must be the current admin of `_proxy`.\n   *\n   */\n  function changeProxyAdmin(address _proxy, address _newAdmin) external onlySelfCall {\n    // bytes4(keccak256(\"changeAdmin(address)\"))\n    bytes4 _selector = 0x8f283970;\n    (bool _success, ) = _proxy.call(abi.encodeWithSelector(_selector, _newAdmin));\n    if (!_success) revert ErrProxyCallFailed(_selector);\n  }\n\n  /**\n   * @dev Override `CoreGovernance-_getMinimumVoteWeight`.\n   */\n  function _getMinimumVoteWeight() internal view virtual override returns (uint256) {\n    bytes4 _selector = IQuorum.minimumVoteWeight.selector;\n    (bool _success, bytes memory _returndata) = roninTrustedOrganizationContract().staticcall(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector)\n      )\n    );\n    if (!_success) revert ErrProxyCallFailed(_selector);\n    return abi.decode(_returndata, (uint256));\n  }\n\n  /**\n   * @dev Override `CoreGovernance-_getTotalWeights`.\n   */\n  function _getTotalWeights() internal view virtual override returns (uint256) {\n    bytes4 _selector = IRoninTrustedOrganization.totalWeights.selector;\n    (bool _success, bytes memory _returndata) = roninTrustedOrganizationContract().staticcall(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector)\n      )\n    );\n    if (!_success) revert ErrProxyCallFailed(_selector);\n    return abi.decode(_returndata, (uint256));\n  }\n}\n"
    },
    "contracts/libraries/EmergencyExitBallot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nlibrary EmergencyExitBallot {\n  // keccak256(\"EmergencyExitBallot(address consensusAddress,address recipientAfterUnlockedFund,uint256 requestedAt,uint256 expiredAt)\");\n  bytes32 public constant EMERGENCY_EXIT_BALLOT_TYPEHASH =\n    0x697acba4deaf1a718d8c2d93e42860488cb7812696f28ca10eed17bac41e7027;\n\n  /**\n   * @dev Returns hash of the ballot.\n   */\n  function hash(\n    address _consensusAddress,\n    address _recipientAfterUnlockedFund,\n    uint256 _requestedAt,\n    uint256 _expiredAt\n  ) internal pure returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          EMERGENCY_EXIT_BALLOT_TYPEHASH,\n          _consensusAddress,\n          _recipientAfterUnlockedFund,\n          _requestedAt,\n          _expiredAt\n        )\n      );\n  }\n}\n"
    },
    "contracts/extensions/sequential-governance/CoreGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../../libraries/Proposal.sol\";\nimport \"../../libraries/GlobalProposal.sol\";\nimport \"../../libraries/Ballot.sol\";\nimport \"../../interfaces/consumers/ChainTypeConsumer.sol\";\nimport \"../../interfaces/consumers/SignatureConsumer.sol\";\nimport \"../../interfaces/consumers/VoteStatusConsumer.sol\";\n\nabstract contract CoreGovernance is SignatureConsumer, VoteStatusConsumer, ChainTypeConsumer {\n  using Proposal for Proposal.ProposalDetail;\n  using GlobalProposal for GlobalProposal.GlobalProposalDetail;\n\n  struct ProposalVote {\n    VoteStatus status;\n    bytes32 hash;\n    uint256 againstVoteWeight; // Total weight of against votes\n    uint256 forVoteWeight; // Total weight of for votes\n    address[] forVoteds; // Array of addresses voting for\n    address[] againstVoteds; // Array of addresses voting against\n    uint256 expiryTimestamp;\n    mapping(address => Signature) sig;\n    mapping(address => bool) voted;\n  }\n\n  /// @dev Emitted when a proposal is created\n  event ProposalCreated(\n    uint256 indexed chainId,\n    uint256 indexed round,\n    bytes32 indexed proposalHash,\n    Proposal.ProposalDetail proposal,\n    address creator\n  );\n  /// @dev Emitted when a proposal is created\n  event GlobalProposalCreated(\n    uint256 indexed round,\n    bytes32 indexed proposalHash,\n    Proposal.ProposalDetail proposal,\n    bytes32 globalProposalHash,\n    GlobalProposal.GlobalProposalDetail globalProposal,\n    address creator\n  );\n  /// @dev Emitted when the proposal is voted\n  event ProposalVoted(bytes32 indexed proposalHash, address indexed voter, Ballot.VoteType support, uint256 weight);\n  /// @dev Emitted when the proposal is approved\n  event ProposalApproved(bytes32 indexed proposalHash);\n  /// @dev Emitted when the vote is reject\n  event ProposalRejected(bytes32 indexed proposalHash);\n  /// @dev Emitted when the vote is expired\n  event ProposalExpired(bytes32 indexed proposalHash);\n  /// @dev Emitted when the proposal is executed\n  event ProposalExecuted(bytes32 indexed proposalHash, bool[] successCalls, bytes[] returnDatas);\n\n  /// @dev Mapping from chain id => vote round\n  /// @notice chain id = 0 for global proposal\n  mapping(uint256 => uint256) public round;\n  /// @dev Mapping from chain id => vote round => proposal vote\n  mapping(uint256 => mapping(uint256 => ProposalVote)) public vote;\n\n  uint256 private _proposalExpiryDuration;\n\n  constructor(uint256 _expiryDuration) {\n    _setProposalExpiryDuration(_expiryDuration);\n  }\n\n  /**\n   * @dev Creates new voting round by calculating the `_round` number of chain `_chainId`.\n   * Increases the `_round` number if the previous one is not expired. Delete the previous proposal\n   * if it is expired and not increase the `_round`.\n   */\n  function _createVotingRound(uint256 _chainId) internal returns (uint256 _round) {\n    _round = round[_chainId];\n    // Skip checking for the first ever round\n    if (_round == 0) {\n      _round = round[_chainId] = 1;\n    } else {\n      ProposalVote storage _latestProposalVote = vote[_chainId][_round];\n      bool _isExpired = _tryDeleteExpiredVotingRound(_latestProposalVote);\n      // Skip increasing round number if the latest round is expired, allow the vote to be overridden\n      if (!_isExpired) {\n        require(_latestProposalVote.status != VoteStatus.Pending, \"CoreGovernance: current proposal is not completed\");\n        _round = ++round[_chainId];\n      }\n    }\n  }\n\n  /**\n   * @dev Saves new round voting for the proposal `_proposalHash` of chain `_chainId`.\n   */\n  function _saveVotingRound(\n    ProposalVote storage _vote,\n    bytes32 _proposalHash,\n    uint256 _expiryTimestamp\n  ) internal {\n    _vote.hash = _proposalHash;\n    _vote.expiryTimestamp = _expiryTimestamp;\n  }\n\n  /**\n   * @dev Proposes for a new proposal.\n   *\n   * Requirements:\n   * - The chain id is not equal to 0.\n   *\n   * Emits the `ProposalCreated` event.\n   *\n   */\n  function _proposeProposal(\n    uint256 _chainId,\n    uint256 _expiryTimestamp,\n    address[] memory _targets,\n    uint256[] memory _values,\n    bytes[] memory _calldatas,\n    uint256[] memory _gasAmounts,\n    address _creator\n  ) internal virtual returns (Proposal.ProposalDetail memory _proposal) {\n    require(_chainId != 0, \"CoreGovernance: invalid chain id\");\n    uint256 _round = _createVotingRound(_chainId);\n\n    _proposal = Proposal.ProposalDetail(_round, _chainId, _expiryTimestamp, _targets, _values, _calldatas, _gasAmounts);\n    _proposal.validate(_proposalExpiryDuration);\n\n    bytes32 _proposalHash = _proposal.hash();\n    _saveVotingRound(vote[_chainId][_round], _proposalHash, _expiryTimestamp);\n    emit ProposalCreated(_chainId, _round, _proposalHash, _proposal, _creator);\n  }\n\n  /**\n   * @dev Proposes proposal struct.\n   *\n   * Requirements:\n   * - The chain id is not equal to 0.\n   * - The proposal nonce is equal to the new round.\n   *\n   * Emits the `ProposalCreated` event.\n   *\n   */\n  function _proposeProposalStruct(Proposal.ProposalDetail memory _proposal, address _creator)\n    internal\n    virtual\n    returns (uint256 _round)\n  {\n    uint256 _chainId = _proposal.chainId;\n    require(_chainId != 0, \"CoreGovernance: invalid chain id\");\n    _proposal.validate(_proposalExpiryDuration);\n\n    bytes32 _proposalHash = _proposal.hash();\n    _round = _createVotingRound(_chainId);\n    _saveVotingRound(vote[_chainId][_round], _proposalHash, _proposal.expiryTimestamp);\n    require(_round == _proposal.nonce, \"CoreGovernance: invalid proposal nonce\");\n    emit ProposalCreated(_chainId, _round, _proposalHash, _proposal, _creator);\n  }\n\n  /**\n   * @dev Proposes for a global proposal.\n   *\n   * Emits the `GlobalProposalCreated` event.\n   *\n   */\n  function _proposeGlobal(\n    uint256 _expiryTimestamp,\n    GlobalProposal.TargetOption[] calldata _targetOptions,\n    uint256[] memory _values,\n    bytes[] memory _calldatas,\n    uint256[] memory _gasAmounts,\n    address _roninTrustedOrganizationContract,\n    address _gatewayContract,\n    address _creator\n  ) internal virtual {\n    uint256 _round = _createVotingRound(0);\n    GlobalProposal.GlobalProposalDetail memory _globalProposal = GlobalProposal.GlobalProposalDetail(\n      _round,\n      _expiryTimestamp,\n      _targetOptions,\n      _values,\n      _calldatas,\n      _gasAmounts\n    );\n    Proposal.ProposalDetail memory _proposal = _globalProposal.into_proposal_detail(\n      _roninTrustedOrganizationContract,\n      _gatewayContract\n    );\n    _proposal.validate(_proposalExpiryDuration);\n\n    bytes32 _proposalHash = _proposal.hash();\n    _saveVotingRound(vote[0][_round], _proposalHash, _expiryTimestamp);\n    emit GlobalProposalCreated(_round, _proposalHash, _proposal, _globalProposal.hash(), _globalProposal, _creator);\n  }\n\n  /**\n   * @dev Proposes global proposal struct.\n   *\n   * Requirements:\n   * - The proposal nonce is equal to the new round.\n   *\n   * Emits the `GlobalProposalCreated` event.\n   *\n   */\n  function _proposeGlobalStruct(\n    GlobalProposal.GlobalProposalDetail memory _globalProposal,\n    address _roninTrustedOrganizationContract,\n    address _gatewayContract,\n    address _creator\n  ) internal virtual returns (Proposal.ProposalDetail memory _proposal) {\n    _proposal = _globalProposal.into_proposal_detail(_roninTrustedOrganizationContract, _gatewayContract);\n    _proposal.validate(_proposalExpiryDuration);\n\n    bytes32 _proposalHash = _proposal.hash();\n    uint256 _round = _createVotingRound(0);\n    _saveVotingRound(vote[0][_round], _proposalHash, _globalProposal.expiryTimestamp);\n    require(_round == _proposal.nonce, \"CoreGovernance: invalid proposal nonce\");\n    emit GlobalProposalCreated(_round, _proposalHash, _proposal, _globalProposal.hash(), _globalProposal, _creator);\n  }\n\n  /**\n   * @dev Casts vote for the proposal with data and returns whether the voting is done.\n   *\n   * Requirements:\n   * - The proposal nonce is equal to the round.\n   * - The vote is not finalized.\n   * - The voter has not voted for the round.\n   *\n   * Emits the `ProposalVoted` event. Emits the `ProposalApproved`, `ProposalExecuted` or `ProposalRejected` once the\n   * proposal is approved, executed or rejected.\n   *\n   */\n  function _castVote(\n    Proposal.ProposalDetail memory _proposal,\n    Ballot.VoteType _support,\n    uint256 _minimumForVoteWeight,\n    uint256 _minimumAgainstVoteWeight,\n    address _voter,\n    Signature memory _signature,\n    uint256 _voterWeight\n  ) internal virtual returns (bool _done) {\n    uint256 _chainId = _proposal.chainId;\n    uint256 _round = _proposal.nonce;\n    ProposalVote storage _vote = vote[_chainId][_round];\n\n    if (_tryDeleteExpiredVotingRound(_vote)) {\n      return true;\n    }\n\n    require(round[_proposal.chainId] == _round, \"CoreGovernance: query for invalid proposal nonce\");\n    require(_vote.status == VoteStatus.Pending, \"CoreGovernance: the vote is finalized\");\n    if (_voted(_vote, _voter)) {\n      revert(string(abi.encodePacked(\"CoreGovernance: \", Strings.toHexString(uint160(_voter), 20), \" already voted\")));\n    }\n\n    _vote.voted[_voter] = true;\n    // Stores the signature if it is not empty\n    if (_signature.r > 0 || _signature.s > 0 || _signature.v > 0) {\n      _vote.sig[_voter] = _signature;\n    }\n    emit ProposalVoted(_vote.hash, _voter, _support, _voterWeight);\n\n    uint256 _forVoteWeight;\n    uint256 _againstVoteWeight;\n    if (_support == Ballot.VoteType.For) {\n      _vote.forVoteds.push(_voter);\n      _forVoteWeight = _vote.forVoteWeight += _voterWeight;\n    } else if (_support == Ballot.VoteType.Against) {\n      _vote.againstVoteds.push(_voter);\n      _againstVoteWeight = _vote.againstVoteWeight += _voterWeight;\n    } else {\n      revert(\"CoreGovernance: unsupported vote type\");\n    }\n\n    if (_forVoteWeight >= _minimumForVoteWeight) {\n      _done = true;\n      _vote.status = VoteStatus.Approved;\n      emit ProposalApproved(_vote.hash);\n      _tryExecute(_vote, _proposal);\n    } else if (_againstVoteWeight >= _minimumAgainstVoteWeight) {\n      _done = true;\n      _vote.status = VoteStatus.Rejected;\n      emit ProposalRejected(_vote.hash);\n    }\n  }\n\n  /**\n   * @dev When the contract is on Ronin chain, checks whether the proposal is expired and delete it if is expired.\n   *\n   * Emits the event `ProposalExpired` if the vote is expired.\n   *\n   * Note: This function assumes the vote `_proposalVote` is already created, consider verifying the vote's existence\n   * before or it will emit an unexpected event of `ProposalExpired`.\n   */\n  function _tryDeleteExpiredVotingRound(ProposalVote storage _proposalVote) internal returns (bool _isExpired) {\n    _isExpired =\n      _getChainType() == ChainType.RoninChain &&\n      _proposalVote.status == VoteStatus.Pending &&\n      _proposalVote.expiryTimestamp <= block.timestamp;\n\n    if (_isExpired) {\n      emit ProposalExpired(_proposalVote.hash);\n\n      for (uint256 _i; _i < _proposalVote.forVoteds.length; _i++) {\n        delete _proposalVote.voted[_proposalVote.forVoteds[_i]];\n        delete _proposalVote.sig[_proposalVote.forVoteds[_i]];\n      }\n      for (uint256 _i; _i < _proposalVote.againstVoteds.length; _i++) {\n        delete _proposalVote.voted[_proposalVote.againstVoteds[_i]];\n        delete _proposalVote.sig[_proposalVote.againstVoteds[_i]];\n      }\n      delete _proposalVote.status;\n      delete _proposalVote.hash;\n      delete _proposalVote.againstVoteWeight;\n      delete _proposalVote.forVoteWeight;\n      delete _proposalVote.forVoteds;\n      delete _proposalVote.againstVoteds;\n      delete _proposalVote.expiryTimestamp;\n    }\n  }\n\n  /**\n   * @dev Executes the proposal and update the vote status once the proposal is executable.\n   */\n  function _tryExecute(ProposalVote storage _vote, Proposal.ProposalDetail memory _proposal) internal {\n    if (_proposal.executable()) {\n      _vote.status = VoteStatus.Executed;\n      (bool[] memory _successCalls, bytes[] memory _returnDatas) = _proposal.execute();\n      emit ProposalExecuted(_vote.hash, _successCalls, _returnDatas);\n    }\n  }\n\n  /**\n   * @dev Sets the expiry duration for a new proposal.\n   */\n  function _setProposalExpiryDuration(uint256 _expiryDuration) internal {\n    _proposalExpiryDuration = _expiryDuration;\n  }\n\n  /**\n   * @dev Returns whether the voter casted for the proposal.\n   */\n  function _voted(ProposalVote storage _vote, address _voter) internal view returns (bool) {\n    return _vote.voted[_voter];\n  }\n\n  /**\n   * @dev Returns the expiry duration for a new proposal.\n   */\n  function _getProposalExpiryDuration() internal view returns (uint256) {\n    return _proposalExpiryDuration;\n  }\n\n  /**\n   * @dev Returns total weight from validators.\n   */\n  function _getTotalWeights() internal view virtual returns (uint256);\n\n  /**\n   * @dev Returns minimum vote to pass a proposal.\n   */\n  function _getMinimumVoteWeight() internal view virtual returns (uint256);\n\n  /**\n   * @dev Returns current context is running on whether Ronin chain or on mainchain.\n   */\n  function _getChainType() internal view virtual returns (ChainType);\n}\n"
    },
    "contracts/libraries/Proposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Proposal {\n  struct ProposalDetail {\n    // Nonce to make sure proposals are executed in order\n    uint256 nonce;\n    // Value 0: all chain should run this proposal\n    // Other values: only specifc chain has to execute\n    uint256 chainId;\n    uint256 expiryTimestamp;\n    address[] targets;\n    uint256[] values;\n    bytes[] calldatas;\n    uint256[] gasAmounts;\n  }\n\n  // keccak256(\"ProposalDetail(uint256 nonce,uint256 chainId,uint256 expiryTimestamp,address[] targets,uint256[] values,bytes[] calldatas,uint256[] gasAmounts)\");\n  bytes32 public constant TYPE_HASH = 0xd051578048e6ff0bbc9fca3b65a42088dbde10f36ca841de566711087ad9b08a;\n\n  /**\n   * @dev Validates the proposal.\n   */\n  function validate(ProposalDetail memory _proposal, uint256 _maxExpiryDuration) internal view {\n    require(\n      _proposal.targets.length > 0 &&\n        _proposal.targets.length == _proposal.values.length &&\n        _proposal.targets.length == _proposal.calldatas.length &&\n        _proposal.targets.length == _proposal.gasAmounts.length,\n      \"Proposal: invalid array length\"\n    );\n    require(_proposal.expiryTimestamp <= block.timestamp + _maxExpiryDuration, \"Proposal: invalid expiry timestamp\");\n  }\n\n  /**\n   * @dev Returns struct hash of the proposal.\n   */\n  function hash(ProposalDetail memory _proposal) internal pure returns (bytes32) {\n    bytes32 _targetsHash;\n    bytes32 _valuesHash;\n    bytes32 _calldatasHash;\n    bytes32 _gasAmountsHash;\n\n    uint256[] memory _values = _proposal.values;\n    address[] memory _targets = _proposal.targets;\n    bytes32[] memory _calldataHashList = new bytes32[](_proposal.calldatas.length);\n    uint256[] memory _gasAmounts = _proposal.gasAmounts;\n\n    for (uint256 _i; _i < _calldataHashList.length; _i++) {\n      _calldataHashList[_i] = keccak256(_proposal.calldatas[_i]);\n    }\n\n    assembly {\n      _targetsHash := keccak256(add(_targets, 32), mul(mload(_targets), 32))\n      _valuesHash := keccak256(add(_values, 32), mul(mload(_values), 32))\n      _calldatasHash := keccak256(add(_calldataHashList, 32), mul(mload(_calldataHashList), 32))\n      _gasAmountsHash := keccak256(add(_gasAmounts, 32), mul(mload(_gasAmounts), 32))\n    }\n\n    return\n      keccak256(\n        abi.encode(\n          TYPE_HASH,\n          _proposal.nonce,\n          _proposal.chainId,\n          _proposal.expiryTimestamp,\n          _targetsHash,\n          _valuesHash,\n          _calldatasHash,\n          _gasAmountsHash\n        )\n      );\n  }\n\n  /**\n   * @dev Returns whether the proposal is executable for the current chain.\n   *\n   * @notice Does not check whether the call result is successful or not. Please use `execute` instead.\n   *\n   */\n  function executable(ProposalDetail memory _proposal) internal view returns (bool _result) {\n    return _proposal.chainId == 0 || _proposal.chainId == block.chainid;\n  }\n\n  /**\n   * @dev Executes the proposal.\n   */\n  function execute(ProposalDetail memory _proposal)\n    internal\n    returns (bool[] memory _successCalls, bytes[] memory _returnDatas)\n  {\n    require(executable(_proposal), \"Proposal: query for invalid chainId\");\n    _successCalls = new bool[](_proposal.targets.length);\n    _returnDatas = new bytes[](_proposal.targets.length);\n    for (uint256 _i = 0; _i < _proposal.targets.length; ++_i) {\n      require(gasleft() > _proposal.gasAmounts[_i], \"Proposal: insufficient gas\");\n\n      (_successCalls[_i], _returnDatas[_i]) = _proposal.targets[_i].call{\n        value: _proposal.values[_i],\n        gas: _proposal.gasAmounts[_i]\n      }(_proposal.calldatas[_i]);\n    }\n  }\n}\n"
    },
    "contracts/libraries/GlobalProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Proposal.sol\";\n\nlibrary GlobalProposal {\n  enum TargetOption {\n    RoninTrustedOrganizationContract,\n    GatewayContract\n  }\n\n  struct GlobalProposalDetail {\n    // Nonce to make sure proposals are executed in order\n    uint256 nonce;\n    uint256 expiryTimestamp;\n    TargetOption[] targetOptions;\n    uint256[] values;\n    bytes[] calldatas;\n    uint256[] gasAmounts;\n  }\n\n  // keccak256(\"GlobalProposalDetail(uint256 nonce,uint256 expiryTimestamp,uint8[] targetOptions,uint256[] values,bytes[] calldatas,uint256[] gasAmounts)\");\n  bytes32 public constant TYPE_HASH = 0x1463f426c05aff2c1a7a0957a71c9898bc8b47142540538e79ee25ee91141350;\n\n  /**\n   * @dev Returns struct hash of the proposal.\n   */\n  function hash(GlobalProposalDetail memory _proposal) internal pure returns (bytes32) {\n    bytes32 _targetsHash;\n    bytes32 _valuesHash;\n    bytes32 _calldatasHash;\n    bytes32 _gasAmountsHash;\n\n    uint256[] memory _values = _proposal.values;\n    TargetOption[] memory _targets = _proposal.targetOptions;\n    bytes32[] memory _calldataHashList = new bytes32[](_proposal.calldatas.length);\n    uint256[] memory _gasAmounts = _proposal.gasAmounts;\n\n    for (uint256 _i; _i < _calldataHashList.length; _i++) {\n      _calldataHashList[_i] = keccak256(_proposal.calldatas[_i]);\n    }\n\n    assembly {\n      _targetsHash := keccak256(add(_targets, 32), mul(mload(_targets), 32))\n      _valuesHash := keccak256(add(_values, 32), mul(mload(_values), 32))\n      _calldatasHash := keccak256(add(_calldataHashList, 32), mul(mload(_calldataHashList), 32))\n      _gasAmountsHash := keccak256(add(_gasAmounts, 32), mul(mload(_gasAmounts), 32))\n    }\n\n    return\n      keccak256(\n        abi.encode(\n          TYPE_HASH,\n          _proposal.nonce,\n          _proposal.expiryTimestamp,\n          _targetsHash,\n          _valuesHash,\n          _calldatasHash,\n          _gasAmountsHash\n        )\n      );\n  }\n\n  /**\n   * @dev Converts into the normal proposal.\n   */\n  function into_proposal_detail(\n    GlobalProposalDetail memory _proposal,\n    address _roninTrustedOrganizationContract,\n    address _gatewayContract\n  ) internal pure returns (Proposal.ProposalDetail memory _detail) {\n    _detail.nonce = _proposal.nonce;\n    _detail.expiryTimestamp = _proposal.expiryTimestamp;\n    _detail.chainId = 0;\n    _detail.targets = new address[](_proposal.targetOptions.length);\n    _detail.values = _proposal.values;\n    _detail.calldatas = _proposal.calldatas;\n    _detail.gasAmounts = _proposal.gasAmounts;\n\n    for (uint256 _i; _i < _proposal.targetOptions.length; _i++) {\n      if (_proposal.targetOptions[_i] == TargetOption.GatewayContract) {\n        _detail.targets[_i] = _gatewayContract;\n      } else if (_proposal.targetOptions[_i] == TargetOption.RoninTrustedOrganizationContract) {\n        _detail.targets[_i] = _roninTrustedOrganizationContract;\n      } else {\n        revert(\"GlobalProposal: unsupported target\");\n      }\n    }\n  }\n}\n"
    },
    "contracts/libraries/Ballot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nlibrary Ballot {\n  using ECDSA for bytes32;\n\n  enum VoteType {\n    For,\n    Against\n  }\n\n  // keccak256(\"Ballot(bytes32 proposalHash,uint8 support)\");\n  bytes32 public constant BALLOT_TYPEHASH = 0xd900570327c4c0df8dd6bdd522b7da7e39145dd049d2fd4602276adcd511e3c2;\n\n  function hash(bytes32 _proposalHash, VoteType _support) internal pure returns (bytes32) {\n    return keccak256(abi.encode(BALLOT_TYPEHASH, _proposalHash, _support));\n  }\n}\n"
    },
    "contracts/interfaces/consumers/ChainTypeConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainTypeConsumer {\n  enum ChainType {\n    RoninChain,\n    Mainchain\n  }\n}\n"
    },
    "contracts/extensions/collections/HasProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\n\nabstract contract HasProxyAdmin {\n  // bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  modifier onlyAdmin() {\n    require(msg.sender == _getAdmin(), \"HasProxyAdmin: unauthorized sender\");\n    _;\n  }\n\n  /**\n   * @dev Returns proxy admin.\n   */\n  function _getAdmin() internal view returns (address) {\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n}\n"
    },
    "contracts/interfaces/collections/IHasValidatorContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IHasContract.sol\";\n\ninterface IHasValidatorContract is IHasContract {\n  /// @dev Emitted when the validator contract is updated.\n  event ValidatorContractUpdated(address);\n\n  /// @dev Error of method caller must be validator contract.\n  error ErrCallerMustBeValidatorContract();\n\n  /**\n   * @dev Returns the validator contract.\n   */\n  function validatorContract() external view returns (address);\n\n  /**\n   * @dev Sets the validator contract.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The new address is a contract.\n   *\n   * Emits the event `ValidatorContractUpdated`.\n   *\n   */\n  function setValidatorContract(address) external;\n}\n"
    },
    "contracts/interfaces/validator/IRoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ICandidateManager.sol\";\nimport \"./info-fragments/ICommonInfo.sol\";\nimport \"./ICoinbaseExecution.sol\";\nimport \"./ISlashingExecution.sol\";\nimport \"./IEmergencyExit.sol\";\n\ninterface IRoninValidatorSet is\n  ICandidateManager,\n  ICommonInfo,\n  ISlashingExecution,\n  ICoinbaseExecution,\n  IEmergencyExit\n{}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/interfaces/collections/IHasContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IHasContract {\n  /// @dev Error of set to non-contract.\n  error ErrZeroCodeContract();\n}\n"
    },
    "contracts/interfaces/validator/ICandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ICandidateManager {\n  struct ValidatorCandidate {\n    // Admin of the candidate\n    address admin;\n    // Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n    address consensusAddr;\n    // Address that receives mining reward of the validator\n    address payable treasuryAddr;\n    // Address of the bridge operator corresponding to the candidate\n    address bridgeOperatorAddr;\n    // The percentage of reward that validators can be received, the rest goes to the delegators.\n    // Values in range [0; 100_00] stands for 0-100%\n    uint256 commissionRate;\n    // The timestamp that scheduled to revoke the candidate (no schedule=0)\n    uint256 revokingTimestamp;\n    // The deadline that the candidate must top up staking amount to keep it larger than or equal to the threshold (no deadline=0)\n    uint256 topupDeadline;\n  }\n\n  struct CommissionSchedule {\n    // The timestamp that the commission schedule gets affected (no schedule=0).\n    uint256 effectiveTimestamp;\n    // The new commission rate. Value is in range [0; 100_00], stands for 0-100%\n    uint256 commissionRate;\n  }\n\n  /// @dev Emitted when the maximum number of validator candidates is updated.\n  event MaxValidatorCandidateUpdated(uint256 threshold);\n  /// @dev Emitted when the min offset to the effective date of commission rate change is updated.\n  event MinEffectiveDaysOnwardsUpdated(uint256 numOfDays);\n  /// @dev Emitted when the validator candidate is granted.\n  event CandidateGranted(\n    address indexed consensusAddr,\n    address indexed treasuryAddr,\n    address indexed admin,\n    address bridgeOperator\n  );\n  /// @dev Emitted when the revoking timestamp of a candidate is updated.\n  event CandidateRevokingTimestampUpdated(address indexed consensusAddr, uint256 revokingTimestamp);\n  /// @dev Emitted when the topup deadline of a candidate is updated.\n  event CandidateTopupDeadlineUpdated(address indexed consensusAddr, uint256 topupDeadline);\n  /// @dev Emitted when the validator candidate is revoked.\n  event CandidatesRevoked(address[] consensusAddrs);\n\n  /// @dev Emitted when a schedule for updating commission rate is set.\n  event CommissionRateUpdateScheduled(address indexed consensusAddr, uint256 effectiveTimestamp, uint256 rate);\n  /// @dev Emitted when the commission rate of a validator is updated.\n  event CommissionRateUpdated(address indexed consensusAddr, uint256 rate);\n\n  /// @dev Error of exceeding maximum number of candidates.\n  error ErrExceedsMaxNumberOfCandidate();\n  /// @dev Error of querying for already existent candidate.\n  error ErrExistentCandidate();\n  /// @dev Error of querying for non-existent candidate.\n  error ErrNonExistentCandidate();\n  /// @dev Error of candidate admin already exists.\n  error ErrExistentCandidateAdmin(address _candidateAdminAddr);\n  /// @dev Error of treasury already exists.\n  error ErrExistentTreasury(address _treasuryAddr);\n  /// @dev Error of bridge operator already exists.\n  error ErrExistentBridgeOperator(address _bridgeOperatorAddr);\n  /// @dev Error of invalid commission rate.\n  error ErrInvalidCommissionRate();\n  /// @dev Error of invalid effective days onwards.\n  error ErrInvalidEffectiveDaysOnwards();\n  /// @dev Error of invalid min effective days onwards.\n  error ErrInvalidMinEffectiveDaysOnwards();\n  /// @dev Error of already requested revoking candidate before.\n  error ErrAlreadyRequestedRevokingCandidate();\n  /// @dev Error of commission change schedule exists.\n  error ErrAlreadyRequestedUpdatingCommissionRate();\n  /// @dev Error of trusted org cannot renounce.\n  error ErrTrustedOrgCannotRenounce();\n\n  /**\n   * @dev Returns the maximum number of validator candidate.\n   */\n  function maxValidatorCandidate() external view returns (uint256);\n\n  /**\n   * @dev Returns the minimum number of days to the effective date of commission rate change.\n   */\n  function minEffectiveDaysOnwards() external view returns (uint256);\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function setMaxValidatorCandidate(uint256) external;\n\n  /**\n   * @dev Sets the minimum number of days to the effective date of commision rate change.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external;\n\n  /**\n   * @dev Grants a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateGranted`.\n   *\n   */\n  function execApplyValidatorCandidate(\n    address _admin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    address _bridgeOperatorAddr,\n    uint256 _commissionRate\n  ) external;\n\n  /**\n   * @dev Requests to revoke a validator candidate in next `_secsLeft` seconds.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateRevokingTimestampUpdated`.\n   *\n   */\n  function execRequestRenounceCandidate(address, uint256 _secsLeft) external;\n\n  /**\n   * @dev Fallback function of `CandidateStaking-requestUpdateCommissionRate`.\n   *\n   * Requirements:\n   * - The method caller is the staking contract.\n   * - The `_effectiveTimestamp` must be the beginning of a UTC day, and at least from 7 days onwards\n   * - The `_rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdateScheduled`.\n   *\n   */\n  function execRequestUpdateCommissionRate(\n    address _consensusAddr,\n    uint256 _effectiveTimestamp,\n    uint256 _rate\n  ) external;\n\n  /**\n   * @dev Returns whether the address is a validator (candidate).\n   */\n  function isValidatorCandidate(address _addr) external view returns (bool);\n\n  /**\n   * @dev Returns the validator candidate.\n   */\n  function getValidatorCandidates() external view returns (address[] memory);\n\n  /**\n   * @dev Returns all candidate info.\n   */\n  function getCandidateInfos() external view returns (ValidatorCandidate[] memory);\n\n  /**\n   * @dev Returns the info of a candidate.\n   */\n  function getCandidateInfo(address _candidate) external view returns (ValidatorCandidate memory);\n\n  /**\n   * @dev Returns whether the address is the candidate admin.\n   */\n  function isCandidateAdmin(address _candidate, address _admin) external view returns (bool);\n\n  /**\n   * @dev Returns the schedule of changing commission rate of a candidate address.\n   */\n  function getCommissionChangeSchedule(address _candidate) external view returns (CommissionSchedule memory);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ICommonInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IJailingInfo.sol\";\nimport \"./ITimingInfo.sol\";\nimport \"./IValidatorInfo.sol\";\n\ninterface ICommonInfo is ITimingInfo, IJailingInfo, IValidatorInfo {\n  struct EmergencyExitInfo {\n    uint256 lockedAmount;\n    // The timestamp that this locked amount will be recycled to staking vesting contract\n    uint256 recyclingAt;\n  }\n\n  /// @dev Emitted when the deprecated reward is withdrawn.\n  event DeprecatedRewardRecycled(address indexed recipientAddr, uint256 amount);\n  /// @dev Emitted when the deprecated reward withdrawal is failed\n  event DeprecatedRewardRecycleFailed(address indexed recipientAddr, uint256 amount, uint256 balance);\n\n  /// @dev Error thrown when receives RON from neither staking vesting contract nor staking contract\n  error ErrUnauthorizedReceiveRON();\n  /// @dev Error thrown when queries for a non existent info.\n  error NonExistentRecyclingInfo();\n\n  /**\n   * @dev Returns the total deprecated reward, which includes reward that is not sent for slashed validators and unsastified bridge operators\n   */\n  function totalDeprecatedReward() external view returns (uint256);\n\n  /**\n   * @dev Returns the emergency exit request.\n   */\n  function getEmergencyExitInfo(address _consensusAddr) external view returns (EmergencyExitInfo memory);\n}\n"
    },
    "contracts/interfaces/validator/ICoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashingExecution.sol\";\n\ninterface ICoinbaseExecution is ISlashingExecution {\n  enum BlockRewardDeprecatedType {\n    UNKNOWN,\n    UNAVAILABILITY,\n    AFTER_BAILOUT\n  }\n\n  /// @dev Emitted when the validator set is updated\n  event ValidatorSetUpdated(uint256 indexed period, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated, to mirror the in-jail and maintaining status of the validator.\n  event BlockProducerSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated.\n  event BridgeOperatorSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] bridgeOperators);\n\n  /// @dev Emitted when the reward of the block producer is deprecated.\n  event BlockRewardDeprecated(\n    address indexed coinbaseAddr,\n    uint256 rewardAmount,\n    BlockRewardDeprecatedType deprecatedType\n  );\n  /// @dev Emitted when the block reward is submitted.\n  event BlockRewardSubmitted(address indexed coinbaseAddr, uint256 submittedAmount, uint256 bonusAmount);\n\n  /// @dev Emitted when the block producer reward is distributed.\n  event MiningRewardDistributed(address indexed consensusAddr, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the block producer reward.\n  event MiningRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the bridge operator reward is distributed.\n  event BridgeOperatorRewardDistributed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipientAddr,\n    uint256 amount\n  );\n  /// @dev Emitted when the contract fails when distributing the bridge operator reward.\n  event BridgeOperatorRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the amount of RON reward is distributed to staking contract.\n  event StakingRewardDistributed(uint256 totalAmount, address[] consensusAddrs, uint256[] amounts);\n  /// @dev Emitted when the contracts fails when distributing the amount of RON to the staking contract.\n  event StakingRewardDistributionFailed(\n    uint256 totalAmount,\n    address[] consensusAddrs,\n    uint256[] amounts,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the epoch is wrapped up.\n  event WrappedUpEpoch(uint256 indexed periodNumber, uint256 indexed epochNumber, bool periodEnding);\n  /// @dev Emitted when the bridge tracking contract's response is incorrect\n  event BridgeTrackingIncorrectlyResponded();\n\n  /// @dev Error of method caller must be coinbase\n  error ErrCallerMustBeCoinbase();\n  /// @dev Error of only allowed at the end of epoch\n  error ErrAtEndOfEpochOnly();\n  /// @dev Error of query for already wrapped up epoch\n  error ErrAlreadyWrappedEpoch();\n\n  /**\n   * @dev Submits reward of the current block.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDeprecated` if the coinbase is slashed or no longer be a block producer.\n   * Emits the event `BlockRewardSubmitted` for the valid call.\n   *\n   */\n  function submitBlockReward() external payable;\n\n  /**\n   * @dev Wraps up the current epoch.\n   *\n   * Requirements:\n   * - The method must be called when the current epoch is ending.\n   * - The epoch is not wrapped yet.\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDistributed` when some validator has reward distributed.\n   * Emits the event `StakingRewardDistributed` when some staking pool has reward distributed.\n   * Emits the event `BlockProducerSetUpdated` when the epoch is wrapped up.\n   * Emits the event `BridgeOperatorSetUpdated` when the epoch is wrapped up at period ending.\n   * Emits the event `ValidatorSetUpdated` when the epoch is wrapped up at period ending, and the validator set gets updated.\n   * Emits the event `WrappedUpEpoch`.\n   *\n   */\n  function wrapUpEpoch() external payable;\n}\n"
    },
    "contracts/interfaces/validator/ISlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISlashingExecution {\n  /// @dev Emitted when the validator is punished.\n  event ValidatorPunished(\n    address indexed consensusAddr,\n    uint256 indexed period,\n    uint256 jailedUntil,\n    uint256 deductedStakingAmount,\n    bool blockProducerRewardDeprecated,\n    bool bridgeOperatorRewardDeprecated\n  );\n  /// @dev Emitted when the validator get out of jail by bailout.\n  event ValidatorUnjailed(address indexed validator, uint256 period);\n\n  /// @dev Error of cannot bailout due to high tier slash.\n  error ErrCannotBailout(address validator);\n\n  /**\n   * @dev Finalize the slash request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorPunished`.\n   *\n   */\n  function execSlash(\n    address _validatorAddr,\n    uint256 _newJailedUntil,\n    uint256 _slashAmount,\n    bool _cannotBailout\n  ) external;\n\n  /**\n   * @dev Finalize the bailout request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorUnjailed`.\n   *\n   */\n  function execBailOut(address _validatorAddr, uint256 _period) external;\n}\n"
    },
    "contracts/interfaces/validator/IEmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IEmergencyExit {\n  /// @dev Emitted when the fund is locked from an emergency exit request\n  event EmergencyExitRequested(address indexed consensusAddr, uint256 lockedAmount);\n  /// @dev Emitted when the fund that locked from an emergency exit request is transferred to the recipient.\n  event EmergencyExitLockedFundReleased(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount\n  );\n  /// @dev Emitted when the fund that locked from an emergency exit request is failed to transferred back.\n  event EmergencyExitLockedFundReleasingFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the emergency exit locked amount is updated.\n  event EmergencyExitLockedAmountUpdated(uint256 amount);\n  /// @dev Emitted when the emergency expiry duration is updated.\n  event EmergencyExpiryDurationUpdated(uint256 amount);\n\n  /// @dev Error of already requested emergency exit before.\n  error ErrAlreadyRequestedEmergencyExit();\n\n  /**\n   * @dev Returns the amount of RON to lock from a consensus address.\n   */\n  function emergencyExitLockedAmount() external returns (uint256);\n\n  /**\n   * @dev Returns the duration that an emergency request is expired and the fund will be recycled.\n   */\n  function emergencyExpiryDuration() external returns (uint256);\n\n  /**\n   * @dev Sets the amount of RON to lock from a consensus address.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedAmountUpdated`.\n   *\n   */\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external;\n\n  /**\n   * @dev Sets the duration that an emergency request is expired and the fund will be recycled.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExpiryDurationUpdated`.\n   *\n   */\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external;\n\n  /**\n   * @dev Unlocks fund for emergency exit request.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedFundReleased` if the fund is successfully unlocked.\n   * Emits the event `EmergencyExitLockedFundReleasingFailed` if the fund is failed to unlock.\n   *\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(address _consensusAddr, address payable _recipient) external;\n\n  /**\n   * @dev Fallback function of `IStaking-requestEmergencyExit`.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   */\n  function execEmergencyExit(address _consensusAddr, uint256 _secLeftToRevoke) external;\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IJailingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IJailingInfo {\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkJailed(address) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeft(address _addr)\n    external\n    view\n    returns (\n      bool isJailed_,\n      uint256 blockLeft_,\n      uint256 epochLeft_\n    );\n\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) at a specific block.\n   */\n  function checkJailedAtBlock(address _addr, uint256 _blockNum) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail at a specific block and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeftAtBlock(address _addr, uint256 _blockNum)\n    external\n    view\n    returns (\n      bool isJailed_,\n      uint256 blockLeft_,\n      uint256 epochLeft_\n    );\n\n  /**\n   * @dev Returns whether the validators are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkManyJailed(address[] calldata) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during the current period.\n   */\n  function checkMiningRewardDeprecated(address _blockProducer) external view returns (bool);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during a specific period.\n   */\n  function checkMiningRewardDeprecatedAtPeriod(address _blockProducer, uint256 _period) external view returns (bool);\n\n  /**\n   * @dev Returns whether the incoming reward of the validator with `_consensusAddr` is deprecated in the latest wrapped up period.\n   */\n  function checkBridgeRewardDeprecatedAtLatestPeriod(address _consensusAddr) external view returns (bool _result);\n\n  /**\n   * @dev Returns whether the incoming reward of the validator with `_consensusAddr` is deprecated in the  `_period`.\n   */\n  function checkBridgeRewardDeprecatedAtPeriod(address _consensusAddr, uint256 _period)\n    external\n    view\n    returns (bool _result);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ITimingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ITimingInfo {\n  /**\n   * @dev Returns the block that validator set was updated.\n   */\n  function getLastUpdatedBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of blocks in a epoch.\n   */\n  function numberOfBlocksInEpoch() external view returns (uint256 _numberOfBlocks);\n\n  /**\n   * @dev Returns the epoch index from the block number.\n   */\n  function epochOf(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Returns whether the epoch ending is at the block number `_block`.\n   */\n  function epochEndingAt(uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Tries to get the period index from the epoch number.\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber);\n\n  /**\n   * @dev Returns whether the period ending at the current block number.\n   */\n  function isPeriodEnding() external view returns (bool);\n\n  /**\n   * @dev Returns the period index from the current block.\n   */\n  function currentPeriod() external view returns (uint256);\n\n  /**\n   * @dev Returns the block number that the current period starts at.\n   */\n  function currentPeriodStartAtBlock() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IValidatorInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\n\ninterface IValidatorInfo {\n  /// @dev Emitted when the number of max validator is updated.\n  event MaxValidatorNumberUpdated(uint256);\n  /// @dev Emitted when the number of reserved slots for prioritized validators is updated.\n  event MaxPrioritizedValidatorNumberUpdated(uint256);\n\n  /// @dev Error of number of prioritized greater than number of max validators.\n  error ErrInvalidMaxPrioritizedValidatorNumber();\n\n  /**\n   * @dev Returns the maximum number of validators in the epoch.\n   */\n  function maxValidatorNumber() external view returns (uint256 _maximumValidatorNumber);\n\n  /**\n   * @dev Returns the number of reserved slots for prioritized validators.\n   */\n  function maxPrioritizedValidatorNumber() external view returns (uint256 _maximumPrioritizedValidatorNumber);\n\n  /**\n   * @dev Returns the current validator list.\n   */\n  function getValidators()\n    external\n    view\n    returns (\n      address[] memory _validatorList,\n      address[] memory _bridgeOperators,\n      EnumFlags.ValidatorFlag[] memory _flags\n    );\n\n  /**\n   * @dev Returns whether the address is either a bridge operator or a block producer.\n   */\n  function isValidator(address _addr) external view returns (bool);\n\n  /**\n   * @dev Returns the current block producer list.\n   */\n  function getBlockProducers() external view returns (address[] memory);\n\n  /**\n   * @dev Returns whether the address is block producer or not.\n   */\n  function isBlockProducer(address _addr) external view returns (bool);\n\n  /**\n   * @dev Returns total numbers of the block producers.\n   */\n  function totalBlockProducers() external view returns (uint256);\n\n  /**\n   * @dev Returns the current bridge operator list.\n   */\n  function getBridgeOperators() external view returns (address[] memory);\n\n  /**\n   * @dev Returns the bridge operator list corresponding to validator address list.\n   */\n  function getBridgeOperatorsOf(address[] memory _validatorAddrs) external view returns (address[] memory);\n\n  /**\n   * @dev Returns whether the address is bridge operator.\n   */\n  function isBridgeOperator(address _addr) external view returns (bool isOperator);\n\n  /**\n   * @dev Returns whether the consensus address is operating the bridge or not.\n   */\n  function isOperatingBridge(address _consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns total numbers of the bridge operators.\n   */\n  function totalBridgeOperators() external view returns (uint256);\n\n  /**\n   * @dev Updates the max validator number\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxValidatorNumberUpdated`\n   *\n   */\n  function setMaxValidatorNumber(uint256 _maxValidatorNumber) external;\n\n  /**\n   * @dev Updates the number of reserved slots for prioritized validators\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxPrioritizedValidatorNumberUpdated`\n   *\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _maxPrioritizedValidatorNumber) external;\n}\n"
    },
    "contracts/libraries/EnumFlags.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This library implements checking flag of an enumerated value.\n * The originated idea is inherited from [Enum.HashFlag(Enum)](https://learn.microsoft.com/en-us/dotnet/api/system.enum.hasflag?view=net-6.0) method of C#.\n */\nlibrary EnumFlags {\n  enum ValidatorFlag {\n    None, // bit(00)\n    BlockProducer, // bit(01)\n    BridgeOperator, // bit(10)\n    Both // bit(11)\n  }\n\n  function isNone(ValidatorFlag _value) internal pure returns (bool) {\n    return uint8(_value) == 0;\n  }\n\n  /**\n   * @dev Checks if `_value` has `_flag`.\n   */\n  function hasFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (bool) {\n    return (uint8(_value) & uint8(_flag)) != 0;\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after adding `_flag`.\n   */\n  function addFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) | uint8(_flag));\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after remove `_flag`.\n   */\n  function removeFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) & ~uint8(_flag));\n  }\n}\n"
    },
    "contracts/extensions/collections/HasRoninTrustedOrganizationContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasRoninTrustedOrganizationContract.sol\";\nimport \"../../interfaces/IRoninTrustedOrganization.sol\";\n\ncontract HasRoninTrustedOrganizationContract is IHasRoninTrustedOrganizationContract, HasProxyAdmin {\n  IRoninTrustedOrganization internal _roninTrustedOrganizationContract;\n\n  modifier onlyRoninTrustedOrganizationContract() {\n    if (roninTrustedOrganizationContract() != msg.sender) revert ErrCallerMustBeRoninTrustedOrgContract();\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasRoninTrustedOrganizationContract\n   */\n  function roninTrustedOrganizationContract() public view override returns (address) {\n    return address(_roninTrustedOrganizationContract);\n  }\n\n  /**\n   * @inheritdoc IHasRoninTrustedOrganizationContract\n   */\n  function setRoninTrustedOrganizationContract(address _addr) external virtual override onlyAdmin {\n    if (_addr.code.length == 0) revert ErrZeroCodeContract();\n    _setRoninTrustedOrganizationContract(_addr);\n  }\n\n  /**\n   * @dev Sets the ronin trusted organization contract.\n   *\n   * Emits the event `RoninTrustedOrganizationContractUpdated`.\n   *\n   */\n  function _setRoninTrustedOrganizationContract(address _addr) internal {\n    _roninTrustedOrganizationContract = IRoninTrustedOrganization(_addr);\n    emit RoninTrustedOrganizationContractUpdated(_addr);\n  }\n}\n"
    },
    "contracts/extensions/collections/HasBridgeContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasBridgeContract.sol\";\nimport \"../../interfaces/IBridge.sol\";\n\ncontract HasBridgeContract is IHasBridgeContract, HasProxyAdmin {\n  IBridge internal _bridgeContract;\n\n  modifier onlyBridgeContract() {\n    if (bridgeContract() != msg.sender) revert ErrCallerMustBeBridgeContract();\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasBridgeContract\n   */\n  function bridgeContract() public view override returns (address) {\n    return address(_bridgeContract);\n  }\n\n  /**\n   * @inheritdoc IHasBridgeContract\n   */\n  function setBridgeContract(address _addr) external virtual override onlyAdmin {\n    if (_addr.code.length <= 0) revert ErrZeroCodeContract();\n    _setBridgeContract(_addr);\n  }\n\n  /**\n   * @dev Sets the bridge contract.\n   *\n   * Emits the event `BridgeContractUpdated`.\n   *\n   */\n  function _setBridgeContract(address _addr) internal {\n    _bridgeContract = IBridge(_addr);\n    emit BridgeContractUpdated(_addr);\n  }\n}\n"
    },
    "contracts/interfaces/IRoninTrustedOrganization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IQuorum.sol\";\n\ninterface IRoninTrustedOrganization is IQuorum {\n  struct TrustedOrganization {\n    // Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n    address consensusAddr;\n    // Address to voting proposal\n    address governor;\n    // Address to voting bridge operators\n    address bridgeVoter;\n    // Its Weight\n    uint256 weight;\n    // The block that the organization was added\n    uint256 addedBlock;\n  }\n\n  /// @dev Emitted when the trusted organization is added.\n  event TrustedOrganizationsAdded(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is updated.\n  event TrustedOrganizationsUpdated(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is removed.\n  event TrustedOrganizationsRemoved(address[] orgs);\n\n  /**\n   * @dev Adds a list of addresses into the trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   * - The field `addedBlock` should be blank.\n   *\n   * Emits the event `TrustedOrganizationAdded` once an organization is added.\n   *\n   */\n  function addTrustedOrganizations(TrustedOrganization[] calldata) external;\n\n  /**\n   * @dev Updates weights for a list of existent trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   *\n   * Emits the `TrustedOrganizationUpdated` event.\n   *\n   */\n  function updateTrustedOrganizations(TrustedOrganization[] calldata _list) external;\n\n  /**\n   * @dev Removes a list of addresses from the trusted organization.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `TrustedOrganizationRemoved` once an organization is removed.\n   *\n   * @param _consensusAddrs The list of consensus addresses linked to corresponding trusted organization that to be removed.\n   */\n  function removeTrustedOrganizations(address[] calldata _consensusAddrs) external;\n\n  /**\n   * @dev Returns total weights.\n   */\n  function totalWeights() external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a consensus.\n   */\n  function getConsensusWeight(address _consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a governor.\n   */\n  function getGovernorWeight(address _governor) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a bridge voter.\n   */\n  function getBridgeVoterWeight(address _addr) external view returns (uint256);\n\n  /**\n   * @dev Returns the weights of a list of consensus addresses.\n   */\n  function getConsensusWeights(address[] calldata _list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of governor addresses.\n   */\n  function getGovernorWeights(address[] calldata _list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of bridge voter addresses.\n   */\n  function getBridgeVoterWeights(address[] calldata _list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns total weights of the consensus list.\n   */\n  function sumConsensusWeights(address[] calldata _list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns total weights of the governor list.\n   */\n  function sumGovernorWeights(address[] calldata _list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns total weights of the bridge voter list.\n   */\n  function sumBridgeVoterWeights(address[] calldata _list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns the trusted organization at `_index`.\n   */\n  function getTrustedOrganizationAt(uint256 _index) external view returns (TrustedOrganization memory);\n\n  /**\n   * @dev Returns the number of trusted organizations.\n   */\n  function countTrustedOrganizations() external view returns (uint256);\n\n  /**\n   * @dev Returns all of the trusted organizations.\n   */\n  function getAllTrustedOrganizations() external view returns (TrustedOrganization[] memory);\n\n  /**\n   * @dev Returns the trusted organization by consensus address.\n   *\n   * Reverts once the consensus address is non-existent.\n   */\n  function getTrustedOrganization(address _consensusAddr) external view returns (TrustedOrganization memory);\n}\n"
    },
    "contracts/interfaces/collections/IHasRoninTrustedOrganizationContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IHasContract.sol\";\n\ninterface IHasRoninTrustedOrganizationContract is IHasContract {\n  /// @dev Emitted when the ronin trusted organization contract is updated.\n  event RoninTrustedOrganizationContractUpdated(address);\n\n  /// @dev Error of method caller must be Ronin trusted org contract.\n  error ErrCallerMustBeRoninTrustedOrgContract();\n\n  /**\n   * @dev Returns the ronin trusted organization contract.\n   */\n  function roninTrustedOrganizationContract() external view returns (address);\n\n  /**\n   * @dev Sets the ronin trusted organization contract.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The new address is a contract.\n   *\n   * Emits the event `RoninTrustedOrganizationContractUpdated`.\n   *\n   */\n  function setRoninTrustedOrganizationContract(address) external;\n}\n"
    },
    "contracts/interfaces/IQuorum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IQuorum {\n  /// @dev Emitted when the threshold is updated\n  event ThresholdUpdated(\n    uint256 indexed nonce,\n    uint256 indexed numerator,\n    uint256 indexed denominator,\n    uint256 previousNumerator,\n    uint256 previousDenominator\n  );\n\n  /**\n   * @dev Returns the threshold.\n   */\n  function getThreshold() external view returns (uint256 _num, uint256 _denom);\n\n  /**\n   * @dev Checks whether the `_voteWeight` passes the threshold.\n   */\n  function checkThreshold(uint256 _voteWeight) external view returns (bool);\n\n  /**\n   * @dev Returns the minimum vote weight to pass the threshold.\n   */\n  function minimumVoteWeight() external view returns (uint256);\n\n  /**\n   * @dev Sets the threshold.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `ThresholdUpdated` event.\n   *\n   */\n  function setThreshold(uint256 _numerator, uint256 _denominator)\n    external\n    returns (uint256 _previousNum, uint256 _previousDenom);\n}\n"
    },
    "contracts/interfaces/collections/IHasBridgeContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IHasContract.sol\";\n\ninterface IHasBridgeContract is IHasContract {\n  /// @dev Emitted when the bridge contract is updated.\n  event BridgeContractUpdated(address);\n\n  /// @dev Error of method caller must be bridge contract.\n  error ErrCallerMustBeBridgeContract();\n\n  /**\n   * @dev Returns the bridge contract.\n   */\n  function bridgeContract() external view returns (address);\n\n  /**\n   * @dev Sets the bridge contract.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The new address is a contract.\n   *\n   * Emits the event `BridgeContractUpdated`.\n   *\n   */\n  function setBridgeContract(address) external;\n}\n"
    },
    "contracts/interfaces/IBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBridge {\n  /**\n   * @dev Replaces the old bridge operator list by the new one.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emitted the event `BridgeOperatorsReplaced`.\n   *\n   */\n  function replaceBridgeOperators(address[] calldata) external;\n\n  /**\n   * @dev Returns the bridge operator list.\n   */\n  function getBridgeOperators() external view returns (address[] memory);\n}\n"
    },
    "contracts/ronin/validator/EmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../interfaces/IRoninGovernanceAdmin.sol\";\nimport \"../../interfaces/validator/IEmergencyExit.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\nimport \"./CandidateManager.sol\";\n\nabstract contract EmergencyExit is IEmergencyExit, RONTransferHelper, CandidateManager, CommonStorage {\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function emergencyExitLockedAmount() external view returns (uint256) {\n    return _emergencyExitLockedAmount;\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function emergencyExpiryDuration() external view returns (uint256) {\n    return _emergencyExpiryDuration;\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function execEmergencyExit(address _consensusAddr, uint256 _secLeftToRevoke) external onlyStakingContract {\n    EmergencyExitInfo storage _info = _exitInfo[_consensusAddr];\n    if (_info.recyclingAt != 0) revert ErrAlreadyRequestedEmergencyExit();\n\n    uint256 _revokingTimestamp = block.timestamp + _secLeftToRevoke;\n    _setRevokingTimestamp(_candidateInfo[_consensusAddr], _revokingTimestamp);\n    _emergencyExitJailedTimestamp[_consensusAddr] = _revokingTimestamp;\n    _bridgeRewardDeprecatedAtPeriod[_consensusAddr][currentPeriod()] = true;\n\n    uint256 _deductedAmount = _stakingContract.execDeductStakingAmount(_consensusAddr, _emergencyExitLockedAmount);\n    if (_deductedAmount > 0) {\n      uint256 _recyclingAt = block.timestamp + _emergencyExpiryDuration;\n      _lockedConsensusList.push(_consensusAddr);\n      _info.lockedAmount = _deductedAmount;\n      _info.recyclingAt = _recyclingAt;\n      IRoninGovernanceAdmin(_getAdmin()).createEmergencyExitPoll(\n        _consensusAddr,\n        _candidateInfo[_consensusAddr].treasuryAddr,\n        block.timestamp,\n        _recyclingAt\n      );\n    }\n    emit EmergencyExitRequested(_consensusAddr, _deductedAmount);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external onlyAdmin {\n    _setEmergencyExitLockedAmount(_emergencyExitLockedAmount);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external onlyAdmin {\n    _setEmergencyExpiryDuration(_emergencyExpiryDuration);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(address _consensusAddr, address payable _recipient)\n    external\n    onlyAdmin\n  {\n    if (_exitInfo[_consensusAddr].recyclingAt == 0) {\n      return;\n    }\n\n    uint256 _length = _lockedConsensusList.length;\n    uint256 _index = _length;\n\n    for (uint _i; _i < _length; _i++) {\n      if (_lockedConsensusList[_i] == _consensusAddr) {\n        _index = _i;\n        break;\n      }\n    }\n\n    // The locked amount might be recycled\n    if (_index == _length) {\n      return;\n    }\n\n    uint256 _amount = _exitInfo[_consensusAddr].lockedAmount;\n    if (_amount > 0) {\n      delete _exitInfo[_consensusAddr];\n      if (_length > 1) {\n        _lockedConsensusList[_index] = _lockedConsensusList[_length - 1];\n      }\n      _lockedConsensusList.pop();\n\n      _lockedFundReleased[_consensusAddr] = true;\n      if (_unsafeSendRON(_recipient, _amount, DEFAULT_ADDITION_GAS)) {\n        emit EmergencyExitLockedFundReleased(_consensusAddr, _recipient, _amount);\n        return;\n      }\n\n      emit EmergencyExitLockedFundReleasingFailed(_consensusAddr, _recipient, _amount, address(this).balance);\n    }\n  }\n\n  /**\n   * @dev Tries to recycle the locked funds from emergency exit requests.\n   */\n  function _tryRecycleLockedFundsFromEmergencyExits() internal {\n    uint256 _length = _lockedConsensusList.length;\n\n    uint256 _i;\n    address _addr;\n    EmergencyExitInfo storage _info;\n\n    while (_i < _length) {\n      _addr = _lockedConsensusList[_i];\n      _info = _exitInfo[_addr];\n\n      if (_info.recyclingAt <= block.timestamp) {\n        _totalDeprecatedReward += _info.lockedAmount;\n\n        delete _exitInfo[_addr];\n        if (--_length > 0) {\n          _lockedConsensusList[_i] = _lockedConsensusList[_length];\n        }\n        _lockedConsensusList.pop();\n        continue;\n      }\n\n      _i++;\n    }\n  }\n\n  /**\n   * @dev Override `CandidateManager-_emergencyExitLockedFundReleased`.\n   */\n  function _emergencyExitLockedFundReleased(address _consensusAddr) internal virtual override returns (bool) {\n    return _lockedFundReleased[_consensusAddr];\n  }\n\n  /**\n   * @dev Override `CandidateManager-_removeCandidate`.\n   */\n  function _removeCandidate(address _consensusAddr) internal override {\n    delete _lockedFundReleased[_consensusAddr];\n    super._removeCandidate(_consensusAddr);\n  }\n\n  /**\n   * @dev Override `ValidatorInfoStorage-_bridgeOperatorOf`.\n   */\n  function _bridgeOperatorOf(address _consensusAddr)\n    internal\n    view\n    virtual\n    override(CandidateManager, ValidatorInfoStorage)\n    returns (address)\n  {\n    return CandidateManager._bridgeOperatorOf(_consensusAddr);\n  }\n\n  /**\n   * @dev See `setEmergencyExitLockedAmount.\n   */\n  function _setEmergencyExitLockedAmount(uint256 _amount) internal {\n    _emergencyExitLockedAmount = _amount;\n    emit EmergencyExitLockedAmountUpdated(_amount);\n  }\n\n  /**\n   * @dev See `setEmergencyExpiryDuration`.\n   */\n  function _setEmergencyExpiryDuration(uint256 _duration) internal {\n    _emergencyExpiryDuration = _duration;\n    emit EmergencyExpiryDurationUpdated(_duration);\n  }\n}\n"
    },
    "contracts/extensions/RONTransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nabstract contract RONTransferHelper {\n  /// @dev Error of recipient not accepting RON when transfer RON.\n  error ErrRecipientRevert();\n  /// @dev Error of sender has insufficient balance.\n  error ErrInsufficientBalance();\n\n  /**\n   * @dev See `_sendRON`.\n   * Reverts if the recipient does not receive RON.\n   */\n  function _transferRON(address payable _recipient, uint256 _amount) internal {\n    if (!_sendRON(_recipient, _amount)) revert ErrRecipientRevert();\n  }\n\n  /**\n   * @dev Send `_amount` RON to the address `_recipient`.\n   * Returns whether the recipient receives RON or not.\n   * Reverts once the contract balance is insufficient.\n   *\n   * Note: consider using `ReentrancyGuard` before calling this function.\n   *\n   */\n  function _sendRON(address payable _recipient, uint256 _amount) internal returns (bool _success) {\n    if (address(this).balance < _amount) revert ErrInsufficientBalance();\n    return _unsafeSendRON(_recipient, _amount);\n  }\n\n  /**\n   * @dev Unsafe send `_amount` RON to the address `_recipient`. If the sender's balance is insufficient,\n   * the call does not revert.\n   *\n   * Note:\n   * - Does not assert whether the balance of sender is sufficient.\n   * - Does not assert whether the recipient accepts RON.\n   * - Consider using `ReentrancyGuard` before calling this function.\n   *\n   */\n  function _unsafeSendRON(address payable _recipient, uint256 _amount) internal returns (bool _success) {\n    (_success, ) = _recipient.call{ value: _amount }(\"\");\n  }\n\n  /**\n   * @dev Same purpose with {_unsafeSendRON(address,uin256)} but containing gas limit stipend forwarded in the call.\n   */\n  function _unsafeSendRON(\n    address payable _recipient,\n    uint256 _amount,\n    uint256 _gas\n  ) internal returns (bool _success) {\n    (_success, ) = _recipient.call{ value: _amount, gas: _gas }(\"\");\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/CommonStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../interfaces/validator/info-fragments/ICommonInfo.sol\";\nimport \"./JailingStorage.sol\";\nimport \"./TimingStorage.sol\";\nimport \"./ValidatorInfoStorage.sol\";\n\nabstract contract CommonStorage is ICommonInfo, TimingStorage, JailingStorage, ValidatorInfoStorage {\n  /// @dev Mapping from consensus address => pending reward from producing block\n  mapping(address => uint256) internal _miningReward;\n  /// @dev Mapping from consensus address => pending reward from delegating\n  mapping(address => uint256) internal _delegatingReward;\n\n  /// @dev The total reward for bridge operators\n  uint256 internal _totalBridgeReward;\n  /// @dev Mapping from consensus address => pending reward for being bridge operator\n  mapping(address => uint256) internal _bridgeOperatingReward;\n\n  /// @dev The deprecated reward that has not been withdrawn by admin\n  uint256 internal _totalDeprecatedReward;\n\n  /// @dev The amount of RON to lock from a consensus address.\n  uint256 internal _emergencyExitLockedAmount;\n  /// @dev The duration that an emergency request is expired and the fund will be recycled.\n  uint256 internal _emergencyExpiryDuration;\n  /// @dev The address list of consensus addresses that being locked fund.\n  address[] internal _lockedConsensusList;\n  /// @dev Mapping from consensus => request exist info\n  mapping(address => EmergencyExitInfo) internal _exitInfo;\n  /// @dev Mapping from consensus => flag indicating whether the locked fund is released\n  mapping(address => bool) internal _lockedFundReleased;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[44] private ______gap;\n\n  /**\n   * @inheritdoc ICommonInfo\n   */\n  function getEmergencyExitInfo(address _consensusAddr)\n    external\n    view\n    override\n    returns (EmergencyExitInfo memory _info)\n  {\n    _info = _exitInfo[_consensusAddr];\n    if (_info.recyclingAt == 0) revert NonExistentRecyclingInfo();\n  }\n\n  /**\n   * @inheritdoc ICommonInfo\n   */\n  function totalDeprecatedReward() external view override returns (uint256) {\n    return _totalDeprecatedReward;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochOf(uint256 _block)\n    public\n    view\n    virtual\n    override(ITimingInfo, JailingStorage, TimingStorage)\n    returns (uint256)\n  {\n    return TimingStorage.epochOf(_block);\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriod() public view virtual override(ITimingInfo, JailingStorage, TimingStorage) returns (uint256) {\n    return TimingStorage.currentPeriod();\n  }\n}\n"
    },
    "contracts/ronin/validator/CandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasStakingContract.sol\";\nimport \"../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../interfaces/validator/ICandidateManager.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\n\nabstract contract CandidateManager is ICandidateManager, PercentageConsumer, GlobalConfigConsumer, HasStakingContract {\n  /// @dev Maximum number of validator candidate\n  uint256 private _maxValidatorCandidate;\n\n  /// @dev The validator candidate array\n  address[] internal _candidates;\n  /// @dev Mapping from candidate consensus address => bitwise negation of validator index in `_candidates`\n  mapping(address => uint256) internal _candidateIndex;\n  /// @dev Mapping from candidate consensus address => their info\n  mapping(address => ValidatorCandidate) internal _candidateInfo;\n\n  /**\n   * @dev The minimum offset in day from current date to the effective date of a new commission schedule.\n   * Value of 1 means the change gets affected at the beginning of the following day.\n   **/\n  uint256 internal _minEffectiveDaysOnwards;\n  /// @dev Mapping from candidate consensus address => schedule commission change.\n  mapping(address => CommissionSchedule) internal _candidateCommissionChangeSchedule;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] private ______gap;\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function maxValidatorCandidate() public view override returns (uint256) {\n    return _maxValidatorCandidate;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function minEffectiveDaysOnwards() external view override returns (uint256) {\n    return _minEffectiveDaysOnwards;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function setMaxValidatorCandidate(uint256 _number) external override onlyAdmin {\n    _setMaxValidatorCandidate(_number);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external override onlyAdmin {\n    _setMinEffectiveDaysOnwards(_numOfDays);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function execApplyValidatorCandidate(\n    address _candidateAdmin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    address _bridgeOperatorAddr,\n    uint256 _commissionRate\n  ) external override onlyStakingContract {\n    uint256 _length = _candidates.length;\n    if (_length >= maxValidatorCandidate()) revert ErrExceedsMaxNumberOfCandidate();\n    if (isValidatorCandidate(_consensusAddr)) revert ErrExistentCandidate();\n    if (_commissionRate > _MAX_PERCENTAGE) revert ErrInvalidCommissionRate();\n\n    for (uint _i; _i < _candidates.length; _i++) {\n      ValidatorCandidate storage existentInfo = _candidateInfo[_candidates[_i]];\n      if (_candidateAdmin == existentInfo.admin) revert ErrExistentCandidateAdmin(_candidateAdmin);\n      if (_treasuryAddr == existentInfo.treasuryAddr) revert ErrExistentTreasury(_treasuryAddr);\n      if (_bridgeOperatorAddr == existentInfo.bridgeOperatorAddr) revert ErrExistentBridgeOperator(_bridgeOperatorAddr);\n    }\n\n    _candidateIndex[_consensusAddr] = ~_length;\n    _candidates.push(_consensusAddr);\n\n    ValidatorCandidate storage _info = _candidateInfo[_consensusAddr];\n    _info.admin = _candidateAdmin;\n    _info.consensusAddr = _consensusAddr;\n    _info.treasuryAddr = _treasuryAddr;\n    _info.bridgeOperatorAddr = _bridgeOperatorAddr;\n    _info.commissionRate = _commissionRate;\n    emit CandidateGranted(_consensusAddr, _treasuryAddr, _candidateAdmin, _bridgeOperatorAddr);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function execRequestRenounceCandidate(address _consensusAddr, uint256 _secsLeft)\n    external\n    override\n    onlyStakingContract\n  {\n    if (_isTrustedOrg(_consensusAddr)) revert ErrTrustedOrgCannotRenounce();\n\n    ValidatorCandidate storage _info = _candidateInfo[_consensusAddr];\n    if (_info.revokingTimestamp != 0) revert ErrAlreadyRequestedRevokingCandidate();\n    _setRevokingTimestamp(_info, block.timestamp + _secsLeft);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function execRequestUpdateCommissionRate(\n    address _consensusAddr,\n    uint256 _effectiveDaysOnwards,\n    uint256 _commissionRate\n  ) external override onlyStakingContract {\n    if (_candidateCommissionChangeSchedule[_consensusAddr].effectiveTimestamp != 0) {\n      revert ErrAlreadyRequestedUpdatingCommissionRate();\n    }\n    if (_commissionRate > _MAX_PERCENTAGE) revert ErrInvalidCommissionRate();\n    if (_effectiveDaysOnwards < _minEffectiveDaysOnwards) revert ErrInvalidEffectiveDaysOnwards();\n\n    CommissionSchedule storage _schedule = _candidateCommissionChangeSchedule[_consensusAddr];\n    uint256 _effectiveTimestamp = ((block.timestamp / PERIOD_DURATION) + _effectiveDaysOnwards) * PERIOD_DURATION;\n    _schedule.effectiveTimestamp = _effectiveTimestamp;\n    _schedule.commissionRate = _commissionRate;\n\n    emit CommissionRateUpdateScheduled(_consensusAddr, _effectiveTimestamp, _commissionRate);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function isValidatorCandidate(address _addr) public view override returns (bool) {\n    return _candidateIndex[_addr] != 0;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCandidateInfos() external view override returns (ValidatorCandidate[] memory _list) {\n    _list = new ValidatorCandidate[](_candidates.length);\n    for (uint _i; _i < _list.length; _i++) {\n      _list[_i] = _candidateInfo[_candidates[_i]];\n    }\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCandidateInfo(address _candidate) external view override returns (ValidatorCandidate memory) {\n    if (!isValidatorCandidate(_candidate)) revert ErrNonExistentCandidate();\n    return _candidateInfo[_candidate];\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getValidatorCandidates() public view override returns (address[] memory) {\n    return _candidates;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCommissionChangeSchedule(address _candidate) external view override returns (CommissionSchedule memory) {\n    return _candidateCommissionChangeSchedule[_candidate];\n  }\n\n  /**\n   * @dev Removes unsastisfied candidates, the ones who have insufficient minimum candidate staking amount,\n   * or the ones who requested to renounce their candidate role.\n   *\n   * Emits the event `CandidatesRevoked` when a candidate is revoked.\n   *\n   */\n  function _syncCandidateSet(uint256 _nextPeriod) internal returns (address[] memory _unsatisfiedCandidates) {\n    IStaking _staking = _stakingContract;\n    uint256 _waitingSecsToRevoke = _staking.waitingSecsToRevoke();\n    uint256 _minStakingAmount = _staking.minValidatorStakingAmount();\n    uint256[] memory _selfStakings = _staking.getManySelfStakings(_candidates);\n\n    uint256 _length = _candidates.length;\n    uint256 _unsatisfiedCount;\n    _unsatisfiedCandidates = new address[](_length);\n\n    {\n      uint256 _i;\n      address _addr;\n      ValidatorCandidate storage _info;\n      while (_i < _length) {\n        _addr = _candidates[_i];\n        _info = _candidateInfo[_addr];\n\n        // Checks for under-balance status of candidates\n        bool _hasTopupDeadline = _info.topupDeadline != 0;\n        if (_selfStakings[_i] < _minStakingAmount) {\n          // Updates deadline on the first time unsatisfied the staking amount condition\n          if (!_hasTopupDeadline) {\n            uint256 _topupDeadline = block.timestamp + _waitingSecsToRevoke;\n            _info.topupDeadline = _topupDeadline;\n            emit CandidateTopupDeadlineUpdated(_addr, _topupDeadline);\n          }\n        } else if (_hasTopupDeadline) {\n          // Removes the deadline if the staking amount condition is satisfied\n          delete _info.topupDeadline;\n          emit CandidateTopupDeadlineUpdated(_addr, 0);\n        }\n\n        // Removes unsastisfied candidates\n        bool _revokingActivated = (_info.revokingTimestamp != 0 && _info.revokingTimestamp <= block.timestamp) ||\n          _emergencyExitLockedFundReleased(_addr);\n        bool _topupDeadlineMissed = _info.topupDeadline != 0 && _info.topupDeadline <= block.timestamp;\n        if (_revokingActivated || _topupDeadlineMissed) {\n          _selfStakings[_i] = _selfStakings[--_length];\n          _unsatisfiedCandidates[_unsatisfiedCount++] = _addr;\n          _removeCandidate(_addr);\n          continue;\n        }\n\n        // Checks for schedule of commission change and updates commission rate\n        uint256 _scheduleTimestamp = _candidateCommissionChangeSchedule[_addr].effectiveTimestamp;\n        if (_scheduleTimestamp != 0 && _scheduleTimestamp <= block.timestamp) {\n          uint256 _commisionRate = _candidateCommissionChangeSchedule[_addr].commissionRate;\n          delete _candidateCommissionChangeSchedule[_addr];\n          _info.commissionRate = _commisionRate;\n          emit CommissionRateUpdated(_addr, _commisionRate);\n        }\n\n        _i++;\n      }\n    }\n\n    assembly {\n      mstore(_unsatisfiedCandidates, _unsatisfiedCount)\n    }\n\n    if (_unsatisfiedCount > 0) {\n      emit CandidatesRevoked(_unsatisfiedCandidates);\n      _staking.execDeprecatePools(_unsatisfiedCandidates, _nextPeriod);\n    }\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function isCandidateAdmin(address _candidate, address _admin) external view override returns (bool) {\n    return _candidateInfo[_candidate].admin == _admin;\n  }\n\n  /**\n   * @dev Override `ValidatorInfoStorage-_bridgeOperatorOf`.\n   */\n  function _bridgeOperatorOf(address _consensusAddr) internal view virtual returns (address) {\n    return _candidateInfo[_consensusAddr].bridgeOperatorAddr;\n  }\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function _setMaxValidatorCandidate(uint256 _threshold) internal {\n    _maxValidatorCandidate = _threshold;\n    emit MaxValidatorCandidateUpdated(_threshold);\n  }\n\n  /**\n   * @dev Sets the minimum number of days onwards to the effective date of commission rate change.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function _setMinEffectiveDaysOnwards(uint256 _numOfDays) internal {\n    if (_numOfDays < 1) revert ErrInvalidMinEffectiveDaysOnwards();\n    _minEffectiveDaysOnwards = _numOfDays;\n    emit MinEffectiveDaysOnwardsUpdated(_numOfDays);\n  }\n\n  /**\n   * @dev Removes the candidate.\n   */\n  function _removeCandidate(address _addr) internal virtual {\n    uint256 _idx = _candidateIndex[_addr];\n    if (_idx == 0) {\n      return;\n    }\n\n    delete _candidateInfo[_addr];\n    delete _candidateIndex[_addr];\n    delete _candidateCommissionChangeSchedule[_addr];\n\n    address _lastCandidate = _candidates[_candidates.length - 1];\n    if (_lastCandidate != _addr) {\n      _candidateIndex[_lastCandidate] = _idx;\n      _candidates[~_idx] = _lastCandidate;\n    }\n\n    _candidates.pop();\n  }\n\n  /**\n   * @dev Sets timestamp to revoke a candidate.\n   */\n  function _setRevokingTimestamp(ValidatorCandidate storage _candidate, uint256 _timestamp) internal {\n    if (!isValidatorCandidate(_candidate.consensusAddr)) revert ErrNonExistentCandidate();\n    _candidate.revokingTimestamp = _timestamp;\n    emit CandidateRevokingTimestampUpdated(_candidate.consensusAddr, _timestamp);\n  }\n\n  /**\n   * @dev Returns a flag indicating whether the fund is unlocked.\n   */\n  function _emergencyExitLockedFundReleased(address _consensusAddr) internal virtual returns (bool);\n\n  /**\n   * @dev Returns whether the consensus address is a trusted org or not.\n   */\n  function _isTrustedOrg(address _consensusAddr) internal virtual returns (bool);\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/JailingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../interfaces/validator/info-fragments/IJailingInfo.sol\";\nimport \"./TimingStorage.sol\";\n\nabstract contract JailingStorage is IJailingInfo {\n  /// @dev Mapping from consensus address => period number => block producer has no pending reward.\n  mapping(address => mapping(uint256 => bool)) internal _miningRewardDeprecatedAtPeriod;\n  /// @dev Mapping from consensus address => period number => whether the block producer get cut off reward, due to bailout.\n  mapping(address => mapping(uint256 => bool)) internal _miningRewardBailoutCutOffAtPeriod;\n  /// @dev Mapping from consensus address => period number => block operator has no pending reward.\n  mapping(address => mapping(uint256 => bool)) internal _bridgeRewardDeprecatedAtPeriod;\n\n  /// @dev Mapping from consensus address => the last block that the block producer is jailed.\n  mapping(address => uint256) internal _blockProducerJailedBlock;\n  /// @dev Mapping from consensus address => the last timestamp that the bridge operator is jailed.\n  mapping(address => uint256) internal _emergencyExitJailedTimestamp;\n  /// @dev Mapping from consensus address => the last block that the block producer cannot bailout.\n  mapping(address => uint256) internal _cannotBailoutUntilBlock;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] private ______gap;\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkJailed(address _addr) external view override returns (bool) {\n    return checkJailedAtBlock(_addr, block.number);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function getJailedTimeLeft(address _addr)\n    external\n    view\n    override\n    returns (\n      bool isJailed_,\n      uint256 blockLeft_,\n      uint256 epochLeft_\n    )\n  {\n    return getJailedTimeLeftAtBlock(_addr, block.number);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkJailedAtBlock(address _addr, uint256 _blockNum) public view override returns (bool) {\n    return _jailedAtBlock(_addr, _blockNum);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function getJailedTimeLeftAtBlock(address _addr, uint256 _blockNum)\n    public\n    view\n    override\n    returns (\n      bool isJailed_,\n      uint256 blockLeft_,\n      uint256 epochLeft_\n    )\n  {\n    uint256 _jailedBlock = _blockProducerJailedBlock[_addr];\n    if (_jailedBlock < _blockNum) {\n      return (false, 0, 0);\n    }\n\n    isJailed_ = true;\n    blockLeft_ = _jailedBlock - _blockNum + 1;\n    epochLeft_ = epochOf(_jailedBlock) - epochOf(_blockNum) + 1;\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkManyJailed(address[] calldata _addrList) external view override returns (bool[] memory _result) {\n    _result = new bool[](_addrList.length);\n    for (uint256 _i; _i < _addrList.length; _i++) {\n      _result[_i] = _jailed(_addrList[_i]);\n    }\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkMiningRewardDeprecated(address _blockProducer) external view override returns (bool _result) {\n    uint256 _period = currentPeriod();\n    return _miningRewardDeprecated(_blockProducer, _period);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkMiningRewardDeprecatedAtPeriod(address _blockProducer, uint256 _period)\n    external\n    view\n    override\n    returns (bool _result)\n  {\n    return _miningRewardDeprecated(_blockProducer, _period);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   *\n   * @dev Because the information of deprecating bridge reward of a period is only determined at the end of that period, this\n   * method will return the deprecating info of the latest period. A method for querying that info of current period is no need.\n   */\n  function checkBridgeRewardDeprecatedAtLatestPeriod(address _consensusAddr)\n    external\n    view\n    override\n    returns (bool _result)\n  {\n    uint256 _period = currentPeriod() - 1;\n    return _bridgeRewardDeprecated(_consensusAddr, _period);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkBridgeRewardDeprecatedAtPeriod(address _consensusAddr, uint256 _period)\n    external\n    view\n    override\n    returns (bool _result)\n  {\n    return _bridgeRewardDeprecated(_consensusAddr, _period);\n  }\n\n  /**\n   * @dev See `ITimingInfo-epochOf`\n   */\n  function epochOf(uint256 _block) public view virtual returns (uint256);\n\n  /**\n   * @dev See `ITimingInfo-currentPeriod`\n   */\n  function currentPeriod() public view virtual returns (uint256);\n\n  /**\n   * @dev Returns whether the reward of the validator is put in jail (cannot join the set of validators) during the current period.\n   */\n  function _jailed(address _validatorAddr) internal view returns (bool) {\n    return _jailedAtBlock(_validatorAddr, block.number);\n  }\n\n  /**\n   * @dev Returns whether the reward of the validator is put in jail (cannot join the set of validators) at a specific block.\n   */\n  function _jailedAtBlock(address _validatorAddr, uint256 _blockNum) internal view returns (bool) {\n    return _blockNum <= _blockProducerJailedBlock[_validatorAddr];\n  }\n\n  /**\n   * @dev Returns whether the block producer has no pending reward in that period.\n   */\n  function _miningRewardDeprecated(address _validatorAddr, uint256 _period) internal view returns (bool) {\n    return _miningRewardDeprecatedAtPeriod[_validatorAddr][_period];\n  }\n\n  /**\n   * @dev Returns whether the bridge operator has no pending reward in the period.\n   */\n  function _bridgeRewardDeprecated(address _validatorAddr, uint256 _period) internal view returns (bool) {\n    return _bridgeRewardDeprecatedAtPeriod[_validatorAddr][_period];\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/TimingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../../interfaces/validator/info-fragments/ITimingInfo.sol\";\n\nabstract contract TimingStorage is ITimingInfo, GlobalConfigConsumer {\n  /// @dev The number of blocks in a epoch\n  uint256 internal _numberOfBlocksInEpoch;\n  /// @dev The last updated block\n  uint256 internal _lastUpdatedBlock;\n  /// @dev The last updated period\n  uint256 internal _lastUpdatedPeriod;\n  /// @dev The starting block of the last updated period\n  uint256 internal _currentPeriodStartAtBlock;\n\n  /// @dev Mapping from epoch index => period index\n  mapping(uint256 => uint256) internal _periodOf;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[49] private ______gap;\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function getLastUpdatedBlock() external view override returns (uint256) {\n    return _lastUpdatedBlock;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochOf(uint256 _block) public view virtual override returns (uint256) {\n    return _block / _numberOfBlocksInEpoch + 1;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber) {\n    return (_epoch <= epochOf(block.number) || _periodOf[_epoch] > 0, _periodOf[_epoch]);\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function isPeriodEnding() external view override returns (bool) {\n    return _isPeriodEnding(_computePeriod(block.timestamp));\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochEndingAt(uint256 _block) public view virtual override returns (bool) {\n    return _block % _numberOfBlocksInEpoch == _numberOfBlocksInEpoch - 1;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriod() public view virtual override returns (uint256) {\n    return _lastUpdatedPeriod;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriodStartAtBlock() public view override returns (uint256) {\n    return _currentPeriodStartAtBlock;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function numberOfBlocksInEpoch() public view virtual override returns (uint256 _numberOfBlocks) {\n    return _numberOfBlocksInEpoch;\n  }\n\n  /**\n   * @dev See `ITimingInfo-isPeriodEnding`\n   */\n  function _isPeriodEnding(uint256 _newPeriod) internal view virtual returns (bool) {\n    return _newPeriod > _lastUpdatedPeriod;\n  }\n\n  /**\n   * @dev Returns the calculated period.\n   */\n  function _computePeriod(uint256 _timestamp) internal pure returns (uint256) {\n    return _timestamp / PERIOD_DURATION;\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/ValidatorInfoStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\nimport \"../../../extensions/collections/HasRoninTrustedOrganizationContract.sol\";\nimport \"../../../interfaces/validator/info-fragments/IValidatorInfo.sol\";\n\nabstract contract ValidatorInfoStorage is IValidatorInfo, HasRoninTrustedOrganizationContract {\n  using EnumFlags for EnumFlags.ValidatorFlag;\n\n  /// @dev The maximum number of validator.\n  uint256 internal _maxValidatorNumber;\n\n  /// @dev The total of validators\n  uint256 public validatorCount;\n  /// @dev Mapping from validator index => validator address\n  mapping(uint256 => address) internal _validators;\n  /// @dev Mapping from address => flag indicating the validator ability: producing block, operating bridge\n  mapping(address => EnumFlags.ValidatorFlag) internal _validatorMap;\n  /// @dev The number of slot that is reserved for prioritized validators\n  uint256 internal _maxPrioritizedValidatorNumber;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function getValidators()\n    public\n    view\n    override\n    returns (\n      address[] memory _validatorList,\n      address[] memory _bridgeOperators,\n      EnumFlags.ValidatorFlag[] memory _flags\n    )\n  {\n    _validatorList = new address[](validatorCount);\n    _bridgeOperators = new address[](validatorCount);\n    _flags = new EnumFlags.ValidatorFlag[](validatorCount);\n    for (uint _i; _i < _validatorList.length; _i++) {\n      address _validator = _validators[_i];\n      _validatorList[_i] = _validator;\n      _bridgeOperators[_i] = _bridgeOperatorOf(_validator);\n      _flags[_i] = _validatorMap[_validator];\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function isValidator(address _addr) public view override returns (bool) {\n    return !_validatorMap[_addr].isNone();\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function getBlockProducers() public view override returns (address[] memory _result) {\n    _result = new address[](validatorCount);\n    uint256 _count = 0;\n    for (uint _i; _i < _result.length; _i++) {\n      if (isBlockProducer(_validators[_i])) {\n        _result[_count++] = _validators[_i];\n      }\n    }\n\n    assembly {\n      mstore(_result, _count)\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function isBlockProducer(address _addr) public view override returns (bool) {\n    return _validatorMap[_addr].hasFlag(EnumFlags.ValidatorFlag.BlockProducer);\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function totalBlockProducers() external view returns (uint256 _total) {\n    for (uint _i; _i < validatorCount; _i++) {\n      if (isBlockProducer(_validators[_i])) {\n        _total++;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function getBridgeOperators() public view override returns (address[] memory _result) {\n    _result = new address[](validatorCount);\n    uint256 _count = 0;\n    for (uint _i; _i < _result.length; _i++) {\n      if (isOperatingBridge(_validators[_i])) {\n        _result[_count++] = _bridgeOperatorOf(_validators[_i]);\n      }\n    }\n\n    assembly {\n      mstore(_result, _count)\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function getBridgeOperatorsOf(address[] memory _validatorAddrs)\n    public\n    view\n    override\n    returns (address[] memory _result)\n  {\n    _result = new address[](_validatorAddrs.length);\n    for (uint _i; _i < _result.length; _i++) {\n      _result[_i] = _bridgeOperatorOf(_validatorAddrs[_i]);\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function isBridgeOperator(address _bridgeOperatorAddr) external view override returns (bool _isOperator) {\n    for (uint _i; _i < validatorCount; _i++) {\n      if (_bridgeOperatorOf(_validators[_i]) == _bridgeOperatorAddr && isOperatingBridge(_validators[_i])) {\n        _isOperator = true;\n        break;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function isOperatingBridge(address _consensusAddr) public view override returns (bool) {\n    return _validatorMap[_consensusAddr].hasFlag(EnumFlags.ValidatorFlag.BridgeOperator);\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function maxValidatorNumber() external view override returns (uint256 _maximumValidatorNumber) {\n    return _maxValidatorNumber;\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function maxPrioritizedValidatorNumber() external view override returns (uint256 _maximumPrioritizedValidatorNumber) {\n    return _maxPrioritizedValidatorNumber;\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function totalBridgeOperators() public view returns (uint256 _total) {\n    for (uint _i; _i < validatorCount; _i++) {\n      if (isOperatingBridge(_validators[_i])) {\n        _total++;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function setMaxValidatorNumber(uint256 _max) external override onlyAdmin {\n    _setMaxValidatorNumber(_max);\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _number) external override onlyAdmin {\n    _setMaxPrioritizedValidatorNumber(_number);\n  }\n\n  /**\n   * @dev Returns the bridge operator of a consensus address.\n   */\n  function _bridgeOperatorOf(address _consensusAddr) internal view virtual returns (address);\n\n  /**\n   * @dev See `IValidatorInfo-setMaxValidatorNumber`\n   */\n  function _setMaxValidatorNumber(uint256 _number) internal {\n    _maxValidatorNumber = _number;\n    emit MaxValidatorNumberUpdated(_number);\n  }\n\n  /**\n   * @dev See `IValidatorInfo-setMaxPrioritizedValidatorNumber`\n   */\n  function _setMaxPrioritizedValidatorNumber(uint256 _number) internal {\n    if (_number > _maxValidatorNumber) revert ErrInvalidMaxPrioritizedValidatorNumber();\n    _maxPrioritizedValidatorNumber = _number;\n    emit MaxPrioritizedValidatorNumberUpdated(_number);\n  }\n}\n"
    },
    "contracts/extensions/consumers/GlobalConfigConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nabstract contract GlobalConfigConsumer {\n  /// @dev The addition amount of gas sending along in external calls. Total gas stipend is added with default 2300 gas.\n  uint256 public constant DEFAULT_ADDITION_GAS = 1200;\n  /// @dev The length of a period in second.\n  uint256 public constant PERIOD_DURATION = 1 days;\n}\n"
    },
    "contracts/extensions/collections/HasStakingContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasStakingContract.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\n\ncontract HasStakingContract is IHasStakingContract, HasProxyAdmin {\n  IStaking internal _stakingContract;\n\n  modifier onlyStakingContract() {\n    if (stakingContract() != msg.sender) revert ErrCallerMustBeStakingContract();\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasStakingContract\n   */\n  function stakingContract() public view override returns (address) {\n    return address(_stakingContract);\n  }\n\n  /**\n   * @inheritdoc IHasStakingContract\n   */\n  function setStakingContract(address _addr) external override onlyAdmin {\n    if (_addr.code.length == 0) revert ErrZeroCodeContract();\n    _setStakingContract(_addr);\n  }\n\n  /**\n   * @dev Sets the staking contract.\n   *\n   * Emits the event `StakingContractUpdated`.\n   *\n   */\n  function _setStakingContract(address _addr) internal {\n    _stakingContract = IStaking(_addr);\n    emit StakingContractUpdated(_addr);\n  }\n}\n"
    },
    "contracts/extensions/consumers/PercentageConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract PercentageConsumer {\n  uint256 internal constant _MAX_PERCENTAGE = 100_00;\n}\n"
    },
    "contracts/interfaces/staking/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseStaking.sol\";\nimport \"./ICandidateStaking.sol\";\nimport \"./IDelegatorStaking.sol\";\n\ninterface IStaking is IRewardPool, IBaseStaking, ICandidateStaking, IDelegatorStaking {\n  /**\n   * @dev Records the amount of rewards `_rewards` for the pools `_consensusAddrs`.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   *\n   * Emits the event `PoolsUpdated` once the contract recorded the rewards successfully.\n   * Emits the event `PoolsUpdateFailed` once the input array lengths are not equal.\n   * Emits the event `PoolsUpdateConflicted` when there are some pools which already updated in the period.\n   *\n   * Note: This method should be called once at the period ending.\n   *\n   */\n  function execRecordRewards(\n    address[] calldata _consensusAddrs,\n    uint256[] calldata _rewards,\n    uint256 _period\n  ) external payable;\n\n  /**\n   * @dev Deducts from staking amount of the validator `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   *\n   * Emits the event `Unstaked`.\n   *\n   */\n  function execDeductStakingAmount(address _consensusAddr, uint256 _amount)\n    external\n    returns (uint256 _actualDeductingAmount);\n}\n"
    },
    "contracts/interfaces/collections/IHasStakingContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IHasContract.sol\";\n\ninterface IHasStakingContract is IHasContract {\n  /// @dev Emitted when the staking contract is updated.\n  event StakingContractUpdated(address);\n\n  /// @dev Error of method caller must be staking contract.\n  error ErrCallerMustBeStakingContract();\n\n  /**\n   * @dev Returns the staking contract.\n   */\n  function stakingContract() external view returns (address);\n\n  /**\n   * @dev Sets the staking contract.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The new address is a contract.\n   *\n   * Emits the event `StakingContractUpdated`.\n   *\n   */\n  function setStakingContract(address) external;\n}\n"
    },
    "contracts/interfaces/staking/IBaseStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IBaseStaking {\n  struct PoolDetail {\n    // Address of the pool i.e. consensus address of the validator\n    address addr;\n    // Pool admin address\n    address admin;\n    // Self-staking amount\n    uint256 stakingAmount;\n    // Total number of RON staking for the pool\n    uint256 stakingTotal;\n    // Mapping from delegator => delegating amount\n    mapping(address => uint256) delegatingAmount;\n    // Mapping from delegator => the last timestamp that delegator staked\n    mapping(address => uint256) lastDelegatingTimestamp;\n  }\n\n  /// @dev Emitted when the minium number of seconds to undelegate is updated.\n  event CooldownSecsToUndelegateUpdated(uint256 minSecs);\n  /// @dev Emitted when the number of seconds that a candidate must wait to be revoked.\n  event WaitingSecsToRevokeUpdated(uint256 secs);\n\n  /// @dev Error of cannot transfer RON.\n  error ErrCannotTransferRON();\n  /// @dev Error of receiving zero message value.\n  error ErrZeroValue();\n  /// @dev Error of pool admin is not allowed to call.\n  error ErrPoolAdminForbidden();\n  /// @dev Error of no one is allowed to call but the pool's admin.\n  error ErrOnlyPoolAdminAllowed();\n  /// @dev Error of admin of any active pool cannot delegate.\n  error ErrAdminOfAnyActivePoolForbidden(address admin);\n  /// @dev Error of querying inactive pool.\n  error ErrInactivePool(address poolAddr);\n  /// @dev Error of length of input arrays are not of the same.\n  error ErrInvalidArrays();\n\n  /**\n   * @dev Returns whether the `_poolAdminAddr` is currently active.\n   */\n  function isAdminOfActivePool(address _poolAdminAddr) external view returns (bool);\n\n  /**\n   * @dev Returns the consensus address corresponding to the pool admin.\n   */\n  function getPoolAddressOf(address _poolAdminAddr) external view returns (address);\n\n  /**\n   * @dev Returns the staking pool detail.\n   */\n  function getPoolDetail(address)\n    external\n    view\n    returns (\n      address _admin,\n      uint256 _stakingAmount,\n      uint256 _stakingTotal\n    );\n\n  /**\n   * @dev Returns the self-staking amounts of the pools.\n   */\n  function getManySelfStakings(address[] calldata) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns The cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n   */\n  function cooldownSecsToUndelegate() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of seconds that a candidate must wait for the renounce request gets affected.\n   */\n  function waitingSecsToRevoke() external view returns (uint256);\n\n  /**\n   * @dev Sets the cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CooldownSecsToUndelegateUpdated`.\n   *\n   */\n  function setCooldownSecsToUndelegate(uint256 _cooldownSecs) external;\n\n  /**\n   * @dev Sets the number of seconds that a candidate must wait to be revoked.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `WaitingSecsToRevokeUpdated`.\n   *\n   */\n  function setWaitingSecsToRevoke(uint256 _secs) external;\n}\n"
    },
    "contracts/interfaces/staking/ICandidateStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IRewardPool.sol\";\n\ninterface ICandidateStaking is IRewardPool {\n  /// @dev Emitted when the minimum staking amount for being a validator is updated.\n  event MinValidatorStakingAmountUpdated(uint256 threshold);\n  /// @dev Emitted when the max commission rate is updated.\n  event MaxCommissionRateUpdated(uint256 maxRate);\n\n  /// @dev Emitted when the pool admin staked for themself.\n  event Staked(address indexed consensuAddr, uint256 amount);\n  /// @dev Emitted when the pool admin unstaked the amount of RON from themself.\n  event Unstaked(address indexed consensuAddr, uint256 amount);\n\n  /// @dev Emitted when the validator pool is approved.\n  event PoolApproved(address indexed validator, address indexed admin);\n  /// @dev Emitted when the validator pool is deprecated.\n  event PoolsDeprecated(address[] validator);\n  /// @dev Emitted when the staking amount transfer failed.\n  event StakingAmountTransferFailed(\n    address indexed validator,\n    address indexed admin,\n    uint256 amount,\n    uint256 contractBalance\n  );\n  /// @dev Emitted when the staking amount deducted failed, e.g. when the validator gets slashed.\n  event StakingAmountDeductFailed(\n    address indexed validator,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Error of cannot transfer RON to specified target.\n  error ErrCannotInitTransferRON(address addr, string extraInfo);\n  /// @dev Error of three interaction addresses must be of the same in applying for validator candidate.\n  error ErrThreeInteractionAddrsNotEqual();\n  /// @dev Error of three operation addresses must be distinct in applying for validator candidate.\n  error ErrThreeOperationAddrsNotDistinct();\n  /// @dev Error of unstaking zero amount.\n  error ErrUnstakeZeroAmount();\n  /// @dev Error of invalid staking amount left after deducted.\n  error ErrStakingAmountLeft();\n  /// @dev Error of insufficient staking amount for unstaking.\n  error ErrInsufficientStakingAmount();\n  /// @dev Error of unstaking too early.\n  error ErrUnstakeTooEarly();\n  /// @dev Error of setting commission rate exceeds max allowed.\n  error ErrInvalidCommissionRate();\n\n  /**\n   * @dev Returns the minimum threshold for being a validator candidate.\n   */\n  function minValidatorStakingAmount() external view returns (uint256);\n\n  /**\n   * @dev Returns the max commission rate that the candidate can set.\n   */\n  function maxCommissionRate() external view returns (uint256);\n\n  /**\n   * @dev Sets the minimum threshold for being a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinValidatorStakingAmountUpdated` event.\n   *\n   */\n  function setMinValidatorStakingAmount(uint256) external;\n\n  /**\n   * @dev Sets the max commission rate that a candidate can set.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MaxCommissionRateUpdated` event.\n   *\n   */\n  function setMaxCommissionRate(uint256 _maxRate) external;\n\n  /**\n   * @dev Proposes a candidate to become a validator.\n   *\n   * Requirements:\n   * - The method caller is able to receive RON.\n   * - The treasury is able to receive RON.\n   * - The amount is larger than or equal to the minimum validator staking amount `minValidatorStakingAmount()`.\n   *\n   * Emits the event `PoolApproved`.\n   *\n   * @param _candidateAdmin the candidate admin will be stored in the validator contract, used for calling function that affects\n   * to its candidate, e.g. scheduling maintenance.\n   *\n   */\n  function applyValidatorCandidate(\n    address _candidateAdmin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    address _bridgeOperatorAddr,\n    uint256 _commissionRate\n  ) external payable;\n\n  /**\n   * @dev Deprecates the pool.\n   * - Deduct self-staking amount of the pool admin to zero.\n   * - Transfer the deducted amount to the pool admin.\n   * - Deactivate the pool admin address in the mapping of active pool admins\n   *\n   * Requirements:\n   * - The method caller is validator contract.\n   *\n   * Emits the event `PoolsDeprecated` and `Unstaked` events.\n   * Emits the event `StakingAmountTransferFailed` if the contract cannot transfer RON back to the pool admin.\n   *\n   */\n  function execDeprecatePools(address[] calldata _pools, uint256 _period) external;\n\n  /**\n   * @dev Self-delegates to the validator candidate `_consensusAddr`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   * - The `msg.value` is larger than 0.\n   *\n   * Emits the event `Staked`.\n   *\n   */\n  function stake(address _consensusAddr) external payable;\n\n  /**\n   * @dev Unstakes from the validator candidate `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   * Emits the event `Unstaked`.\n   *\n   */\n  function unstake(address _consensusAddr, uint256 _amount) external;\n\n  /**\n   * @dev Pool admin requests update validator commission rate. The request will be forwarded to the candidate manager\n   * contract, and the value is getting updated in {ICandidateManager-execRequestUpdateCommissionRate}.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   * - The `_effectiveDaysOnwards` must be equal to or larger than the {CandidateManager-_minEffectiveDaysOnwards}.\n   * - The `_rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdated`.\n   *\n   */\n  function requestUpdateCommissionRate(\n    address _consensusAddr,\n    uint256 _effectiveDaysOnwards,\n    uint256 _commissionRate\n  ) external;\n\n  /**\n   * @dev Renounces being a validator candidate and takes back the delegating/staking amount.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   */\n  function requestRenounce(address _consensusAddr) external;\n\n  /**\n   * @dev Renounces being a validator candidate and takes back the delegating/staking amount.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   */\n  function requestEmergencyExit(address _consensusAddr) external;\n}\n"
    },
    "contracts/interfaces/staking/IDelegatorStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IRewardPool.sol\";\n\ninterface IDelegatorStaking is IRewardPool {\n  /// @dev Emitted when the delegator staked for a validator candidate.\n  event Delegated(address indexed delegator, address indexed consensuAddr, uint256 amount);\n  /// @dev Emitted when the delegator unstaked from a validator candidate.\n  event Undelegated(address indexed delegator, address indexed consensuAddr, uint256 amount);\n\n  /// @dev Error of undelegating zero amount.\n  error ErrUndelegateZeroAmount();\n  /// @dev Error of undelegating insufficient amount.\n  error ErrInsufficientDelegatingAmount();\n  /// @dev Error of undelegating too early.\n  error ErrUndelegateTooEarly();\n\n  /**\n   * @dev Stakes for a validator candidate `_consensusAddr`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is not the pool admin.\n   *\n   * Emits the `Delegated` event.\n   *\n   */\n  function delegate(address _consensusAddr) external payable;\n\n  /**\n   * @dev Unstakes from a validator candidate `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   *\n   * Emits the `Undelegated` event.\n   *\n   */\n  function undelegate(address _consensusAddr, uint256 _amount) external;\n\n  /**\n   * @dev Bulk unstakes from a list of candidates.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   *\n   * Emits the events `Undelegated`.\n   *\n   */\n  function bulkUndelegate(address[] calldata _consensusAddrs, uint256[] calldata _amounts) external;\n\n  /**\n   * @dev Unstakes an amount of RON from the `_consensusAddrSrc` and stake for `_consensusAddrDst`.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   * - The consensus address `_consensusAddrDst` is a validator candidate.\n   *\n   * Emits the `Undelegated` event and the `Delegated` event.\n   *\n   */\n  function redelegate(\n    address _consensusAddrSrc,\n    address _consensusAddrDst,\n    uint256 _amount\n  ) external;\n\n  /**\n   * @dev Returns the claimable reward of the user `_user`.\n   */\n  function getRewards(address _user, address[] calldata _poolAddrList)\n    external\n    view\n    returns (uint256[] memory _rewards);\n\n  /**\n   * @dev Claims the reward of method caller.\n   *\n   * Emits the `RewardClaimed` event.\n   *\n   */\n  function claimRewards(address[] calldata _consensusAddrList) external returns (uint256 _amount);\n\n  /**\n   * @dev Claims the rewards and delegates them to the consensus address.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   * - The consensus address `_consensusAddrDst` is a validator candidate.\n   *\n   * Emits the `RewardClaimed` event and the `Delegated` event.\n   *\n   */\n  function delegateRewards(address[] calldata _consensusAddrList, address _consensusAddrDst)\n    external\n    returns (uint256 _amount);\n}\n"
    },
    "contracts/interfaces/staking/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/consumers/PeriodWrapperConsumer.sol\";\n\ninterface IRewardPool is PeriodWrapperConsumer {\n  struct UserRewardFields {\n    // Recorded reward amount.\n    uint256 debited;\n    // The last accumulated of the amount rewards per share (one unit staking) that the info updated.\n    uint256 aRps;\n    // Lowest staking amount in the period.\n    uint256 lowestAmount;\n    // Last period number that the info updated.\n    uint256 lastPeriod;\n  }\n\n  struct PoolFields {\n    // Accumulated of the amount rewards per share (one unit staking).\n    uint256 aRps;\n    // The staking total to share reward of the current period.\n    PeriodWrapper shares;\n  }\n\n  /// @dev Emitted when the fields to calculate pending reward for the user is updated.\n  event UserRewardUpdated(address indexed poolAddr, address indexed user, uint256 debited);\n  /// @dev Emitted when the user claimed their reward\n  event RewardClaimed(address indexed poolAddr, address indexed user, uint256 amount);\n\n  /// @dev Emitted when the pool shares are updated\n  event PoolSharesUpdated(uint256 indexed period, address indexed poolAddr, uint256 shares);\n  /// @dev Emitted when the pools are updated\n  event PoolsUpdated(uint256 indexed period, address[] poolAddrs, uint256[] aRps, uint256[] shares);\n  /// @dev Emitted when the contract fails when updating the pools\n  event PoolsUpdateFailed(uint256 indexed period, address[] poolAddrs, uint256[] rewards);\n  /// @dev Emitted when the contract fails when updating the pools that already set\n  event PoolsUpdateConflicted(uint256 indexed period, address[] poolAddrs);\n\n  /// @dev Error of invalid pool share.\n  error ErrInvalidPoolShare();\n\n  /**\n   * @dev Returns the reward amount that user claimable.\n   */\n  function getReward(address _poolAddr, address _user) external view returns (uint256);\n\n  /**\n   * @dev Returns the staking amount of an user.\n   */\n  function getStakingAmount(address _poolAddr, address _user) external view returns (uint256);\n\n  /**\n   * @dev Returns the staking amounts of the users.\n   */\n  function getManyStakingAmounts(address[] calldata _poolAddrs, address[] calldata _userList)\n    external\n    view\n    returns (uint256[] memory);\n\n  /**\n   * @dev Returns the total staking amount of all users for a pool.\n   */\n  function getStakingTotal(address _poolAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the total staking amounts of all users for the pools `_poolAddrs`.\n   */\n  function getManyStakingTotals(address[] calldata _poolAddrs) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/interfaces/consumers/PeriodWrapperConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PeriodWrapperConsumer {\n  struct PeriodWrapper {\n    // Inner value.\n    uint256 inner;\n    // Last period number that the info updated.\n    uint256 lastPeriod;\n  }\n}\n"
    },
    "contracts/mocks/validator/MockValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../ronin/validator/CandidateManager.sol\";\n\ncontract MockValidatorSet is IRoninValidatorSet, CandidateManager {\n  address public stakingVestingContract;\n  address public slashIndicatorContract;\n\n  uint256 internal _lastUpdatedPeriod;\n  uint256 internal _numberOfBlocksInEpoch;\n  /// @dev Mapping from period number => slashed\n  mapping(uint256 => bool) internal _periodSlashed;\n\n  constructor(\n    address __stakingContract,\n    address _slashIndicatorContract,\n    address _stakingVestingContract,\n    uint256 __maxValidatorCandidate,\n    uint256 __numberOfBlocksInEpoch,\n    uint256 __minEffectiveDaysOnwards\n  ) {\n    _setStakingContract(__stakingContract);\n    _setMaxValidatorCandidate(__maxValidatorCandidate);\n    slashIndicatorContract = _slashIndicatorContract;\n    stakingVestingContract = _stakingVestingContract;\n    _numberOfBlocksInEpoch = __numberOfBlocksInEpoch;\n    _minEffectiveDaysOnwards = __minEffectiveDaysOnwards;\n  }\n\n  function submitBlockReward() external payable override {}\n\n  function wrapUpEpoch() external payable override {\n    _syncCandidateSet(_lastUpdatedPeriod + 1);\n    _lastUpdatedPeriod = currentPeriod();\n  }\n\n  function getLastUpdatedBlock() external view override returns (uint256) {}\n\n  function checkManyJailed(address[] calldata) external view override returns (bool[] memory) {}\n\n  function checkMiningRewardDeprecatedAtPeriod(address, uint256 _period) external view override returns (bool) {}\n\n  function checkMiningRewardDeprecated(address) external view override returns (bool) {}\n\n  function checkBridgeRewardDeprecatedAtLatestPeriod(address _consensusAddr)\n    external\n    view\n    override\n    returns (bool _result)\n  {}\n\n  function checkBridgeRewardDeprecatedAtPeriod(address _consensusAddr, uint256 _period)\n    external\n    view\n    returns (bool _result)\n  {}\n\n  function epochOf(uint256 _block) external view override returns (uint256) {}\n\n  function getValidators()\n    external\n    view\n    override\n    returns (\n      address[] memory,\n      address[] memory,\n      EnumFlags.ValidatorFlag[] memory\n    )\n  {}\n\n  function epochEndingAt(uint256 _block) external view override returns (bool) {}\n\n  function execSlash(\n    address _validatorAddr,\n    uint256 _newJailedUntil,\n    uint256 _slashAmount,\n    bool _cannotBailout\n  ) external override {}\n\n  function execBailOut(address, uint256) external override {}\n\n  function setMaxValidatorNumber(uint256 _maxValidatorNumber) external override {}\n\n  function setMaxPrioritizedValidatorNumber(uint256 _maxPrioritizedValidatorNumber) external override {}\n\n  function maxValidatorNumber() external view override returns (uint256 _maximumValidatorNumber) {}\n\n  function maxPrioritizedValidatorNumber()\n    external\n    view\n    override\n    returns (uint256 _maximumPrioritizedValidatorNumber)\n  {}\n\n  function isValidator(address) external pure override returns (bool) {\n    return true;\n  }\n\n  function numberOfBlocksInEpoch() public view override returns (uint256) {\n    return _numberOfBlocksInEpoch;\n  }\n\n  function getBridgeOperators() external view override returns (address[] memory) {}\n\n  function getBridgeOperatorsOf(address[] memory _validatorAddrs) external view override returns (address[] memory) {}\n\n  function isBridgeOperator(address) external pure override returns (bool) {\n    return true;\n  }\n\n  function totalBridgeOperators() external view override returns (uint256) {}\n\n  function getBlockProducers() external view override returns (address[] memory) {}\n\n  function isBlockProducer(address) external pure override returns (bool) {\n    return true;\n  }\n\n  function totalBlockProducers() external view override returns (uint256) {}\n\n  function tryGetPeriodOfEpoch(uint256) external view returns (bool, uint256) {}\n\n  function isPeriodEnding() public view virtual returns (bool) {\n    return currentPeriod() > _lastUpdatedPeriod;\n  }\n\n  function currentPeriod() public view override returns (uint256) {\n    return block.timestamp / 86400;\n  }\n\n  function checkJailed(address) external view override returns (bool) {}\n\n  function getJailedTimeLeft(address)\n    external\n    view\n    override\n    returns (\n      bool,\n      uint256,\n      uint256\n    )\n  {}\n\n  function currentPeriodStartAtBlock() external view override returns (uint256) {}\n\n  function checkJailedAtBlock(address _addr, uint256 _blockNum) external view override returns (bool) {}\n\n  function getJailedTimeLeftAtBlock(address _addr, uint256 _blockNum)\n    external\n    view\n    override\n    returns (\n      bool isJailed_,\n      uint256 blockLeft_,\n      uint256 epochLeft_\n    )\n  {}\n\n  function totalDeprecatedReward() external view override returns (uint256) {}\n\n  function _bridgeOperatorOf(address _consensusAddr) internal view override returns (address) {\n    return super._bridgeOperatorOf(_consensusAddr);\n  }\n\n  function execReleaseLockedFundForEmergencyExitRequest(address _consensusAddr, address payable _recipient)\n    external\n    override\n  {}\n\n  function emergencyExitLockedAmount() external override returns (uint256) {}\n\n  function emergencyExpiryDuration() external override returns (uint256) {}\n\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external override {}\n\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external override {}\n\n  function getEmergencyExitInfo(address _consensusAddr) external view override returns (EmergencyExitInfo memory) {}\n\n  function execEmergencyExit(address, uint256) external {}\n\n  function isOperatingBridge(address) external view returns (bool) {}\n\n  function _emergencyExitLockedFundReleased(address _consensusAddr) internal virtual override returns (bool) {}\n\n  function _isTrustedOrg(address _consensusAddr) internal virtual override returns (bool) {}\n}\n"
    },
    "contracts/ronin/staking/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../libraries/Math.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"./CandidateStaking.sol\";\nimport \"./DelegatorStaking.sol\";\n\ncontract Staking is IStaking, CandidateStaking, DelegatorStaking, Initializable {\n  constructor() {\n    _disableInitializers();\n  }\n\n  receive() external payable onlyValidatorContract {}\n\n  fallback() external payable onlyValidatorContract {}\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __validatorContract,\n    uint256 __minValidatorStakingAmount,\n    uint256 __maxCommissionRate,\n    uint256 __cooldownSecsToUndelegate,\n    uint256 __waitingSecsToRevoke\n  ) external initializer {\n    _setValidatorContract(__validatorContract);\n    _setMinValidatorStakingAmount(__minValidatorStakingAmount);\n    _setMaxCommissionRate(__maxCommissionRate);\n    _setCooldownSecsToUndelegate(__cooldownSecsToUndelegate);\n    _setWaitingSecsToRevoke(__waitingSecsToRevoke);\n  }\n\n  /**\n   * @inheritdoc IStaking\n   */\n  function execRecordRewards(\n    address[] calldata _consensusAddrs,\n    uint256[] calldata _rewards,\n    uint256 _period\n  ) external payable override onlyValidatorContract {\n    _recordRewards(_consensusAddrs, _rewards, _period);\n  }\n\n  /**\n   * @inheritdoc IStaking\n   */\n  function execDeductStakingAmount(address _consensusAddr, uint256 _amount)\n    external\n    override\n    onlyValidatorContract\n    returns (uint256 _actualDeductingAmount)\n  {\n    _actualDeductingAmount = _deductStakingAmount(_stakingPool[_consensusAddr], _amount);\n    address payable _validatorContractAddr = payable(validatorContract());\n    if (!_unsafeSendRON(_validatorContractAddr, _actualDeductingAmount)) {\n      emit StakingAmountDeductFailed(\n        _consensusAddr,\n        _validatorContractAddr,\n        _actualDeductingAmount,\n        address(this).balance\n      );\n    }\n  }\n\n  /**\n   * @inheritdoc RewardCalculation\n   */\n  function _currentPeriod() internal view virtual override returns (uint256) {\n    return _validatorContract.currentPeriod();\n  }\n\n  /**\n   * @inheritdoc CandidateStaking\n   */\n  function _deductStakingAmount(PoolDetail storage _pool, uint256 _amount)\n    internal\n    override\n    returns (uint256 _actualDeductingAmount)\n  {\n    _actualDeductingAmount = Math.min(_pool.stakingAmount, _amount);\n\n    _pool.stakingAmount -= _actualDeductingAmount;\n    _changeDelegatingAmount(\n      _pool,\n      _pool.admin,\n      _pool.stakingAmount,\n      Math.subNonNegative(_pool.stakingTotal, _actualDeductingAmount)\n    );\n    emit Unstaked(_pool.addr, _actualDeductingAmount);\n  }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary Math {\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns whether the number `c` is in range of [a; b].\n   */\n  function inRange(\n    uint256 c,\n    uint256 a,\n    uint256 b\n  ) internal pure returns (bool) {\n    return a <= c && c <= b;\n  }\n\n  /**\n   * @dev Returns whether two inclusive ranges [x1;x2] and [y1;y2] overlap.\n   */\n  function twoRangeOverlap(\n    uint256 x1,\n    uint256 x2,\n    uint256 y1,\n    uint256 y2\n  ) internal pure returns (bool) {\n    return x1 <= y2 && y1 <= x2;\n  }\n\n  /**\n   * @dev Returns value of a + b; in case result is larger than upperbound, upperbound is returned.\n   */\n  function addWithUpperbound(\n    uint256 a,\n    uint256 b,\n    uint256 upperbound\n  ) internal pure returns (uint256) {\n    return min(a + b, upperbound);\n  }\n\n  /**\n   * @dev Returns value of a - b; in case of negative result, 0 is returned.\n   */\n  function subNonNegative(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - min(a, b);\n  }\n}\n"
    },
    "contracts/ronin/staking/CandidateStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../libraries/AddressArrayUtils.sol\";\nimport \"../../interfaces/staking/ICandidateStaking.sol\";\nimport \"./BaseStaking.sol\";\n\nabstract contract CandidateStaking is BaseStaking, ICandidateStaking, GlobalConfigConsumer, PercentageConsumer {\n  /// @dev The minimum threshold for being a validator candidate.\n  uint256 internal _minValidatorStakingAmount;\n\n  /// @dev The max commission rate that the validator can set (in range of [0;100_00] means [0-100%])\n  uint256 internal _maxCommissionRate;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[49] ______gap;\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function minValidatorStakingAmount() public view override returns (uint256) {\n    return _minValidatorStakingAmount;\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function maxCommissionRate() external view override returns (uint256) {\n    return _maxCommissionRate;\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function setMinValidatorStakingAmount(uint256 _threshold) external override onlyAdmin {\n    _setMinValidatorStakingAmount(_threshold);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function setMaxCommissionRate(uint256 _maxRate) external override onlyAdmin {\n    _setMaxCommissionRate(_maxRate);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function applyValidatorCandidate(\n    address _candidateAdmin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    address _bridgeOperatorAddr,\n    uint256 _commissionRate\n  ) external payable override nonReentrant {\n    if (isAdminOfActivePool(msg.sender)) revert ErrAdminOfAnyActivePoolForbidden(msg.sender);\n    if (_commissionRate > _maxCommissionRate) revert ErrInvalidCommissionRate();\n\n    uint256 _amount = msg.value;\n    address payable _poolAdmin = payable(msg.sender);\n    _applyValidatorCandidate(\n      _poolAdmin,\n      _candidateAdmin,\n      _consensusAddr,\n      _treasuryAddr,\n      _bridgeOperatorAddr,\n      _commissionRate,\n      _amount\n    );\n\n    PoolDetail storage _pool = _stakingPool[_consensusAddr];\n    _pool.admin = _poolAdmin;\n    _pool.addr = _consensusAddr;\n    _adminOfActivePoolMapping[_poolAdmin] = _consensusAddr;\n\n    _stake(_stakingPool[_consensusAddr], _poolAdmin, _amount);\n    emit PoolApproved(_consensusAddr, _poolAdmin);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function requestUpdateCommissionRate(\n    address _consensusAddr,\n    uint256 _effectiveDaysOnwards,\n    uint256 _commissionRate\n  ) external override poolIsActive(_consensusAddr) onlyPoolAdmin(_stakingPool[_consensusAddr], msg.sender) {\n    if (_commissionRate > _maxCommissionRate) revert ErrInvalidCommissionRate();\n    _validatorContract.execRequestUpdateCommissionRate(_consensusAddr, _effectiveDaysOnwards, _commissionRate);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function execDeprecatePools(address[] calldata _pools, uint256 _newPeriod) external override onlyValidatorContract {\n    if (_pools.length == 0) {\n      return;\n    }\n\n    for (uint _i = 0; _i < _pools.length; _i++) {\n      PoolDetail storage _pool = _stakingPool[_pools[_i]];\n      // Deactivate the pool admin in the active mapping.\n      delete _adminOfActivePoolMapping[_pool.admin];\n\n      // Deduct and transfer the self staking amount to the pool admin.\n      uint256 _deductingAmount = _pool.stakingAmount;\n      if (_deductingAmount > 0) {\n        _deductStakingAmount(_pool, _deductingAmount);\n        if (!_unsafeSendRON(payable(_pool.admin), _deductingAmount, DEFAULT_ADDITION_GAS)) {\n          emit StakingAmountTransferFailed(_pool.addr, _pool.admin, _deductingAmount, address(this).balance);\n        }\n      }\n\n      // Settle the unclaimed reward and transfer to the pool admin.\n      uint256 _lastRewardAmount = _claimReward(_pools[_i], _pool.admin, _newPeriod);\n      if (_lastRewardAmount > 0) {\n        _unsafeSendRON(payable(_pool.admin), _lastRewardAmount, DEFAULT_ADDITION_GAS);\n      }\n    }\n\n    emit PoolsDeprecated(_pools);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function stake(address _consensusAddr) external payable override noEmptyValue poolIsActive(_consensusAddr) {\n    _stake(_stakingPool[_consensusAddr], msg.sender, msg.value);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function unstake(address _consensusAddr, uint256 _amount)\n    external\n    override\n    nonReentrant\n    poolIsActive(_consensusAddr)\n  {\n    if (_amount == 0) revert ErrUnstakeZeroAmount();\n    address _requester = msg.sender;\n    PoolDetail storage _pool = _stakingPool[_consensusAddr];\n    uint256 _remainAmount = _pool.stakingAmount - _amount;\n    if (_remainAmount < _minValidatorStakingAmount) revert ErrStakingAmountLeft();\n\n    _unstake(_pool, _requester, _amount);\n    if (!_unsafeSendRON(payable(_requester), _amount, DEFAULT_ADDITION_GAS)) revert ErrCannotTransferRON();\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function requestRenounce(address _consensusAddr)\n    external\n    override\n    poolIsActive(_consensusAddr)\n    onlyPoolAdmin(_stakingPool[_consensusAddr], msg.sender)\n  {\n    _validatorContract.execRequestRenounceCandidate(_consensusAddr, _waitingSecsToRevoke);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function requestEmergencyExit(address _consensusAddr)\n    external\n    override\n    poolIsActive(_consensusAddr)\n    onlyPoolAdmin(_stakingPool[_consensusAddr], msg.sender)\n  {\n    _validatorContract.execEmergencyExit(_consensusAddr, _waitingSecsToRevoke);\n  }\n\n  /**\n   * @dev See `ICandidateStaking-applyValidatorCandidate`\n   */\n  function _applyValidatorCandidate(\n    address payable _poolAdmin,\n    address _candidateAdmin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    address _bridgeOperatorAddr,\n    uint256 _commissionRate,\n    uint256 _amount\n  ) internal {\n    if (!_unsafeSendRON(_poolAdmin, 0)) revert ErrCannotInitTransferRON(_poolAdmin, \"pool admin\");\n    if (!_unsafeSendRON(_treasuryAddr, 0)) revert ErrCannotInitTransferRON(_treasuryAddr, \"treasury\");\n    if (_amount < _minValidatorStakingAmount) revert ErrInsufficientStakingAmount();\n    if (_commissionRate > _maxCommissionRate) revert ErrInvalidCommissionRate();\n\n    if (_poolAdmin != _candidateAdmin || _candidateAdmin != _treasuryAddr) revert ErrThreeInteractionAddrsNotEqual();\n\n    address[] memory _diffAddrs = new address[](3);\n    _diffAddrs[0] = _poolAdmin;\n    _diffAddrs[1] = _consensusAddr;\n    _diffAddrs[2] = _bridgeOperatorAddr;\n    if (AddressArrayUtils.hasDuplicate(_diffAddrs)) revert ErrThreeOperationAddrsNotDistinct();\n\n    _validatorContract.execApplyValidatorCandidate(\n      _candidateAdmin,\n      _consensusAddr,\n      _treasuryAddr,\n      _bridgeOperatorAddr,\n      _commissionRate\n    );\n  }\n\n  /**\n   * @dev See `ICandidateStaking-stake`\n   */\n  function _stake(\n    PoolDetail storage _pool,\n    address _requester,\n    uint256 _amount\n  ) internal onlyPoolAdmin(_pool, _requester) {\n    _pool.stakingAmount += _amount;\n    _changeDelegatingAmount(_pool, _requester, _pool.stakingAmount, _pool.stakingTotal + _amount);\n    _pool.lastDelegatingTimestamp[_requester] = block.timestamp;\n    emit Staked(_pool.addr, _amount);\n  }\n\n  /**\n   * @dev See `ICandidateStaking-unstake`\n   */\n  function _unstake(\n    PoolDetail storage _pool,\n    address _requester,\n    uint256 _amount\n  ) internal onlyPoolAdmin(_pool, _requester) {\n    if (_amount > _pool.stakingAmount) revert ErrInsufficientStakingAmount();\n    if (_pool.lastDelegatingTimestamp[_requester] + _cooldownSecsToUndelegate > block.timestamp) {\n      revert ErrUnstakeTooEarly();\n    }\n\n    _pool.stakingAmount -= _amount;\n    _changeDelegatingAmount(_pool, _requester, _pool.stakingAmount, _pool.stakingTotal - _amount);\n    emit Unstaked(_pool.addr, _amount);\n  }\n\n  /**\n   * @dev Deducts from staking amount of the validator `_consensusAddr` for `_amount`.\n   *\n   * Emits the event `Unstaked`.\n   *\n   * @return The actual deducted amount\n   */\n  function _deductStakingAmount(PoolDetail storage _pool, uint256 _amount) internal virtual returns (uint256);\n\n  /**\n   * @dev Sets the minimum threshold for being a validator candidate.\n   *\n   * Emits the `MinValidatorStakingAmountUpdated` event.\n   *\n   */\n  function _setMinValidatorStakingAmount(uint256 _threshold) internal {\n    _minValidatorStakingAmount = _threshold;\n    emit MinValidatorStakingAmountUpdated(_threshold);\n  }\n\n  /**\n   * @dev Sets the max commission rate that a candidate can set.\n   *\n   * Emits the `MaxCommissionRateUpdated` event.\n   *\n   */\n  function _setMaxCommissionRate(uint256 _maxRate) internal {\n    if (_maxRate > _MAX_PERCENTAGE) revert ErrInvalidCommissionRate();\n    _maxCommissionRate = _maxRate;\n    emit MaxCommissionRateUpdated(_maxRate);\n  }\n}\n"
    },
    "contracts/ronin/staking/DelegatorStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/staking/IDelegatorStaking.sol\";\nimport \"./BaseStaking.sol\";\n\nabstract contract DelegatorStaking is BaseStaking, IDelegatorStaking {\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function delegate(address _consensusAddr) external payable noEmptyValue poolIsActive(_consensusAddr) {\n    if (isAdminOfActivePool(msg.sender)) revert ErrAdminOfAnyActivePoolForbidden(msg.sender);\n    _delegate(_stakingPool[_consensusAddr], msg.sender, msg.value);\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function undelegate(address _consensusAddr, uint256 _amount) external nonReentrant {\n    address payable _delegator = payable(msg.sender);\n    _undelegate(_stakingPool[_consensusAddr], _delegator, _amount);\n    if (!_sendRON(_delegator, _amount)) revert ErrCannotTransferRON();\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function bulkUndelegate(address[] calldata _consensusAddrs, uint256[] calldata _amounts) external nonReentrant {\n    if (_consensusAddrs.length == 0 || _consensusAddrs.length != _amounts.length) revert ErrInvalidArrays();\n\n    address payable _delegator = payable(msg.sender);\n    uint256 _total;\n\n    for (uint _i = 0; _i < _consensusAddrs.length; _i++) {\n      _total += _amounts[_i];\n      _undelegate(_stakingPool[_consensusAddrs[_i]], _delegator, _amounts[_i]);\n    }\n\n    if (!_sendRON(_delegator, _total)) revert ErrCannotTransferRON();\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function redelegate(\n    address _consensusAddrSrc,\n    address _consensusAddrDst,\n    uint256 _amount\n  ) external nonReentrant poolIsActive(_consensusAddrDst) {\n    address _delegator = msg.sender;\n    _undelegate(_stakingPool[_consensusAddrSrc], _delegator, _amount);\n    _delegate(_stakingPool[_consensusAddrDst], _delegator, _amount);\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function claimRewards(address[] calldata _consensusAddrList)\n    external\n    override\n    nonReentrant\n    returns (uint256 _amount)\n  {\n    _amount = _claimRewards(msg.sender, _consensusAddrList);\n    _transferRON(payable(msg.sender), _amount);\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function delegateRewards(address[] calldata _consensusAddrList, address _consensusAddrDst)\n    external\n    override\n    nonReentrant\n    poolIsActive(_consensusAddrDst)\n    returns (uint256 _amount)\n  {\n    if (isAdminOfActivePool(msg.sender)) revert ErrAdminOfAnyActivePoolForbidden(msg.sender);\n    return _delegateRewards(msg.sender, _consensusAddrList, _consensusAddrDst);\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function getRewards(address _user, address[] calldata _poolAddrList)\n    external\n    view\n    returns (uint256[] memory _rewards)\n  {\n    address _consensusAddr;\n    uint256 _period = _validatorContract.currentPeriod();\n    _rewards = new uint256[](_poolAddrList.length);\n\n    for (uint256 _i = 0; _i < _poolAddrList.length; _i++) {\n      _consensusAddr = _poolAddrList[_i];\n      _rewards[_i] = _getReward(_consensusAddr, _user, _period, getStakingAmount(_consensusAddr, _user));\n    }\n  }\n\n  /**\n   * @dev Delegates from a validator address.\n   *\n   * Requirements:\n   * - The delegator is not the pool admin.\n   *\n   * Emits the `Delegated` event.\n   *\n   * Note: This function does not verify the `msg.value` with the amount.\n   *\n   */\n  function _delegate(\n    PoolDetail storage _pool,\n    address _delegator,\n    uint256 _amount\n  ) internal notPoolAdmin(_pool, _delegator) {\n    _changeDelegatingAmount(\n      _pool,\n      _delegator,\n      _pool.delegatingAmount[_delegator] + _amount,\n      _pool.stakingTotal + _amount\n    );\n    _pool.lastDelegatingTimestamp[_delegator] = block.timestamp;\n    emit Delegated(_delegator, _pool.addr, _amount);\n  }\n\n  /**\n   * @dev Undelegates from a validator address.\n   *\n   * Requirements:\n   * - The delegator is not the pool admin.\n   * - The amount is larger than 0.\n   * - The delegating amount is larger than or equal to the undelegating amount.\n   *\n   * Emits the `Undelegated` event.\n   *\n   * Note: Consider transferring back the amount of RON after calling this function.\n   *\n   */\n  function _undelegate(\n    PoolDetail storage _pool,\n    address _delegator,\n    uint256 _amount\n  ) private notPoolAdmin(_pool, _delegator) {\n    if (_amount == 0) revert ErrUndelegateZeroAmount();\n    if (_pool.delegatingAmount[_delegator] < _amount) revert ErrInsufficientDelegatingAmount();\n    if (_pool.lastDelegatingTimestamp[_delegator] + _cooldownSecsToUndelegate >= block.timestamp) {\n      revert ErrUndelegateTooEarly();\n    }\n\n    _changeDelegatingAmount(\n      _pool,\n      _delegator,\n      _pool.delegatingAmount[_delegator] - _amount,\n      _pool.stakingTotal - _amount\n    );\n    emit Undelegated(_delegator, _pool.addr, _amount);\n  }\n\n  /**\n   * @dev Claims rewards from the pools `_poolAddrList`.\n   * Note: This function does not transfer reward to user.\n   */\n  function _claimRewards(address _user, address[] memory _poolAddrList) internal returns (uint256 _amount) {\n    uint256 _period = _currentPeriod();\n    for (uint256 _i = 0; _i < _poolAddrList.length; _i++) {\n      _amount += _claimReward(_poolAddrList[_i], _user, _period);\n    }\n  }\n\n  /**\n   * @dev Claims the rewards and delegates them to the consensus address.\n   */\n  function _delegateRewards(\n    address _user,\n    address[] calldata _poolAddrList,\n    address _poolAddrDst\n  ) internal returns (uint256 _amount) {\n    _amount = _claimRewards(_user, _poolAddrList);\n    _delegate(_stakingPool[_poolAddrDst], _user, _amount);\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/AddressArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary AddressArrayUtils {\n  /**\n   * @dev Returns whether or not there's a duplicate. Runs in O(n^2).\n   * @param A Array to search\n   * @return Returns true if duplicate, false otherwise\n   */\n  function hasDuplicate(address[] memory A) internal pure returns (bool) {\n    if (A.length == 0) {\n      return false;\n    }\n    for (uint256 i = 0; i < A.length - 1; i++) {\n      for (uint256 j = i + 1; j < A.length; j++) {\n        if (A[i] == A[j]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @dev Returns whether two arrays of addresses are equal or not.\n   */\n  function isEqual(address[] memory _this, address[] memory _other) internal pure returns (bool) {\n    bytes32 _thisHash;\n    bytes32 _otherHash;\n\n    assembly {\n      _thisHash := keccak256(add(_this, 32), mul(mload(_this), 32))\n      _otherHash := keccak256(add(_other, 32), mul(mload(_other), 32))\n    }\n\n    return _thisHash == _otherHash;\n  }\n}\n"
    },
    "contracts/ronin/staking/BaseStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../extensions/collections/HasValidatorContract.sol\";\nimport \"../../interfaces/staking/IBaseStaking.sol\";\nimport \"../../libraries/Math.sol\";\nimport \"./RewardCalculation.sol\";\n\nabstract contract BaseStaking is\n  RONTransferHelper,\n  ReentrancyGuard,\n  RewardCalculation,\n  HasValidatorContract,\n  IBaseStaking\n{\n  /// @dev Mapping from pool address => staking pool detail\n  mapping(address => PoolDetail) internal _stakingPool;\n\n  /// @dev The cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n  uint256 internal _cooldownSecsToUndelegate;\n  /// @dev The number of seconds that a candidate must wait to be revoked and take the self-staking amount back.\n  uint256 internal _waitingSecsToRevoke;\n\n  /// @dev Mapping from admin address of an active pool => consensus address.\n  mapping(address => address) internal _adminOfActivePoolMapping;\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[49] private ______gap;\n\n  modifier noEmptyValue() {\n    if (msg.value == 0) revert ErrZeroValue();\n    _;\n  }\n\n  modifier notPoolAdmin(PoolDetail storage _pool, address _delegator) {\n    if (_pool.admin == _delegator) revert ErrPoolAdminForbidden();\n    _;\n  }\n\n  modifier onlyPoolAdmin(PoolDetail storage _pool, address _requester) {\n    if (_pool.admin != _requester) revert ErrOnlyPoolAdminAllowed();\n    _;\n  }\n\n  modifier poolIsActive(address _poolAddr) {\n    if (!_validatorContract.isValidatorCandidate(_poolAddr)) revert ErrInactivePool(_poolAddr);\n    _;\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function isAdminOfActivePool(address _poolAdminAddr) public view override returns (bool) {\n    return _adminOfActivePoolMapping[_poolAdminAddr] != address(0);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function getPoolAddressOf(address _poolAdminAddr) external view override returns (address) {\n    return _adminOfActivePoolMapping[_poolAdminAddr];\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function getPoolDetail(address _poolAddr)\n    external\n    view\n    returns (\n      address _admin,\n      uint256 _stakingAmount,\n      uint256 _stakingTotal\n    )\n  {\n    PoolDetail storage _pool = _stakingPool[_poolAddr];\n    return (_pool.admin, _pool.stakingAmount, _pool.stakingTotal);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function getManySelfStakings(address[] calldata _pools) external view returns (uint256[] memory _selfStakings) {\n    _selfStakings = new uint256[](_pools.length);\n    for (uint _i = 0; _i < _pools.length; _i++) {\n      _selfStakings[_i] = _stakingPool[_pools[_i]].stakingAmount;\n    }\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getStakingTotal(address _poolAddr) public view override returns (uint256) {\n    return _stakingPool[_poolAddr].stakingTotal;\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getManyStakingTotals(address[] calldata _poolList)\n    public\n    view\n    override\n    returns (uint256[] memory _stakingAmounts)\n  {\n    _stakingAmounts = new uint256[](_poolList.length);\n    for (uint _i = 0; _i < _poolList.length; _i++) {\n      _stakingAmounts[_i] = getStakingTotal(_poolList[_i]);\n    }\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getStakingAmount(address _poolAddr, address _user) public view override returns (uint256) {\n    return _stakingPool[_poolAddr].delegatingAmount[_user];\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getManyStakingAmounts(address[] calldata _poolAddrs, address[] calldata _userList)\n    external\n    view\n    override\n    returns (uint256[] memory _stakingAmounts)\n  {\n    if (_poolAddrs.length != _userList.length) revert ErrInvalidArrays();\n    _stakingAmounts = new uint256[](_poolAddrs.length);\n    for (uint _i = 0; _i < _stakingAmounts.length; _i++) {\n      _stakingAmounts[_i] = _stakingPool[_poolAddrs[_i]].delegatingAmount[_userList[_i]];\n    }\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function cooldownSecsToUndelegate() external view returns (uint256) {\n    return _cooldownSecsToUndelegate;\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function waitingSecsToRevoke() external view returns (uint256) {\n    return _waitingSecsToRevoke;\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function setCooldownSecsToUndelegate(uint256 _cooldownSecs) external override onlyAdmin {\n    _setCooldownSecsToUndelegate(_cooldownSecs);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function setWaitingSecsToRevoke(uint256 _secs) external override onlyAdmin {\n    _setWaitingSecsToRevoke(_secs);\n  }\n\n  /**\n   * @dev Sets the minium number of seconds to undelegate.\n   *\n   * Emits the event `CooldownSecsToUndelegateUpdated`.\n   *\n   */\n  function _setCooldownSecsToUndelegate(uint256 _cooldownSecs) internal {\n    _cooldownSecsToUndelegate = _cooldownSecs;\n    emit CooldownSecsToUndelegateUpdated(_cooldownSecs);\n  }\n\n  /**\n   * @dev Sets the number of seconds that a candidate must wait to be revoked.\n   *\n   * Emits the event `WaitingSecsToRevokeUpdated`.\n   *\n   */\n  function _setWaitingSecsToRevoke(uint256 _secs) internal {\n    _waitingSecsToRevoke = _secs;\n    emit WaitingSecsToRevokeUpdated(_secs);\n  }\n\n  /**\n   * @dev Changes the delegate amount.\n   */\n  function _changeDelegatingAmount(\n    PoolDetail storage _pool,\n    address _delegator,\n    uint256 _newDelegatingAmount,\n    uint256 _newStakingTotal\n  ) internal {\n    _syncUserReward(_pool.addr, _delegator, _newDelegatingAmount);\n    _pool.stakingTotal = _newStakingTotal;\n    _pool.delegatingAmount[_delegator] = _newDelegatingAmount;\n  }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/ronin/staking/RewardCalculation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/staking/IRewardPool.sol\";\nimport \"../../libraries/Math.sol\";\n\n/**\n * @title RewardCalculation contract\n * @dev This contract mainly contains the methods to calculate reward for staking contract.\n */\nabstract contract RewardCalculation is IRewardPool {\n  /// @dev Mapping from pool address => period number => accumulated rewards per share (one unit staking)\n  mapping(address => mapping(uint256 => PeriodWrapper)) private _accumulatedRps;\n  /// @dev Mapping from the pool address => user address => the reward info of the user\n  mapping(address => mapping(address => UserRewardFields)) private _userReward;\n  /// @dev Mapping from the pool address => reward pool fields\n  mapping(address => PoolFields) private _stakingPool;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getReward(address _poolAddr, address _user) external view returns (uint256) {\n    return _getReward(_poolAddr, _user, _currentPeriod(), getStakingAmount(_poolAddr, _user));\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getStakingAmount(address _poolAddr, address _user) public view virtual returns (uint256);\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getStakingTotal(address _poolAddr) public view virtual returns (uint256);\n\n  /**\n   * @dev Returns the reward amount that user claimable.\n   */\n  function _getReward(\n    address _poolAddr,\n    address _user,\n    uint256 _latestPeriod,\n    uint256 _latestStakingAmount\n  ) internal view returns (uint256) {\n    UserRewardFields storage _reward = _userReward[_poolAddr][_user];\n\n    if (_reward.lastPeriod == _latestPeriod) {\n      return _reward.debited;\n    }\n\n    uint256 _aRps;\n    uint256 _lastPeriodReward;\n    PoolFields storage _pool = _stakingPool[_poolAddr];\n    PeriodWrapper storage _wrappedArps = _accumulatedRps[_poolAddr][_reward.lastPeriod];\n\n    if (_wrappedArps.lastPeriod > 0) {\n      // Calculates the last period reward if the aRps at the period is set\n      _aRps = _wrappedArps.inner;\n      _lastPeriodReward = _reward.lowestAmount * (_aRps - _reward.aRps);\n    } else {\n      // Fallbacks to the previous aRps in case the aRps is not set\n      _aRps = _reward.aRps;\n    }\n\n    uint256 _newPeriodsReward = _latestStakingAmount * (_pool.aRps - _aRps);\n    return _reward.debited + (_lastPeriodReward + _newPeriodsReward) / 1e18;\n  }\n\n  /**\n   * @dev Syncs the user reward.\n   *\n   * Emits the event `UserRewardUpdated` once the debit amount is updated.\n   * Emits the event `PoolSharesUpdated` once the pool share is updated.\n   *\n   * Note: The method should be called whenever the user's staking amount changes.\n   *\n   */\n  function _syncUserReward(\n    address _poolAddr,\n    address _user,\n    uint256 _newStakingAmount\n  ) internal {\n    uint256 _period = _currentPeriod();\n    PoolFields storage _pool = _stakingPool[_poolAddr];\n    uint256 _lastShares = _pool.shares.inner;\n\n    // Updates the pool shares if it is outdated\n    if (_pool.shares.lastPeriod < _period) {\n      _pool.shares = PeriodWrapper(getStakingTotal(_poolAddr), _period);\n    }\n\n    UserRewardFields storage _reward = _userReward[_poolAddr][_user];\n    uint256 _currentStakingAmount = getStakingAmount(_poolAddr, _user);\n    uint256 _debited = _getReward(_poolAddr, _user, _period, _currentStakingAmount);\n\n    if (_reward.debited != _debited) {\n      _reward.debited = _debited;\n      emit UserRewardUpdated(_poolAddr, _user, _debited);\n    }\n\n    _syncMinStakingAmount(_pool, _reward, _period, _newStakingAmount, _currentStakingAmount);\n    _reward.aRps = _pool.aRps;\n    _reward.lastPeriod = _period;\n\n    if (_pool.shares.inner != _lastShares) {\n      emit PoolSharesUpdated(_period, _poolAddr, _pool.shares.inner);\n    }\n  }\n\n  /**\n   * @dev Syncs the minimum staking amount of an user in the current period.\n   */\n  function _syncMinStakingAmount(\n    PoolFields storage _pool,\n    UserRewardFields storage _reward,\n    uint256 _latestPeriod,\n    uint256 _newStakingAmount,\n    uint256 _currentStakingAmount\n  ) internal {\n    if (_reward.lastPeriod < _latestPeriod) {\n      _reward.lowestAmount = _currentStakingAmount;\n    }\n\n    uint256 _lowestAmount = Math.min(_reward.lowestAmount, _newStakingAmount);\n    uint256 _diffAmount = _reward.lowestAmount - _lowestAmount;\n    if (_diffAmount > 0) {\n      _reward.lowestAmount = _lowestAmount;\n      if (_pool.shares.inner < _diffAmount) revert ErrInvalidPoolShare();\n      _pool.shares.inner -= _diffAmount;\n    }\n  }\n\n  /**\n   * @dev Claims the settled reward for a specific user.\n   *\n   * @param _lastPeriod Must be in two possible value: `_currentPeriod` in normal calculation, or\n   * `_currentPeriod + 1` in case of calculating the reward for revoked validators.\n   *\n   * Emits the `RewardClaimed` event and the `UserRewardUpdated` event.\n   *\n   * Note: This method should be called before transferring rewards for the user.\n   *\n   */\n  function _claimReward(\n    address _poolAddr,\n    address _user,\n    uint256 _lastPeriod\n  ) internal returns (uint256 _amount) {\n    uint256 _currentStakingAmount = getStakingAmount(_poolAddr, _user);\n    _amount = _getReward(_poolAddr, _user, _lastPeriod, _currentStakingAmount);\n    emit RewardClaimed(_poolAddr, _user, _amount);\n\n    UserRewardFields storage _reward = _userReward[_poolAddr][_user];\n    _reward.debited = 0;\n    _syncMinStakingAmount(_stakingPool[_poolAddr], _reward, _lastPeriod, _currentStakingAmount, _currentStakingAmount);\n    _reward.lastPeriod = _lastPeriod;\n    _reward.aRps = _stakingPool[_poolAddr].aRps;\n    emit UserRewardUpdated(_poolAddr, _user, 0);\n  }\n\n  /**\n   * @dev Records the amount of rewards `_rewards` for the pools `_poolAddrs`.\n   *\n   * Emits the event `PoolsUpdated` once the contract recorded the rewards successfully.\n   * Emits the event `PoolsUpdateFailed` once the input array lengths are not equal.\n   * Emits the event `PoolUpdateConflicted` when the pool is already updated in the period.\n   *\n   * Note: This method should be called once at the period ending.\n   *\n   */\n  function _recordRewards(\n    address[] memory _poolAddrs,\n    uint256[] calldata _rewards,\n    uint256 _period\n  ) internal {\n    if (_poolAddrs.length != _rewards.length) {\n      emit PoolsUpdateFailed(_period, _poolAddrs, _rewards);\n      return;\n    }\n\n    uint256 _rps;\n    uint256 _count;\n    address _poolAddr;\n    uint256 _stakingTotal;\n    uint256[] memory _aRps = new uint256[](_poolAddrs.length);\n    uint256[] memory _shares = new uint256[](_poolAddrs.length);\n    address[] memory _conflicted = new address[](_poolAddrs.length);\n\n    for (uint _i = 0; _i < _poolAddrs.length; _i++) {\n      _poolAddr = _poolAddrs[_i];\n      PoolFields storage _pool = _stakingPool[_poolAddr];\n      _stakingTotal = getStakingTotal(_poolAddr);\n\n      if (_accumulatedRps[_poolAddr][_period].lastPeriod == _period) {\n        _conflicted[_count++] = _poolAddr;\n        continue;\n      }\n\n      // Updates the pool shares if it is outdated\n      if (_pool.shares.lastPeriod < _period) {\n        _pool.shares = PeriodWrapper(_stakingTotal, _period);\n      }\n\n      // The rps is 0 if no one stakes for the pool\n      _rps = _pool.shares.inner == 0 ? 0 : (_rewards[_i] * 1e18) / _pool.shares.inner;\n      _aRps[_i - _count] = _pool.aRps += _rps;\n      _accumulatedRps[_poolAddr][_period] = PeriodWrapper(_pool.aRps, _period);\n      _pool.shares.inner = _stakingTotal;\n      _shares[_i - _count] = _pool.shares.inner;\n      _poolAddrs[_i - _count] = _poolAddr;\n    }\n\n    if (_count > 0) {\n      assembly {\n        mstore(_conflicted, _count)\n        mstore(_poolAddrs, sub(mload(_poolAddrs), _count))\n      }\n      emit PoolsUpdateConflicted(_period, _conflicted);\n    }\n\n    if (_poolAddrs.length > 0) {\n      emit PoolsUpdated(_period, _poolAddrs, _aRps, _shares);\n    }\n  }\n\n  /**\n   * @dev Returns the current period.\n   */\n  function _currentPeriod() internal view virtual returns (uint256);\n}\n"
    },
    "contracts/ronin/Maintenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IMaintenance.sol\";\nimport \"../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../extensions/collections/HasValidatorContract.sol\";\nimport \"../libraries/Math.sol\";\n\ncontract Maintenance is IMaintenance, HasValidatorContract, Initializable {\n  using Math for uint256;\n\n  /// @dev Mapping from consensus address => maintenance schedule.\n  mapping(address => Schedule) internal _schedule;\n\n  /// @dev The min duration to maintenance in blocks.\n  uint256 public minMaintenanceDurationInBlock;\n  /// @dev The max duration to maintenance in blocks.\n  uint256 public maxMaintenanceDurationInBlock;\n  /// @dev The offset to the min block number that the schedule can start.\n  uint256 public minOffsetToStartSchedule;\n  /// @dev The offset to the max block number that the schedule can start.\n  uint256 public maxOffsetToStartSchedule;\n  /// @dev The max number of scheduled maintenances.\n  uint256 public maxSchedules;\n  /// @dev The cooldown time to request new schedule.\n  uint256 public cooldownSecsToMaintain;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __validatorContract,\n    uint256 _minMaintenanceDurationInBlock,\n    uint256 _maxMaintenanceDurationInBlock,\n    uint256 _minOffsetToStartSchedule,\n    uint256 _maxOffsetToStartSchedule,\n    uint256 _maxSchedules,\n    uint256 _cooldownSecsToMaintain\n  ) external initializer {\n    _setValidatorContract(__validatorContract);\n    _setMaintenanceConfig(\n      _minMaintenanceDurationInBlock,\n      _maxMaintenanceDurationInBlock,\n      _minOffsetToStartSchedule,\n      _maxOffsetToStartSchedule,\n      _maxSchedules,\n      _cooldownSecsToMaintain\n    );\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function setMaintenanceConfig(\n    uint256 _minMaintenanceDurationInBlock,\n    uint256 _maxMaintenanceDurationInBlock,\n    uint256 _minOffsetToStartSchedule,\n    uint256 _maxOffsetToStartSchedule,\n    uint256 _maxSchedules,\n    uint256 _cooldownSecsToMaintain\n  ) external onlyAdmin {\n    _setMaintenanceConfig(\n      _minMaintenanceDurationInBlock,\n      _maxMaintenanceDurationInBlock,\n      _minOffsetToStartSchedule,\n      _maxOffsetToStartSchedule,\n      _maxSchedules,\n      _cooldownSecsToMaintain\n    );\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function schedule(\n    address _consensusAddr,\n    uint256 _startedAtBlock,\n    uint256 _endedAtBlock\n  ) external override {\n    IRoninValidatorSet _validator = _validatorContract;\n\n    require(_validator.isBlockProducer(_consensusAddr), \"Maintenance: consensus address must be a block producer\");\n    require(\n      _validator.isCandidateAdmin(_consensusAddr, msg.sender),\n      \"Maintenance: method caller must be a candidate admin\"\n    );\n    require(!checkScheduled(_consensusAddr), \"Maintenance: already scheduled\");\n    require(checkCooldownEnds(_consensusAddr), \"Maintainance: cooldown time not end\");\n    require(totalSchedules() < maxSchedules, \"Maintenance: exceeds total of schedules\");\n    require(\n      _startedAtBlock.inRange(block.number + minOffsetToStartSchedule, block.number + maxOffsetToStartSchedule),\n      \"Maintenance: start block is out of offset\"\n    );\n    require(_startedAtBlock < _endedAtBlock, \"Maintenance: start block must be less than end block\");\n    uint256 _blockPeriod = _endedAtBlock - _startedAtBlock;\n    require(\n      _blockPeriod.inRange(minMaintenanceDurationInBlock, maxMaintenanceDurationInBlock),\n      \"Maintenance: invalid maintenance duration\"\n    );\n    require(_validator.epochEndingAt(_startedAtBlock - 1), \"Maintenance: start block is not at the start of an epoch\");\n    require(_validator.epochEndingAt(_endedAtBlock), \"Maintenance: end block is not at the end of an epoch\");\n\n    Schedule storage _sSchedule = _schedule[_consensusAddr];\n    _sSchedule.from = _startedAtBlock;\n    _sSchedule.to = _endedAtBlock;\n    _sSchedule.lastUpdatedBlock = block.number;\n    _sSchedule.requestTimestamp = block.timestamp;\n    emit MaintenanceScheduled(_consensusAddr, _sSchedule);\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function cancelSchedule(address _consensusAddr) external override {\n    require(\n      _validatorContract.isCandidateAdmin(_consensusAddr, msg.sender),\n      \"Maintenance: method caller must be the candidate admin\"\n    );\n    require(checkScheduled(_consensusAddr), \"Maintenance: no schedule exists\");\n    require(!checkMaintained(_consensusAddr, block.number), \"Maintenance: already on maintenance\");\n    Schedule storage _sSchedule = _schedule[_consensusAddr];\n    delete _sSchedule.from;\n    delete _sSchedule.to;\n    _sSchedule.lastUpdatedBlock = block.number;\n    emit MaintenanceScheduleCancelled(_consensusAddr);\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function getSchedule(address _consensusAddr) external view override returns (Schedule memory) {\n    return _schedule[_consensusAddr];\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkManyMaintained(address[] calldata _addrList, uint256 _block)\n    external\n    view\n    override\n    returns (bool[] memory _resList)\n  {\n    _resList = new bool[](_addrList.length);\n    for (uint _i = 0; _i < _addrList.length; _i++) {\n      _resList[_i] = checkMaintained(_addrList[_i], _block);\n    }\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkManyMaintainedInBlockRange(\n    address[] calldata _addrList,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view override returns (bool[] memory _resList) {\n    _resList = new bool[](_addrList.length);\n    for (uint _i = 0; _i < _addrList.length; _i++) {\n      _resList[_i] = _maintainingInBlockRange(_addrList[_i], _fromBlock, _toBlock);\n    }\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function totalSchedules() public view override returns (uint256 _count) {\n    (address[] memory _validators, , ) = _validatorContract.getValidators();\n    for (uint _i = 0; _i < _validators.length; _i++) {\n      if (checkScheduled(_validators[_i])) {\n        _count++;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkMaintained(address _consensusAddr, uint256 _block) public view override returns (bool) {\n    Schedule storage _s = _schedule[_consensusAddr];\n    return _s.from <= _block && _block <= _s.to;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkMaintainedInBlockRange(\n    address _consensusAddr,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) public view override returns (bool) {\n    return _maintainingInBlockRange(_consensusAddr, _fromBlock, _toBlock);\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkScheduled(address _consensusAddr) public view override returns (bool) {\n    return block.number <= _schedule[_consensusAddr].to;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkCooldownEnds(address _consensusAddr) public view override returns (bool) {\n    return block.timestamp > _schedule[_consensusAddr].requestTimestamp + cooldownSecsToMaintain;\n  }\n\n  /**\n   * @dev Sets the min block period and max block period to maintenance.\n   *\n   * Requirements:\n   * - The max period is larger than the min period.\n   *\n   * Emits the event `MaintenanceConfigUpdated`.\n   *\n   */\n  function _setMaintenanceConfig(\n    uint256 _minMaintenanceDurationInBlock,\n    uint256 _maxMaintenanceDurationInBlock,\n    uint256 _minOffsetToStartSchedule,\n    uint256 _maxOffsetToStartSchedule,\n    uint256 _maxSchedules,\n    uint256 _cooldownSecsToMaintain\n  ) internal {\n    require(\n      _minMaintenanceDurationInBlock < _maxMaintenanceDurationInBlock,\n      \"Maintenance: invalid maintenance duration configs\"\n    );\n    require(\n      _minOffsetToStartSchedule < _maxOffsetToStartSchedule,\n      \"Maintenance: invalid offset to start schedule configs\"\n    );\n    minMaintenanceDurationInBlock = _minMaintenanceDurationInBlock;\n    maxMaintenanceDurationInBlock = _maxMaintenanceDurationInBlock;\n    minOffsetToStartSchedule = _minOffsetToStartSchedule;\n    maxOffsetToStartSchedule = _maxOffsetToStartSchedule;\n    maxSchedules = _maxSchedules;\n    cooldownSecsToMaintain = _cooldownSecsToMaintain;\n    emit MaintenanceConfigUpdated(\n      _minMaintenanceDurationInBlock,\n      _maxMaintenanceDurationInBlock,\n      _minOffsetToStartSchedule,\n      _maxOffsetToStartSchedule,\n      _maxSchedules,\n      _cooldownSecsToMaintain\n    );\n  }\n\n  /**\n   * @dev Check if the validator was maintaining in the current period.\n   *\n   * Note: This method should be called at the end of the period.\n   */\n  function _maintainingInBlockRange(\n    address _consensusAddr,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) private view returns (bool) {\n    Schedule storage _s = _schedule[_consensusAddr];\n    return Math.twoRangeOverlap(_fromBlock, _toBlock, _s.from, _s.to);\n  }\n}\n"
    },
    "contracts/interfaces/IMaintenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IMaintenance {\n  struct Schedule {\n    uint256 from;\n    uint256 to;\n    uint256 lastUpdatedBlock;\n    uint256 requestTimestamp;\n  }\n\n  /// @dev Emitted when a maintenance is scheduled.\n  event MaintenanceScheduled(address indexed consensusAddr, Schedule);\n  /// @dev Emitted when a schedule of maintenance is cancelled.\n  event MaintenanceScheduleCancelled(address indexed consensusAddr);\n  /// @dev Emitted when the maintenance config is updated.\n  event MaintenanceConfigUpdated(\n    uint256 minMaintenanceDurationInBlock,\n    uint256 maxMaintenanceDurationInBlock,\n    uint256 minOffsetToStartSchedule,\n    uint256 maxOffsetToStartSchedule,\n    uint256 maxSchedules,\n    uint256 cooldownSecsToMaintain\n  );\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr` maintained at the block number `_block`.\n   */\n  function checkMaintained(address _consensusAddr, uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr` maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks.\n   */\n  function checkMaintainedInBlockRange(\n    address _consensusAddr,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool);\n\n  /**\n   * @dev Returns the bool array indicating the validators maintained at block number `_block` or not.\n   */\n  function checkManyMaintained(address[] calldata _addrList, uint256 _block) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns a bool array indicating the validators maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks or not.\n   */\n  function checkManyMaintainedInBlockRange(\n    address[] calldata _addrList,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr` has scheduled.\n   */\n  function checkScheduled(address _consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr`\n   */\n  function checkCooldownEnds(address _consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns the detailed schedule of the validator `_consensusAddr`.\n   */\n  function getSchedule(address _consensusAddr) external view returns (Schedule memory);\n\n  /**\n   * @dev Returns the total of current schedules.\n   */\n  function totalSchedules() external view returns (uint256 _count);\n\n  /**\n   * @dev Sets the duration restriction, start time restriction, and max allowed for maintenance.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The max duration is larger than the min duration.\n   * - The max offset is larger than the min offset.\n   *\n   * Emits the event `MaintenanceConfigUpdated`.\n   *\n   */\n  function setMaintenanceConfig(\n    uint256 _minMaintenanceDurationInBlock,\n    uint256 _maxMaintenanceDurationInBlock,\n    uint256 _minOffsetToStartSchedule,\n    uint256 _maxOffsetToStartSchedule,\n    uint256 _maxSchedules,\n    uint256 _cooldownSecsToMaintain\n  ) external;\n\n  /**\n   * @dev Returns the min duration for maintenance in block.\n   */\n  function minMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the max duration for maintenance in block.\n   */\n  function maxMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev The offset to the min block number that the schedule can start\n   */\n  function minOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev The offset to the max block number that the schedule can start\n   */\n  function maxOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev Returns the max number of scheduled maintenances.\n   */\n  function maxSchedules() external view returns (uint256);\n\n  /**\n   * @dev Schedules for maintenance from `_startedAtBlock` to `_startedAtBlock`.\n   *\n   * Requirements:\n   * - The candidate `_consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `_consensusAddr`.\n   * - The candidate `_consensusAddr` has no schedule yet or the previous is done.\n   * - The total number of schedules is not larger than `maxSchedules()`.\n   * - The start block must be at least `minOffsetToStartSchedule()` and at most `maxOffsetToStartSchedule()` blocks from the current block.\n   * - The end block is larger than the start block.\n   * - The scheduled duration is larger than the `minMaintenanceDurationInBlock()` and less than the `maxMaintenanceDurationInBlock()`.\n   * - The start block is at the start of an epoch.\n   * - The end block is at the end of an epoch.\n   *\n   * Emits the event `MaintenanceScheduled`.\n   *\n   */\n  function schedule(\n    address _consensusAddr,\n    uint256 _startedAtBlock,\n    uint256 _endedAtBlock\n  ) external;\n\n  /**\n   * @dev Cancel the schedule of maintenance for the `_consensusAddr`.\n   *\n   * Requirements:\n   * - The candidate `_consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `_consensusAddr`.\n   * - A schedule for the `_consensusAddr` must be existent and not executed yet.\n   *\n   * Emits the event `MaintenanceScheduleCancelled`.\n   */\n  function cancelSchedule(address _consensusAddr) external;\n}\n"
    },
    "contracts/ronin/StakingVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IStakingVesting.sol\";\nimport \"../extensions/collections/HasValidatorContract.sol\";\nimport \"../extensions/RONTransferHelper.sol\";\n\ncontract StakingVesting is IStakingVesting, HasValidatorContract, RONTransferHelper, Initializable {\n  /// @dev The block bonus for the block producer whenever a new block is mined.\n  uint256 internal _blockProducerBonusPerBlock;\n  /// @dev The block bonus for the bridge operator whenever a new block is mined.\n  uint256 internal _bridgeOperatorBonusPerBlock;\n  /// @dev The last block number that the staking vesting sent.\n  uint256 public lastBlockSendingBonus;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __validatorContract,\n    uint256 __blockProducerBonusPerBlock,\n    uint256 __bridgeOperatorBonusPerBlock\n  ) external payable initializer {\n    _setValidatorContract(__validatorContract);\n    _setBlockProducerBonusPerBlock(__blockProducerBonusPerBlock);\n    _setBridgeOperatorBonusPerBlock(__bridgeOperatorBonusPerBlock);\n  }\n\n  /**\n   * @inheritdoc IStakingVesting\n   */\n  function receiveRON() external payable {}\n\n  /**\n   * @inheritdoc IStakingVesting\n   */\n  function blockProducerBlockBonus(\n    uint256 /* _block */\n  ) public view override returns (uint256) {\n    return _blockProducerBonusPerBlock;\n  }\n\n  /**\n   * @inheritdoc IStakingVesting\n   */\n  function bridgeOperatorBlockBonus(\n    uint256 /* _block */\n  ) public view override returns (uint256) {\n    return _bridgeOperatorBonusPerBlock;\n  }\n\n  /**\n   * @inheritdoc IStakingVesting\n   */\n  function requestBonus(bool _forBlockProducer, bool _forBridgeOperator)\n    external\n    override\n    onlyValidatorContract\n    returns (\n      bool _success,\n      uint256 _blockProducerBonus,\n      uint256 _bridgeOperatorBonus\n    )\n  {\n    require(block.number > lastBlockSendingBonus, \"StakingVesting: bonus for already sent\");\n    lastBlockSendingBonus = block.number;\n\n    _blockProducerBonus = _forBlockProducer ? blockProducerBlockBonus(block.number) : 0;\n    _bridgeOperatorBonus = _forBridgeOperator ? bridgeOperatorBlockBonus(block.number) : 0;\n\n    uint256 _totalAmount = _blockProducerBonus + _bridgeOperatorBonus;\n\n    if (_totalAmount > 0) {\n      address payable _validatorContractAddr = payable(validatorContract());\n\n      _success = _unsafeSendRON(_validatorContractAddr, _totalAmount);\n\n      if (!_success) {\n        emit BonusTransferFailed(\n          block.number,\n          _validatorContractAddr,\n          _blockProducerBonus,\n          _bridgeOperatorBonus,\n          address(this).balance\n        );\n        return (_success, 0, 0);\n      }\n\n      emit BonusTransferred(block.number, _validatorContractAddr, _blockProducerBonus, _bridgeOperatorBonus);\n    }\n  }\n\n  /**\n   * @inheritdoc IStakingVesting\n   */\n  function setBlockProducerBonusPerBlock(uint256 _amount) external override onlyAdmin {\n    _setBlockProducerBonusPerBlock(_amount);\n  }\n\n  /**\n   * @inheritdoc IStakingVesting\n   */\n  function setBridgeOperatorBonusPerBlock(uint256 _amount) external override onlyAdmin {\n    _setBridgeOperatorBonusPerBlock(_amount);\n  }\n\n  /**\n   * @dev Sets the bonus amount per block for block producer.\n   *\n   * Emits the event `BlockProducerBonusPerBlockUpdated`.\n   *\n   */\n  function _setBlockProducerBonusPerBlock(uint256 _amount) internal {\n    _blockProducerBonusPerBlock = _amount;\n    emit BlockProducerBonusPerBlockUpdated(_amount);\n  }\n\n  /**\n   * @dev Sets the bonus amount per block for bridge operator.\n   *\n   * Emits the event `BridgeOperatorBonusPerBlockUpdated`.\n   *\n   */\n  function _setBridgeOperatorBonusPerBlock(uint256 _amount) internal {\n    _bridgeOperatorBonusPerBlock = _amount;\n    emit BridgeOperatorBonusPerBlockUpdated(_amount);\n  }\n}\n"
    },
    "contracts/interfaces/IStakingVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IStakingVesting {\n  /// @dev Emitted when the block bonus for block producer is transferred.\n  event BonusTransferred(\n    uint256 indexed blockNumber,\n    address indexed recipient,\n    uint256 blockProducerAmount,\n    uint256 bridgeOperatorAmount\n  );\n  /// @dev Emitted when the transfer of block bonus for block producer is failed.\n  event BonusTransferFailed(\n    uint256 indexed blockNumber,\n    address indexed recipient,\n    uint256 blockProducerAmount,\n    uint256 bridgeOperatorAmount,\n    uint256 contractBalance\n  );\n  /// @dev Emitted when the block bonus for block producer is updated\n  event BlockProducerBonusPerBlockUpdated(uint256);\n  /// @dev Emitted when the block bonus for bridge operator is updated\n  event BridgeOperatorBonusPerBlockUpdated(uint256);\n\n  /**\n   * @dev Returns the bonus amount for the block producer at `_block`.\n   */\n  function blockProducerBlockBonus(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Returns the bonus amount for the bridge validator at `_block`.\n   */\n  function bridgeOperatorBlockBonus(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Receives RON from any address.\n   */\n  function receiveRON() external payable;\n\n  /**\n   * @dev Returns the last block number that the staking vesting is sent.\n   */\n  function lastBlockSendingBonus() external view returns (uint256);\n\n  /**\n   * @dev Transfers the staking vesting for the block producer and the bridge operator whenever a new block is mined.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   * - The method must be called only once per block.\n   *\n   * Emits the event `BonusTransferred` or `BonusTransferFailed`.\n   *\n   * Notes:\n   * - The method does not revert when the contract balance is insufficient to send bonus. This assure the submit reward method\n   * will not be reverted, and the underlying nodes does not hang.\n   *\n   * @param _forBlockProducer Indicates whether requesting the bonus for the block procucer, in case of being in jail or relevance.\n   * @param _forBridgeOperator Indicates whether requesting the bonus for the bridge operator.\n   *\n   * @return _success Whether the transfer is successfully. This returns false mostly because this contract is out of balance.\n   * @return _blockProducerBonus The amount of bonus actually sent for the block producer, returns 0 when the transfer is failed.\n   * @return _bridgeOperatorBonus The amount of bonus actually sent for the bridge operator, returns 0 when the transfer is failed.\n   *\n   */\n  function requestBonus(bool _forBlockProducer, bool _forBridgeOperator)\n    external\n    returns (\n      bool _success,\n      uint256 _blockProducerBonus,\n      uint256 _bridgeOperatorBonus\n    );\n\n  /**\n   * @dev Sets the bonus amount per block for block producer.\n   *\n   * Emits the event `BlockProducerBonusPerBlockUpdated`.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   */\n  function setBlockProducerBonusPerBlock(uint256 _amount) external;\n\n  /**\n   * @dev Sets the bonus amount per block for bridge operator.\n   *\n   * Emits the event `BridgeOperatorBonusPerBlockUpdated`.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   */\n  function setBridgeOperatorBonusPerBlock(uint256 _amount) external;\n}\n"
    },
    "contracts/ronin/VaultForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../extensions/forwarder/Forwarder.sol\";\nimport \"../extensions/RONTransferHelper.sol\";\n\n/**\n * @title A vault contract that keeps RON, and behaves as an EOA account to interact with a target contract.\n * @dev There are three roles of interaction:\n * - Admin: top-up and withdraw RON to the vault, cannot forward call to the target.\n * - Moderator: forward all calls to the target, can top-up RON, cannot withdraw RON.\n * - Others: can top-up RON, cannot execute any other actions.\n */\ncontract VaultForwarder is Forwarder, RONTransferHelper {\n  /// @dev Emitted when the admin withdraws all RON from the forwarder contract.\n  event ForwarderRONWithdrawn(address indexed _recipient, uint256 _value);\n\n  constructor(\n    address[] memory _targets,\n    address _admin,\n    address _mod\n  ) Forwarder(_targets, _admin, _mod) {}\n\n  /**\n   * @dev Withdraws all balance from the transfer to the admin.\n   *\n   * Requirements:\n   * - Only the admin can call this method.\n   */\n  function withdrawAll() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    uint256 _value = address(this).balance;\n    emit ForwarderRONWithdrawn(msg.sender, _value);\n    _transferRON(payable(msg.sender), _value);\n  }\n}\n"
    },
    "contracts/extensions/forwarder/Forwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\ncontract Forwarder is AccessControlEnumerable {\n  /// @dev Only user with moderator role can invoke {functionCall} method to forward the call to the target.\n  bytes32 public constant MODERATOR_ROLE = keccak256(\"MODERATOR_ROLE\");\n\n  /**\n   * @dev The target contracts must be registerred by the admin before called to. The admin can register the targets at\n   * the contract construction or by assigning {TARGET_ROLE} to the target addresses.\n   */\n  bytes32 public constant TARGET_ROLE = keccak256(\"TARGET_ROLE\");\n\n  /**\n   * @dev Initializes the forwarder with an initial target address and a contract admin.\n   */\n  constructor(\n    address[] memory _targets,\n    address _admin,\n    address _moderator\n  ) payable {\n    for (uint _i = 0; _i < _targets.length; _i++) {\n      _setupRole(TARGET_ROLE, _targets[_i]);\n    }\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n    _setupRole(MODERATOR_ROLE, _moderator);\n  }\n\n  modifier validTarget(address _target) {\n    _checkRole(TARGET_ROLE, _target);\n    _;\n  }\n\n  /**\n   * @dev Receives RON transfer from all addresses.\n   */\n  fallback() external payable {}\n\n  /**\n   * @dev Receives RON transfer from all addresses.\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Forwards the encoded call specified by `_data` to the target. The forwarder attachs `_val` value\n   * from the forwarder contract and sends along with the call.\n   *\n   * Requirements:\n   * - Only target with {TARGET_ROLE} can be called to.\n   * - Only user with {MODERATOR_ROLE} can call this method.\n   */\n  function functionCall(\n    address _target,\n    bytes memory _data,\n    uint256 _val\n  ) external payable validTarget(_target) onlyRole(MODERATOR_ROLE) {\n    require(_val <= address(this).balance, \"Forwarder: invalid forwarding value\");\n    _call(_target, _data, _val);\n  }\n\n  /**\n   * @dev Forwards the current call to `target`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _call(\n    address _target,\n    bytes memory _data,\n    uint256 _value\n  ) internal {\n    (bool _success, bytes memory _res) = _target.call{ value: _value }(_data);\n    if (!_success) {\n      uint _size = _res.length;\n      require(_size >= 4, \"Forwarder: target reverts silently\");\n      assembly {\n        _res := add(_res, 0x20)\n        revert(_res, _size)\n      }\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/ronin/gateway/PauseEnforcer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"../../interfaces/IPauseTarget.sol\";\n\ncontract PauseEnforcer is AccessControlEnumerable {\n  bytes32 public constant SENTRY_ROLE = keccak256(\"SENTRY_ROLE\");\n\n  /// @dev The contract that can be paused or unpaused by the SENTRY_ROLE.\n  IPauseTarget public target;\n  /// @dev Indicating whether or not the target contract is paused in emergency mode.\n  bool public emergency;\n\n  /// @dev Emitted when the emergency ppause is triggered by `account`.\n  event EmergencyPaused(address account);\n  /// @dev Emitted when the emergency unpause is triggered by `account`.\n  event EmergencyUnpaused(address account);\n  /// @dev Emitted when the target is changed.\n  event TargetChanged(IPauseTarget target);\n\n  modifier onEmergency() {\n    require(emergency, \"PauseEnforcer: not on emergency pause\");\n    _;\n  }\n\n  modifier targetPaused() {\n    require(target.paused(), \"PauseEnforcer: target is on pause\");\n    _;\n  }\n\n  modifier targetNotPaused() {\n    require(!target.paused(), \"PauseEnforcer: target is not on pause\");\n    _;\n  }\n\n  constructor(\n    IPauseTarget _target,\n    address _admin,\n    address[] memory _sentries\n  ) {\n    _changeTarget(_target);\n    _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n    for (uint _i; _i < _sentries.length; _i++) {\n      _grantRole(SENTRY_ROLE, _sentries[_i]);\n    }\n  }\n\n  /**\n   * @dev Grants the SENTRY_ROLE to the specified address.\n   */\n  function grantSentry(address _sentry) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _grantRole(SENTRY_ROLE, _sentry);\n  }\n\n  /**\n   * @dev Revokes the SENTRY_ROLE from the specified address.\n   */\n  function revokeSentry(address _sentry) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _revokeRole(SENTRY_ROLE, _sentry);\n  }\n\n  /**\n   * @dev Triggers a pause on the target contract.\n   *\n   * Requirements:\n   * - Only be called by accounts with the SENTRY_ROLE,\n   * - The target contract is not already paused.\n   */\n  function triggerPause() external onlyRole(SENTRY_ROLE) targetNotPaused {\n    emergency = true;\n    target.pause();\n    emit EmergencyPaused(msg.sender);\n  }\n\n  /**\n   * @dev Triggers an unpause on the target contract.\n   *\n   * Requirements:\n   * - Only be called by accounts with the SENTRY_ROLE,\n   * - The target contract is already paused.\n   * - The target contract is paused in emergency mode.\n   */\n  function triggerUnpause() external onlyRole(SENTRY_ROLE) onEmergency targetPaused {\n    emergency = false;\n    target.unpause();\n    emit EmergencyUnpaused(msg.sender);\n  }\n\n  /**\n   * @dev Helper function to reset emergency status.\n   */\n  function resetEmergency() external {\n    require(\n      hasRole(DEFAULT_ADMIN_ROLE, msg.sender) || hasRole(SENTRY_ROLE, msg.sender),\n      \"PauseEnforcer: Unauthorized reset\"\n    );\n    emergency = false;\n  }\n\n  /**\n   * @dev Setter for `target`.\n   *\n   * Requirements:\n   * - Only admin can call this method.\n   */\n  function changeTarget(IPauseTarget _target) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _changeTarget(_target);\n  }\n\n  /**\n   * @dev Internal helper for setting value to `target`.\n   */\n  function _changeTarget(IPauseTarget _target) internal {\n    target = _target;\n    emit TargetChanged(_target);\n  }\n}\n"
    },
    "contracts/interfaces/IPauseTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPauseTarget {\n  function pause() external;\n\n  function unpause() external;\n\n  function paused() external returns (bool);\n}\n"
    },
    "contracts/ronin/gateway/RoninGatewayV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../extensions/GatewayV2.sol\";\nimport \"../../extensions/MinimumWithdrawal.sol\";\nimport \"../../interfaces/IERC20Mintable.sol\";\nimport \"../../interfaces/IERC721Mintable.sol\";\nimport \"../../interfaces/IBridgeTracking.sol\";\nimport \"../../interfaces/IRoninGatewayV2.sol\";\nimport \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../interfaces/consumers/VoteStatusConsumer.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/collections/IHasValidatorContract.sol\";\nimport \"../../interfaces/collections/IHasBridgeTrackingContract.sol\";\nimport \"../../interfaces/collections/IHasRoninTrustedOrganizationContract.sol\";\nimport \"../../libraries/IsolatedGovernance.sol\";\n\ncontract RoninGatewayV2 is\n  GatewayV2,\n  Initializable,\n  MinimumWithdrawal,\n  AccessControlEnumerable,\n  VoteStatusConsumer,\n  IRoninGatewayV2,\n  IHasValidatorContract,\n  IHasBridgeTrackingContract,\n  IHasRoninTrustedOrganizationContract\n{\n  using Token for Token.Info;\n  using Transfer for Transfer.Request;\n  using Transfer for Transfer.Receipt;\n  using IsolatedGovernance for IsolatedGovernance.Vote;\n  using EnumFlags for EnumFlags.ValidatorFlag;\n\n  /// @dev Withdrawal unlocker role hash\n  bytes32 public constant WITHDRAWAL_MIGRATOR = keccak256(\"WITHDRAWAL_MIGRATOR\");\n\n  /// @dev Flag indicating whether the withdrawal migrate progress is done\n  bool public withdrawalMigrated;\n  /// @dev Total withdrawal\n  uint256 public withdrawalCount;\n  /// @dev Mapping from chain id => deposit id => deposit vote\n  mapping(uint256 => mapping(uint256 => IsolatedGovernance.Vote)) public depositVote;\n  /// @dev Mapping from withdrawal id => mainchain withdrew vote\n  mapping(uint256 => IsolatedGovernance.Vote) public mainchainWithdrewVote;\n  /// @dev Mapping from withdrawal id => withdrawal receipt\n  mapping(uint256 => Transfer.Receipt) public withdrawal;\n  /// @dev Mapping from withdrawal id => validator address => signatures\n  mapping(uint256 => mapping(address => bytes)) internal _withdrawalSig;\n  /// @dev Mapping from token address => chain id => mainchain token address\n  mapping(address => mapping(uint256 => MappedToken)) internal _mainchainToken;\n\n  /// @dev The ronin validator contract\n  IRoninValidatorSet internal _validatorContract;\n  /// @dev The bridge tracking contract\n  IBridgeTracking internal _bridgeTrackingContract;\n\n  /// @dev Mapping from withdrawal id => vote for recording withdrawal stats\n  mapping(uint256 => IsolatedGovernance.Vote) public withdrawalStatVote;\n\n  /// @dev The trusted organization contract\n  IRoninTrustedOrganization internal _trustedOrgContract;\n\n  uint256 internal _trustedNum;\n  uint256 internal _trustedDenom;\n\n  fallback() external payable {\n    _fallback();\n  }\n\n  receive() external payable {\n    _fallback();\n  }\n\n  modifier onlyBridgeOperator() {\n    require(_validatorContract.isBridgeOperator(msg.sender), \"RoninGatewayV2: unauthorized sender\");\n    _;\n  }\n\n  /**\n   * @dev Initializes contract storage.\n   */\n  function initialize(\n    address _roleSetter,\n    uint256 _numerator,\n    uint256 _denominator,\n    uint256 _trustedNumerator,\n    uint256 _trustedDenominator,\n    address[] calldata _withdrawalMigrators,\n    // _packedAddresses[0]: roninTokens\n    // _packedAddresses[1]: mainchainTokens\n    address[][2] calldata _packedAddresses,\n    // _packedNumbers[0]: chainIds\n    // _packedNumbers[1]: minimumThresholds\n    uint256[][2] calldata _packedNumbers,\n    Token.Standard[] calldata _standards\n  ) external virtual initializer {\n    _setupRole(DEFAULT_ADMIN_ROLE, _roleSetter);\n    _setThreshold(_numerator, _denominator);\n    _setTrustedThreshold(_trustedNumerator, _trustedDenominator);\n    if (_packedAddresses[0].length > 0) {\n      _mapTokens(_packedAddresses[0], _packedAddresses[1], _packedNumbers[0], _standards);\n      _setMinimumThresholds(_packedAddresses[0], _packedNumbers[1]);\n    }\n\n    for (uint256 _i; _i < _withdrawalMigrators.length; _i++) {\n      _grantRole(WITHDRAWAL_MIGRATOR, _withdrawalMigrators[_i]);\n    }\n  }\n\n  /**\n   * @inheritdoc IHasValidatorContract\n   */\n  function validatorContract() external view returns (address) {\n    return address(_validatorContract);\n  }\n\n  /**\n   * @inheritdoc IHasValidatorContract\n   */\n  function setValidatorContract(address _addr) external override onlyAdmin {\n    require(_addr.code.length > 0, \"RoninGatewayV2: set to non-contract\");\n    _setValidatorContract(_addr);\n  }\n\n  /**\n   * @inheritdoc IHasBridgeTrackingContract\n   */\n  function bridgeTrackingContract() external view override returns (address) {\n    return address(_bridgeTrackingContract);\n  }\n\n  /**\n   * @inheritdoc IHasBridgeTrackingContract\n   */\n  function setBridgeTrackingContract(address _addr) external override onlyAdmin {\n    require(_addr.code.length > 0, \"RoninGatewayV2: set to non-contract\");\n    _setBridgeTrackingContract(_addr);\n  }\n\n  /**\n   * @inheritdoc IHasRoninTrustedOrganizationContract\n   */\n  function roninTrustedOrganizationContract() external view override returns (address) {\n    return address(_trustedOrgContract);\n  }\n\n  /**\n   * @inheritdoc IHasRoninTrustedOrganizationContract\n   */\n  function setRoninTrustedOrganizationContract(address _addr) external override onlyAdmin {\n    require(_addr.code.length > 0, \"RoninGatewayV2: set to non-contract\");\n    _setRoninTrustedOrganizationContract(_addr);\n  }\n\n  /**\n   * @dev Migrates withdrawals.\n   *\n   * Requirements:\n   * - The method caller is the migrator.\n   * - The arrays have the same length and its length larger than 0.\n   *\n   */\n  function migrateWithdrawals(Transfer.Request[] calldata _requests, address[] calldata _requesters)\n    external\n    onlyRole(WITHDRAWAL_MIGRATOR)\n  {\n    require(!withdrawalMigrated, \"RoninGatewayV2: withdrawals migrated\");\n    require(_requesters.length == _requests.length && _requests.length > 0, \"RoninGatewayV2: invalid array lengths\");\n    for (uint256 _i; _i < _requests.length; _i++) {\n      MappedToken memory _token = getMainchainToken(_requests[_i].tokenAddr, 1);\n      require(_requests[_i].info.erc == _token.erc, \"RoninGatewayV2: invalid token standard\");\n      _storeAsReceipt(_requests[_i], 1, _requesters[_i], _token.tokenAddr);\n    }\n  }\n\n  /**\n   * @dev Mark the migration as done.\n   */\n  function markWithdrawalMigrated() external {\n    require(\n      hasRole(DEFAULT_ADMIN_ROLE, msg.sender) || hasRole(WITHDRAWAL_MIGRATOR, msg.sender),\n      \"RoninGatewayV2: unauthorized sender\"\n    );\n    require(!withdrawalMigrated, \"RoninGatewayV2: withdrawals migrated\");\n    withdrawalMigrated = true;\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function getWithdrawalSignatures(uint256 _withdrawalId, address[] calldata _validators)\n    external\n    view\n    returns (bytes[] memory _signatures)\n  {\n    _signatures = new bytes[](_validators.length);\n    for (uint256 _i = 0; _i < _validators.length; _i++) {\n      _signatures[_i] = _withdrawalSig[_withdrawalId][_validators[_i]];\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function depositFor(Transfer.Receipt calldata _receipt) external whenNotPaused onlyBridgeOperator {\n    address _sender = msg.sender;\n    _depositFor(_receipt, _sender, minimumVoteWeight(), minimumTrustedVoteWeight());\n    _bridgeTrackingContract.recordVote(IBridgeTracking.VoteKind.Deposit, _receipt.id, _sender);\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function tryBulkAcknowledgeMainchainWithdrew(uint256[] calldata _withdrawalIds)\n    external\n    onlyBridgeOperator\n    returns (bool[] memory _executedReceipts)\n  {\n    address _governor = msg.sender;\n    uint256 _minVoteWeight = minimumVoteWeight();\n    uint256 _minTrustedVoteWeight = minimumTrustedVoteWeight();\n\n    uint256 _withdrawalId;\n    _executedReceipts = new bool[](_withdrawalIds.length);\n    for (uint256 _i; _i < _withdrawalIds.length; _i++) {\n      _withdrawalId = _withdrawalIds[_i];\n      _bridgeTrackingContract.recordVote(IBridgeTracking.VoteKind.MainchainWithdrawal, _withdrawalId, _governor);\n      if (mainchainWithdrew(_withdrawalId)) {\n        _executedReceipts[_i] = true;\n      } else {\n        IsolatedGovernance.Vote storage _vote = mainchainWithdrewVote[_withdrawalId];\n        Transfer.Receipt memory _withdrawal = withdrawal[_withdrawalId];\n        bytes32 _hash = _withdrawal.hash();\n        VoteStatus _status = _castIsolatedVote(_vote, _governor, _minVoteWeight, _minTrustedVoteWeight, _hash);\n        if (_status == VoteStatus.Approved) {\n          _vote.status = VoteStatus.Executed;\n          _bridgeTrackingContract.handleVoteApproved(IBridgeTracking.VoteKind.MainchainWithdrawal, _withdrawalId);\n          emit MainchainWithdrew(_hash, _withdrawal);\n        }\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function tryBulkDepositFor(Transfer.Receipt[] calldata _receipts)\n    external\n    whenNotPaused\n    onlyBridgeOperator\n    returns (bool[] memory _executedReceipts)\n  {\n    address _sender = msg.sender;\n\n    Transfer.Receipt memory _receipt;\n    _executedReceipts = new bool[](_receipts.length);\n    uint256 _minVoteWeight = minimumVoteWeight();\n    uint256 _minTrustedVoteWeight = minimumTrustedVoteWeight();\n    for (uint256 _i; _i < _receipts.length; _i++) {\n      _receipt = _receipts[_i];\n      _bridgeTrackingContract.recordVote(IBridgeTracking.VoteKind.Deposit, _receipt.id, _sender);\n      if (depositVote[_receipt.mainchain.chainId][_receipt.id].status == VoteStatus.Executed) {\n        _executedReceipts[_i] = true;\n      } else {\n        _depositFor(_receipt, _sender, _minVoteWeight, _minTrustedVoteWeight);\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function requestWithdrawalFor(Transfer.Request calldata _request, uint256 _chainId) external whenNotPaused {\n    _requestWithdrawalFor(_request, msg.sender, _chainId);\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function bulkRequestWithdrawalFor(Transfer.Request[] calldata _requests, uint256 _chainId) external whenNotPaused {\n    require(_requests.length > 0, \"RoninGatewayV2: empty array\");\n    for (uint256 _i; _i < _requests.length; _i++) {\n      _requestWithdrawalFor(_requests[_i], msg.sender, _chainId);\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function requestWithdrawalSignatures(uint256 _withdrawalId) external whenNotPaused {\n    require(!mainchainWithdrew(_withdrawalId), \"RoninGatewayV2: withdrew on mainchain already\");\n    Transfer.Receipt memory _receipt = withdrawal[_withdrawalId];\n    require(_receipt.ronin.chainId == block.chainid, \"RoninGatewayV2: query for invalid withdrawal\");\n    emit WithdrawalSignaturesRequested(_receipt.hash(), _receipt);\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function bulkSubmitWithdrawalSignatures(uint256[] calldata _withdrawals, bytes[] calldata _signatures)\n    external\n    whenNotPaused\n    onlyBridgeOperator\n  {\n    address _validator = msg.sender;\n\n    require(\n      _withdrawals.length > 0 && _withdrawals.length == _signatures.length,\n      \"RoninGatewayV2: invalid array length\"\n    );\n\n    uint256 _minVoteWeight = minimumVoteWeight();\n    uint256 _minTrustedVoteWeight = minimumTrustedVoteWeight();\n\n    uint256 _id;\n    for (uint256 _i; _i < _withdrawals.length; _i++) {\n      _id = _withdrawals[_i];\n      _withdrawalSig[_id][_validator] = _signatures[_i];\n      _bridgeTrackingContract.recordVote(IBridgeTracking.VoteKind.Withdrawal, _id, _validator);\n\n      IsolatedGovernance.Vote storage _proposal = withdrawalStatVote[_id];\n      VoteStatus _status = _castIsolatedVote(\n        _proposal,\n        _validator,\n        _minVoteWeight,\n        _minTrustedVoteWeight,\n        bytes32(_id)\n      );\n      if (_status == VoteStatus.Approved) {\n        _proposal.status = VoteStatus.Executed;\n        _bridgeTrackingContract.handleVoteApproved(IBridgeTracking.VoteKind.Withdrawal, _id);\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function mapTokens(\n    address[] calldata _roninTokens,\n    address[] calldata _mainchainTokens,\n    uint256[] calldata _chainIds,\n    Token.Standard[] calldata _standards\n  ) external onlyAdmin {\n    require(_roninTokens.length > 0, \"RoninGatewayV2: invalid array length\");\n    _mapTokens(_roninTokens, _mainchainTokens, _chainIds, _standards);\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function depositVoted(\n    uint256 _chainId,\n    uint256 _depositId,\n    address _voter\n  ) external view returns (bool) {\n    return depositVote[_chainId][_depositId].voted(_voter);\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function mainchainWithdrewVoted(uint256 _withdrawalId, address _voter) external view returns (bool) {\n    return mainchainWithdrewVote[_withdrawalId].voted(_voter);\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function mainchainWithdrew(uint256 _withdrawalId) public view returns (bool) {\n    return mainchainWithdrewVote[_withdrawalId].status == VoteStatus.Executed;\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV2\n   */\n  function getMainchainToken(address _roninToken, uint256 _chainId) public view returns (MappedToken memory _token) {\n    _token = _mainchainToken[_roninToken][_chainId];\n    require(_token.tokenAddr != address(0), \"RoninGatewayV2: unsupported token\");\n  }\n\n  /**\n   * @dev Maps Ronin tokens to mainchain networks.\n   *\n   * Requirement:\n   * - The arrays have the same length.\n   *\n   * Emits the `TokenMapped` event.\n   *\n   */\n  function _mapTokens(\n    address[] calldata _roninTokens,\n    address[] calldata _mainchainTokens,\n    uint256[] calldata _chainIds,\n    Token.Standard[] calldata _standards\n  ) internal {\n    require(\n      _roninTokens.length == _mainchainTokens.length && _roninTokens.length == _chainIds.length,\n      \"RoninGatewayV2: invalid array length\"\n    );\n\n    for (uint256 _i; _i < _roninTokens.length; _i++) {\n      _mainchainToken[_roninTokens[_i]][_chainIds[_i]].tokenAddr = _mainchainTokens[_i];\n      _mainchainToken[_roninTokens[_i]][_chainIds[_i]].erc = _standards[_i];\n    }\n\n    emit TokenMapped(_roninTokens, _mainchainTokens, _chainIds, _standards);\n  }\n\n  /**\n   * @dev Deposits based on the receipt.\n   *\n   * Emits the `Deposited` once the assets are released.\n   *\n   */\n  function _depositFor(\n    Transfer.Receipt memory _receipt,\n    address _validator,\n    uint256 _minVoteWeight,\n    uint256 _minTrustedVoteWeight\n  ) internal {\n    uint256 _id = _receipt.id;\n    _receipt.info.validate();\n    require(_receipt.kind == Transfer.Kind.Deposit, \"RoninGatewayV2: invalid receipt kind\");\n    require(_receipt.ronin.chainId == block.chainid, \"RoninGatewayV2: invalid chain id\");\n    MappedToken memory _token = getMainchainToken(_receipt.ronin.tokenAddr, _receipt.mainchain.chainId);\n    require(\n      _token.erc == _receipt.info.erc && _token.tokenAddr == _receipt.mainchain.tokenAddr,\n      \"RoninGatewayV2: invalid receipt\"\n    );\n\n    IsolatedGovernance.Vote storage _proposal = depositVote[_receipt.mainchain.chainId][_id];\n    bytes32 _receiptHash = _receipt.hash();\n    VoteStatus _status = _castIsolatedVote(_proposal, _validator, _minVoteWeight, _minTrustedVoteWeight, _receiptHash);\n    emit DepositVoted(_validator, _id, _receipt.mainchain.chainId, _receiptHash);\n    if (_status == VoteStatus.Approved) {\n      _proposal.status = VoteStatus.Executed;\n      _receipt.info.handleAssetTransfer(payable(_receipt.ronin.addr), _receipt.ronin.tokenAddr, IWETH(address(0)));\n      _bridgeTrackingContract.handleVoteApproved(IBridgeTracking.VoteKind.Deposit, _receipt.id);\n      emit Deposited(_receiptHash, _receipt);\n    }\n  }\n\n  /**\n   * @dev Locks the assets and request withdrawal.\n   *\n   * Requirements:\n   * - The token info is valid.\n   *\n   * Emits the `WithdrawalRequested` event.\n   *\n   */\n  function _requestWithdrawalFor(\n    Transfer.Request calldata _request,\n    address _requester,\n    uint256 _chainId\n  ) internal {\n    _request.info.validate();\n    _checkWithdrawal(_request);\n    MappedToken memory _token = getMainchainToken(_request.tokenAddr, _chainId);\n    require(_request.info.erc == _token.erc, \"RoninGatewayV2: invalid token standard\");\n    _request.info.transferFrom(_requester, address(this), _request.tokenAddr);\n    _storeAsReceipt(_request, _chainId, _requester, _token.tokenAddr);\n  }\n\n  /**\n   * @dev Stores the withdrawal request as a receipt.\n   *\n   * Emits the `WithdrawalRequested` event.\n   *\n   */\n  function _storeAsReceipt(\n    Transfer.Request calldata _request,\n    uint256 _chainId,\n    address _requester,\n    address _mainchainTokenAddr\n  ) internal returns (uint256 _withdrawalId) {\n    _withdrawalId = withdrawalCount++;\n    Transfer.Receipt memory _receipt = _request.into_withdrawal_receipt(\n      _requester,\n      _withdrawalId,\n      _mainchainTokenAddr,\n      _chainId\n    );\n    withdrawal[_withdrawalId] = _receipt;\n    emit WithdrawalRequested(_receipt.hash(), _receipt);\n  }\n\n  /**\n   * @dev Don't send me RON.\n   */\n  function _fallback() internal virtual {\n    revert(\"RoninGatewayV2: invalid request\");\n  }\n\n  /**\n   * @inheritdoc GatewayV2\n   */\n  function _getTotalWeight() internal view virtual override returns (uint256) {\n    return _validatorContract.totalBridgeOperators();\n  }\n\n  /**\n   * @dev Returns the total trusted weight.\n   */\n  function _getTotalTrustedWeight() internal view virtual returns (uint256) {\n    return _trustedOrgContract.countTrustedOrganizations();\n  }\n\n  /**\n   * @dev Sets the validator contract.\n   *\n   * Emits the event `ValidatorContractUpdated`.\n   *\n   */\n  function _setValidatorContract(address _addr) internal {\n    _validatorContract = IRoninValidatorSet(_addr);\n    emit ValidatorContractUpdated(_addr);\n  }\n\n  /**\n   * @dev Sets the bridge tracking contract.\n   *\n   * Emits the event `BridgeTrackingContractUpdated`.\n   *\n   */\n  function _setBridgeTrackingContract(address _addr) internal {\n    _bridgeTrackingContract = IBridgeTracking(_addr);\n    emit BridgeTrackingContractUpdated(_addr);\n  }\n\n  /**\n   * @dev Sets the ronin trusted organization contract.\n   *\n   * Emits the event `RoninTrustedOrganizationContractUpdated`.\n   *\n   */\n  function _setRoninTrustedOrganizationContract(address _addr) internal {\n    _trustedOrgContract = IRoninTrustedOrganization(_addr);\n    emit RoninTrustedOrganizationContractUpdated(_addr);\n  }\n\n  /**\n   * @dev Casts and updates the vote result.\n   *\n   * Requirements:\n   * - The vote is not finalized.\n   * - The voter has not voted for the round.\n   *\n   */\n  function _castIsolatedVote(\n    IsolatedGovernance.Vote storage _v,\n    address _voter,\n    uint256 _minVoteWeight,\n    uint256 _minTrustedVoteWeight,\n    bytes32 _hash\n  ) internal virtual returns (VoteStatus _status) {\n    _v.castVote(_voter, _hash);\n    (uint256 _totalWeight, uint256 _trustedWeight) = _getVoteWeight(_v, _hash);\n    return _v.syncVoteStatus(_minVoteWeight, _totalWeight, _minTrustedVoteWeight, _trustedWeight, _hash);\n  }\n\n  /**\n   * @dev Returns the vote weight for a specified hash.\n   */\n  function _getVoteWeight(IsolatedGovernance.Vote storage _v, bytes32 _hash)\n    internal\n    view\n    returns (uint256 _totalWeight, uint256 _trustedWeight)\n  {\n    (\n      address[] memory _consensusList,\n      address[] memory _bridgeOperators,\n      EnumFlags.ValidatorFlag[] memory _flags\n    ) = _validatorContract.getValidators();\n    uint256[] memory _trustedWeights = _trustedOrgContract.getConsensusWeights(_consensusList);\n\n    for (uint _i; _i < _bridgeOperators.length; _i++) {\n      if (_flags[_i].hasFlag(EnumFlags.ValidatorFlag.BridgeOperator) && _v.voteHashOf[_bridgeOperators[_i]] == _hash) {\n        _totalWeight++;\n        if (_trustedWeights[_i] > 0) {\n          _trustedWeight++;\n        }\n      }\n    }\n  }\n\n  function setTrustedThreshold(uint256 _trustedNumerator, uint256 _trustedDenominator)\n    external\n    virtual\n    onlyAdmin\n    returns (uint256, uint256)\n  {\n    return _setTrustedThreshold(_trustedNumerator, _trustedDenominator);\n  }\n\n  /**\n   * @dev Returns the minimum trusted vote weight to pass the threshold.\n   */\n  function minimumTrustedVoteWeight() public view virtual returns (uint256) {\n    return _minimumTrustedVoteWeight(_getTotalTrustedWeight());\n  }\n\n  /**\n   * @dev Returns the threshold about trusted org.\n   */\n  function getTrustedThreshold() external view virtual returns (uint256 trustedNum_, uint256 trustedDenom_) {\n    return (_trustedNum, _trustedDenom);\n  }\n\n  /**\n   * @dev Sets trusted threshold and returns the old one.\n   *\n   * Emits the `TrustedThresholdUpdated` event.\n   *\n   */\n  function _setTrustedThreshold(uint256 _trustedNumerator, uint256 _trustedDenominator)\n    internal\n    virtual\n    returns (uint256 _previousTrustedNum, uint256 _previousTrustedDenom)\n  {\n    require(_trustedNumerator <= _trustedDenominator, \"GatewayV2: invalid trusted threshold\");\n    _previousTrustedNum = _num;\n    _previousTrustedDenom = _denom;\n    _trustedNum = _trustedNumerator;\n    _trustedDenom = _trustedDenominator;\n    emit TrustedThresholdUpdated(\n      nonce++,\n      _trustedNumerator,\n      _trustedDenominator,\n      _previousTrustedNum,\n      _previousTrustedDenom\n    );\n  }\n\n  /**\n   * @dev Returns minimum trusted vote weight.\n   */\n  function _minimumTrustedVoteWeight(uint256 _totalTrustedWeight) internal view virtual returns (uint256) {\n    return (_trustedNum * _totalTrustedWeight + _trustedDenom - 1) / _trustedDenom;\n  }\n}\n"
    },
    "contracts/extensions/GatewayV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"../interfaces/IQuorum.sol\";\nimport \"./collections/HasProxyAdmin.sol\";\n\nabstract contract GatewayV2 is HasProxyAdmin, Pausable, IQuorum {\n  uint256 internal _num;\n  uint256 internal _denom;\n\n  address private ______deprecated;\n  uint256 public nonce;\n\n  address public emergencyPauser;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[49] private ______gap;\n\n  /**\n   * @dev Grant emergency pauser role for `_addr`.\n   */\n  function setEmergencyPauser(address _addr) external onlyAdmin {\n    emergencyPauser = _addr;\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function getThreshold() external view virtual returns (uint256 num_, uint256 denom_) {\n    return (_num, _denom);\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function checkThreshold(uint256 _voteWeight) external view virtual returns (bool) {\n    return _voteWeight * _denom >= _num * _getTotalWeight();\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function setThreshold(uint256 _numerator, uint256 _denominator)\n    external\n    virtual\n    onlyAdmin\n    returns (uint256, uint256)\n  {\n    return _setThreshold(_numerator, _denominator);\n  }\n\n  /**\n   * @dev Triggers paused state.\n   */\n  function pause() external {\n    require(msg.sender == _getAdmin() || msg.sender == emergencyPauser, \"GatewayV2: not authorized pauser\");\n    _pause();\n  }\n\n  /**\n   * @dev Triggers unpaused state.\n   */\n  function unpause() external {\n    require(msg.sender == _getAdmin() || msg.sender == emergencyPauser, \"GatewayV2: not authorized pauser\");\n    _unpause();\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function minimumVoteWeight() public view virtual returns (uint256) {\n    return _minimumVoteWeight(_getTotalWeight());\n  }\n\n  /**\n   * @dev Sets threshold and returns the old one.\n   *\n   * Emits the `ThresholdUpdated` event.\n   *\n   */\n  function _setThreshold(uint256 _numerator, uint256 _denominator)\n    internal\n    virtual\n    returns (uint256 _previousNum, uint256 _previousDenom)\n  {\n    require(_numerator <= _denominator, \"GatewayV2: invalid threshold\");\n    _previousNum = _num;\n    _previousDenom = _denom;\n    _num = _numerator;\n    _denom = _denominator;\n    emit ThresholdUpdated(nonce++, _numerator, _denominator, _previousNum, _previousDenom);\n  }\n\n  /**\n   * @dev Returns minimum vote weight.\n   */\n  function _minimumVoteWeight(uint256 _totalWeight) internal view virtual returns (uint256) {\n    return (_num * _totalWeight + _denom - 1) / _denom;\n  }\n\n  /**\n   * @dev Returns the total weight.\n   */\n  function _getTotalWeight() internal view virtual returns (uint256);\n}\n"
    },
    "contracts/extensions/MinimumWithdrawal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./collections/HasProxyAdmin.sol\";\nimport \"../libraries/Transfer.sol\";\n\nabstract contract MinimumWithdrawal is HasProxyAdmin {\n  /// @dev Emitted when the minimum thresholds are updated\n  event MinimumThresholdsUpdated(address[] tokens, uint256[] threshold);\n\n  /// @dev Mapping from token address => minimum thresholds\n  mapping(address => uint256) public minimumThreshold;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @dev Sets the minimum thresholds to withdraw.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The arrays have the same length and its length larger than 0.\n   *\n   * Emits the `MinimumThresholdsUpdated` event.\n   *\n   */\n  function setMinimumThresholds(address[] calldata _tokens, uint256[] calldata _thresholds) external virtual onlyAdmin {\n    require(_tokens.length > 0, \"MinimumWithdrawal: invalid array length\");\n    _setMinimumThresholds(_tokens, _thresholds);\n  }\n\n  /**\n   * @dev Sets minimum thresholds.\n   *\n   * Requirements:\n   * - The array lengths are equal.\n   *\n   * Emits the `MinimumThresholdsUpdated` event.\n   *\n   */\n  function _setMinimumThresholds(address[] calldata _tokens, uint256[] calldata _thresholds) internal virtual {\n    require(_tokens.length == _thresholds.length, \"MinimumWithdrawal: invalid array length\");\n    for (uint256 _i; _i < _tokens.length; _i++) {\n      minimumThreshold[_tokens[_i]] = _thresholds[_i];\n    }\n    emit MinimumThresholdsUpdated(_tokens, _thresholds);\n  }\n\n  /**\n   * @dev Checks whether the request is larger than or equal to the minimum threshold.\n   */\n  function _checkWithdrawal(Transfer.Request calldata _request) internal view {\n    require(\n      _request.info.erc != Token.Standard.ERC20 || _request.info.quantity >= minimumThreshold[_request.tokenAddr],\n      \"MinimumWithdrawal: query for too small quantity\"\n    );\n  }\n}\n"
    },
    "contracts/interfaces/IERC20Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\ninterface IERC20Mintable {\n  function mint(address _to, uint256 _value) external returns (bool _success);\n}\n"
    },
    "contracts/interfaces/IERC721Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC721Mintable {\n  function mint(address _to, uint256 _tokenId) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IBridgeTracking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBridgeTracking {\n  struct Request {\n    VoteKind kind;\n    uint256 id;\n  }\n\n  enum VoteKind {\n    Deposit,\n    Withdrawal,\n    MainchainWithdrawal\n  }\n\n  /**\n   * @dev Returns the total number of votes at the specific period `_period`.\n   */\n  function totalVotes(uint256 _period) external view returns (uint256);\n\n  /**\n   * @dev Returns the total number of ballots at the specific period `_period`.\n   */\n  function totalBallots(uint256 _period) external view returns (uint256);\n\n  /**\n   * @dev Returns the total number of ballots of bridge operators at the specific period `_period`.\n   */\n  function getManyTotalBallots(uint256 _period, address[] calldata _bridgeOperators)\n    external\n    view\n    returns (uint256[] memory);\n\n  /**\n   * @dev Returns the total number of ballots of a bridge operator at the specific period `_period`.\n   */\n  function totalBallotsOf(uint256 _period, address _bridgeOperator) external view returns (uint256);\n\n  /**\n   * @dev Handles the request once it is approved.\n   *\n   * Requirements:\n   * - The method caller is the bridge contract.\n   *\n   */\n  function handleVoteApproved(VoteKind _kind, uint256 _requestId) external;\n\n  /**\n   * @dev Records vote for a receipt and a operator.\n   *\n   * Requirements:\n   * - The method caller is the bridge contract.\n   *\n   */\n  function recordVote(\n    VoteKind _kind,\n    uint256 _requestId,\n    address _operator\n  ) external;\n}\n"
    },
    "contracts/interfaces/IRoninGatewayV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../libraries/Transfer.sol\";\nimport \"./consumers/MappedTokenConsumer.sol\";\n\ninterface IRoninGatewayV2 is MappedTokenConsumer {\n  /// @dev Emitted when the assets are depositted\n  event Deposited(bytes32 receiptHash, Transfer.Receipt receipt);\n  /// @dev Emitted when the withdrawal is requested\n  event WithdrawalRequested(bytes32 receiptHash, Transfer.Receipt);\n  /// @dev Emitted when the assets are withdrawn on mainchain\n  event MainchainWithdrew(bytes32 receiptHash, Transfer.Receipt receipt);\n  /// @dev Emitted when the withdrawal signatures is requested\n  event WithdrawalSignaturesRequested(bytes32 receiptHash, Transfer.Receipt);\n  /// @dev Emitted when the tokens are mapped\n  event TokenMapped(address[] roninTokens, address[] mainchainTokens, uint256[] chainIds, Token.Standard[] standards);\n  /// @dev Emitted when the threshold is updated\n  event TrustedThresholdUpdated(\n    uint256 indexed nonce,\n    uint256 indexed numerator,\n    uint256 indexed denominator,\n    uint256 previousNumerator,\n    uint256 previousDenominator\n  );\n  /// @dev Emitted when a deposit is voted\n  event DepositVoted(address indexed bridgeOperator, uint256 indexed id, uint256 indexed chainId, bytes32 receiptHash);\n\n  /**\n   * @dev Returns withdrawal count.\n   */\n  function withdrawalCount() external view returns (uint256);\n\n  /**\n   * @dev Returns withdrawal signatures.\n   */\n  function getWithdrawalSignatures(uint256 _withdrawalId, address[] calldata _validators)\n    external\n    view\n    returns (bytes[] memory);\n\n  /**\n   * @dev Deposits based on the receipt.\n   *\n   * Requirements:\n   * - The method caller is a validator.\n   *\n   * Emits the `Deposited` once the assets are released.\n   *\n   * @notice The assets will be transferred whenever the valid call passes the quorum threshold.\n   *\n   */\n  function depositFor(Transfer.Receipt calldata _receipt) external;\n\n  /**\n   * @dev Marks the withdrawals are done on mainchain and returns the boolean array indicating whether the withdrawal\n   * vote is already done before.\n   *\n   * Requirements:\n   * - The method caller is a validator.\n   *\n   * Emits the `MainchainWithdrew` once the valid call passes the quorum threshold.\n   *\n   * @notice Not reverting to avoid unnecessary failed transactions because the validators can send transactions at the\n   * same time.\n   *\n   */\n  function tryBulkAcknowledgeMainchainWithdrew(uint256[] calldata _withdrawalIds) external returns (bool[] memory);\n\n  /**\n   * @dev Tries bulk deposits based on the receipts and returns the boolean array indicating whether the deposit vote\n   * is already done before. Reverts if the deposit is invalid or is voted by the validator again.\n   *\n   * Requirements:\n   * - The method caller is a validator.\n   *\n   * Emits the `Deposited` once the assets are released.\n   *\n   * @notice The assets will be transferred whenever the valid call for the receipt passes the quorum threshold. Not\n   * reverting to avoid unnecessary failed transactions because the validators can send transactions at the same time.\n   *\n   */\n  function tryBulkDepositFor(Transfer.Receipt[] calldata _receipts) external returns (bool[] memory);\n\n  /**\n   * @dev Locks the assets and request withdrawal.\n   *\n   * Emits the `WithdrawalRequested` event.\n   *\n   */\n  function requestWithdrawalFor(Transfer.Request calldata _request, uint256 _chainId) external;\n\n  /**\n   * @dev Bulk requests withdrawals.\n   *\n   * Emits the `WithdrawalRequested` events.\n   *\n   */\n  function bulkRequestWithdrawalFor(Transfer.Request[] calldata _requests, uint256 _chainId) external;\n\n  /**\n   * @dev Requests withdrawal signatures for a specific withdrawal.\n   *\n   * Emits the `WithdrawalSignaturesRequested` event.\n   *\n   */\n  function requestWithdrawalSignatures(uint256 _withdrawalId) external;\n\n  /**\n   * @dev Submits withdrawal signatures.\n   *\n   * Requirements:\n   * - The method caller is a validator.\n   *\n   */\n  function bulkSubmitWithdrawalSignatures(uint256[] calldata _withdrawals, bytes[] calldata _signatures) external;\n\n  /**\n   * @dev Maps Ronin tokens to mainchain networks.\n   *\n   * Requirement:\n   * - The method caller is admin.\n   * - The arrays have the same length and its length larger than 0.\n   *\n   * Emits the `TokenMapped` event.\n   *\n   */\n  function mapTokens(\n    address[] calldata _roninTokens,\n    address[] calldata _mainchainTokens,\n    uint256[] calldata chainIds,\n    Token.Standard[] calldata _standards\n  ) external;\n\n  /**\n   * @dev Returns whether the deposit is casted by the voter.\n   */\n  function depositVoted(\n    uint256 _chainId,\n    uint256 _depositId,\n    address _voter\n  ) external view returns (bool);\n\n  /**\n   * @dev Returns whether the mainchain withdrew is casted by the voter.\n   */\n  function mainchainWithdrewVoted(uint256 _withdrawalId, address _voter) external view returns (bool);\n\n  /**\n   * @dev Returns whether the withdrawal is done on mainchain.\n   */\n  function mainchainWithdrew(uint256 _withdrawalId) external view returns (bool);\n\n  /**\n   * @dev Returns mainchain token address.\n   * Reverts for unsupported token.\n   */\n  function getMainchainToken(address _roninToken, uint256 _chainId) external view returns (MappedToken memory _token);\n}\n"
    },
    "contracts/interfaces/collections/IHasBridgeTrackingContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IHasContract.sol\";\n\ninterface IHasBridgeTrackingContract is IHasContract {\n  /// @dev Emitted when the bridge tracking contract is updated.\n  event BridgeTrackingContractUpdated(address);\n\n  /// @dev Error of method caller must be bridge tracking contract.\n  error ErrCallerMustBeBridgeTrackingContract();\n\n  /**\n   * @dev Returns the bridge tracking contract.\n   */\n  function bridgeTrackingContract() external view returns (address);\n\n  /**\n   * @dev Sets the bridge tracking contract.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The new address is a contract.\n   *\n   * Emits the event `BridgeTrackingContractUpdated`.\n   *\n   */\n  function setBridgeTrackingContract(address) external;\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/libraries/Transfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./Token.sol\";\n\nlibrary Transfer {\n  using ECDSA for bytes32;\n\n  enum Kind {\n    Deposit,\n    Withdrawal\n  }\n\n  struct Request {\n    // For deposit request: Recipient address on Ronin network\n    // For withdrawal request: Recipient address on mainchain network\n    address recipientAddr;\n    // Token address to deposit/withdraw\n    // Value 0: native token\n    address tokenAddr;\n    Token.Info info;\n  }\n\n  /**\n   * @dev Converts the transfer request into the deposit receipt.\n   */\n  function into_deposit_receipt(\n    Request memory _request,\n    address _requester,\n    uint256 _id,\n    address _roninTokenAddr,\n    uint256 _roninChainId\n  ) internal view returns (Receipt memory _receipt) {\n    _receipt.id = _id;\n    _receipt.kind = Kind.Deposit;\n    _receipt.mainchain.addr = _requester;\n    _receipt.mainchain.tokenAddr = _request.tokenAddr;\n    _receipt.mainchain.chainId = block.chainid;\n    _receipt.ronin.addr = _request.recipientAddr;\n    _receipt.ronin.tokenAddr = _roninTokenAddr;\n    _receipt.ronin.chainId = _roninChainId;\n    _receipt.info = _request.info;\n  }\n\n  /**\n   * @dev Converts the transfer request into the withdrawal receipt.\n   */\n  function into_withdrawal_receipt(\n    Request memory _request,\n    address _requester,\n    uint256 _id,\n    address _mainchainTokenAddr,\n    uint256 _mainchainId\n  ) internal view returns (Receipt memory _receipt) {\n    _receipt.id = _id;\n    _receipt.kind = Kind.Withdrawal;\n    _receipt.ronin.addr = _requester;\n    _receipt.ronin.tokenAddr = _request.tokenAddr;\n    _receipt.ronin.chainId = block.chainid;\n    _receipt.mainchain.addr = _request.recipientAddr;\n    _receipt.mainchain.tokenAddr = _mainchainTokenAddr;\n    _receipt.mainchain.chainId = _mainchainId;\n    _receipt.info = _request.info;\n  }\n\n  struct Receipt {\n    uint256 id;\n    Kind kind;\n    Token.Owner mainchain;\n    Token.Owner ronin;\n    Token.Info info;\n  }\n\n  // keccak256(\"Receipt(uint256 id,uint8 kind,TokenOwner mainchain,TokenOwner ronin,TokenInfo info)TokenInfo(uint8 erc,uint256 id,uint256 quantity)TokenOwner(address addr,address tokenAddr,uint256 chainId)\");\n  bytes32 public constant TYPE_HASH = 0xb9d1fe7c9deeec5dc90a2f47ff1684239519f2545b2228d3d91fb27df3189eea;\n\n  /**\n   * @dev Returns token info struct hash.\n   */\n  function hash(Receipt memory _receipt) internal pure returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          TYPE_HASH,\n          _receipt.id,\n          _receipt.kind,\n          Token.hash(_receipt.mainchain),\n          Token.hash(_receipt.ronin),\n          Token.hash(_receipt.info)\n        )\n      );\n  }\n\n  /**\n   * @dev Returns the receipt digest.\n   */\n  function receiptDigest(bytes32 _domainSeparator, bytes32 _receiptHash) internal pure returns (bytes32) {\n    return _domainSeparator.toTypedDataHash(_receiptHash);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/libraries/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../interfaces/IWETH.sol\";\n\nlibrary Token {\n  enum Standard {\n    ERC20,\n    ERC721\n  }\n  struct Info {\n    Standard erc;\n    // For ERC20:  the id must be 0 and the quantity is larger than 0.\n    // For ERC721: the quantity must be 0.\n    uint256 id;\n    uint256 quantity;\n  }\n\n  // keccak256(\"TokenInfo(uint8 erc,uint256 id,uint256 quantity)\");\n  bytes32 public constant INFO_TYPE_HASH = 0x1e2b74b2a792d5c0f0b6e59b037fa9d43d84fbb759337f0112fcc15ca414fc8d;\n\n  /**\n   * @dev Returns token info struct hash.\n   */\n  function hash(Info memory _info) internal pure returns (bytes32) {\n    return keccak256(abi.encode(INFO_TYPE_HASH, _info.erc, _info.id, _info.quantity));\n  }\n\n  /**\n   * @dev Validates the token info.\n   */\n  function validate(Info memory _info) internal pure {\n    require(\n      (_info.erc == Standard.ERC20 && _info.quantity > 0 && _info.id == 0) ||\n        (_info.erc == Standard.ERC721 && _info.quantity == 0),\n      \"Token: invalid info\"\n    );\n  }\n\n  /**\n   * @dev Transfer asset from.\n   *\n   * Requirements:\n   * - The `_from` address must approve for the contract using this library.\n   *\n   */\n  function transferFrom(\n    Info memory _info,\n    address _from,\n    address _to,\n    address _token\n  ) internal {\n    bool _success;\n    bytes memory _data;\n    if (_info.erc == Standard.ERC20) {\n      (_success, _data) = _token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, _from, _to, _info.quantity));\n      _success = _success && (_data.length == 0 || abi.decode(_data, (bool)));\n    } else if (_info.erc == Standard.ERC721) {\n      // bytes4(keccak256(\"transferFrom(address,address,uint256)\"))\n      (_success, ) = _token.call(abi.encodeWithSelector(0x23b872dd, _from, _to, _info.id));\n    } else {\n      revert(\"Token: unsupported token standard\");\n    }\n\n    if (!_success) {\n      revert(\n        string(\n          abi.encodePacked(\n            \"Token: could not transfer \",\n            toString(_info),\n            \" from \",\n            Strings.toHexString(uint160(_from), 20),\n            \" to \",\n            Strings.toHexString(uint160(_to), 20),\n            \" token \",\n            Strings.toHexString(uint160(_token), 20)\n          )\n        )\n      );\n    }\n  }\n\n  /**\n   * @dev Transfers ERC721 token and returns the result.\n   */\n  function tryTransferERC721(\n    address _token,\n    address _to,\n    uint256 _id\n  ) internal returns (bool _success) {\n    (_success, ) = _token.call(abi.encodeWithSelector(IERC721.transferFrom.selector, address(this), _to, _id));\n  }\n\n  /**\n   * @dev Transfers ERC20 token and returns the result.\n   */\n  function tryTransferERC20(\n    address _token,\n    address _to,\n    uint256 _quantity\n  ) internal returns (bool _success) {\n    bytes memory _data;\n    (_success, _data) = _token.call(abi.encodeWithSelector(IERC20.transfer.selector, _to, _quantity));\n    _success = _success && (_data.length == 0 || abi.decode(_data, (bool)));\n  }\n\n  /**\n   * @dev Transfer assets from current address to `_to` address.\n   */\n  function transfer(\n    Info memory _info,\n    address _to,\n    address _token\n  ) internal {\n    bool _success;\n    if (_info.erc == Standard.ERC20) {\n      _success = tryTransferERC20(_token, _to, _info.quantity);\n    } else if (_info.erc == Standard.ERC721) {\n      _success = tryTransferERC721(_token, _to, _info.id);\n    } else {\n      revert(\"Token: unsupported token standard\");\n    }\n\n    if (!_success) {\n      revert(\n        string(\n          abi.encodePacked(\n            \"Token: could not transfer \",\n            toString(_info),\n            \" to \",\n            Strings.toHexString(uint160(_to), 20),\n            \" token \",\n            Strings.toHexString(uint160(_token), 20)\n          )\n        )\n      );\n    }\n  }\n\n  /**\n   * @dev Tries minting and transfering assets.\n   *\n   * @notice Prioritizes transfer native token if the token is wrapped.\n   *\n   */\n  function handleAssetTransfer(\n    Info memory _info,\n    address payable _to,\n    address _token,\n    IWETH _wrappedNativeToken\n  ) internal {\n    bool _success;\n    if (_token == address(_wrappedNativeToken)) {\n      // Try sending the native token before transferring the wrapped token\n      if (!_to.send(_info.quantity)) {\n        _wrappedNativeToken.deposit{ value: _info.quantity }();\n        transfer(_info, _to, _token);\n      }\n    } else if (_info.erc == Token.Standard.ERC20) {\n      uint256 _balance = IERC20(_token).balanceOf(address(this));\n\n      if (_balance < _info.quantity) {\n        // bytes4(keccak256(\"mint(address,uint256)\"))\n        (_success, ) = _token.call(abi.encodeWithSelector(0x40c10f19, address(this), _info.quantity - _balance));\n        require(_success, \"Token: ERC20 minting failed\");\n      }\n\n      transfer(_info, _to, _token);\n    } else if (_info.erc == Token.Standard.ERC721) {\n      if (!tryTransferERC721(_token, _to, _info.id)) {\n        // bytes4(keccak256(\"mint(address,uint256)\"))\n        (_success, ) = _token.call(abi.encodeWithSelector(0x40c10f19, _to, _info.id));\n        require(_success, \"Token: ERC721 minting failed\");\n      }\n    } else {\n      revert(\"Token: unsupported token standard\");\n    }\n  }\n\n  /**\n   * @dev Returns readable string.\n   */\n  function toString(Info memory _info) internal pure returns (string memory) {\n    return\n      string(\n        abi.encodePacked(\n          \"TokenInfo(\",\n          Strings.toHexString(uint160(_info.erc), 1),\n          \",\",\n          Strings.toHexString(_info.id),\n          \",\",\n          Strings.toHexString(_info.quantity),\n          \")\"\n        )\n      );\n  }\n\n  struct Owner {\n    address addr;\n    address tokenAddr;\n    uint256 chainId;\n  }\n\n  // keccak256(\"TokenOwner(address addr,address tokenAddr,uint256 chainId)\");\n  bytes32 public constant OWNER_TYPE_HASH = 0x353bdd8d69b9e3185b3972e08b03845c0c14a21a390215302776a7a34b0e8764;\n\n  /**\n   * @dev Returns ownership struct hash.\n   */\n  function hash(Owner memory _owner) internal pure returns (bytes32) {\n    return keccak256(abi.encode(OWNER_TYPE_HASH, _owner.addr, _owner.tokenAddr, _owner.chainId));\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWETH {\n  function deposit() external payable;\n\n  function withdraw(uint256 _wad) external;\n\n  function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/consumers/MappedTokenConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../libraries/Token.sol\";\n\ninterface MappedTokenConsumer {\n  struct MappedToken {\n    Token.Standard erc;\n    address tokenAddr;\n  }\n}\n"
    },
    "contracts/extensions/bridge-operator-governance/BOsGovernanceRelay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/consumers/SignatureConsumer.sol\";\nimport \"../../interfaces/consumers/VoteStatusConsumer.sol\";\nimport \"../../libraries/BridgeOperatorsBallot.sol\";\nimport \"../../libraries/AddressArrayUtils.sol\";\nimport \"../../libraries/IsolatedGovernance.sol\";\n\nabstract contract BOsGovernanceRelay is SignatureConsumer, VoteStatusConsumer {\n  /// @dev The last the brige operator set info.\n  BridgeOperatorsBallot.BridgeOperatorSet internal _lastSyncedBridgeOperatorSetInfo;\n  /// @dev Mapping from period index => epoch index => bridge operators vote\n  mapping(uint256 => mapping(uint256 => IsolatedGovernance.Vote)) internal _vote;\n\n  /**\n   * @dev Returns the synced bridge operator set info.\n   */\n  function lastSyncedBridgeOperatorSetInfo() external view returns (BridgeOperatorsBallot.BridgeOperatorSet memory) {\n    return _lastSyncedBridgeOperatorSetInfo;\n  }\n\n  /**\n   * @dev Relays votes by signatures.\n   *\n   * Requirements:\n   * - The period of voting is larger than the last synced period.\n   * - The arrays are not empty.\n   * - The signature signers are in order.\n   *\n   * @notice Does not store the voter signature into storage.\n   *\n   */\n  function _relayVotesBySignatures(\n    BridgeOperatorsBallot.BridgeOperatorSet calldata _ballot,\n    Signature[] calldata _signatures,\n    uint256 _minimumVoteWeight,\n    bytes32 _domainSeperator\n  ) internal {\n    require(\n      (_ballot.period >= _lastSyncedBridgeOperatorSetInfo.period &&\n        _ballot.epoch > _lastSyncedBridgeOperatorSetInfo.epoch),\n      \"BOsGovernanceRelay: query for outdated bridge operator set\"\n    );\n    BridgeOperatorsBallot.verifyBallot(_ballot);\n    require(\n      !AddressArrayUtils.isEqual(_ballot.operators, _lastSyncedBridgeOperatorSetInfo.operators),\n      \"BOsGovernanceRelay: bridge operator set is already voted\"\n    );\n    require(_signatures.length > 0, \"BOsGovernanceRelay: invalid array length\");\n\n    Signature calldata _sig;\n    address[] memory _signers = new address[](_signatures.length);\n    address _lastSigner;\n    bytes32 _hash = BridgeOperatorsBallot.hash(_ballot);\n    bytes32 _digest = ECDSA.toTypedDataHash(_domainSeperator, _hash);\n\n    for (uint256 _i = 0; _i < _signatures.length; _i++) {\n      _sig = _signatures[_i];\n      _signers[_i] = ECDSA.recover(_digest, _sig.v, _sig.r, _sig.s);\n      require(_lastSigner < _signers[_i], \"BOsGovernanceRelay: invalid order\");\n      _lastSigner = _signers[_i];\n    }\n\n    IsolatedGovernance.Vote storage _v = _vote[_ballot.period][_ballot.epoch];\n    uint256 _totalVoteWeight = _sumBridgeVoterWeights(_signers);\n    if (_totalVoteWeight >= _minimumVoteWeight) {\n      require(_totalVoteWeight > 0, \"BOsGovernanceRelay: invalid vote weight\");\n      _v.status = VoteStatus.Approved;\n      _lastSyncedBridgeOperatorSetInfo = _ballot;\n      return;\n    }\n\n    revert(\"BOsGovernanceRelay: relay failed\");\n  }\n\n  /**\n   * @dev Returns the weight of the governor list.\n   */\n  function _sumBridgeVoterWeights(address[] memory _bridgeVoters) internal view virtual returns (uint256);\n}\n"
    },
    "contracts/mainchain/MainchainGovernanceAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"../extensions/bridge-operator-governance/BOsGovernanceRelay.sol\";\nimport \"../extensions/sequential-governance/GovernanceRelay.sol\";\nimport \"../extensions/TransparentUpgradeableProxyV2.sol\";\nimport \"../extensions/GovernanceAdmin.sol\";\nimport \"../interfaces/IBridge.sol\";\n\ncontract MainchainGovernanceAdmin is AccessControlEnumerable, GovernanceRelay, GovernanceAdmin, BOsGovernanceRelay {\n  bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n  uint256 private constant DEFAULT_EXPIRY_DURATION = 1 << 255;\n\n  constructor(\n    uint256 _roninChainId,\n    address _roleSetter,\n    address _roninTrustedOrganizationContract,\n    address _bridgeContract,\n    address[] memory _relayers\n  ) GovernanceAdmin(_roninChainId, _roninTrustedOrganizationContract, _bridgeContract, DEFAULT_EXPIRY_DURATION) {\n    _setupRole(DEFAULT_ADMIN_ROLE, _roleSetter);\n    for (uint256 _i; _i < _relayers.length; _i++) {\n      _grantRole(RELAYER_ROLE, _relayers[_i]);\n    }\n  }\n\n  /**\n   * @dev Returns whether the voter `_voter` casted vote for the proposal.\n   */\n  function proposalRelayed(uint256 _chainId, uint256 _round) external view returns (bool) {\n    return vote[_chainId][_round].status != VoteStatus.Pending;\n  }\n\n  /**\n   * @dev Returns whether the voter `_voter` casted vote for bridge operators at a specific period.\n   */\n  function bridgeOperatorsRelayed(uint256 _period, uint256 _epoch) external view returns (bool) {\n    return _vote[_period][_epoch].status != VoteStatus.Pending;\n  }\n\n  /**\n   * @dev See `GovernanceRelay-_relayProposal`.\n   *\n   * Requirements:\n   * - The method caller is relayer.\n   *\n   */\n  function relayProposal(\n    Proposal.ProposalDetail calldata _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures\n  ) external onlyRole(RELAYER_ROLE) {\n    _relayProposal(_proposal, _supports, _signatures, DOMAIN_SEPARATOR, msg.sender);\n  }\n\n  /**\n   * @dev See `GovernanceRelay-_relayGlobalProposal`.\n   *\n   * Requirements:\n   * - The method caller is relayer.\n   *\n   */\n  function relayGlobalProposal(\n    GlobalProposal.GlobalProposalDetail calldata _globalProposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures\n  ) external onlyRole(RELAYER_ROLE) {\n    _relayGlobalProposal(\n      _globalProposal,\n      _supports,\n      _signatures,\n      DOMAIN_SEPARATOR,\n      roninTrustedOrganizationContract(),\n      bridgeContract(),\n      msg.sender\n    );\n  }\n\n  /**\n   * @dev See `BOsGovernanceRelay-_relayVotesBySignatures`.\n   *\n   * Requirements:\n   * - The method caller is relayer.\n   *\n   */\n  function relayBridgeOperators(\n    BridgeOperatorsBallot.BridgeOperatorSet calldata _ballot,\n    Signature[] calldata _signatures\n  ) external onlyRole(RELAYER_ROLE) {\n    _relayVotesBySignatures(_ballot, _signatures, _getMinimumVoteWeight(), DOMAIN_SEPARATOR);\n    TransparentUpgradeableProxyV2(payable(bridgeContract())).functionDelegateCall(\n      abi.encodeWithSelector(_bridgeContract.replaceBridgeOperators.selector, _ballot.operators)\n    );\n  }\n\n  /**\n   * @inheritdoc GovernanceRelay\n   */\n  function _sumWeights(address[] memory _governors) internal view virtual override returns (uint256) {\n    bytes4 _selector = IRoninTrustedOrganization.sumGovernorWeights.selector;\n    (bool _success, bytes memory _returndata) = roninTrustedOrganizationContract().staticcall(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector, _governors)\n      )\n    );\n    if (!_success) revert ErrProxyCallFailed(_selector);\n    return abi.decode(_returndata, (uint256));\n  }\n\n  /**\n   * @inheritdoc BOsGovernanceRelay\n   */\n  function _sumBridgeVoterWeights(address[] memory _governors) internal view virtual override returns (uint256) {\n    bytes4 _selector = IRoninTrustedOrganization.sumBridgeVoterWeights.selector;\n    (bool _success, bytes memory _returndata) = roninTrustedOrganizationContract().staticcall(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector, _governors)\n      )\n    );\n    if (!_success) revert ErrProxyCallFailed(_selector);\n    return abi.decode(_returndata, (uint256));\n  }\n\n  /**\n   * @dev See {CoreGovernance-_getChainType}\n   */\n  function _getChainType() internal pure override returns (ChainType) {\n    return ChainType.Mainchain;\n  }\n}\n"
    },
    "contracts/extensions/sequential-governance/GovernanceRelay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./CoreGovernance.sol\";\n\nabstract contract GovernanceRelay is CoreGovernance {\n  using Proposal for Proposal.ProposalDetail;\n  using GlobalProposal for GlobalProposal.GlobalProposalDetail;\n\n  /**\n   * @dev Relays votes by signatures.\n   *\n   * @notice Does not store the voter signature into storage.\n   *\n   */\n  function _relayVotesBySignatures(\n    Proposal.ProposalDetail memory _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures,\n    bytes32 _forDigest,\n    bytes32 _againstDigest\n  ) internal {\n    require(_supports.length > 0 && _supports.length == _signatures.length, \"GovernanceRelay: invalid array length\");\n    uint256 _forVoteCount;\n    uint256 _againstVoteCount;\n    address[] memory _forVoteSigners = new address[](_signatures.length);\n    address[] memory _againstVoteSigners = new address[](_signatures.length);\n\n    {\n      address _signer;\n      address _lastSigner;\n      Ballot.VoteType _support;\n      Signature calldata _sig;\n\n      for (uint256 _i; _i < _signatures.length; _i++) {\n        _sig = _signatures[_i];\n        _support = _supports[_i];\n\n        if (_support == Ballot.VoteType.For) {\n          _signer = ECDSA.recover(_forDigest, _sig.v, _sig.r, _sig.s);\n          _forVoteSigners[_forVoteCount++] = _signer;\n        } else if (_support == Ballot.VoteType.Against) {\n          _signer = ECDSA.recover(_againstDigest, _sig.v, _sig.r, _sig.s);\n          _againstVoteSigners[_againstVoteCount++] = _signer;\n        } else {\n          revert(\"GovernanceRelay: query for unsupported vote type\");\n        }\n\n        require(_lastSigner < _signer, \"GovernanceRelay: invalid order\");\n        _lastSigner = _signer;\n      }\n    }\n\n    assembly {\n      mstore(_forVoteSigners, _forVoteCount)\n      mstore(_againstVoteSigners, _againstVoteCount)\n    }\n\n    ProposalVote storage _vote = vote[_proposal.chainId][_proposal.nonce];\n    uint256 _minimumForVoteWeight = _getMinimumVoteWeight();\n    uint256 _totalForVoteWeight = _sumWeights(_forVoteSigners);\n    if (_totalForVoteWeight >= _minimumForVoteWeight) {\n      require(_totalForVoteWeight > 0, \"GovernanceRelay: invalid vote weight\");\n      _vote.status = VoteStatus.Approved;\n      emit ProposalApproved(_vote.hash);\n      _tryExecute(_vote, _proposal);\n      return;\n    }\n\n    uint256 _minimumAgainstVoteWeight = _getTotalWeights() - _minimumForVoteWeight + 1;\n    uint256 _totalAgainstVoteWeight = _sumWeights(_againstVoteSigners);\n    if (_totalAgainstVoteWeight >= _minimumAgainstVoteWeight) {\n      require(_totalAgainstVoteWeight > 0, \"GovernanceRelay: invalid vote weight\");\n      _vote.status = VoteStatus.Rejected;\n      emit ProposalRejected(_vote.hash);\n      return;\n    }\n\n    revert(\"GovernanceRelay: relay failed\");\n  }\n\n  /**\n   * @dev Relays voted proposal.\n   *\n   * Requirements:\n   * - The relay proposal is finalized.\n   *\n   */\n  function _relayProposal(\n    Proposal.ProposalDetail calldata _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures,\n    bytes32 _domainSeparator,\n    address _creator\n  ) internal {\n    _proposeProposalStruct(_proposal, _creator);\n    bytes32 _proposalHash = _proposal.hash();\n    _relayVotesBySignatures(\n      _proposal,\n      _supports,\n      _signatures,\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_proposalHash, Ballot.VoteType.For)),\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_proposalHash, Ballot.VoteType.Against))\n    );\n  }\n\n  /**\n   * @dev Relays voted global proposal.\n   *\n   * Requirements:\n   * - The relay proposal is finalized.\n   *\n   */\n  function _relayGlobalProposal(\n    GlobalProposal.GlobalProposalDetail calldata _globalProposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures,\n    bytes32 _domainSeparator,\n    address _roninTrustedOrganizationContract,\n    address _gatewayContract,\n    address _creator\n  ) internal {\n    Proposal.ProposalDetail memory _proposal = _proposeGlobalStruct(\n      _globalProposal,\n      _roninTrustedOrganizationContract,\n      _gatewayContract,\n      _creator\n    );\n    bytes32 _globalProposalHash = _globalProposal.hash();\n    _relayVotesBySignatures(\n      _proposal,\n      _supports,\n      _signatures,\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_globalProposalHash, Ballot.VoteType.For)),\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_globalProposalHash, Ballot.VoteType.Against))\n    );\n  }\n\n  /**\n   * @dev Returns the weight of the governor list.\n   */\n  function _sumWeights(address[] memory _governors) internal view virtual returns (uint256);\n}\n"
    },
    "contracts/extensions/TransparentUpgradeableProxyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract TransparentUpgradeableProxyV2 is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n\n  /**\n   * @dev Calls a function from the current implementation as specified by `_data`, which should be an encoded function call.\n   *\n   * Requirements:\n   * - Only the admin can call this function.\n   *\n   * Note: The proxy admin is not allowed to interact with the proxy logic through the fallback function to avoid\n   * triggering some unexpected logic. This is to allow the administrator to explicitly call the proxy, please consider\n   * reviewing the encoded data `_data` and the method which is called before using this.\n   *\n   */\n  function functionDelegateCall(bytes memory _data) public payable ifAdmin {\n    address _addr = _implementation();\n    assembly {\n      let _result := delegatecall(gas(), _addr, add(_data, 32), mload(_data), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch _result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "contracts/mocks/MockBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol\";\nimport \"../interfaces/IBridge.sol\";\n\ncontract MockBridge is IBridge {\n  /// @dev Mapping from validator address => last block that the bridge operator is added\n  mapping(address => uint256) public bridgeOperatorAddedBlock;\n  /// @dev Bridge operators array\n  address[] public bridgeOperators;\n\n  function replaceBridgeOperators(address[] calldata _list) external {\n    address _addr;\n    for (uint256 _i = 0; _i < _list.length; _i++) {\n      _addr = _list[_i];\n      if (bridgeOperatorAddedBlock[_addr] == 0) {\n        bridgeOperators.push(_addr);\n      }\n      bridgeOperatorAddedBlock[_addr] = block.number;\n    }\n\n    {\n      uint256 _i;\n      while (_i < bridgeOperators.length) {\n        _addr = bridgeOperators[_i];\n        if (bridgeOperatorAddedBlock[_addr] < block.number) {\n          delete bridgeOperatorAddedBlock[_addr];\n          bridgeOperators[_i] = bridgeOperators[bridgeOperators.length - 1];\n          bridgeOperators.pop();\n          continue;\n        }\n        _i++;\n      }\n    }\n  }\n\n  function getBridgeOperators() external view override returns (address[] memory) {\n    return bridgeOperators;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "contracts/multi-chains/RoninTrustedOrganization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../libraries/AddressArrayUtils.sol\";\nimport \"../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../extensions/collections/HasProxyAdmin.sol\";\n\ncontract RoninTrustedOrganization is IRoninTrustedOrganization, HasProxyAdmin, Initializable {\n  uint256 internal _num;\n  uint256 internal _denom;\n  uint256 internal _totalWeight;\n  uint256 internal _nonce;\n\n  /// @dev Mapping from consensus address => weight\n  mapping(address => uint256) internal _consensusWeight;\n  /// @dev Mapping from governor address => weight\n  mapping(address => uint256) internal _governorWeight;\n  /// @dev Mapping from bridge voter address => weight\n  mapping(address => uint256) internal _bridgeVoterWeight;\n\n  /// @dev Mapping from consensus address => added block\n  mapping(address => uint256) internal _addedBlock;\n\n  /// @dev Consensus array\n  address[] internal _consensusList;\n  /// @dev Governors array\n  address[] internal _governorList;\n  /// @dev Bridge voters array\n  address[] internal _bridgeVoterList;\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    TrustedOrganization[] calldata _trustedOrgs,\n    uint256 __num,\n    uint256 __denom\n  ) external initializer {\n    if (_trustedOrgs.length > 0) {\n      _addTrustedOrganizations(_trustedOrgs);\n    }\n    _setThreshold(__num, __denom);\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function getThreshold() external view virtual returns (uint256 num_, uint256 denom_) {\n    return (_num, _denom);\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function checkThreshold(uint256 _voteWeight) external view virtual returns (bool) {\n    return _voteWeight * _denom >= _num * _totalWeight;\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function minimumVoteWeight() external view virtual returns (uint256) {\n    return (_num * _totalWeight + _denom - 1) / _denom;\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function setThreshold(uint256 _numerator, uint256 _denominator)\n    external\n    override\n    onlyAdmin\n    returns (uint256, uint256)\n  {\n    return _setThreshold(_numerator, _denominator);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function addTrustedOrganizations(TrustedOrganization[] calldata _list) external override onlyAdmin {\n    _addTrustedOrganizations(_list);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function updateTrustedOrganizations(TrustedOrganization[] calldata _list) external override onlyAdmin {\n    require(_list.length > 0, \"RoninTrustedOrganization: invalid array length\");\n    for (uint256 _i; _i < _list.length; _i++) {\n      _updateTrustedOrganization(_list[_i]);\n    }\n    emit TrustedOrganizationsUpdated(_list);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function removeTrustedOrganizations(address[] calldata _list) external override onlyAdmin {\n    require(_list.length > 0, \"RoninTrustedOrganization: invalid array length\");\n    for (uint _i = 0; _i < _list.length; _i++) {\n      _removeTrustedOrganization(_list[_i]);\n    }\n    emit TrustedOrganizationsRemoved(_list);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function totalWeights() external view virtual returns (uint256) {\n    return _totalWeight;\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getConsensusWeight(address _consensusAddr) external view returns (uint256) {\n    return _consensusWeight[_consensusAddr];\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getGovernorWeight(address _governor) external view returns (uint256) {\n    return _governorWeight[_governor];\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getBridgeVoterWeight(address _addr) external view returns (uint256) {\n    return _bridgeVoterWeight[_addr];\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getConsensusWeights(address[] calldata _list) external view returns (uint256[] memory _res) {\n    _res = new uint256[](_list.length);\n    for (uint _i = 0; _i < _res.length; _i++) {\n      _res[_i] = _consensusWeight[_list[_i]];\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getGovernorWeights(address[] calldata _list) external view returns (uint256[] memory _res) {\n    _res = new uint256[](_list.length);\n    for (uint _i = 0; _i < _res.length; _i++) {\n      _res[_i] = _governorWeight[_list[_i]];\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getBridgeVoterWeights(address[] calldata _list) external view returns (uint256[] memory _res) {\n    _res = new uint256[](_list.length);\n    for (uint _i = 0; _i < _res.length; _i++) {\n      _res[_i] = _bridgeVoterWeight[_list[_i]];\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function sumConsensusWeights(address[] calldata _list) external view returns (uint256 _res) {\n    for (uint _i = 0; _i < _list.length; _i++) {\n      _res += _consensusWeight[_list[_i]];\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function sumGovernorWeights(address[] calldata _list) external view returns (uint256 _res) {\n    for (uint _i = 0; _i < _list.length; _i++) {\n      _res += _governorWeight[_list[_i]];\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function sumBridgeVoterWeights(address[] calldata _list) external view returns (uint256 _res) {\n    for (uint _i = 0; _i < _list.length; _i++) {\n      _res += _bridgeVoterWeight[_list[_i]];\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function countTrustedOrganizations() external view override returns (uint256) {\n    return _consensusList.length;\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getAllTrustedOrganizations() external view override returns (TrustedOrganization[] memory _list) {\n    _list = new TrustedOrganization[](_consensusList.length);\n    address _addr;\n    for (uint256 _i; _i < _list.length; _i++) {\n      _addr = _consensusList[_i];\n      _list[_i].consensusAddr = _addr;\n      _list[_i].governor = _governorList[_i];\n      _list[_i].bridgeVoter = _bridgeVoterList[_i];\n      _list[_i].weight = _consensusWeight[_addr];\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getTrustedOrganization(address _consensusAddr) external view returns (TrustedOrganization memory) {\n    for (uint _i = 0; _i < _consensusList.length; _i++) {\n      if (_consensusList[_i] == _consensusAddr) {\n        return getTrustedOrganizationAt(_i);\n      }\n    }\n    revert(\"RoninTrustedOrganization: query for non-existent consensus address\");\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getTrustedOrganizationAt(uint256 _idx) public view override returns (TrustedOrganization memory) {\n    address _addr = _consensusList[_idx];\n    return\n      TrustedOrganization(\n        _addr,\n        _governorList[_idx],\n        _bridgeVoterList[_idx],\n        _consensusWeight[_addr],\n        _addedBlock[_addr]\n      );\n  }\n\n  /**\n   * @dev Adds a list of trusted organizations.\n   */\n  function _addTrustedOrganizations(TrustedOrganization[] calldata _list) internal virtual {\n    for (uint256 _i; _i < _list.length; _i++) {\n      _addTrustedOrganization(_list[_i]);\n    }\n    emit TrustedOrganizationsAdded(_list);\n  }\n\n  /**\n   * @dev Adds a trusted organization.\n   *\n   * Requirements:\n   * - The weight is larger than 0.\n   * - The consensus address is not added.\n   * - The govenor address is not added.\n   * - The bridge voter address is not added.\n   *\n   */\n  function _addTrustedOrganization(TrustedOrganization memory _v) internal virtual {\n    require(_v.addedBlock == 0, \"RoninTrustedOrganization: invalid request\");\n    _sanityCheckTrustedOrganizationData(_v);\n\n    if (_consensusWeight[_v.consensusAddr] > 0) {\n      revert(\n        string(\n          abi.encodePacked(\n            \"RoninTrustedOrganization: consensus address \",\n            Strings.toHexString(uint160(_v.consensusAddr), 20),\n            \" is added already\"\n          )\n        )\n      );\n    }\n\n    if (_governorWeight[_v.governor] > 0) {\n      revert(\n        string(\n          abi.encodePacked(\n            \"RoninTrustedOrganization: govenor address \",\n            Strings.toHexString(uint160(_v.governor), 20),\n            \" is added already\"\n          )\n        )\n      );\n    }\n\n    if (_bridgeVoterWeight[_v.bridgeVoter] > 0) {\n      revert(\n        string(\n          abi.encodePacked(\n            \"RoninTrustedOrganization: bridge voter address \",\n            Strings.toHexString(uint160(_v.bridgeVoter), 20),\n            \" is added already\"\n          )\n        )\n      );\n    }\n\n    _consensusList.push(_v.consensusAddr);\n    _consensusWeight[_v.consensusAddr] = _v.weight;\n\n    _governorList.push(_v.governor);\n    _governorWeight[_v.governor] = _v.weight;\n\n    _bridgeVoterList.push(_v.bridgeVoter);\n    _bridgeVoterWeight[_v.bridgeVoter] = _v.weight;\n\n    _addedBlock[_v.consensusAddr] = block.number;\n\n    _totalWeight += _v.weight;\n  }\n\n  /**\n   * @dev Updates a trusted organization.\n   *\n   * Requirements:\n   * - The weight is larger than 0.\n   * - The consensus address is already added.\n   *\n   */\n  function _updateTrustedOrganization(TrustedOrganization memory _v) internal virtual {\n    _sanityCheckTrustedOrganizationData(_v);\n\n    uint256 _weight = _consensusWeight[_v.consensusAddr];\n    if (_weight == 0) {\n      revert(\n        string(\n          abi.encodePacked(\n            \"RoninTrustedOrganization: consensus address \",\n            Strings.toHexString(uint160(_v.consensusAddr), 20),\n            \" is not added\"\n          )\n        )\n      );\n    }\n\n    uint256 _count = _consensusList.length;\n    for (uint256 _i = 0; _i < _count; _i++) {\n      if (_consensusList[_i] == _v.consensusAddr) {\n        _totalWeight -= _weight;\n        _totalWeight += _v.weight;\n\n        if (_governorList[_i] != _v.governor) {\n          require(_governorWeight[_v.governor] == 0, \"RoninTrustedOrganization: query for duplicated governor\");\n          delete _governorWeight[_governorList[_i]];\n          _governorList[_i] = _v.governor;\n        }\n\n        if (_bridgeVoterList[_i] != _v.bridgeVoter) {\n          require(\n            _bridgeVoterWeight[_v.bridgeVoter] == 0,\n            \"RoninTrustedOrganization: query for duplicated bridge voter\"\n          );\n          delete _bridgeVoterWeight[_bridgeVoterList[_i]];\n          _bridgeVoterList[_i] = _v.bridgeVoter;\n        }\n\n        _consensusWeight[_v.consensusAddr] = _v.weight;\n        _governorWeight[_v.governor] = _v.weight;\n        _bridgeVoterWeight[_v.bridgeVoter] = _v.weight;\n        return;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes a trusted organization.\n   *\n   * Requirements:\n   * - The consensus address is added.\n   *\n   */\n  function _removeTrustedOrganization(address _addr) internal virtual {\n    uint256 _weight = _consensusWeight[_addr];\n    if (_weight == 0) {\n      revert(\n        string(\n          abi.encodePacked(\n            \"RoninTrustedOrganization: consensus address \",\n            Strings.toHexString(uint160(_addr), 20),\n            \" is not added\"\n          )\n        )\n      );\n    }\n\n    uint256 _index;\n    uint256 _count = _consensusList.length;\n    for (uint256 _i = 0; _i < _count; _i++) {\n      if (_consensusList[_i] == _addr) {\n        _index = _i;\n        break;\n      }\n    }\n\n    _totalWeight -= _weight;\n\n    delete _addedBlock[_addr];\n    delete _consensusWeight[_addr];\n    _consensusList[_index] = _consensusList[_count - 1];\n    _consensusList.pop();\n\n    delete _governorWeight[_governorList[_index]];\n    _governorList[_index] = _governorList[_count - 1];\n    _governorList.pop();\n\n    delete _bridgeVoterWeight[_bridgeVoterList[_index]];\n    _bridgeVoterList[_index] = _bridgeVoterList[_count - 1];\n    _bridgeVoterList.pop();\n  }\n\n  /**\n   * @dev Sets threshold and returns the old one.\n   *\n   * Emits the `ThresholdUpdated` event.\n   *\n   */\n  function _setThreshold(uint256 _numerator, uint256 _denominator)\n    internal\n    virtual\n    returns (uint256 _previousNum, uint256 _previousDenom)\n  {\n    require(_numerator <= _denominator, \"RoninTrustedOrganization: invalid threshold\");\n    _previousNum = _num;\n    _previousDenom = _denom;\n    _num = _numerator;\n    _denom = _denominator;\n    emit ThresholdUpdated(_nonce++, _numerator, _denominator, _previousNum, _previousDenom);\n  }\n\n  /**\n   * @dev Hook that checks trusted organization's data. Reverts if the requirements are not met.\n   *\n   * Requirements:\n   * - The weight must be larger than 0.\n   * - The consensus address, governor address, and bridge voter address are different.\n   */\n  function _sanityCheckTrustedOrganizationData(TrustedOrganization memory _v) private pure {\n    require(_v.weight > 0, \"RoninTrustedOrganization: invalid weight\");\n\n    address[] memory _addresses = new address[](3);\n    _addresses[0] = _v.consensusAddr;\n    _addresses[1] = _v.governor;\n    _addresses[2] = _v.bridgeVoter;\n    require(!AddressArrayUtils.hasDuplicate(_addresses), \"RoninTrustedOrganization: three addresses must be distinct\");\n  }\n}\n"
    },
    "contracts/ronin/gateway/BridgeTracking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../extensions/collections/HasBridgeContract.sol\";\nimport \"../../extensions/collections/HasValidatorContract.sol\";\nimport \"../../interfaces/IBridgeTracking.sol\";\n\ncontract BridgeTracking is HasBridgeContract, HasValidatorContract, Initializable, IBridgeTracking {\n  struct PeriodVotingMetric {\n    /// @dev Total requests that are tracked in the period. This value is 0 until the {_bufferMetric.requests[]} gets added into a period metric.\n    uint256 totalRequests;\n    uint256 totalBallots;\n    mapping(address => uint256) totalBallotsOf;\n    address[] voters;\n  }\n\n  struct PeriodVotingMetricTimeWrapper {\n    uint256 lastEpoch;\n    Request[] requests;\n    PeriodVotingMetric data;\n  }\n\n  struct ReceiptTrackingInfo {\n    /// @dev The period that the receipt is approved. Value 0 means the receipt is not approved yet.\n    uint256 approvedPeriod;\n    /// @dev The address list of voters\n    address[] voters;\n    /// @dev Mapping from voter => flag indicating the voter casts vote for this receipt\n    mapping(address => bool) voted;\n    /// @dev The period that the receipt is tracked, i.e. the metric is transferred from buffer to the period. Value 0 means the receipt is currently in buffer or not tracked yet.\n    uint256 trackedPeriod;\n  }\n\n  /// @dev The block that the contract allows incoming mutable calls.\n  uint256 public startedAtBlock;\n\n  /// @dev The temporary info of votes and ballots\n  PeriodVotingMetricTimeWrapper internal _bufferMetric;\n  /// @dev Mapping from period number => vote stats based on period\n  mapping(uint256 => PeriodVotingMetric) internal _periodMetric;\n  /// @dev Mapping from vote kind => receipt id => receipt stats\n  mapping(VoteKind => mapping(uint256 => ReceiptTrackingInfo)) internal _receiptTrackingInfo;\n\n  modifier skipOnUnstarted() {\n    if (block.number < startedAtBlock) {\n      return;\n    }\n    _;\n  }\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address _bridgeContract,\n    address _validatorContract,\n    uint256 _startedAtBlock\n  ) external initializer {\n    _setBridgeContract(_bridgeContract);\n    _setValidatorContract(_validatorContract);\n    startedAtBlock = _startedAtBlock;\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function totalVotes(uint256 _period) external view override returns (uint256 _totalVotes) {\n    _totalVotes = _periodMetric[_period].totalRequests;\n    if (_isBufferCountedForPeriod(_period)) {\n      _totalVotes += _bufferMetric.requests.length;\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function totalBallots(uint256 _period) external view override returns (uint256 _totalBallots) {\n    _totalBallots = _periodMetric[_period].totalBallots;\n    if (_isBufferCountedForPeriod(_period)) {\n      _totalBallots += _bufferMetric.data.totalBallots;\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function getManyTotalBallots(uint256 _period, address[] calldata _bridgeOperators)\n    external\n    view\n    override\n    returns (uint256[] memory _res)\n  {\n    _res = new uint256[](_bridgeOperators.length);\n    bool _isBufferCounted = _isBufferCountedForPeriod(_period);\n    for (uint _i = 0; _i < _bridgeOperators.length; _i++) {\n      _res[_i] = _totalBallotsOf(_period, _bridgeOperators[_i], _isBufferCounted);\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function totalBallotsOf(uint256 _period, address _bridgeOperator) public view override returns (uint256) {\n    return _totalBallotsOf(_period, _bridgeOperator, _isBufferCountedForPeriod(_period));\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function handleVoteApproved(VoteKind _kind, uint256 _requestId) external override onlyBridgeContract skipOnUnstarted {\n    ReceiptTrackingInfo storage _receiptInfo = _receiptTrackingInfo[_kind][_requestId];\n\n    // Only records for the receipt which not approved\n    if (_receiptInfo.approvedPeriod == 0) {\n      _trySyncBuffer();\n      uint256 _currentPeriod = _validatorContract.currentPeriod();\n      _receiptInfo.approvedPeriod = _currentPeriod;\n\n      Request storage _bufferRequest = _bufferMetric.requests.push();\n      _bufferRequest.kind = _kind;\n      _bufferRequest.id = _requestId;\n\n      address[] storage _voters = _receiptInfo.voters;\n      for (uint _i = 0; _i < _voters.length; _i++) {\n        _increaseBallot(_kind, _requestId, _voters[_i], _currentPeriod);\n      }\n\n      delete _receiptInfo.voters;\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function recordVote(\n    VoteKind _kind,\n    uint256 _requestId,\n    address _operator\n  ) external override onlyBridgeContract skipOnUnstarted {\n    uint256 _period = _validatorContract.currentPeriod();\n    _trySyncBuffer();\n    ReceiptTrackingInfo storage _receiptInfo = _receiptTrackingInfo[_kind][_requestId];\n\n    // When the vote is not approved yet, the voters are saved in the receipt info, and not increase ballot metric.\n    // The ballot metric will be increased later in the {handleVoteApproved} method.\n    if (_receiptInfo.approvedPeriod == 0) {\n      _receiptInfo.voters.push(_operator);\n      return;\n    }\n\n    _increaseBallot(_kind, _requestId, _operator, _period);\n  }\n\n  /**\n   * @dev Increases the ballot for the operator at a period.\n   */\n  function _increaseBallot(\n    VoteKind _kind,\n    uint256 _requestId,\n    address _operator,\n    uint256 _currentPeriod\n  ) internal {\n    ReceiptTrackingInfo storage _receiptInfo = _receiptTrackingInfo[_kind][_requestId];\n    if (_receiptInfo.voted[_operator]) {\n      return;\n    }\n\n    _receiptInfo.voted[_operator] = true;\n\n    uint256 _trackedPeriod = _receiptInfo.trackedPeriod;\n\n    // Do not increase ballot for receipt that is neither in the buffer, nor in the most current tracked period.\n    // If the receipt is not tracked in a period, increase metric in buffer.\n    if (_trackedPeriod == 0) {\n      if (_bufferMetric.data.totalBallotsOf[_operator] == 0) {\n        _bufferMetric.data.voters.push(_operator);\n      }\n      _bufferMetric.data.totalBallots++;\n      _bufferMetric.data.totalBallotsOf[_operator]++;\n    }\n    // If the receipt is tracked in the most current tracked period, increase metric in the period.\n    else if (_trackedPeriod == _currentPeriod) {\n      PeriodVotingMetric storage _metric = _periodMetric[_trackedPeriod];\n      _metric.totalBallots++;\n      _metric.totalBallotsOf[_operator]++;\n    }\n  }\n\n  /**\n   * @dev See `totalBallotsOf`.\n   */\n  function _totalBallotsOf(\n    uint256 _period,\n    address _bridgeOperator,\n    bool _mustCountLastStats\n  ) internal view returns (uint256 _totalBallots) {\n    _totalBallots = _periodMetric[_period].totalBallotsOf[_bridgeOperator];\n    if (_mustCountLastStats) {\n      _totalBallots += _bufferMetric.data.totalBallotsOf[_bridgeOperator];\n    }\n  }\n\n  /**\n   * @dev Syncs period stats. Move all data from the buffer metric to the period metric.\n   *\n   * Requirements:\n   * - The epoch after the buffer epoch is wrapped up.\n   */\n  function _trySyncBuffer() internal {\n    uint256 _currentEpoch = _validatorContract.epochOf(block.number);\n    if (_bufferMetric.lastEpoch < _currentEpoch) {\n      (, uint256 _trackedPeriod) = _validatorContract.tryGetPeriodOfEpoch(_bufferMetric.lastEpoch + 1);\n      _bufferMetric.lastEpoch = _currentEpoch;\n\n      // Copy numbers of totals\n      PeriodVotingMetric storage _metric = _periodMetric[_trackedPeriod];\n      _metric.totalRequests += _bufferMetric.requests.length;\n      _metric.totalBallots += _bufferMetric.data.totalBallots;\n\n      // Copy voters info and voters' ballot\n      for (uint _i = 0; _i < _bufferMetric.data.voters.length; _i++) {\n        address _voter = _bufferMetric.data.voters[_i];\n        _metric.totalBallotsOf[_voter] += _bufferMetric.data.totalBallotsOf[_voter];\n        delete _bufferMetric.data.totalBallotsOf[_voter]; // need to manually delete each element, due to mapping\n      }\n\n      // Mark all receipts in the buffer as tracked. Keep total number of receipts and delete receipt details.\n      for (uint _i = 0; _i < _bufferMetric.requests.length; _i++) {\n        Request storage _bufferRequest = _bufferMetric.requests[_i];\n        ReceiptTrackingInfo storage _receiptInfo = _receiptTrackingInfo[_bufferRequest.kind][_bufferRequest.id];\n        _receiptInfo.trackedPeriod = _trackedPeriod;\n      }\n\n      delete _bufferMetric.requests;\n      delete _bufferMetric.data;\n    }\n  }\n\n  /**\n   * @dev Returns whether the buffer stats must be counted or not.\n   */\n  function _isBufferCountedForPeriod(uint256 _queriedPeriod) internal view returns (bool) {\n    uint256 _currentEpoch = _validatorContract.epochOf(block.number);\n    (bool _filled, uint256 _periodOfNextTemporaryEpoch) = _validatorContract.tryGetPeriodOfEpoch(\n      _bufferMetric.lastEpoch + 1\n    );\n    return _filled && _queriedPeriod == _periodOfNextTemporaryEpoch && _bufferMetric.lastEpoch < _currentEpoch;\n  }\n}\n"
    },
    "contracts/mocks/MockGatewayForTracking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../interfaces/IBridgeTracking.sol\";\nimport \"../extensions/collections/HasBridgeTrackingContract.sol\";\n\ncontract MockGatewayForTracking is HasBridgeTrackingContract {\n  constructor(address _bridgeTrackingContract) {\n    _setBridgeTrackingContract(_bridgeTrackingContract);\n  }\n\n  function sendBallot(\n    IBridgeTracking.VoteKind _kind,\n    uint256 _id,\n    address[] memory _voters\n  ) external {\n    for (uint256 _i; _i < _voters.length; _i++) {\n      _bridgeTrackingContract.recordVote(_kind, _id, _voters[_i]);\n    }\n  }\n\n  function sendApprovedVote(IBridgeTracking.VoteKind _kind, uint256 _id) external {\n    _bridgeTrackingContract.handleVoteApproved(_kind, _id);\n  }\n}\n"
    },
    "contracts/extensions/collections/HasBridgeTrackingContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasBridgeTrackingContract.sol\";\nimport \"../../interfaces/IBridgeTracking.sol\";\n\ncontract HasBridgeTrackingContract is IHasBridgeTrackingContract, HasProxyAdmin {\n  IBridgeTracking internal _bridgeTrackingContract;\n\n  modifier onlyBridgeTrackingContract() {\n    if (bridgeTrackingContract() != msg.sender) revert ErrCallerMustBeBridgeTrackingContract();\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasBridgeTrackingContract\n   */\n  function bridgeTrackingContract() public view override returns (address) {\n    return address(_bridgeTrackingContract);\n  }\n\n  /**\n   * @inheritdoc IHasBridgeTrackingContract\n   */\n  function setBridgeTrackingContract(address _addr) external virtual override onlyAdmin {\n    if (_addr.code.length == 0) revert ErrZeroCodeContract();\n    _setBridgeTrackingContract(_addr);\n  }\n\n  /**\n   * @dev Sets the bridge tracking contract.\n   *\n   * Emits the event `BridgeTrackingContractUpdated`.\n   *\n   */\n  function _setBridgeTrackingContract(address _addr) internal {\n    _bridgeTrackingContract = IBridgeTracking(_addr);\n    emit BridgeTrackingContractUpdated(_addr);\n  }\n}\n"
    },
    "contracts/ronin/validator/CoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasBridgeTrackingContract.sol\";\nimport \"../../extensions/collections/HasMaintenanceContract.sol\";\nimport \"../../extensions/collections/HasSlashIndicatorContract.sol\";\nimport \"../../extensions/collections/HasStakingVestingContract.sol\";\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../interfaces/validator/ICoinbaseExecution.sol\";\nimport \"../../libraries/EnumFlags.sol\";\nimport \"../../libraries/Math.sol\";\nimport \"../../precompile-usages/PCUSortValidators.sol\";\nimport \"../../precompile-usages/PCUPickValidatorSet.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\nimport \"./CandidateManager.sol\";\nimport \"./EmergencyExit.sol\";\n\nabstract contract CoinbaseExecution is\n  ICoinbaseExecution,\n  RONTransferHelper,\n  PCUSortValidators,\n  PCUPickValidatorSet,\n  HasStakingVestingContract,\n  HasBridgeTrackingContract,\n  HasMaintenanceContract,\n  HasSlashIndicatorContract,\n  EmergencyExit\n{\n  using EnumFlags for EnumFlags.ValidatorFlag;\n\n  modifier onlyCoinbase() {\n    if (msg.sender != block.coinbase) revert ErrCallerMustBeCoinbase();\n    _;\n  }\n\n  modifier whenEpochEnding() {\n    if (!epochEndingAt(block.number)) revert ErrAtEndOfEpochOnly();\n    _;\n  }\n\n  modifier oncePerEpoch() {\n    if (epochOf(_lastUpdatedBlock) >= epochOf(block.number)) revert ErrAlreadyWrappedEpoch();\n    _lastUpdatedBlock = block.number;\n    _;\n  }\n\n  /**\n   * @inheritdoc ICoinbaseExecution\n   */\n  function submitBlockReward() external payable override onlyCoinbase {\n    bool _requestForBlockProducer = isBlockProducer(msg.sender) &&\n      !_jailed(msg.sender) &&\n      !_miningRewardDeprecated(msg.sender, currentPeriod());\n\n    (, uint256 _blockProducerBonus, uint256 _bridgeOperatorBonus) = _stakingVestingContract.requestBonus(\n      _requestForBlockProducer,\n      true // _requestForBridgeOperator\n    );\n\n    _totalBridgeReward += _bridgeOperatorBonus;\n\n    // Deprecates reward for non-validator or slashed validator\n    if (!_requestForBlockProducer) {\n      _totalDeprecatedReward += msg.value;\n      emit BlockRewardDeprecated(msg.sender, msg.value, BlockRewardDeprecatedType.UNAVAILABILITY);\n      return;\n    }\n\n    emit BlockRewardSubmitted(msg.sender, msg.value, _blockProducerBonus);\n\n    uint256 _period = currentPeriod();\n    uint256 _reward = msg.value + _blockProducerBonus;\n    uint256 _cutOffReward;\n    if (_miningRewardBailoutCutOffAtPeriod[msg.sender][_period]) {\n      (, , , uint256 _cutOffPercentage) = _slashIndicatorContract.getCreditScoreConfigs();\n      _cutOffReward = (_reward * _cutOffPercentage) / _MAX_PERCENTAGE;\n      _totalDeprecatedReward += _cutOffReward;\n      emit BlockRewardDeprecated(msg.sender, _cutOffReward, BlockRewardDeprecatedType.AFTER_BAILOUT);\n    }\n\n    _reward -= _cutOffReward;\n    uint256 _maxRate = _stakingContract.maxCommissionRate();\n    uint256 _rate = Math.min(_candidateInfo[msg.sender].commissionRate, _maxRate);\n    uint256 _miningAmount = (_rate * _reward) / _MAX_PERCENTAGE;\n    _miningReward[msg.sender] += _miningAmount;\n\n    uint256 _delegatingAmount = _reward - _miningAmount;\n    _delegatingReward[msg.sender] += _delegatingAmount;\n  }\n\n  /**\n   * @inheritdoc ICoinbaseExecution\n   */\n  function wrapUpEpoch() external payable virtual override onlyCoinbase whenEpochEnding oncePerEpoch {\n    uint256 _newPeriod = _computePeriod(block.timestamp);\n    bool _periodEnding = _isPeriodEnding(_newPeriod);\n\n    (address[] memory _currentValidators, , ) = getValidators();\n    address[] memory _revokedCandidates;\n    uint256 _epoch = epochOf(block.number);\n    uint256 _nextEpoch = _epoch + 1;\n    uint256 _lastPeriod = currentPeriod();\n\n    if (_periodEnding) {\n      _syncBridgeOperatingReward(_lastPeriod, _currentValidators);\n      (\n        uint256 _totalDelegatingReward,\n        uint256[] memory _delegatingRewards\n      ) = _distributeRewardToTreasuriesAndCalculateTotalDelegatingReward(_lastPeriod, _currentValidators);\n      _settleAndTransferDelegatingRewards(_lastPeriod, _currentValidators, _totalDelegatingReward, _delegatingRewards);\n      _tryRecycleLockedFundsFromEmergencyExits();\n      _recycleDeprecatedRewards();\n      _slashIndicatorContract.updateCreditScores(_currentValidators, _lastPeriod);\n      (_currentValidators, _revokedCandidates) = _syncValidatorSet(_newPeriod);\n      if (_revokedCandidates.length > 0) {\n        _slashIndicatorContract.execResetCreditScores(_revokedCandidates);\n      }\n      _currentPeriodStartAtBlock = block.number + 1;\n    }\n    _revampRoles(_newPeriod, _nextEpoch, _currentValidators);\n    emit WrappedUpEpoch(_lastPeriod, _epoch, _periodEnding);\n    _periodOf[_nextEpoch] = _newPeriod;\n    _lastUpdatedPeriod = _newPeriod;\n  }\n\n  /**\n   * @dev This loop over the all current validators to sync the bridge operating reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _syncBridgeOperatingReward(uint256 _lastPeriod, address[] memory _currentValidators) internal {\n    uint256 _totalBridgeBallots = _bridgeTrackingContract.totalBallots(_lastPeriod);\n    uint256 _totalBridgeVotes = _bridgeTrackingContract.totalVotes(_lastPeriod);\n    uint256[] memory _bridgeBallots = _bridgeTrackingContract.getManyTotalBallots(\n      _lastPeriod,\n      getBridgeOperatorsOf(_currentValidators)\n    );\n\n    if (\n      !_validateBridgeTrackingResponse(_totalBridgeBallots, _totalBridgeVotes, _bridgeBallots) || _totalBridgeVotes == 0\n    ) {\n      // Shares equally in case the bridge has nothing to vote or bridge tracking response is incorrect\n      for (uint256 _i; _i < _currentValidators.length; _i++) {\n        _bridgeOperatingReward[_currentValidators[_i]] = _totalBridgeReward / _currentValidators.length;\n      }\n      return;\n    }\n\n    (\n      uint256 _missingVotesRatioTier1,\n      uint256 _missingVotesRatioTier2,\n      uint256 _jailDurationForMissingVotesRatioTier2,\n      uint256 _skipBridgeOperatorSlashingThreshold\n    ) = _slashIndicatorContract.getBridgeOperatorSlashingConfigs();\n\n    // Slashes the bridge reward if the total of votes exceeds the slashing threshold.\n    bool _shouldSlash = _totalBridgeVotes > _skipBridgeOperatorSlashingThreshold;\n    for (uint256 _i; _i < _currentValidators.length; _i++) {\n      // Shares the bridge operators reward proportionally.\n      _bridgeOperatingReward[_currentValidators[_i]] = (_totalBridgeReward * _bridgeBallots[_i]) / _totalBridgeBallots;\n      if (_shouldSlash) {\n        _slashBridgeOperatorBasedOnPerformance(\n          _lastPeriod,\n          _currentValidators[_i],\n          _MAX_PERCENTAGE - (_bridgeBallots[_i] * _MAX_PERCENTAGE) / _totalBridgeVotes,\n          _jailDurationForMissingVotesRatioTier2,\n          _missingVotesRatioTier1,\n          _missingVotesRatioTier2\n        );\n      }\n    }\n  }\n\n  /**\n   * @dev Returns whether the responses from bridge tracking are correct.\n   */\n  function _validateBridgeTrackingResponse(\n    uint256 _totalBridgeBallots,\n    uint256 _totalBridgeVotes,\n    uint256[] memory _bridgeBallots\n  ) private returns (bool _valid) {\n    _valid = true;\n    uint256 _sumBallots;\n    for (uint _i; _i < _bridgeBallots.length; _i++) {\n      if (_bridgeBallots[_i] > _totalBridgeVotes) {\n        _valid = false;\n        break;\n      }\n      _sumBallots += _bridgeBallots[_i];\n    }\n    _valid = _valid && (_sumBallots <= _totalBridgeBallots);\n    if (!_valid) {\n      emit BridgeTrackingIncorrectlyResponded();\n    }\n  }\n\n  /**\n   * @dev Slashes the validator on the corresponding bridge operator performance. Updates the status of the deprecated reward. Not update the reward amount.\n   *\n   * Consider validating the bridge tracking response by using the method `_validateBridgeTrackingResponse` before calling this function.\n   */\n  function _slashBridgeOperatorBasedOnPerformance(\n    uint256 _period,\n    address _validator,\n    uint256 _missedRatio,\n    uint256 _jailDurationTier2,\n    uint256 _ratioTier1,\n    uint256 _ratioTier2\n  ) internal {\n    if (_missedRatio >= _ratioTier2) {\n      _bridgeRewardDeprecatedAtPeriod[_validator][_period] = true;\n      _miningRewardDeprecatedAtPeriod[_validator][_period] = true;\n\n      // Cannot saving gas by temp variable here due to too deep stack.\n      _blockProducerJailedBlock[_validator] = Math.max(\n        block.number + _jailDurationTier2,\n        _blockProducerJailedBlock[_validator]\n      );\n      _cannotBailoutUntilBlock[_validator] = Math.max(\n        block.number + _jailDurationTier2,\n        _cannotBailoutUntilBlock[_validator]\n      );\n\n      _slashIndicatorContract.execSlashBridgeOperator(_validator, 2, _period);\n      emit ValidatorPunished(_validator, _period, _blockProducerJailedBlock[_validator], 0, true, true);\n    } else if (_missedRatio >= _ratioTier1) {\n      _bridgeRewardDeprecatedAtPeriod[_validator][_period] = true;\n      _slashIndicatorContract.execSlashBridgeOperator(_validator, 1, _period);\n      emit ValidatorPunished(_validator, _period, _blockProducerJailedBlock[_validator], 0, false, true);\n    }\n  }\n\n  /**\n   * @dev This loops over all current validators to:\n   * - Update delegating reward for and calculate total delegating rewards to be sent to the staking contract,\n   * - Distribute the reward of block producers and bridge operators to their treasury addresses,\n   * - Update the total deprecated reward if the two previous conditions do not sastify.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _distributeRewardToTreasuriesAndCalculateTotalDelegatingReward(\n    uint256 _lastPeriod,\n    address[] memory _currentValidators\n  ) private returns (uint256 _totalDelegatingReward, uint256[] memory _delegatingRewards) {\n    address _consensusAddr;\n    address payable _treasury;\n    _delegatingRewards = new uint256[](_currentValidators.length);\n    for (uint _i; _i < _currentValidators.length; _i++) {\n      _consensusAddr = _currentValidators[_i];\n      _treasury = _candidateInfo[_consensusAddr].treasuryAddr;\n\n      if (!_bridgeRewardDeprecated(_consensusAddr, _lastPeriod)) {\n        _distributeBridgeOperatingReward(_consensusAddr, _candidateInfo[_consensusAddr].bridgeOperatorAddr, _treasury);\n      } else {\n        _totalDeprecatedReward += _bridgeOperatingReward[_consensusAddr];\n      }\n\n      if (!_jailed(_consensusAddr) && !_miningRewardDeprecated(_consensusAddr, _lastPeriod)) {\n        _totalDelegatingReward += _delegatingReward[_consensusAddr];\n        _delegatingRewards[_i] = _delegatingReward[_consensusAddr];\n        _distributeMiningReward(_consensusAddr, _treasury);\n      } else {\n        _totalDeprecatedReward += _miningReward[_consensusAddr] + _delegatingReward[_consensusAddr];\n      }\n\n      delete _delegatingReward[_consensusAddr];\n      delete _miningReward[_consensusAddr];\n      delete _bridgeOperatingReward[_consensusAddr];\n    }\n    delete _totalBridgeReward;\n  }\n\n  /**\n   * @dev Distributes bonus of staking vesting and mining fee for the block producer.\n   *\n   * Emits the `MiningRewardDistributed` once the reward is distributed successfully.\n   * Emits the `MiningRewardDistributionFailed` once the contract fails to distribute reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _distributeMiningReward(address _consensusAddr, address payable _treasury) private {\n    uint256 _amount = _miningReward[_consensusAddr];\n    if (_amount > 0) {\n      if (_unsafeSendRON(_treasury, _amount, DEFAULT_ADDITION_GAS)) {\n        emit MiningRewardDistributed(_consensusAddr, _treasury, _amount);\n        return;\n      }\n\n      emit MiningRewardDistributionFailed(_consensusAddr, _treasury, _amount, address(this).balance);\n    }\n  }\n\n  /**\n   * @dev Distribute bonus of staking vesting for the bridge operator.\n   *\n   * Emits the `BridgeOperatorRewardDistributed` once the reward is distributed successfully.\n   * Emits the `BridgeOperatorRewardDistributionFailed` once the contract fails to distribute reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _distributeBridgeOperatingReward(\n    address _consensusAddr,\n    address _bridgeOperator,\n    address payable _treasury\n  ) private {\n    uint256 _amount = _bridgeOperatingReward[_consensusAddr];\n    if (_amount > 0) {\n      if (_unsafeSendRON(_treasury, _amount, DEFAULT_ADDITION_GAS)) {\n        emit BridgeOperatorRewardDistributed(_consensusAddr, _bridgeOperator, _treasury, _amount);\n        return;\n      }\n\n      emit BridgeOperatorRewardDistributionFailed(\n        _consensusAddr,\n        _bridgeOperator,\n        _treasury,\n        _amount,\n        address(this).balance\n      );\n    }\n  }\n\n  /**\n   * @dev Helper function to settle rewards for delegators of `_currentValidators` at the end of each period,\n   * then transfer the rewards from this contract to the staking contract, in order to finalize a period.\n   *\n   * Emits the `StakingRewardDistributed` once the reward is distributed successfully.\n   * Emits the `StakingRewardDistributionFailed` once the contract fails to distribute reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _settleAndTransferDelegatingRewards(\n    uint256 _period,\n    address[] memory _currentValidators,\n    uint256 _totalDelegatingReward,\n    uint256[] memory _delegatingRewards\n  ) private {\n    IStaking _staking = _stakingContract;\n    if (_totalDelegatingReward > 0) {\n      if (_unsafeSendRON(payable(address(_staking)), _totalDelegatingReward)) {\n        _staking.execRecordRewards(_currentValidators, _delegatingRewards, _period);\n        emit StakingRewardDistributed(_totalDelegatingReward, _currentValidators, _delegatingRewards);\n        return;\n      }\n\n      emit StakingRewardDistributionFailed(\n        _totalDelegatingReward,\n        _currentValidators,\n        _delegatingRewards,\n        address(this).balance\n      );\n    }\n  }\n\n  /**\n   * @dev Transfer the deprecated rewards e.g. the rewards that get deprecated when validator is slashed/maintained,\n   * to the staking vesting contract\n   *\n   * Note: This method should be called once in the end of each period.\n   */\n  function _recycleDeprecatedRewards() private {\n    uint256 _withdrawAmount = _totalDeprecatedReward;\n\n    if (_withdrawAmount != 0) {\n      address _withdrawTarget = stakingVestingContract();\n\n      delete _totalDeprecatedReward;\n\n      (bool _success, ) = _withdrawTarget.call{ value: _withdrawAmount }(\n        abi.encodeWithSelector(IStakingVesting.receiveRON.selector)\n      );\n\n      if (_success) {\n        emit DeprecatedRewardRecycled(_withdrawTarget, _withdrawAmount);\n      } else {\n        emit DeprecatedRewardRecycleFailed(_withdrawTarget, _withdrawAmount, address(this).balance);\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the validator set based on the validator candidates from the Staking contract.\n   *\n   * Emits the `ValidatorSetUpdated` event.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _syncValidatorSet(uint256 _newPeriod)\n    private\n    returns (address[] memory _newValidators, address[] memory _unsastifiedCandidates)\n  {\n    _unsastifiedCandidates = _syncCandidateSet(_newPeriod);\n    uint256[] memory _weights = _stakingContract.getManyStakingTotals(_candidates);\n    uint256[] memory _trustedWeights = _roninTrustedOrganizationContract.getConsensusWeights(_candidates);\n    uint256 _newValidatorCount;\n    (_newValidators, _newValidatorCount) = _pcPickValidatorSet(\n      _candidates,\n      _weights,\n      _trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n    _setNewValidatorSet(_newValidators, _newValidatorCount, _newPeriod);\n  }\n\n  /**\n   * @dev Private helper function helps writing the new validator set into the contract storage.\n   *\n   * Emits the `ValidatorSetUpdated` event.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _setNewValidatorSet(\n    address[] memory _newValidators,\n    uint256 _newValidatorCount,\n    uint256 _newPeriod\n  ) private {\n    // Remove exceeding validators in the current set\n    for (uint256 _i = _newValidatorCount; _i < validatorCount; _i++) {\n      delete _validatorMap[_validators[_i]];\n      delete _validators[_i];\n    }\n\n    // Remove flag for all validator in the current set\n    for (uint _i; _i < _newValidatorCount; _i++) {\n      delete _validatorMap[_validators[_i]];\n    }\n\n    // Update new validator set and set flag correspondingly.\n    for (uint256 _i; _i < _newValidatorCount; _i++) {\n      address _newValidator = _newValidators[_i];\n      _validatorMap[_newValidator] = EnumFlags.ValidatorFlag.Both;\n      _validators[_i] = _newValidator;\n    }\n\n    validatorCount = _newValidatorCount;\n    emit ValidatorSetUpdated(_newPeriod, _newValidators);\n  }\n\n  /**\n   * @dev Activate/Deactivate the validators from producing blocks, based on their in jail status and maintenance status.\n   *\n   * Requirements:\n   * - This method is called at the end of each epoch\n   *\n   * Emits the `BlockProducerSetUpdated` event.\n   * Emits the `BridgeOperatorSetUpdated` event.\n   *\n   */\n  function _revampRoles(\n    uint256 _newPeriod,\n    uint256 _nextEpoch,\n    address[] memory _currentValidators\n  ) private {\n    bool[] memory _maintainedList = _maintenanceContract.checkManyMaintained(_currentValidators, block.number + 1);\n\n    for (uint _i; _i < _currentValidators.length; _i++) {\n      address _validator = _currentValidators[_i];\n      bool _emergencyExitRequested = block.timestamp <= _emergencyExitJailedTimestamp[_validator];\n      bool _isProducerBefore = isBlockProducer(_validator);\n      bool _isProducerAfter = !(_jailed(_validator) || _maintainedList[_i] || _emergencyExitRequested);\n\n      if (!_isProducerBefore && _isProducerAfter) {\n        _validatorMap[_validator] = _validatorMap[_validator].addFlag(EnumFlags.ValidatorFlag.BlockProducer);\n      } else if (_isProducerBefore && !_isProducerAfter) {\n        _validatorMap[_validator] = _validatorMap[_validator].removeFlag(EnumFlags.ValidatorFlag.BlockProducer);\n      }\n\n      bool _isBridgeOperatorBefore = isOperatingBridge(_validator);\n      bool _isBridgeOperatorAfter = !_emergencyExitRequested;\n      if (!_isBridgeOperatorBefore && _isBridgeOperatorAfter) {\n        _validatorMap[_validator] = _validatorMap[_validator].addFlag(EnumFlags.ValidatorFlag.BridgeOperator);\n      } else if (_isBridgeOperatorBefore && !_isBridgeOperatorAfter) {\n        _validatorMap[_validator] = _validatorMap[_validator].removeFlag(EnumFlags.ValidatorFlag.BridgeOperator);\n      }\n    }\n\n    emit BlockProducerSetUpdated(_newPeriod, _nextEpoch, getBlockProducers());\n    emit BridgeOperatorSetUpdated(_newPeriod, _nextEpoch, getBridgeOperators());\n  }\n\n  /**\n   * @dev Override `CandidateManager-_isTrustedOrg`.\n   */\n  function _isTrustedOrg(address _consensusAddr) internal view override returns (bool) {\n    return _roninTrustedOrganizationContract.getConsensusWeight(_consensusAddr) > 0;\n  }\n}\n"
    },
    "contracts/extensions/collections/HasMaintenanceContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasMaintenanceContract.sol\";\nimport \"../../interfaces/IMaintenance.sol\";\n\ncontract HasMaintenanceContract is IHasMaintenanceContract, HasProxyAdmin {\n  IMaintenance internal _maintenanceContract;\n\n  modifier onlyMaintenanceContract() {\n    if (maintenanceContract() != msg.sender) revert ErrCallerMustBeMaintenanceContract();\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasMaintenanceContract\n   */\n  function maintenanceContract() public view override returns (address) {\n    return address(_maintenanceContract);\n  }\n\n  /**\n   * @inheritdoc IHasMaintenanceContract\n   */\n  function setMaintenanceContract(address _addr) external override onlyAdmin {\n    if (_addr.code.length == 0) revert ErrZeroCodeContract();\n    _setMaintenanceContract(_addr);\n  }\n\n  /**\n   * @dev Sets the scheduled maintenance contract.\n   *\n   * Emits the event `MaintenanceContractUpdated`.\n   *\n   */\n  function _setMaintenanceContract(address _addr) internal {\n    _maintenanceContract = IMaintenance(_addr);\n    emit MaintenanceContractUpdated(_addr);\n  }\n}\n"
    },
    "contracts/extensions/collections/HasSlashIndicatorContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasSlashIndicatorContract.sol\";\nimport \"../../interfaces/slash-indicator/ISlashIndicator.sol\";\n\ncontract HasSlashIndicatorContract is IHasSlashIndicatorContract, HasProxyAdmin {\n  ISlashIndicator internal _slashIndicatorContract;\n\n  modifier onlySlashIndicatorContract() {\n    if (slashIndicatorContract() != msg.sender) revert ErrCallerMustBeSlashIndicatorContract();\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasSlashIndicatorContract\n   */\n  function slashIndicatorContract() public view override returns (address) {\n    return address(_slashIndicatorContract);\n  }\n\n  /**\n   * @inheritdoc IHasSlashIndicatorContract\n   */\n  function setSlashIndicatorContract(address _addr) external override onlyAdmin {\n    if (_addr.code.length == 0) revert ErrZeroCodeContract();\n    _setSlashIndicatorContract(_addr);\n  }\n\n  /**\n   * @dev Sets the slash indicator contract.\n   *\n   * Emits the event `SlashIndicatorContractUpdated`.\n   *\n   */\n  function _setSlashIndicatorContract(address _addr) internal {\n    _slashIndicatorContract = ISlashIndicator(_addr);\n    emit SlashIndicatorContractUpdated(_addr);\n  }\n}\n"
    },
    "contracts/extensions/collections/HasStakingVestingContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasStakingVestingContract.sol\";\nimport \"../../interfaces/IStakingVesting.sol\";\n\ncontract HasStakingVestingContract is IHasStakingVestingContract, HasProxyAdmin {\n  IStakingVesting internal _stakingVestingContract;\n\n  modifier onlyStakingVestingContract() {\n    if (stakingVestingContract() != msg.sender) revert ErrCallerMustBeStakingVestingContract();\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasStakingVestingContract\n   */\n  function stakingVestingContract() public view override returns (address) {\n    return address(_stakingVestingContract);\n  }\n\n  /**\n   * @inheritdoc IHasStakingVestingContract\n   */\n  function setStakingVestingContract(address _addr) external override onlyAdmin {\n    if (_addr.code.length == 0) revert ErrZeroCodeContract();\n    _setStakingVestingContract(_addr);\n  }\n\n  /**\n   * @dev Sets the staking vesting contract.\n   *\n   * Emits the event `StakingVestingContractUpdated`.\n   *\n   */\n  function _setStakingVestingContract(address _addr) internal {\n    _stakingVestingContract = IStakingVesting(_addr);\n    emit StakingVestingContractUpdated(_addr);\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUSortValidators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUSortValidators is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of sorting validators\n  function precompileSortValidatorsAddress() public view virtual returns (address) {\n    return address(0x66);\n  }\n\n  /**\n   * @dev Sorts candidates descending by their weights by calling precompile contract.\n   *\n   * Note: This function is marked as virtual for being wrapping in mock contract for testing purpose.\n   */\n  function _pcSortCandidates(address[] memory _candidates, uint256[] memory _weights)\n    internal\n    view\n    virtual\n    returns (address[] memory _result)\n  {\n    address _smc = precompileSortValidatorsAddress();\n    bool _success = true;\n\n    bytes memory _payload = abi.encodeWithSignature(\"sortValidators(address[],uint256[])\", _candidates, _weights);\n    uint256 _payloadLength = _payload.length;\n    uint256 _resultLength = 0x20 * _candidates.length + 0x40;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _result, _resultLength)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n\n      _result := add(_result, 0x20)\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUPickValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUPickValidatorSet is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of picking validator set\n  function precompilePickValidatorSetAddress() public view virtual returns (address) {\n    return address(0x68);\n  }\n\n  /**\n   * @dev Sorts and arranges to return a new validator set.\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcPickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) internal view virtual returns (address[] memory _result, uint256 _newValidatorCount) {\n    address _smc = precompilePickValidatorSetAddress();\n    bytes memory _payload = abi.encodeWithSignature(\n      \"pickValidatorSet(address[],uint256[],uint256[],uint256,uint256)\",\n      _candidates,\n      _weights,\n      _trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n    bool _success = true;\n\n    uint256 _payloadLength = _payload.length;\n    uint256 _resultLength = 0x20 * _candidates.length + 0x40;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _result, _resultLength)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n\n      _result := add(_result, 0x20)\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n\n    _newValidatorCount = _result.length;\n  }\n}\n"
    },
    "contracts/interfaces/collections/IHasMaintenanceContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IHasContract.sol\";\n\ninterface IHasMaintenanceContract is IHasContract {\n  /// @dev Emitted when the maintenance contract is updated.\n  event MaintenanceContractUpdated(address);\n\n  /// @dev Error of method caller must be maintenance contract.\n  error ErrCallerMustBeMaintenanceContract();\n\n  /**\n   * @dev Returns the maintenance contract.\n   */\n  function maintenanceContract() external view returns (address);\n\n  /**\n   * @dev Sets the maintenance contract.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The new address is a contract.\n   *\n   * Emits the event `MaintenanceContractUpdated`.\n   *\n   */\n  function setMaintenanceContract(address) external;\n}\n"
    },
    "contracts/interfaces/collections/IHasSlashIndicatorContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IHasContract.sol\";\n\ninterface IHasSlashIndicatorContract is IHasContract {\n  /// @dev Emitted when the slash indicator contract is updated.\n  event SlashIndicatorContractUpdated(address);\n\n  /// @dev Error of method caller must be slash indicator contract.\n  error ErrCallerMustBeSlashIndicatorContract();\n\n  /**\n   * @dev Returns the slash indicator contract.\n   */\n  function slashIndicatorContract() external view returns (address);\n\n  /**\n   * @dev Sets the slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The new address is a contract.\n   *\n   * Emits the event `SlashIndicatorContractUpdated`.\n   *\n   */\n  function setSlashIndicatorContract(address) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashIndicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashDoubleSign.sol\";\nimport \"./ISlashBridgeVoting.sol\";\nimport \"./ISlashBridgeOperator.sol\";\nimport \"./ISlashUnavailability.sol\";\nimport \"./ICreditScore.sol\";\n\ninterface ISlashIndicator is\n  ISlashDoubleSign,\n  ISlashBridgeVoting,\n  ISlashBridgeOperator,\n  ISlashUnavailability,\n  ICreditScore\n{}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashDoubleSign is IBaseSlash {\n  /**\n   * @dev Emitted when the configs to slash double sign is updated. See the method `getDoubleSignSlashingConfigs`\n   * for param details.\n   */\n  event DoubleSignSlashingConfigsUpdated(\n    uint256 slashDoubleSignAmount,\n    uint256 doubleSigningJailUntilBlock,\n    uint256 doubleSigningOffsetLimitBlock\n  );\n\n  /**\n   * @dev Slashes for double signing.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` if the double signing evidence of the two headers valid.\n   */\n  function slashDoubleSign(\n    address _validatorAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) external;\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return _slashDoubleSignAmount The amount of RON to slash double sign.\n   * @return _doubleSigningJailUntilBlock The block number that the punished validator will be jailed until, due to\n   * double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function getDoubleSignSlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _slashDoubleSignAmount,\n      uint256 _doubleSigningJailUntilBlock,\n      uint256 _doubleSigningOffsetLimitBlock\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `DoubleSignSlashingConfigsUpdated`.\n   *\n   * @param _slashAmount The amount of RON to slash double sign.\n   * @param _jailUntilBlock The block number that the punished validator will be jailed until, due to double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _doubleSigningOffsetLimitBlock\n  ) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashBridgeVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashBridgeVoting is IBaseSlash {\n  /**\n   * @dev Emitted when the configs to slash bridge voting is updated. See the method `getBridgeVotingSlashingConfigs` for param\n   * details.\n   */\n  event BridgeVotingSlashingConfigsUpdated(uint256 bridgeVotingThreshold, uint256 bridgeVotingSlashAmount);\n\n  /**\n   * @dev Slashes for bridge voter governance.\n   *\n   * Emits the event `Slashed`.\n   */\n  function slashBridgeVoting(address _consensusAddr) external;\n\n  /**\n   * @dev Returns the configs related to bridge voting slashing.\n   *\n   * @return _bridgeVotingThreshold The threshold to slash when a trusted organization does not vote for bridge\n   * operators.\n   * @return _bridgeVotingSlashAmount The amount of RON to slash bridge voting.\n   *\n   */\n  function getBridgeVotingSlashingConfigs()\n    external\n    view\n    returns (uint256 _bridgeVotingThreshold, uint256 _bridgeVotingSlashAmount);\n\n  /**\n   * @dev Sets the configs to slash bridge voting.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeVotingSlashingConfigsUpdated`.\n   *\n   * @param _threshold The threshold to slash when a trusted organization does not vote for bridge operators.\n   * @param _slashAmount The amount of RON to slash bridge voting.\n   *\n   */\n  function setBridgeVotingSlashingConfigs(uint256 _threshold, uint256 _slashAmount) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashBridgeOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashBridgeOperator is IBaseSlash {\n  /**\n   * @dev Emitted when the configs to slash bridge operator is updated. See the method\n   * `getBridgeOperatorSlashingConfigs` for param details.\n   */\n  event BridgeOperatorSlashingConfigsUpdated(\n    uint256 missingVotesRatioTier1,\n    uint256 missingVotesRatioTier2,\n    uint256 jailDurationForMissingVotesRatioTier2,\n    uint256 skipBridgeOperatorSlashingThreshold\n  );\n\n  /**\n   * @dev Acknowledges bridge operator slash and emit `Slashed` event correspondingly.\n   * @param _tier The tier of the slash, in value of {1, 2}, corresponding to `SlashType.BRIDGE_OPERATOR_MISSING_VOTE_TIER_1`\n   * and `SlashType.BRIDGE_OPERATOR_MISSING_VOTE_TIER_2`\n   *\n   * Requirements:\n   * - Only validator contract can invoke this method.\n   * - Should be called only at the end of period.\n   * - Should be called only when there is slash of bridge operator.\n   *\n   * Emits the event `Slashed`.\n   */\n  function execSlashBridgeOperator(\n    address _consensusAddr,\n    uint256 _tier,\n    uint256 _period\n  ) external;\n\n  /**\n   * @dev Returns the configs related to bridge operator slashing.\n   *\n   * @return _missingVotesRatioTier1 The bridge reward will be deprecated if (s)he missed more than this ratio.\n   * @return _missingVotesRatioTier2 The bridge reward and mining reward will be deprecated and the corresponding\n   * block producer will be put in jail if (s)he misses more than this ratio.\n   * @return _jailDurationForMissingVotesRatioTier2 The number of blocks to jail the corresponding block producer when\n   * its bridge operator is slashed tier-2.\n   * @return _skipBridgeOperatorSlashingThreshold The threshold to skip slashing the bridge operator in case the total\n   * number of votes in the bridge is too small.\n   *\n   */\n  function getBridgeOperatorSlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _missingVotesRatioTier1,\n      uint256 _missingVotesRatioTier2,\n      uint256 _jailDurationForMissingVotesRatioTier2,\n      uint256 _skipBridgeOperatorSlashingThreshold\n    );\n\n  /**\n   * @dev Sets the configs to slash bridge operators.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeOperatorSlashingConfigsUpdated`.\n   *\n   * @param _ratioTier1 The bridge reward will be deprecated if (s)he missed more than this ratio. Values 0-10,000 map\n   * to 0%-100%.\n   * @param _ratioTier2 The bridge reward and mining reward will be deprecated and the corresponding block producer will\n   * be put in jail if (s)he misses more than this ratio. Values 0-10,000 map to 0%-100%.\n   * @param _jailDurationTier2 The number of blocks to jail the corresponding block producer when its bridge operator is\n   * slashed tier-2.\n   * @param _skipSlashingThreshold The threshold to skip slashing the bridge operator in case the total number of votes\n   * in the bridge is too small.\n   *\n   */\n  function setBridgeOperatorSlashingConfigs(\n    uint256 _ratioTier1,\n    uint256 _ratioTier2,\n    uint256 _jailDurationTier2,\n    uint256 _skipSlashingThreshold\n  ) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashUnavailability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashUnavailability is IBaseSlash {\n  /**\n   * @dev Emitted when the configs to slash bridge operator is updated. See the method `getUnavailabilitySlashingConfigs`\n   * for param details.\n   */\n  event UnavailabilitySlashingConfigsUpdated(\n    uint256 unavailabilityTier1Threshold,\n    uint256 unavailabilityTier2Threshold,\n    uint256 slashAmountForUnavailabilityTier2Threshold,\n    uint256 jailDurationForUnavailabilityTier2Threshold\n  );\n\n  /**\n   * @dev Returns the last block that a block producer is slashed for unavailability.\n   */\n  function lastUnavailabilitySlashedBlock() external view returns (uint256);\n\n  /**\n   * @dev Slashes for unavailability by increasing the counter of block producer `_consensusAddr`.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` when the threshold is reached.\n   *\n   */\n  function slashUnavailability(address _consensusAddr) external;\n\n  /**\n   * @dev Returns the current unavailability indicator of a block producer.\n   */\n  function currentUnavailabilityIndicator(address _validator) external view returns (uint256);\n\n  /**\n   * @dev Returns the unavailability indicator in the period `_period` of a block producer.\n   */\n  function getUnavailabilityIndicator(address _validator, uint256 _period) external view returns (uint256);\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return _unavailabilityTier1Threshold The mining reward will be deprecated, if (s)he missed more than this\n   * threshold. This threshold is applied for tier-1 and tier-3 slash.\n   * @return _unavailabilityTier2Threshold  The mining reward will be deprecated, (s)he will be put in jailed, and will\n   * be deducted self-staking if (s)he misses more than this threshold. This threshold is applied for tier-2 slash.\n   * @return _slashAmountForUnavailabilityTier2Threshold The amount of RON to deduct from self-staking of a block\n   * producer when (s)he is slashed with tier-2 or tier-3.\n   * @return _jailDurationForUnavailabilityTier2Threshold The number of blocks to jail a block producer when (s)he is\n   * slashed with tier-2 or tier-3.\n   *\n   */\n  function getUnavailabilitySlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _unavailabilityTier1Threshold,\n      uint256 _unavailabilityTier2Threshold,\n      uint256 _slashAmountForUnavailabilityTier2Threshold,\n      uint256 _jailDurationForUnavailabilityTier2Threshold\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeOperatorSlashingConfigsUpdated`.\n   *\n   * @param _tier1Threshold The mining reward will be deprecated, if (s)he missed more than this threshold.\n   * @param _tier2Threshold The mining reward will be deprecated, (s)he will be put in jailed, and will be deducted\n   * self-staking if (s)he misses more than this threshold.\n   * @param _slashAmountForTier2Threshold The amount of RON to deduct from self-staking of a block producer when (s)he\n   * is slashed tier-2.\n   * @param _jailDurationForTier2Threshold The number of blocks to jail a block producer when (s)he is slashed tier-2.\n   *\n   */\n  function setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ICreditScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ICreditScore {\n  /// @dev Emitted when the configs to credit score is updated. See the method `setCreditScoreConfigs` for param details.\n  event CreditScoreConfigsUpdated(\n    uint256 gainCreditScore,\n    uint256 maxCreditScore,\n    uint256 bailOutCostMultiplier,\n    uint256 cutOffPercentageAfterBailout\n  );\n  /// @dev Emitted the credit score of validators is updated.\n  event CreditScoresUpdated(address[] validators, uint256[] creditScores);\n  /// @dev Emitted when a validator bailed out of jail.\n  event BailedOut(address indexed validator, uint256 period, uint256 usedCreditScore);\n\n  /**\n   * @dev Updates the credit score for the validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function updateCreditScores(address[] calldata _validators, uint256 _period) external;\n\n  /**\n   * @dev Resets the credit score for the revoked validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function execResetCreditScores(address[] calldata _validators) external;\n\n  /**\n   * @dev A slashed validator use this method to get out of jail.\n   *\n   * Requirements:\n   * - The `_consensusAddr` must be a validator.\n   * - Only validator's admin can call this method.\n   *\n   * Emits the event `BailedOut`.\n   *\n   */\n  function bailOut(address _consensusAddr) external;\n\n  /**\n   * @dev Sets the configs to credit score.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CreditScoreConfigsUpdated`.\n   *\n   * @param _gainScore The score to gain per period.\n   * @param _maxScore The max number of credit score that a validator can hold.\n   * @param _bailOutMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @param _cutOffPercentage The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) external;\n\n  /**\n   * @dev Returns the configs related to credit score.\n   *\n   * @return _gainCreditScore The score to gain per period.\n   * @return _maxCreditScore The max number of credit score that a validator can hold.\n   * @return _bailOutCostMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @return _cutOffPercentageAfterBailout The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function getCreditScoreConfigs()\n    external\n    view\n    returns (\n      uint256 _gainCreditScore,\n      uint256 _maxCreditScore,\n      uint256 _bailOutCostMultiplier,\n      uint256 _cutOffPercentageAfterBailout\n    );\n\n  /**\n   * @dev Returns the current credit score of the validator.\n   */\n  function getCreditScore(address _validator) external view returns (uint256);\n\n  /**\n   * @dev Returns the current credit score of a list of validators.\n   */\n  function getManyCreditScores(address[] calldata _validators) external view returns (uint256[] memory _resultList);\n\n  /**\n   * @dev Returns the whether the `_validator` has been bailed out at the `_period`.\n   */\n  function checkBailedOutAtPeriod(address _validator, uint256 _period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/slash-indicator/IBaseSlash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IBaseSlash {\n  enum SlashType {\n    UNKNOWN,\n    UNAVAILABILITY_TIER_1,\n    UNAVAILABILITY_TIER_2,\n    DOUBLE_SIGNING,\n    BRIDGE_VOTING,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_1,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_2,\n    UNAVAILABILITY_TIER_3\n  }\n\n  /// @dev Emitted when the validator is slashed.\n  event Slashed(address indexed validator, SlashType slashType, uint256 period);\n}\n"
    },
    "contracts/interfaces/collections/IHasStakingVestingContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IHasContract.sol\";\n\ninterface IHasStakingVestingContract is IHasContract {\n  /// @dev Emitted when the staking vesting contract is updated.\n  event StakingVestingContractUpdated(address);\n\n  /// @dev Error of method caller must be staking vesting contract.\n  error ErrCallerMustBeStakingVestingContract();\n\n  /**\n   * @dev Returns the staking vesting contract.\n   */\n  function stakingVestingContract() external view returns (address);\n\n  /**\n   * @dev Sets the staking vesting contract.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The new address is a contract.\n   *\n   * Emits the event `StakingVestingContractUpdated`.\n   *\n   */\n  function setStakingVestingContract(address) external;\n}\n"
    },
    "contracts/precompile-usages/PrecompiledUsage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PrecompiledUsage {\n  /// @dev Error of call to precompile fails.\n  error ErrCallPrecompiled();\n}\n"
    },
    "contracts/ronin/validator/SlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasSlashIndicatorContract.sol\";\nimport \"../../extensions/collections/HasStakingContract.sol\";\nimport \"../../interfaces/validator/ISlashingExecution.sol\";\nimport \"../../libraries/Math.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\n\nabstract contract SlashingExecution is\n  ISlashingExecution,\n  HasSlashIndicatorContract,\n  HasStakingContract,\n  CommonStorage\n{\n  /**\n   * @inheritdoc ISlashingExecution\n   */\n  function execSlash(\n    address _validatorAddr,\n    uint256 _newJailedUntil,\n    uint256 _slashAmount,\n    bool _cannotBailout\n  ) external override onlySlashIndicatorContract {\n    uint256 _period = currentPeriod();\n    _miningRewardDeprecatedAtPeriod[_validatorAddr][_period] = true;\n\n    _totalDeprecatedReward += _miningReward[_validatorAddr] + _delegatingReward[_validatorAddr];\n\n    delete _miningReward[_validatorAddr];\n    delete _delegatingReward[_validatorAddr];\n\n    _blockProducerJailedBlock[_validatorAddr] = Math.max(_newJailedUntil, _blockProducerJailedBlock[_validatorAddr]);\n\n    if (_slashAmount > 0) {\n      uint256 _actualAmount = _stakingContract.execDeductStakingAmount(_validatorAddr, _slashAmount);\n      _totalDeprecatedReward += _actualAmount;\n    }\n\n    if (_cannotBailout) {\n      _cannotBailoutUntilBlock[_validatorAddr] = Math.max(_newJailedUntil, _cannotBailoutUntilBlock[_validatorAddr]);\n    }\n\n    emit ValidatorPunished(\n      _validatorAddr,\n      _period,\n      _blockProducerJailedBlock[_validatorAddr],\n      _slashAmount,\n      true,\n      false\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashingExecution\n   */\n  function execBailOut(address _validatorAddr, uint256 _period) external override onlySlashIndicatorContract {\n    if (block.number <= _cannotBailoutUntilBlock[_validatorAddr]) revert ErrCannotBailout(_validatorAddr);\n\n    // Note: Removing rewards of validator in `bailOut` function is not needed, since the rewards have been\n    // removed previously in the `slash` function.\n    _miningRewardBailoutCutOffAtPeriod[_validatorAddr][_period] = true;\n    _miningRewardDeprecatedAtPeriod[_validatorAddr][_period] = false;\n    _blockProducerJailedBlock[_validatorAddr] = block.number - 1;\n\n    emit ValidatorUnjailed(_validatorAddr, _period);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashIndicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/slash-indicator/ISlashIndicator.sol\";\nimport \"./SlashDoubleSign.sol\";\nimport \"./SlashBridgeVoting.sol\";\nimport \"./SlashBridgeOperator.sol\";\nimport \"./SlashUnavailability.sol\";\nimport \"./CreditScore.sol\";\n\ncontract SlashIndicator is\n  ISlashIndicator,\n  SlashDoubleSign,\n  SlashBridgeVoting,\n  SlashBridgeOperator,\n  SlashUnavailability,\n  CreditScore,\n  Initializable\n{\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __validatorContract,\n    address __maintenanceContract,\n    address __roninTrustedOrganizationContract,\n    address __roninGovernanceAdminContract,\n    // _bridgeOperatorSlashingConfigs[0]: _missingVotesRatioTier1\n    // _bridgeOperatorSlashingConfigs[1]: _missingVotesRatioTier2\n    // _bridgeOperatorSlashingConfigs[2]: _jailDurationForMissingVotesRatioTier2\n    // _bridgeOperatorSlashingConfigs[3]: _skipBridgeOperatorSlashingThreshold\n    uint256[4] calldata _bridgeOperatorSlashingConfigs,\n    // _bridgeVotingSlashingConfigs[0]: _bridgeVotingThreshold\n    // _bridgeVotingSlashingConfigs[1]: _bridgeVotingSlashAmount\n    uint256[2] calldata _bridgeVotingSlashingConfigs,\n    // _doubleSignSlashingConfigs[0]: _slashDoubleSignAmount\n    // _doubleSignSlashingConfigs[1]: _doubleSigningJailUntilBlock\n    // _doubleSignSlashingConfigs[2]: _doubleSigningOffsetLimitBlock\n    uint256[3] calldata _doubleSignSlashingConfigs,\n    // _unavailabilitySlashingConfigs[0]: _unavailabilityTier1Threshold\n    // _unavailabilitySlashingConfigs[1]: _unavailabilityTier2Threshold\n    // _unavailabilitySlashingConfigs[2]: _slashAmountForUnavailabilityTier2Threshold\n    // _unavailabilitySlashingConfigs[3]: _jailDurationForUnavailabilityTier2Threshold\n    uint256[4] calldata _unavailabilitySlashingConfigs,\n    // _creditScoreConfigs[0]: _gainCreditScore\n    // _creditScoreConfigs[1]: _maxCreditScore\n    // _creditScoreConfigs[2]: _bailOutCostMultiplier\n    // _creditScoreConfigs[3]: _cutOffPercentageAfterBailout\n    uint256[4] calldata _creditScoreConfigs\n  ) external initializer {\n    _setValidatorContract(__validatorContract);\n    _setMaintenanceContract(__maintenanceContract);\n    _setRoninTrustedOrganizationContract(__roninTrustedOrganizationContract);\n    _setRoninGovernanceAdminContract(__roninGovernanceAdminContract);\n    _setBridgeOperatorSlashingConfigs(\n      _bridgeOperatorSlashingConfigs[0],\n      _bridgeOperatorSlashingConfigs[1],\n      _bridgeOperatorSlashingConfigs[2],\n      _bridgeOperatorSlashingConfigs[3]\n    );\n    _setBridgeVotingSlashingConfigs(_bridgeVotingSlashingConfigs[0], _bridgeVotingSlashingConfigs[1]);\n    _setDoubleSignSlashingConfigs(\n      _doubleSignSlashingConfigs[0],\n      _doubleSignSlashingConfigs[1],\n      _doubleSignSlashingConfigs[2]\n    );\n    _setUnavailabilitySlashingConfigs(\n      _unavailabilitySlashingConfigs[0],\n      _unavailabilitySlashingConfigs[1],\n      _unavailabilitySlashingConfigs[2],\n      _unavailabilitySlashingConfigs[3]\n    );\n    _setCreditScoreConfigs(\n      _creditScoreConfigs[0],\n      _creditScoreConfigs[1],\n      _creditScoreConfigs[2],\n      _creditScoreConfigs[3]\n    );\n  }\n\n  /**\n   * @dev Helper for CreditScore contract to reset the indicator of the validator after bailing out.\n   */\n  function _setUnavailabilityIndicator(\n    address _validator,\n    uint256 _period,\n    uint256 _indicator\n  ) internal override(CreditScore, SlashUnavailability) {\n    SlashUnavailability._setUnavailabilityIndicator(_validator, _period, _indicator);\n  }\n\n  /**\n   * @dev Helper for CreditScore contract to query indicator of the validator.\n   */\n  function getUnavailabilityIndicator(address _validator, uint256 _period)\n    public\n    view\n    override(CreditScore, ISlashUnavailability, SlashUnavailability)\n    returns (uint256)\n  {\n    return SlashUnavailability.getUnavailabilityIndicator(_validator, _period);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function checkBailedOutAtPeriod(address _validator, uint256 _period)\n    public\n    view\n    override(CreditScore, ICreditScore, SlashUnavailability)\n    returns (bool)\n  {\n    return CreditScore.checkBailedOutAtPeriod(_validator, _period);\n  }\n\n  /**\n   * @dev Sanity check the address to be slashed\n   */\n  function _shouldSlash(address _addr) internal view override(SlashDoubleSign, SlashUnavailability) returns (bool) {\n    return\n      (msg.sender != _addr) &&\n      _validatorContract.isBlockProducer(_addr) &&\n      !_maintenanceContract.checkMaintained(_addr, block.number);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/slash-indicator/ISlashDoubleSign.sol\";\nimport \"../../precompile-usages/PCUValidateDoubleSign.sol\";\nimport \"../../extensions/collections/HasValidatorContract.sol\";\n\nabstract contract SlashDoubleSign is ISlashDoubleSign, HasValidatorContract, PCUValidateDoubleSign {\n  /// @dev The amount of RON to slash double sign.\n  uint256 internal _slashDoubleSignAmount;\n  /// @dev The block number that the punished validator will be jailed until, due to double signing.\n  uint256 internal _doubleSigningJailUntilBlock;\n  /** @dev The offset from the submitted block to the current block, from which double signing will be invalidated.\n   * This parameter is exposed for system transaction.\n   **/\n  uint256 internal _doubleSigningOffsetLimitBlock;\n  /// @dev Recording of submitted proof to prevent relay attack.\n  mapping(bytes32 => bool) _submittedEvidence;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] private ______gap;\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function slashDoubleSign(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) external override onlyAdmin {\n    bytes32 _header1Checksum = keccak256(_header1);\n    bytes32 _header2Checksum = keccak256(_header2);\n\n    require(\n      !_submittedEvidence[_header1Checksum] && !_submittedEvidence[_header2Checksum],\n      \"SlashDoubleSign: evidence already submitted\"\n    );\n\n    if (_pcValidateEvidence(_consensusAddr, _header1, _header2)) {\n      uint256 _period = _validatorContract.currentPeriod();\n      _submittedEvidence[_header1Checksum] = true;\n      _submittedEvidence[_header2Checksum] = true;\n      emit Slashed(_consensusAddr, SlashType.DOUBLE_SIGNING, _period);\n      _validatorContract.execSlash(_consensusAddr, _doubleSigningJailUntilBlock, _slashDoubleSignAmount, true);\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function getDoubleSignSlashingConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 slashDoubleSignAmount_,\n      uint256 doubleSigningJailUntilBlock_,\n      uint256 doubleSigningOffsetLimitBlock_\n    )\n  {\n    return (_slashDoubleSignAmount, _doubleSigningJailUntilBlock, _doubleSigningOffsetLimitBlock);\n  }\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _offsetLimitBlock\n  ) external override onlyAdmin {\n    _setDoubleSignSlashingConfigs(_slashAmount, _jailUntilBlock, _offsetLimitBlock);\n  }\n\n  /**\n   * @dev See `ISlashDoubleSign-setDoubleSignSlashingConfigs`.\n   */\n  function _setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _offsetLimitBlock\n  ) internal {\n    _slashDoubleSignAmount = _slashAmount;\n    _doubleSigningJailUntilBlock = _jailUntilBlock;\n    _doubleSigningOffsetLimitBlock = _offsetLimitBlock;\n    emit DoubleSignSlashingConfigsUpdated(_slashAmount, _jailUntilBlock, _doubleSigningOffsetLimitBlock);\n  }\n\n  /**\n   * @dev Returns whether the account `_addr` should be slashed or not.\n   */\n  function _shouldSlash(address _addr) internal view virtual returns (bool);\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashBridgeVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../libraries/Math.sol\";\nimport \"../../interfaces/slash-indicator/ISlashBridgeVoting.sol\";\nimport \"../../extensions/collections/HasRoninTrustedOrganizationContract.sol\";\nimport \"../../extensions/collections/HasRoninGovernanceAdminContract.sol\";\nimport \"../../extensions/collections/HasValidatorContract.sol\";\n\nabstract contract SlashBridgeVoting is\n  ISlashBridgeVoting,\n  HasValidatorContract,\n  HasRoninTrustedOrganizationContract,\n  HasRoninGovernanceAdminContract\n{\n  /// @dev Mapping from validator address => period index => bridge voting slashed\n  mapping(address => mapping(uint256 => bool)) internal _bridgeVotingSlashed;\n  /// @dev The threshold to slash when a trusted organization does not vote for bridge operators.\n  uint256 internal _bridgeVotingThreshold;\n  /// @dev The amount of RON to slash bridge voting.\n  uint256 internal _bridgeVotingSlashAmount;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc ISlashBridgeVoting\n   */\n  function slashBridgeVoting(address _consensusAddr) external onlyAdmin {\n    IRoninTrustedOrganization.TrustedOrganization memory _org = _roninTrustedOrganizationContract\n      .getTrustedOrganization(_consensusAddr);\n    uint256 _lastVotedBlock = Math.max(_roninGovernanceAdminContract.lastVotedBlock(_org.bridgeVoter), _org.addedBlock);\n    uint256 _period = _validatorContract.currentPeriod();\n\n    require(\n      block.number - _lastVotedBlock > _bridgeVotingThreshold && !_bridgeVotingSlashed[_consensusAddr][_period],\n      \"SlashBridgeVoting: invalid slash\"\n    );\n\n    _bridgeVotingSlashed[_consensusAddr][_period] = true;\n    emit Slashed(_consensusAddr, SlashType.BRIDGE_VOTING, _period);\n    _validatorContract.execSlash(_consensusAddr, 0, _bridgeVotingSlashAmount, false);\n  }\n\n  /**\n   * @inheritdoc ISlashBridgeVoting\n   */\n  function getBridgeVotingSlashingConfigs()\n    external\n    view\n    override\n    returns (uint256 bridgeVotingThreshold_, uint256 bridgeVotingSlashAmount_)\n  {\n    return (_bridgeVotingThreshold, _bridgeVotingSlashAmount);\n  }\n\n  /**\n   * @inheritdoc ISlashBridgeVoting\n   */\n  function setBridgeVotingSlashingConfigs(uint256 _threshold, uint256 _slashAmount) external override onlyAdmin {\n    _setBridgeVotingSlashingConfigs(_threshold, _slashAmount);\n  }\n\n  /**\n   * @dev See `ISlashBridgeVoting-setBridgeVotingSlashingConfigs`.\n   */\n  function _setBridgeVotingSlashingConfigs(uint256 _threshold, uint256 _slashAmount) internal {\n    _bridgeVotingThreshold = _threshold;\n    _bridgeVotingSlashAmount = _slashAmount;\n    emit BridgeVotingSlashingConfigsUpdated(_threshold, _slashAmount);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashBridgeOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../extensions/collections/HasProxyAdmin.sol\";\nimport \"../../interfaces/slash-indicator/ISlashBridgeOperator.sol\";\nimport \"../../extensions/collections/HasValidatorContract.sol\";\n\nabstract contract SlashBridgeOperator is ISlashBridgeOperator, HasProxyAdmin, HasValidatorContract, PercentageConsumer {\n  /**\n   * @dev The bridge operators will be deprecated reward if (s)he missed more than the ratio.\n   * Values 0-10,000 map to 0%-100%.\n   */\n  uint256 internal _missingVotesRatioTier1;\n  /**\n   * @dev The bridge operators will be deprecated all rewards including bridge reward and mining reward if (s)he missed\n   * more than the ratio. Values 0-10,000 map to 0%-100%.\n   */\n  uint256 internal _missingVotesRatioTier2;\n  /// @dev The number of blocks to jail the corresponding block producer when its bridge operator is slashed tier-2.\n  uint256 internal _jailDurationForMissingVotesRatioTier2;\n  /// @dev The threshold to skip slashing the bridge operator in case the total number of votes in the bridge is too small.\n  uint256 internal _skipBridgeOperatorSlashingThreshold;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc ISlashBridgeOperator\n   */\n  function getBridgeOperatorSlashingConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 missingVotesRatioTier1_,\n      uint256 missingVotesRatioTier2_,\n      uint256 jailDurationForMissingVotesRatioTier2_,\n      uint256 skipBridgeOperatorSlashingThreshold_\n    )\n  {\n    return (\n      _missingVotesRatioTier1,\n      _missingVotesRatioTier2,\n      _jailDurationForMissingVotesRatioTier2,\n      _skipBridgeOperatorSlashingThreshold\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashBridgeOperator\n   */\n  function setBridgeOperatorSlashingConfigs(\n    uint256 _ratioTier1,\n    uint256 _ratioTier2,\n    uint256 _jailDurationTier2,\n    uint256 _skipSlashingThreshold\n  ) external override onlyAdmin {\n    _setBridgeOperatorSlashingConfigs(_ratioTier1, _ratioTier2, _jailDurationTier2, _skipSlashingThreshold);\n  }\n\n  /**\n   * @inheritdoc ISlashBridgeOperator\n   */\n  function execSlashBridgeOperator(\n    address _consensusAddr,\n    uint256 _tier,\n    uint256 _period\n  ) external onlyValidatorContract {\n    if (_tier == 1) {\n      emit Slashed(_consensusAddr, SlashType.BRIDGE_OPERATOR_MISSING_VOTE_TIER_1, _period);\n    } else if (_tier == 2) {\n      emit Slashed(_consensusAddr, SlashType.BRIDGE_OPERATOR_MISSING_VOTE_TIER_2, _period);\n    }\n  }\n\n  /**\n   * @dev See `ISlashBridgeOperator-setBridgeOperatorSlashingConfigs`.\n   */\n  function _setBridgeOperatorSlashingConfigs(\n    uint256 _ratioTier1,\n    uint256 _ratioTier2,\n    uint256 _jailDurationTier2,\n    uint256 _skipSlashingThreshold\n  ) internal {\n    require(\n      _ratioTier1 <= _ratioTier2 && _ratioTier1 <= _MAX_PERCENTAGE && _ratioTier2 <= _MAX_PERCENTAGE,\n      \"SlashIndicator: invalid ratios\"\n    );\n    _missingVotesRatioTier1 = _ratioTier1;\n    _missingVotesRatioTier2 = _ratioTier2;\n    _jailDurationForMissingVotesRatioTier2 = _jailDurationTier2;\n    _skipBridgeOperatorSlashingThreshold = _skipSlashingThreshold;\n    emit BridgeOperatorSlashingConfigsUpdated(_ratioTier1, _ratioTier2, _jailDurationTier2, _skipSlashingThreshold);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashUnavailability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./CreditScore.sol\";\nimport \"../../interfaces/slash-indicator/ISlashUnavailability.sol\";\nimport \"../../extensions/collections/HasValidatorContract.sol\";\n\nabstract contract SlashUnavailability is ISlashUnavailability, HasValidatorContract {\n  /// @dev The last block that a validator is slashed for unavailability.\n  uint256 public lastUnavailabilitySlashedBlock;\n  /// @dev Mapping from validator address => period index => unavailability indicator.\n  mapping(address => mapping(uint256 => uint256)) internal _unavailabilityIndicator;\n\n  /**\n   * @dev The mining reward will be deprecated, if (s)he missed more than this threshold.\n   * This threshold is applied for tier-1 and tier-3 of unavailability slash.\n   */\n  uint256 internal _unavailabilityTier1Threshold;\n  /**\n   * @dev The mining reward will be deprecated, (s)he will be put in jailed, and will be deducted\n   * self-staking if (s)he misses more than this threshold. This threshold is applied for tier-2 slash.\n   */\n  uint256 internal _unavailabilityTier2Threshold;\n  /**\n   * @dev The amount of RON to deduct from self-staking of a block producer when (s)he is slashed with\n   * tier-2 or tier-3.\n   **/\n  uint256 internal _slashAmountForUnavailabilityTier2Threshold;\n  /// @dev The number of blocks to jail a block producer when (s)he is slashed with tier-2 or tier-3.\n  uint256 internal _jailDurationForUnavailabilityTier2Threshold;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  modifier oncePerBlock() {\n    require(\n      block.number > lastUnavailabilitySlashedBlock,\n      \"SlashIndicator: cannot slash a validator twice or slash more than one validator in one block\"\n    );\n    lastUnavailabilitySlashedBlock = block.number;\n    _;\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function slashUnavailability(address _validatorAddr) external override oncePerBlock {\n    require(msg.sender == block.coinbase, \"SlashUnavailability: method caller must be coinbase\");\n    if (!_shouldSlash(_validatorAddr)) {\n      // Should return instead of throwing error since this is a part of system transaction.\n      return;\n    }\n\n    uint256 _period = _validatorContract.currentPeriod();\n    uint256 _count = ++_unavailabilityIndicator[_validatorAddr][_period];\n\n    if (_count == _unavailabilityTier2Threshold) {\n      emit Slashed(_validatorAddr, SlashType.UNAVAILABILITY_TIER_2, _period);\n      _validatorContract.execSlash(\n        _validatorAddr,\n        block.number + _jailDurationForUnavailabilityTier2Threshold,\n        _slashAmountForUnavailabilityTier2Threshold,\n        false\n      );\n    } else if (_count == _unavailabilityTier1Threshold) {\n      bool _tier1SecondTime = checkBailedOutAtPeriod(_validatorAddr, _period);\n      if (!_tier1SecondTime) {\n        emit Slashed(_validatorAddr, SlashType.UNAVAILABILITY_TIER_1, _period);\n        _validatorContract.execSlash(_validatorAddr, 0, 0, false);\n      } else {\n        /// Handles tier-3\n        emit Slashed(_validatorAddr, SlashType.UNAVAILABILITY_TIER_3, _period);\n        uint256 _jailedUntilBlock = block.number + _jailDurationForUnavailabilityTier2Threshold;\n        _validatorContract.execSlash(\n          _validatorAddr,\n          _jailedUntilBlock,\n          _slashAmountForUnavailabilityTier2Threshold,\n          true\n        );\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) external override onlyAdmin {\n    _setUnavailabilitySlashingConfigs(\n      _tier1Threshold,\n      _tier2Threshold,\n      _slashAmountForTier2Threshold,\n      _jailDurationForTier2Threshold\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function getUnavailabilitySlashingConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 unavailabilityTier1Threshold_,\n      uint256 unavailabilityTier2Threshold_,\n      uint256 slashAmountForUnavailabilityTier2Threshold_,\n      uint256 jailDurationForUnavailabilityTier2Threshold_\n    )\n  {\n    return (\n      _unavailabilityTier1Threshold,\n      _unavailabilityTier2Threshold,\n      _slashAmountForUnavailabilityTier2Threshold,\n      _jailDurationForUnavailabilityTier2Threshold\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function currentUnavailabilityIndicator(address _validator) external view override returns (uint256) {\n    return getUnavailabilityIndicator(_validator, _validatorContract.currentPeriod());\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function getUnavailabilityIndicator(address _validator, uint256 _period)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _unavailabilityIndicator[_validator][_period];\n  }\n\n  /**\n   * @dev Sets the unavailability indicator of the `_validator` at `_period`.\n   */\n  function _setUnavailabilityIndicator(\n    address _validator,\n    uint256 _period,\n    uint256 _indicator\n  ) internal virtual {\n    _unavailabilityIndicator[_validator][_period] = _indicator;\n  }\n\n  /**\n   * @dev See `ISlashUnavailability-setUnavailabilitySlashingConfigs`.\n   */\n  function _setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) internal {\n    require(_unavailabilityTier1Threshold <= _unavailabilityTier2Threshold, \"SlashUnavailability: invalid threshold\");\n    _unavailabilityTier1Threshold = _tier1Threshold;\n    _unavailabilityTier2Threshold = _tier2Threshold;\n    _slashAmountForUnavailabilityTier2Threshold = _slashAmountForTier2Threshold;\n    _jailDurationForUnavailabilityTier2Threshold = _jailDurationForTier2Threshold;\n    emit UnavailabilitySlashingConfigsUpdated(\n      _tier1Threshold,\n      _tier2Threshold,\n      _slashAmountForTier2Threshold,\n      _jailDurationForTier2Threshold\n    );\n  }\n\n  /**\n   * @dev Returns whether the account `_addr` should be slashed or not.\n   */\n  function _shouldSlash(address _addr) internal view virtual returns (bool);\n\n  /**\n   * @dev See `ICreditScore-checkBailedOutAtPeriod`\n   */\n  function checkBailedOutAtPeriod(address _validator, uint256 _period) public view virtual returns (bool);\n}\n"
    },
    "contracts/ronin/slash-indicator/CreditScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/slash-indicator/ICreditScore.sol\";\nimport \"../../extensions/collections/HasMaintenanceContract.sol\";\nimport \"../../extensions/collections/HasValidatorContract.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../libraries/Math.sol\";\n\nabstract contract CreditScore is ICreditScore, HasValidatorContract, HasMaintenanceContract, PercentageConsumer {\n  /// @dev Mapping from validator address => period index => whether bailed out before\n  mapping(address => mapping(uint256 => bool)) internal _checkBailedOutAtPeriod;\n  /// @dev Mapping from validator address => credit score\n  mapping(address => uint256) internal _creditScore;\n\n  /// @dev The max gained number of credit score per period.\n  uint256 internal _gainCreditScore;\n  /// @dev The max number of credit score that a validator can hold.\n  uint256 internal _maxCreditScore;\n  /// @dev The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n  uint256 internal _bailOutCostMultiplier;\n  /// @dev The percentage of reward to be cut off from the validator in the rest of the period after bailed out.\n  uint256 internal _cutOffPercentageAfterBailout;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function updateCreditScores(address[] calldata _validators, uint256 _period) external override onlyValidatorContract {\n    uint256 _periodStartAtBlock = _validatorContract.currentPeriodStartAtBlock();\n\n    bool[] memory _jaileds = _validatorContract.checkManyJailed(_validators);\n    bool[] memory _maintaineds = _maintenanceContract.checkManyMaintainedInBlockRange(\n      _validators,\n      _periodStartAtBlock,\n      block.number\n    );\n    uint256[] memory _updatedCreditScores = new uint256[](_validators.length);\n\n    for (uint _i = 0; _i < _validators.length; _i++) {\n      address _validator = _validators[_i];\n\n      uint256 _indicator = getUnavailabilityIndicator(_validator, _period);\n      bool _isJailedInPeriod = _jaileds[_i];\n      bool _isMaintainingInPeriod = _maintaineds[_i];\n\n      uint256 _actualGain = (_isJailedInPeriod || _isMaintainingInPeriod)\n        ? 0\n        : Math.subNonNegative(_gainCreditScore, _indicator);\n\n      _creditScore[_validator] = Math.addWithUpperbound(_creditScore[_validator], _actualGain, _maxCreditScore);\n      _updatedCreditScores[_i] = _creditScore[_validator];\n    }\n\n    emit CreditScoresUpdated(_validators, _updatedCreditScores);\n  }\n\n  function execResetCreditScores(address[] calldata _validators) external override onlyValidatorContract {\n    uint256[] memory _updatedCreditScores = new uint256[](_validators.length);\n    for (uint _i = 0; _i < _validators.length; _i++) {\n      address _validator = _validators[_i];\n      delete _creditScore[_validator];\n      delete _updatedCreditScores[_i];\n    }\n    emit CreditScoresUpdated(_validators, _updatedCreditScores);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function bailOut(address _consensusAddr) external override {\n    require(\n      _validatorContract.isValidatorCandidate(_consensusAddr),\n      \"SlashIndicator: consensus address must be a validator candidate\"\n    );\n    require(\n      _validatorContract.isCandidateAdmin(_consensusAddr, msg.sender),\n      \"SlashIndicator: method caller must be a candidate admin\"\n    );\n\n    (bool _isJailed, , uint256 _jailedEpochLeft) = _validatorContract.getJailedTimeLeft(_consensusAddr);\n    require(_isJailed, \"SlashIndicator: caller must be jailed in the current period\");\n\n    uint256 _period = _validatorContract.currentPeriod();\n    require(!_checkBailedOutAtPeriod[_consensusAddr][_period], \"SlashIndicator: validator has bailed out previously\");\n\n    uint256 _score = _creditScore[_consensusAddr];\n    uint256 _cost = _jailedEpochLeft * _bailOutCostMultiplier;\n    require(_score >= _cost, \"SlashIndicator: insufficient credit score to bail out\");\n\n    _validatorContract.execBailOut(_consensusAddr, _period);\n\n    _creditScore[_consensusAddr] -= _cost;\n    _setUnavailabilityIndicator(_consensusAddr, _period, 0);\n    _checkBailedOutAtPeriod[_consensusAddr][_period] = true;\n    emit BailedOut(_consensusAddr, _period, _cost);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) external override onlyAdmin {\n    _setCreditScoreConfigs(_gainScore, _maxScore, _bailOutMultiplier, _cutOffPercentage);\n  }\n\n  /**\n   * @dev See `ISlashUnavailability`\n   */\n  function getUnavailabilityIndicator(address _validator, uint256 _period) public view virtual returns (uint256);\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getCreditScoreConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 gainCreditScore_,\n      uint256 maxCreditScore_,\n      uint256 bailOutCostMultiplier_,\n      uint256 cutOffPercentageAfterBailout_\n    )\n  {\n    return (_gainCreditScore, _maxCreditScore, _bailOutCostMultiplier, _cutOffPercentageAfterBailout);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getCreditScore(address _validator) external view override returns (uint256) {\n    return _creditScore[_validator];\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getManyCreditScores(address[] calldata _validators)\n    public\n    view\n    override\n    returns (uint256[] memory _resultList)\n  {\n    _resultList = new uint256[](_validators.length);\n\n    for (uint _i = 0; _i < _resultList.length; _i++) {\n      _resultList[_i] = _creditScore[_validators[_i]];\n    }\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function checkBailedOutAtPeriod(address _validator, uint256 _period) public view virtual override returns (bool) {\n    return _checkBailedOutAtPeriod[_validator][_period];\n  }\n\n  /**\n   * @dev See `SlashUnavailability`.\n   */\n  function _setUnavailabilityIndicator(\n    address _validator,\n    uint256 _period,\n    uint256 _indicator\n  ) internal virtual;\n\n  /**\n   * @dev See `ICreditScore-setCreditScoreConfigs`.\n   */\n  function _setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) internal {\n    require(_gainScore <= _maxScore, \"CreditScore: invalid credit score config\");\n    require(_cutOffPercentage <= _MAX_PERCENTAGE, \"CreditScore: invalid cut off percentage config\");\n\n    _gainCreditScore = _gainScore;\n    _maxCreditScore = _maxScore;\n    _bailOutCostMultiplier = _bailOutMultiplier;\n    _cutOffPercentageAfterBailout = _cutOffPercentage;\n    emit CreditScoreConfigsUpdated(_gainScore, _maxScore, _bailOutMultiplier, _cutOffPercentage);\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUValidateDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUValidateDoubleSign is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of validating double sign evidence\n  function precompileValidateDoubleSignAddress() public view virtual returns (address) {\n    return address(0x67);\n  }\n\n  /**\n   * @dev Validates the two submitted block header if they are produced by the same address\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcValidateEvidence(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) internal view virtual returns (bool _validEvidence) {\n    address _smc = precompileValidateDoubleSignAddress();\n    bool _success = true;\n\n    bytes memory _payload = abi.encodeWithSignature(\n      \"validatingDoubleSignProof(address,bytes,bytes)\",\n      _consensusAddr,\n      _header1,\n      _header2\n    );\n    uint _payloadLength = _payload.length;\n    uint[1] memory _output;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _output, 0x20)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n    return (_output[0] != 0);\n  }\n}\n"
    },
    "contracts/extensions/collections/HasRoninGovernanceAdminContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasRoninGovernanceAdminContract.sol\";\nimport \"../../interfaces/IRoninGovernanceAdmin.sol\";\n\ncontract HasRoninGovernanceAdminContract is IHasRoninGovernanceAdminContract, HasProxyAdmin {\n  IRoninGovernanceAdmin internal _roninGovernanceAdminContract;\n\n  modifier onlyRoninGovernanceAdminContract() {\n    if (roninGovernanceAdminContract() != msg.sender) revert ErrCallerMustBeGovernanceAdminContract();\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasRoninGovernanceAdminContract\n   */\n  function roninGovernanceAdminContract() public view override returns (address) {\n    return address(_roninGovernanceAdminContract);\n  }\n\n  /**\n   * @inheritdoc IHasRoninGovernanceAdminContract\n   */\n  function setRoninGovernanceAdminContract(address _addr) external override onlyAdmin {\n    if (_addr.code.length == 0) revert ErrZeroCodeContract();\n    _setRoninGovernanceAdminContract(_addr);\n  }\n\n  /**\n   * @dev Sets the ronin governance admin contract.\n   *\n   * Emits the event `RoninGovernanceAdminContractUpdated`.\n   *\n   */\n  function _setRoninGovernanceAdminContract(address _addr) internal {\n    _roninGovernanceAdminContract = IRoninGovernanceAdmin(_addr);\n    emit RoninGovernanceAdminContractUpdated(_addr);\n  }\n}\n"
    },
    "contracts/interfaces/collections/IHasRoninGovernanceAdminContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IHasContract.sol\";\n\ninterface IHasRoninGovernanceAdminContract is IHasContract {\n  /// @dev Emitted when the ronin governance admin contract is updated.\n  event RoninGovernanceAdminContractUpdated(address);\n\n  /// @dev Error of method caller must be goverance admin contract.\n  error ErrCallerMustBeGovernanceAdminContract();\n\n  /**\n   * @dev Returns the ronin governance admin contract.\n   */\n  function roninGovernanceAdminContract() external view returns (address);\n\n  /**\n   * @dev Sets the ronin governance admin contract.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The new address is a contract.\n   *\n   * Emits the event `RoninGovernanceAdminContractUpdated`.\n   *\n   */\n  function setRoninGovernanceAdminContract(address) external;\n}\n"
    },
    "contracts/mocks/validator/MockRoninValidatorSetExtended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./MockRoninValidatorSetOverridePrecompile.sol\";\nimport \"../../libraries/EnumFlags.sol\";\n\ncontract MockRoninValidatorSetExtended is MockRoninValidatorSetOverridePrecompile {\n  bool private _initialized;\n  uint256[] internal _epochs;\n\n  constructor() {}\n\n  function initEpoch() public {\n    if (!_initialized) {\n      _epochs.push(0);\n      _initialized = true;\n    }\n  }\n\n  function endEpoch() external {\n    _epochs.push(block.number);\n  }\n\n  function epochOf(uint256 _block) public view override returns (uint256 _epoch) {\n    for (uint256 _i = _epochs.length; _i > 0; _i--) {\n      if (_block > _epochs[_i - 1]) {\n        return _i;\n      }\n    }\n  }\n\n  function epochEndingAt(uint256 _block) public view override(ITimingInfo, TimingStorage) returns (bool) {\n    for (uint _i = 0; _i < _epochs.length; _i++) {\n      if (_block == _epochs[_i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function getJailUntils(address[] calldata _addrs) public view returns (uint256[] memory jailUntils_) {\n    jailUntils_ = new uint256[](_addrs.length);\n    for (uint _i = 0; _i < _addrs.length; _i++) {\n      jailUntils_[_i] = _blockProducerJailedBlock[_addrs[_i]];\n    }\n  }\n\n  function addValidators(address[] calldata _addrs) public {\n    for (uint _i = 0; _i < _addrs.length; _i++) {\n      _validators[_i] = _addrs[_i];\n      _validatorMap[_addrs[_i]] = EnumFlags.ValidatorFlag.Both;\n    }\n  }\n}\n"
    },
    "contracts/mocks/validator/MockRoninValidatorSetOverridePrecompile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../MockPrecompile.sol\";\nimport \"../../ronin/validator/RoninValidatorSet.sol\";\n\ncontract MockRoninValidatorSetOverridePrecompile is RoninValidatorSet, MockPrecompile {\n  constructor() {}\n\n  function arrangeValidatorCandidates(\n    address[] memory _candidates,\n    uint256[] memory _trustedWeights,\n    uint _newValidatorCount,\n    uint _maxPrioritizedValidatorNumber\n  ) external pure returns (address[] memory) {\n    _arrangeValidatorCandidates(_candidates, _trustedWeights, _newValidatorCount, _maxPrioritizedValidatorNumber);\n    return _candidates;\n  }\n\n  function _pcSortCandidates(address[] memory _candidates, uint256[] memory _weights)\n    internal\n    pure\n    override\n    returns (address[] memory _result)\n  {\n    return sortValidators(_candidates, _weights);\n  }\n\n  function _pcPickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) internal pure override returns (address[] memory _result, uint256 _newValidatorCount) {\n    _result = pickValidatorSet(\n      _candidates,\n      _weights,\n      _trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n\n    _newValidatorCount = _result.length;\n  }\n}\n"
    },
    "contracts/mocks/MockPrecompile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./libraries/Sorting.sol\";\nimport \"../libraries/Math.sol\";\n\ncontract MockPrecompile {\n  function sortValidators(address[] memory _validators, uint256[] memory _weights)\n    public\n    pure\n    returns (address[] memory)\n  {\n    return Sorting.sort(_validators, _weights);\n  }\n\n  function validatingDoubleSignProof(\n    address, /*consensusAddr*/\n    bytes calldata, /*_header1*/\n    bytes calldata /*_header2*/\n  ) public pure returns (bool _validEvidence) {\n    return true;\n  }\n\n  function pickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) public pure returns (address[] memory _result) {\n    (_result, _trustedWeights) = Sorting.sortWithExternalKeys(_candidates, _weights, _trustedWeights);\n    uint256 _newValidatorCount = Math.min(_maxValidatorNumber, _result.length);\n    _arrangeValidatorCandidates(_result, _trustedWeights, _newValidatorCount, _maxPrioritizedValidatorNumber);\n  }\n\n  /**\n   * @dev Arranges the sorted candidates to list of validators, by asserting prioritized and non-prioritized candidates\n   *\n   * @param _candidates A sorted list of candidates\n   */\n  function _arrangeValidatorCandidates(\n    address[] memory _candidates,\n    uint256[] memory _trustedWeights,\n    uint _newValidatorCount,\n    uint _maxPrioritizedValidatorNumber\n  ) internal pure {\n    address[] memory _waitingCandidates = new address[](_candidates.length);\n    uint _waitingCounter;\n    uint _prioritySlotCounter;\n\n    for (uint _i = 0; _i < _candidates.length; _i++) {\n      if (_trustedWeights[_i] > 0 && _prioritySlotCounter < _maxPrioritizedValidatorNumber) {\n        _candidates[_prioritySlotCounter++] = _candidates[_i];\n        continue;\n      }\n      _waitingCandidates[_waitingCounter++] = _candidates[_i];\n    }\n\n    _waitingCounter = 0;\n    for (uint _i = _prioritySlotCounter; _i < _newValidatorCount; _i++) {\n      _candidates[_i] = _waitingCandidates[_waitingCounter++];\n    }\n\n    assembly {\n      mstore(_candidates, _newValidatorCount)\n    }\n  }\n}\n"
    },
    "contracts/ronin/validator/RoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"./CoinbaseExecution.sol\";\nimport \"./SlashingExecution.sol\";\n\ncontract RoninValidatorSet is Initializable, CoinbaseExecution, SlashingExecution {\n  constructor() {\n    _disableInitializers();\n  }\n\n  fallback() external payable {\n    _fallback();\n  }\n\n  receive() external payable {\n    _fallback();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __slashIndicatorContract,\n    address __stakingContract,\n    address __stakingVestingContract,\n    address __maintenanceContract,\n    address __roninTrustedOrganizationContract,\n    address __bridgeTrackingContract,\n    uint256 __maxValidatorNumber,\n    uint256 __maxValidatorCandidate,\n    uint256 __maxPrioritizedValidatorNumber,\n    uint256 __minEffectiveDaysOnwards,\n    uint256 __numberOfBlocksInEpoch,\n    // __emergencyExitConfigs[0]: emergencyExitLockedAmount\n    // __emergencyExitConfigs[1]: emergencyExpiryDuration\n    uint256[2] calldata __emergencyExitConfigs\n  ) external initializer {\n    _setSlashIndicatorContract(__slashIndicatorContract);\n    _setStakingContract(__stakingContract);\n    _setStakingVestingContract(__stakingVestingContract);\n    _setMaintenanceContract(__maintenanceContract);\n    _setBridgeTrackingContract(__bridgeTrackingContract);\n    _setRoninTrustedOrganizationContract(__roninTrustedOrganizationContract);\n    _setMaxValidatorNumber(__maxValidatorNumber);\n    _setMaxValidatorCandidate(__maxValidatorCandidate);\n    _setMaxPrioritizedValidatorNumber(__maxPrioritizedValidatorNumber);\n    _setMinEffectiveDaysOnwards(__minEffectiveDaysOnwards);\n    _setEmergencyExitLockedAmount(__emergencyExitConfigs[0]);\n    _setEmergencyExpiryDuration(__emergencyExitConfigs[1]);\n    _numberOfBlocksInEpoch = __numberOfBlocksInEpoch;\n  }\n\n  /**\n   * @dev Only receives RON from staking vesting contract (for topping up bonus), and from staking contract (for transferring\n   * deducting amount on slashing).\n   */\n  function _fallback() internal view {\n    if (msg.sender != stakingVestingContract() && msg.sender != stakingContract()) revert ErrUnauthorizedReceiveRON();\n  }\n\n  /**\n   * @dev Override `ValidatorInfoStorage-_bridgeOperatorOf`.\n   */\n  function _bridgeOperatorOf(address _consensusAddr)\n    internal\n    view\n    override(EmergencyExit, ValidatorInfoStorage)\n    returns (address)\n  {\n    return super._bridgeOperatorOf(_consensusAddr);\n  }\n}\n"
    },
    "contracts/mocks/libraries/Sorting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary Sorting {\n  struct Node {\n    uint key;\n    uint value;\n  }\n\n  struct Node3 {\n    uint key;\n    uint value;\n    uint otherKey;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                   VALUE SORTING                                   //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sort(uint[] memory data) internal pure returns (uint[] memory) {\n    return _quickSort(data, int(0), int(data.length - 1));\n  }\n\n  function _quickSort(\n    uint[] memory arr,\n    int left,\n    int right\n  ) private pure returns (uint[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return arr;\n    uint pivot = arr[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (arr[uint(i)] > pivot) i++;\n      while (pivot > arr[uint(j)]) j--;\n      if (i <= j) {\n        (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) arr = _quickSort(arr, left, j);\n    if (i < right) arr = _quickSort(arr, i, right);\n\n    return arr;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                   NODE SORTING                                    //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sort(address[] memory _keys, uint256[] memory _values) internal pure returns (address[] memory) {\n    require(_values.length == _keys.length, \"Sorting: invalid array length\");\n    if (_keys.length == 0) {\n      return _keys;\n    }\n\n    Node[] memory _nodes = new Node[](_keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node(uint256(uint160(_keys[_i])), _values[_i]);\n    }\n    _quickSortNodes(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _keys[_i] = address(uint160(_nodes[_i].key)); // Casting?\n    }\n\n    return _keys;\n  }\n\n  function sortNodes(Node[] memory nodes) internal pure returns (Node[] memory) {\n    return _quickSortNodes(nodes, int(0), int(nodes.length - 1));\n  }\n\n  function _quickSortNodes(\n    Node[] memory nodes,\n    int left,\n    int right\n  ) private pure returns (Node[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return nodes;\n    Node memory pivot = nodes[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (nodes[uint(i)].value > pivot.value) i++;\n      while (pivot.value > nodes[uint(j)].value) j--;\n      if (i <= j) {\n        (nodes[uint(i)], nodes[uint(j)]) = __swapNodes(nodes[uint(i)], nodes[uint(j)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) nodes = _quickSortNodes(nodes, left, j);\n    if (i < right) nodes = _quickSortNodes(nodes, i, right);\n\n    return nodes;\n  }\n\n  function _bubbleSortNodes(Node[] memory nodes) private pure returns (Node[] memory) {\n    uint length = nodes.length;\n    for (uint i = 0; i < length - 1; i++) {\n      for (uint j = i + 1; j < length; j++) {\n        if (nodes[j].value > nodes[i].value) {\n          (nodes[i], nodes[j]) = __swapNodes(nodes[i], nodes[j]);\n        }\n      }\n    }\n    return nodes;\n  }\n\n  function __swapNodes(Node memory x, Node memory y) private pure returns (Node memory, Node memory) {\n    Node memory tmp = x;\n    (x, y) = (y, tmp);\n    return (x, y);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                  NODE3 SORTING                                    //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sortWithExternalKeys(\n    address[] memory _keys,\n    uint256[] memory _values,\n    uint256[] memory _otherKeys\n  ) internal pure returns (address[] memory keys_, uint256[] memory otherKeys_) {\n    require((_values.length == _keys.length) && (_otherKeys.length == _keys.length), \"Sorting: invalid array length\");\n    if (_keys.length == 0) {\n      return (_keys, _otherKeys);\n    }\n\n    Node3[] memory _nodes = new Node3[](_keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node3(uint256(uint160(_keys[_i])), _values[_i], _otherKeys[_i]);\n    }\n    _quickSortNode3s(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _keys[_i] = address(uint160(_nodes[_i].key)); // Casting?\n    }\n\n    return (_keys, _otherKeys);\n  }\n\n  function sortNode3s(Node3[] memory nodes) internal pure returns (Node3[] memory) {\n    return _quickSortNode3s(nodes, int(0), int(nodes.length - 1));\n  }\n\n  function _quickSortNode3s(\n    Node3[] memory nodes,\n    int left,\n    int right\n  ) private pure returns (Node3[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return nodes;\n    Node3 memory pivot = nodes[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (nodes[uint(i)].value > pivot.value) i++;\n      while (pivot.value > nodes[uint(j)].value) j--;\n      if (i <= j) {\n        (nodes[uint(i)], nodes[uint(j)]) = __swapNode3s(nodes[uint(i)], nodes[uint(j)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) nodes = _quickSortNode3s(nodes, left, j);\n    if (i < right) nodes = _quickSortNode3s(nodes, i, right);\n\n    return nodes;\n  }\n\n  function _bubbleSortNode3s(Node3[] memory nodes) private pure returns (Node3[] memory) {\n    uint length = nodes.length;\n    for (uint i = 0; i < length - 1; i++) {\n      for (uint j = i + 1; j < length; j++) {\n        if (nodes[j].value > nodes[i].value) {\n          (nodes[i], nodes[j]) = __swapNode3s(nodes[i], nodes[j]);\n        }\n      }\n    }\n    return nodes;\n  }\n\n  function __swapNode3s(Node3 memory x, Node3 memory y) private pure returns (Node3 memory, Node3 memory) {\n    Node3 memory tmp = x;\n    (x, y) = (y, tmp);\n    return (x, y);\n  }\n}\n"
    },
    "contracts/mainchain/MainchainGatewayV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../extensions/GatewayV2.sol\";\nimport \"../extensions/WithdrawalLimitation.sol\";\nimport \"../libraries/Transfer.sol\";\nimport \"../interfaces/IMainchainGatewayV2.sol\";\n\ncontract MainchainGatewayV2 is WithdrawalLimitation, Initializable, AccessControlEnumerable, IMainchainGatewayV2 {\n  using Token for Token.Info;\n  using Transfer for Transfer.Request;\n  using Transfer for Transfer.Receipt;\n\n  /// @dev Emitted when the bridge operators are replaced\n  event BridgeOperatorsReplaced(address[] operators);\n\n  /// @dev Withdrawal unlocker role hash\n  bytes32 public constant WITHDRAWAL_UNLOCKER_ROLE = keccak256(\"WITHDRAWAL_UNLOCKER_ROLE\");\n\n  /// @dev Wrapped native token address\n  IWETH public wrappedNativeToken;\n  /// @dev Ronin network id\n  uint256 public roninChainId;\n  /// @dev Total deposit\n  uint256 public depositCount;\n  /// @dev Domain seperator\n  bytes32 internal _domainSeparator;\n  /// @dev Mapping from mainchain token => token address on Ronin network\n  mapping(address => MappedToken) internal _roninToken;\n  /// @dev Mapping from withdrawal id => withdrawal hash\n  mapping(uint256 => bytes32) public withdrawalHash;\n  /// @dev Mapping from withdrawal id => locked\n  mapping(uint256 => bool) public withdrawalLocked;\n\n  /// @dev Mapping from validator address => last block that the bridge operator is added\n  mapping(address => uint256) internal _bridgeOperatorAddedBlock;\n  /// @dev Bridge operators array\n  address[] internal _bridgeOperators;\n\n  fallback() external payable {\n    _fallback();\n  }\n\n  receive() external payable {\n    _fallback();\n  }\n\n  /**\n   * @dev Initializes contract storage.\n   */\n  function initialize(\n    address _roleSetter,\n    IWETH _wrappedToken,\n    uint256 _roninChainId,\n    uint256 _numerator,\n    uint256 _highTierVWNumerator,\n    uint256 _denominator,\n    // _addresses[0]: mainchainTokens\n    // _addresses[1]: roninTokens\n    // _addresses[2]: withdrawalUnlockers\n    address[][3] calldata _addresses,\n    // _thresholds[0]: highTierThreshold\n    // _thresholds[1]: lockedThreshold\n    // _thresholds[2]: unlockFeePercentages\n    // _thresholds[3]: dailyWithdrawalLimit\n    uint256[][4] calldata _thresholds,\n    Token.Standard[] calldata _standards\n  ) external payable virtual initializer {\n    _setupRole(DEFAULT_ADMIN_ROLE, _roleSetter);\n    roninChainId = _roninChainId;\n\n    _setWrappedNativeTokenContract(_wrappedToken);\n    _updateDomainSeparator();\n    _setThreshold(_numerator, _denominator);\n    _setHighTierVoteWeightThreshold(_highTierVWNumerator, _denominator);\n    _verifyThresholds();\n\n    if (_addresses[0].length > 0) {\n      // Map mainchain tokens to ronin tokens\n      _mapTokens(_addresses[0], _addresses[1], _standards);\n      // Sets thresholds based on the mainchain tokens\n      _setHighTierThresholds(_addresses[0], _thresholds[0]);\n      _setLockedThresholds(_addresses[0], _thresholds[1]);\n      _setUnlockFeePercentages(_addresses[0], _thresholds[2]);\n      _setDailyWithdrawalLimits(_addresses[0], _thresholds[3]);\n    }\n\n    // Grant role for withdrawal unlocker\n    for (uint256 _i; _i < _addresses[2].length; _i++) {\n      _grantRole(WITHDRAWAL_UNLOCKER_ROLE, _addresses[2][_i]);\n    }\n  }\n\n  /**\n   * @inheritdoc IBridge\n   */\n  function replaceBridgeOperators(address[] calldata _list) external onlyAdmin {\n    address _addr;\n    for (uint256 _i = 0; _i < _list.length; _i++) {\n      _addr = _list[_i];\n      if (_bridgeOperatorAddedBlock[_addr] == 0) {\n        _bridgeOperators.push(_addr);\n      }\n      _bridgeOperatorAddedBlock[_addr] = block.number;\n    }\n\n    {\n      uint256 _i;\n      while (_i < _bridgeOperators.length) {\n        _addr = _bridgeOperators[_i];\n        if (_bridgeOperatorAddedBlock[_addr] < block.number) {\n          delete _bridgeOperatorAddedBlock[_addr];\n          _bridgeOperators[_i] = _bridgeOperators[_bridgeOperators.length - 1];\n          _bridgeOperators.pop();\n          continue;\n        }\n        _i++;\n      }\n    }\n\n    emit BridgeOperatorsReplaced(_list);\n  }\n\n  /**\n   * @inheritdoc IBridge\n   */\n  function getBridgeOperators() external view returns (address[] memory) {\n    return _bridgeOperators;\n  }\n\n  /**\n   * @dev Receives ether without doing anything. Use this function to topup native token.\n   */\n  function receiveEther() external payable {}\n\n  /**\n   * @inheritdoc IMainchainGatewayV2\n   */\n  function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n    return _domainSeparator;\n  }\n\n  /**\n   * @inheritdoc IMainchainGatewayV2\n   */\n  function setWrappedNativeTokenContract(IWETH _wrappedToken) external virtual onlyAdmin {\n    _setWrappedNativeTokenContract(_wrappedToken);\n  }\n\n  /**\n   * @inheritdoc IMainchainGatewayV2\n   */\n  function requestDepositFor(Transfer.Request calldata _request) external payable virtual whenNotPaused {\n    _requestDepositFor(_request, msg.sender);\n  }\n\n  /**\n   * @inheritdoc IMainchainGatewayV2\n   */\n  function submitWithdrawal(Transfer.Receipt calldata _receipt, Signature[] calldata _signatures)\n    external\n    virtual\n    whenNotPaused\n    returns (bool _locked)\n  {\n    return _submitWithdrawal(_receipt, _signatures);\n  }\n\n  /**\n   * @inheritdoc IMainchainGatewayV2\n   */\n  function unlockWithdrawal(Transfer.Receipt calldata _receipt) external onlyRole(WITHDRAWAL_UNLOCKER_ROLE) {\n    bytes32 _receiptHash = _receipt.hash();\n    require(withdrawalHash[_receipt.id] == _receipt.hash(), \"MainchainGatewayV2: invalid receipt\");\n    require(withdrawalLocked[_receipt.id], \"MainchainGatewayV2: query for approved withdrawal\");\n    delete withdrawalLocked[_receipt.id];\n    emit WithdrawalUnlocked(_receiptHash, _receipt);\n\n    address _token = _receipt.mainchain.tokenAddr;\n    if (_receipt.info.erc == Token.Standard.ERC20) {\n      Token.Info memory _feeInfo = _receipt.info;\n      _feeInfo.quantity = _computeFeePercentage(_receipt.info.quantity, unlockFeePercentages[_token]);\n      Token.Info memory _withdrawInfo = _receipt.info;\n      _withdrawInfo.quantity = _receipt.info.quantity - _feeInfo.quantity;\n\n      _feeInfo.handleAssetTransfer(payable(msg.sender), _token, wrappedNativeToken);\n      _withdrawInfo.handleAssetTransfer(payable(_receipt.mainchain.addr), _token, wrappedNativeToken);\n    } else {\n      _receipt.info.handleAssetTransfer(payable(_receipt.mainchain.addr), _token, wrappedNativeToken);\n    }\n\n    emit Withdrew(_receiptHash, _receipt);\n  }\n\n  /**\n   * @inheritdoc IMainchainGatewayV2\n   */\n  function mapTokens(\n    address[] calldata _mainchainTokens,\n    address[] calldata _roninTokens,\n    Token.Standard[] calldata _standards\n  ) external virtual onlyAdmin {\n    require(_mainchainTokens.length > 0, \"MainchainGatewayV2: query for empty array\");\n    _mapTokens(_mainchainTokens, _roninTokens, _standards);\n  }\n\n  /**\n   * @inheritdoc IMainchainGatewayV2\n   */\n  function mapTokensAndThresholds(\n    address[] calldata _mainchainTokens,\n    address[] calldata _roninTokens,\n    Token.Standard[] calldata _standards,\n    // _thresholds[0]: highTierThreshold\n    // _thresholds[1]: lockedThreshold\n    // _thresholds[2]: unlockFeePercentages\n    // _thresholds[3]: dailyWithdrawalLimit\n    uint256[][4] calldata _thresholds\n  ) external virtual onlyAdmin {\n    require(_mainchainTokens.length > 0, \"MainchainGatewayV2: query for empty array\");\n    _mapTokens(_mainchainTokens, _roninTokens, _standards);\n    _setHighTierThresholds(_mainchainTokens, _thresholds[0]);\n    _setLockedThresholds(_mainchainTokens, _thresholds[1]);\n    _setUnlockFeePercentages(_mainchainTokens, _thresholds[2]);\n    _setDailyWithdrawalLimits(_mainchainTokens, _thresholds[3]);\n  }\n\n  /**\n   * @inheritdoc IMainchainGatewayV2\n   */\n  function getRoninToken(address _mainchainToken) public view returns (MappedToken memory _token) {\n    _token = _roninToken[_mainchainToken];\n    require(_token.tokenAddr != address(0), \"MainchainGatewayV2: unsupported token\");\n  }\n\n  /**\n   * @dev Maps mainchain tokens to Ronin network.\n   *\n   * Requirement:\n   * - The arrays have the same length.\n   *\n   * Emits the `TokenMapped` event.\n   *\n   */\n  function _mapTokens(\n    address[] calldata _mainchainTokens,\n    address[] calldata _roninTokens,\n    Token.Standard[] calldata _standards\n  ) internal virtual {\n    require(\n      _mainchainTokens.length == _roninTokens.length && _mainchainTokens.length == _standards.length,\n      \"MainchainGatewayV2: invalid array length\"\n    );\n\n    for (uint256 _i; _i < _mainchainTokens.length; _i++) {\n      _roninToken[_mainchainTokens[_i]].tokenAddr = _roninTokens[_i];\n      _roninToken[_mainchainTokens[_i]].erc = _standards[_i];\n    }\n\n    emit TokenMapped(_mainchainTokens, _roninTokens, _standards);\n  }\n\n  /**\n   * @dev Submits withdrawal receipt.\n   *\n   * Requirements:\n   * - The receipt kind is withdrawal.\n   * - The receipt is to withdraw on this chain.\n   * - The receipt is not used to withdraw before.\n   * - The withdrawal is not reached the limit threshold.\n   * - The signer weight total is larger than or equal to the minimum threshold.\n   * - The signature signers are in order.\n   *\n   * Emits the `Withdrew` once the assets are released.\n   *\n   */\n  function _submitWithdrawal(Transfer.Receipt calldata _receipt, Signature[] memory _signatures)\n    internal\n    virtual\n    returns (bool _locked)\n  {\n    uint256 _id = _receipt.id;\n    uint256 _quantity = _receipt.info.quantity;\n    address _tokenAddr = _receipt.mainchain.tokenAddr;\n\n    _receipt.info.validate();\n    require(_receipt.kind == Transfer.Kind.Withdrawal, \"MainchainGatewayV2: invalid receipt kind\");\n    require(_receipt.mainchain.chainId == block.chainid, \"MainchainGatewayV2: invalid chain id\");\n    MappedToken memory _token = getRoninToken(_receipt.mainchain.tokenAddr);\n    require(\n      _token.erc == _receipt.info.erc && _token.tokenAddr == _receipt.ronin.tokenAddr,\n      \"MainchainGatewayV2: invalid receipt\"\n    );\n    require(withdrawalHash[_id] == bytes32(0), \"MainchainGatewayV2: query for processed withdrawal\");\n    require(\n      _receipt.info.erc == Token.Standard.ERC721 || !_reachedWithdrawalLimit(_tokenAddr, _quantity),\n      \"MainchainGatewayV2: reached daily withdrawal limit\"\n    );\n\n    bytes32 _receiptHash = _receipt.hash();\n    bytes32 _receiptDigest = Transfer.receiptDigest(_domainSeparator, _receiptHash);\n\n    uint256 _minimumVoteWeight;\n    (_minimumVoteWeight, _locked) = _computeMinVoteWeight(_receipt.info.erc, _tokenAddr, _quantity);\n\n    {\n      bool _passed;\n      address _signer;\n      address _lastSigner;\n      Signature memory _sig;\n      uint256 _weight;\n      for (uint256 _i; _i < _signatures.length; _i++) {\n        _sig = _signatures[_i];\n        _signer = ecrecover(_receiptDigest, _sig.v, _sig.r, _sig.s);\n        require(_lastSigner < _signer, \"MainchainGatewayV2: invalid order\");\n        _lastSigner = _signer;\n\n        _weight += _getWeight(_signer);\n        if (_weight >= _minimumVoteWeight) {\n          _passed = true;\n          break;\n        }\n      }\n      require(_passed, \"MainchainGatewayV2: query for insufficient vote weight\");\n      withdrawalHash[_id] = _receiptHash;\n    }\n\n    if (_locked) {\n      withdrawalLocked[_id] = true;\n      emit WithdrawalLocked(_receiptHash, _receipt);\n      return _locked;\n    }\n\n    _recordWithdrawal(_tokenAddr, _quantity);\n    _receipt.info.handleAssetTransfer(payable(_receipt.mainchain.addr), _tokenAddr, wrappedNativeToken);\n    emit Withdrew(_receiptHash, _receipt);\n  }\n\n  /**\n   * @dev Requests deposit made by `_requester` address.\n   *\n   * Requirements:\n   * - The token info is valid.\n   * - The `msg.value` is 0 while depositing ERC20 token.\n   * - The `msg.value` is equal to deposit quantity while depositing native token.\n   *\n   * Emits the `DepositRequested` event.\n   *\n   */\n  function _requestDepositFor(Transfer.Request memory _request, address _requester) internal virtual {\n    MappedToken memory _token;\n    address _weth = address(wrappedNativeToken);\n\n    _request.info.validate();\n    if (_request.tokenAddr == address(0)) {\n      require(_request.info.quantity == msg.value, \"MainchainGatewayV2: invalid request\");\n      _token = getRoninToken(_weth);\n      require(_token.erc == _request.info.erc, \"MainchainGatewayV2: invalid token standard\");\n      _request.tokenAddr = _weth;\n    } else {\n      require(msg.value == 0, \"MainchainGatewayV2: invalid request\");\n      _token = getRoninToken(_request.tokenAddr);\n      require(_token.erc == _request.info.erc, \"MainchainGatewayV2: invalid token standard\");\n      _request.info.transferFrom(_requester, address(this), _request.tokenAddr);\n      // Withdraw if token is WETH\n      if (_weth == _request.tokenAddr) {\n        IWETH(_weth).withdraw(_request.info.quantity);\n      }\n    }\n\n    uint256 _depositId = depositCount++;\n    Transfer.Receipt memory _receipt = _request.into_deposit_receipt(\n      _requester,\n      _depositId,\n      _token.tokenAddr,\n      roninChainId\n    );\n\n    emit DepositRequested(_receipt.hash(), _receipt);\n  }\n\n  /**\n   * @dev Returns the minimum vote weight for the token.\n   */\n  function _computeMinVoteWeight(\n    Token.Standard _erc,\n    address _token,\n    uint256 _quantity\n  ) internal virtual returns (uint256 _weight, bool _locked) {\n    uint256 _totalWeight = _getTotalWeight();\n    _weight = _minimumVoteWeight(_totalWeight);\n    if (_erc == Token.Standard.ERC20) {\n      if (highTierThreshold[_token] <= _quantity) {\n        _weight = _highTierVoteWeight(_totalWeight);\n      }\n      _locked = _lockedWithdrawalRequest(_token, _quantity);\n    }\n  }\n\n  /**\n   * @dev Update domain seperator.\n   */\n  function _updateDomainSeparator() internal {\n    _domainSeparator = keccak256(\n      abi.encode(\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n        keccak256(\"MainchainGatewayV2\"),\n        keccak256(\"2\"),\n        block.chainid,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @dev Sets the WETH contract.\n   *\n   * Emits the `WrappedNativeTokenContractUpdated` event.\n   *\n   */\n  function _setWrappedNativeTokenContract(IWETH _wrapedToken) internal {\n    wrappedNativeToken = _wrapedToken;\n    emit WrappedNativeTokenContractUpdated(_wrapedToken);\n  }\n\n  /**\n   * @dev Receives ETH from WETH or creates deposit request.\n   */\n  function _fallback() internal virtual whenNotPaused {\n    if (msg.sender != address(wrappedNativeToken)) {\n      Transfer.Request memory _request;\n      _request.recipientAddr = msg.sender;\n      _request.info.quantity = msg.value;\n      _requestDepositFor(_request, _request.recipientAddr);\n    }\n  }\n\n  /**\n   * @inheritdoc GatewayV2\n   */\n  function _getTotalWeight() internal view override returns (uint256) {\n    return _bridgeOperators.length;\n  }\n\n  /**\n   * @dev Returns the weight of an address.\n   */\n  function _getWeight(address _addr) internal view returns (uint256) {\n    return _bridgeOperatorAddedBlock[_addr] > 0 ? 1 : 0;\n  }\n}\n"
    },
    "contracts/extensions/WithdrawalLimitation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./GatewayV2.sol\";\n\nabstract contract WithdrawalLimitation is GatewayV2 {\n  /// @dev Emitted when the high-tier vote weight threshold is updated\n  event HighTierVoteWeightThresholdUpdated(\n    uint256 indexed nonce,\n    uint256 indexed numerator,\n    uint256 indexed denominator,\n    uint256 previousNumerator,\n    uint256 previousDenominator\n  );\n  /// @dev Emitted when the thresholds for high-tier withdrawals that requires high-tier vote weights are updated\n  event HighTierThresholdsUpdated(address[] tokens, uint256[] thresholds);\n  /// @dev Emitted when the thresholds for locked withdrawals are updated\n  event LockedThresholdsUpdated(address[] tokens, uint256[] thresholds);\n  /// @dev Emitted when the fee percentages to unlock withdraw are updated\n  event UnlockFeePercentagesUpdated(address[] tokens, uint256[] percentages);\n  /// @dev Emitted when the daily limit thresholds are updated\n  event DailyWithdrawalLimitsUpdated(address[] tokens, uint256[] limits);\n\n  uint256 public constant _MAX_PERCENTAGE = 1_000_000;\n\n  uint256 internal _highTierVWNum;\n  uint256 internal _highTierVWDenom;\n\n  /// @dev Mapping from mainchain token => the amount thresholds for high-tier withdrawals that requires high-tier vote weights\n  mapping(address => uint256) public highTierThreshold;\n  /// @dev Mapping from mainchain token => the amount thresholds to lock withdrawal\n  mapping(address => uint256) public lockedThreshold;\n  /// @dev Mapping from mainchain token => unlock fee percentages for unlocker\n  /// @notice Values 0-1,000,000 map to 0%-100%\n  mapping(address => uint256) public unlockFeePercentages;\n  /// @dev Mapping from mainchain token => daily limit amount for withdrawal\n  mapping(address => uint256) public dailyWithdrawalLimit;\n  /// @dev Mapping from token address => today withdrawal amount\n  mapping(address => uint256) public lastSyncedWithdrawal;\n  /// @dev Mapping from token address => last date synced to record the `lastSyncedWithdrawal`\n  mapping(address => uint256) public lastDateSynced;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @dev Override `GatewayV2-setThreshold`.\n   *\n   * Requirements:\n   * - The high-tier vote weight threshold must equal to or larger than the normal threshold.\n   *\n   */\n  function setThreshold(uint256 _numerator, uint256 _denominator)\n    external\n    virtual\n    override\n    onlyAdmin\n    returns (uint256 _previousNum, uint256 _previousDenom)\n  {\n    (_previousNum, _previousDenom) = _setThreshold(_numerator, _denominator);\n    _verifyThresholds();\n  }\n\n  /**\n   * @dev Returns the high-tier vote weight threshold.\n   */\n  function getHighTierVoteWeightThreshold() external view virtual returns (uint256, uint256) {\n    return (_highTierVWNum, _highTierVWDenom);\n  }\n\n  /**\n   * @dev Checks whether the `_voteWeight` passes the high-tier vote weight threshold.\n   */\n  function checkHighTierVoteWeightThreshold(uint256 _voteWeight) external view virtual returns (bool) {\n    return _voteWeight * _highTierVWDenom >= _highTierVWNum * _getTotalWeight();\n  }\n\n  /**\n   * @dev Sets high-tier vote weight threshold and returns the old one.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The high-tier vote weight threshold must equal to or larger than the normal threshold.\n   *\n   * Emits the `HighTierVoteWeightThresholdUpdated` event.\n   *\n   */\n  function setHighTierVoteWeightThreshold(uint256 _numerator, uint256 _denominator)\n    external\n    virtual\n    onlyAdmin\n    returns (uint256 _previousNum, uint256 _previousDenom)\n  {\n    (_previousNum, _previousDenom) = _setHighTierVoteWeightThreshold(_numerator, _denominator);\n    _verifyThresholds();\n  }\n\n  /**\n   * @dev Sets the thresholds for high-tier withdrawals that requires high-tier vote weights.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The arrays have the same length and its length larger than 0.\n   *\n   * Emits the `HighTierThresholdsUpdated` event.\n   *\n   */\n  function setHighTierThresholds(address[] calldata _tokens, uint256[] calldata _thresholds)\n    external\n    virtual\n    onlyAdmin\n  {\n    require(_tokens.length > 0, \"WithdrawalLimitation: invalid array length\");\n    _setHighTierThresholds(_tokens, _thresholds);\n  }\n\n  /**\n   * @dev Sets the amount thresholds to lock withdrawal.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The arrays have the same length and its length larger than 0.\n   *\n   * Emits the `LockedThresholdsUpdated` event.\n   *\n   */\n  function setLockedThresholds(address[] calldata _tokens, uint256[] calldata _thresholds) external virtual onlyAdmin {\n    require(_tokens.length > 0, \"WithdrawalLimitation: invalid array length\");\n    _setLockedThresholds(_tokens, _thresholds);\n  }\n\n  /**\n   * @dev Sets fee percentages to unlock withdrawal.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The arrays have the same length and its length larger than 0.\n   *\n   * Emits the `UnlockFeePercentagesUpdated` event.\n   *\n   */\n  function setUnlockFeePercentages(address[] calldata _tokens, uint256[] calldata _percentages)\n    external\n    virtual\n    onlyAdmin\n  {\n    require(_tokens.length > 0, \"WithdrawalLimitation: invalid array length\");\n    _setUnlockFeePercentages(_tokens, _percentages);\n  }\n\n  /**\n   * @dev Sets daily limit amounts for the withdrawals.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The arrays have the same length and its length larger than 0.\n   *\n   * Emits the `DailyWithdrawalLimitsUpdated` event.\n   *\n   */\n  function setDailyWithdrawalLimits(address[] calldata _tokens, uint256[] calldata _limits) external virtual onlyAdmin {\n    require(_tokens.length > 0, \"WithdrawalLimitation: invalid array length\");\n    _setDailyWithdrawalLimits(_tokens, _limits);\n  }\n\n  /**\n   * @dev Checks whether the withdrawal reaches the limitation.\n   */\n  function reachedWithdrawalLimit(address _token, uint256 _quantity) external view virtual returns (bool) {\n    return _reachedWithdrawalLimit(_token, _quantity);\n  }\n\n  /**\n   * @dev Sets high-tier vote weight threshold and returns the old one.\n   *\n   * Emits the `HighTierVoteWeightThresholdUpdated` event.\n   *\n   */\n  function _setHighTierVoteWeightThreshold(uint256 _numerator, uint256 _denominator)\n    internal\n    returns (uint256 _previousNum, uint256 _previousDenom)\n  {\n    require(_numerator <= _denominator, \"WithdrawalLimitation: invalid threshold\");\n    _previousNum = _highTierVWNum;\n    _previousDenom = _highTierVWDenom;\n    _highTierVWNum = _numerator;\n    _highTierVWDenom = _denominator;\n    emit HighTierVoteWeightThresholdUpdated(nonce++, _numerator, _denominator, _previousNum, _previousDenom);\n  }\n\n  /**\n   * @dev Sets the thresholds for high-tier withdrawals that requires high-tier vote weights.\n   *\n   * Requirements:\n   * - The array lengths are equal.\n   *\n   * Emits the `HighTierThresholdsUpdated` event.\n   *\n   */\n  function _setHighTierThresholds(address[] calldata _tokens, uint256[] calldata _thresholds) internal virtual {\n    require(_tokens.length == _thresholds.length, \"WithdrawalLimitation: invalid array length\");\n    for (uint256 _i; _i < _tokens.length; _i++) {\n      highTierThreshold[_tokens[_i]] = _thresholds[_i];\n    }\n    emit HighTierThresholdsUpdated(_tokens, _thresholds);\n  }\n\n  /**\n   * @dev Sets the amount thresholds to lock withdrawal.\n   *\n   * Requirements:\n   * - The array lengths are equal.\n   *\n   * Emits the `LockedThresholdsUpdated` event.\n   *\n   */\n  function _setLockedThresholds(address[] calldata _tokens, uint256[] calldata _thresholds) internal virtual {\n    require(_tokens.length == _thresholds.length, \"WithdrawalLimitation: invalid array length\");\n    for (uint256 _i; _i < _tokens.length; _i++) {\n      lockedThreshold[_tokens[_i]] = _thresholds[_i];\n    }\n    emit LockedThresholdsUpdated(_tokens, _thresholds);\n  }\n\n  /**\n   * @dev Sets fee percentages to unlock withdrawal.\n   *\n   * Requirements:\n   * - The array lengths are equal.\n   * - The percentage is equal to or less than 100_000.\n   *\n   * Emits the `UnlockFeePercentagesUpdated` event.\n   *\n   */\n  function _setUnlockFeePercentages(address[] calldata _tokens, uint256[] calldata _percentages) internal virtual {\n    require(_tokens.length == _percentages.length, \"WithdrawalLimitation: invalid array length\");\n    for (uint256 _i; _i < _tokens.length; _i++) {\n      require(_percentages[_i] <= _MAX_PERCENTAGE, \"WithdrawalLimitation: invalid percentage\");\n      unlockFeePercentages[_tokens[_i]] = _percentages[_i];\n    }\n    emit UnlockFeePercentagesUpdated(_tokens, _percentages);\n  }\n\n  /**\n   * @dev Sets daily limit amounts for the withdrawals.\n   *\n   * Requirements:\n   * - The array lengths are equal.\n   *\n   * Emits the `DailyWithdrawalLimitsUpdated` event.\n   *\n   */\n  function _setDailyWithdrawalLimits(address[] calldata _tokens, uint256[] calldata _limits) internal virtual {\n    require(_tokens.length == _limits.length, \"WithdrawalLimitation: invalid array length\");\n    for (uint256 _i; _i < _tokens.length; _i++) {\n      dailyWithdrawalLimit[_tokens[_i]] = _limits[_i];\n    }\n    emit DailyWithdrawalLimitsUpdated(_tokens, _limits);\n  }\n\n  /**\n   * @dev Checks whether the withdrawal reaches the daily limitation.\n   *\n   * Requirements:\n   * - The daily withdrawal threshold should not apply for locked withdrawals.\n   *\n   */\n  function _reachedWithdrawalLimit(address _token, uint256 _quantity) internal view virtual returns (bool) {\n    if (_lockedWithdrawalRequest(_token, _quantity)) {\n      return false;\n    }\n\n    uint256 _currentDate = block.timestamp / 1 days;\n    if (_currentDate > lastDateSynced[_token]) {\n      return dailyWithdrawalLimit[_token] <= _quantity;\n    } else {\n      return dailyWithdrawalLimit[_token] <= lastSyncedWithdrawal[_token] + _quantity;\n    }\n  }\n\n  /**\n   * @dev Record withdrawal token.\n   */\n  function _recordWithdrawal(address _token, uint256 _quantity) internal virtual {\n    uint256 _currentDate = block.timestamp / 1 days;\n    if (_currentDate > lastDateSynced[_token]) {\n      lastDateSynced[_token] = _currentDate;\n      lastSyncedWithdrawal[_token] = _quantity;\n    } else {\n      lastSyncedWithdrawal[_token] += _quantity;\n    }\n  }\n\n  /**\n   * @dev Returns whether the withdrawal request is locked or not.\n   */\n  function _lockedWithdrawalRequest(address _token, uint256 _quantity) internal view virtual returns (bool) {\n    return lockedThreshold[_token] <= _quantity;\n  }\n\n  /**\n   * @dev Computes fee percentage.\n   */\n  function _computeFeePercentage(uint256 _amount, uint256 _percentage) internal view virtual returns (uint256) {\n    return (_amount * _percentage) / _MAX_PERCENTAGE;\n  }\n\n  /**\n   * @dev Returns high-tier vote weight.\n   */\n  function _highTierVoteWeight(uint256 _totalWeight) internal view virtual returns (uint256) {\n    return (_highTierVWNum * _totalWeight + _highTierVWDenom - 1) / _highTierVWDenom;\n  }\n\n  /**\n   * @dev Validates whether the high-tier vote weight threshold is larger than the normal threshold.\n   */\n  function _verifyThresholds() internal view {\n    require(_num * _highTierVWDenom <= _highTierVWNum * _denom, \"WithdrawalLimitation: invalid thresholds\");\n  }\n}\n"
    },
    "contracts/interfaces/IMainchainGatewayV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IBridge.sol\";\nimport \"./IWETH.sol\";\nimport \"./consumers/SignatureConsumer.sol\";\nimport \"./consumers/MappedTokenConsumer.sol\";\nimport \"../libraries/Transfer.sol\";\n\ninterface IMainchainGatewayV2 is SignatureConsumer, MappedTokenConsumer, IBridge {\n  /// @dev Emitted when the deposit is requested\n  event DepositRequested(bytes32 receiptHash, Transfer.Receipt receipt);\n  /// @dev Emitted when the assets are withdrawn\n  event Withdrew(bytes32 receiptHash, Transfer.Receipt receipt);\n  /// @dev Emitted when the tokens are mapped\n  event TokenMapped(address[] mainchainTokens, address[] roninTokens, Token.Standard[] standards);\n  /// @dev Emitted when the wrapped native token contract is updated\n  event WrappedNativeTokenContractUpdated(IWETH weth);\n  /// @dev Emitted when the withdrawal is locked\n  event WithdrawalLocked(bytes32 receiptHash, Transfer.Receipt receipt);\n  /// @dev Emitted when the withdrawal is unlocked\n  event WithdrawalUnlocked(bytes32 receiptHash, Transfer.Receipt receipt);\n\n  /**\n   * @dev Returns the domain seperator.\n   */\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @dev Returns deposit count.\n   */\n  function depositCount() external view returns (uint256);\n\n  /**\n   * @dev Sets the wrapped native token contract.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `WrappedNativeTokenContractUpdated` event.\n   *\n   */\n  function setWrappedNativeTokenContract(IWETH _wrappedToken) external;\n\n  /**\n   * @dev Returns whether the withdrawal is locked.\n   */\n  function withdrawalLocked(uint256 withdrawalId) external view returns (bool);\n\n  /**\n   * @dev Returns the withdrawal hash.\n   */\n  function withdrawalHash(uint256 withdrawalId) external view returns (bytes32);\n\n  /**\n   * @dev Locks the assets and request deposit.\n   */\n  function requestDepositFor(Transfer.Request calldata _request) external payable;\n\n  /**\n   * @dev Withdraws based on the receipt and the validator signatures.\n   * Returns whether the withdrawal is locked.\n   *\n   * Emits the `Withdrew` once the assets are released.\n   *\n   */\n  function submitWithdrawal(Transfer.Receipt memory _receipt, Signature[] memory _signatures)\n    external\n    returns (bool _locked);\n\n  /**\n   * @dev Approves a specific withdrawal.\n   *\n   * Requirements:\n   * - The method caller is a validator.\n   *\n   * Emits the `Withdrew` once the assets are released.\n   *\n   */\n  function unlockWithdrawal(Transfer.Receipt calldata _receipt) external;\n\n  /**\n   * @dev Maps mainchain tokens to Ronin network.\n   *\n   * Requirement:\n   * - The method caller is admin.\n   * - The arrays have the same length and its length larger than 0.\n   *\n   * Emits the `TokenMapped` event.\n   *\n   */\n  function mapTokens(\n    address[] calldata _mainchainTokens,\n    address[] calldata _roninTokens,\n    Token.Standard[] calldata _standards\n  ) external;\n\n  /**\n   * @dev Maps mainchain tokens to Ronin network and sets thresholds.\n   *\n   * Requirement:\n   * - The method caller is admin.\n   * - The arrays have the same length and its length larger than 0.\n   *\n   * Emits the `TokenMapped` event.\n   *\n   */\n  function mapTokensAndThresholds(\n    address[] calldata _mainchainTokens,\n    address[] calldata _roninTokens,\n    Token.Standard[] calldata _standards,\n    uint256[][4] calldata _thresholds\n  ) external;\n\n  /**\n   * @dev Returns token address on Ronin network.\n   * Note: Reverts for unsupported token.\n   */\n  function getRoninToken(address _mainchainToken) external view returns (MappedToken memory _token);\n}\n"
    },
    "contracts/mocks/MockSlashIndicatorExtended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./MockPrecompile.sol\";\nimport \"../ronin/slash-indicator/SlashIndicator.sol\";\n\ncontract MockSlashIndicatorExtended is SlashIndicator, MockPrecompile {\n  function slashFelony(address _validatorAddr) external {\n    _validatorContract.execSlash(_validatorAddr, 0, 0, false);\n  }\n\n  function slashMisdemeanor(address _validatorAddr) external {\n    _validatorContract.execSlash(_validatorAddr, 0, 0, false);\n  }\n\n  function _pcValidateEvidence(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) internal pure override returns (bool _validEvidence) {\n    return validatingDoubleSignProof(_consensusAddr, _header1, _header2);\n  }\n}\n"
    },
    "contracts/mocks/sorting/MockSorting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport \"../libraries/Sorting.sol\";\n\ncontract MockSorting {\n  uint256[] public data;\n\n  function addData(uint256[] memory _data) public {\n    for (uint256 i; i < _data.length; i++) {\n      data.push(_data[i]);\n    }\n  }\n\n  function sort(uint256[] memory _data) public pure returns (uint256[] memory) {\n    return Sorting.sort(_data);\n  }\n\n  function sortOnStorage() public returns (uint256[] memory, uint256) {\n    uint256[] memory _tmpData = data;\n    data = Sorting.sort(_tmpData);\n\n    return (data, data.length);\n  }\n\n  function sortAddressesAndValues(address[] calldata _addrs, uint256[] calldata _values)\n    public\n    pure\n    returns (address[] memory)\n  {\n    return Sorting.sort(_addrs, _values);\n  }\n}\n"
    },
    "contracts/mocks/MockStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../ronin/staking/RewardCalculation.sol\";\n\ncontract MockStaking is RewardCalculation, GlobalConfigConsumer {\n  /// @dev Mapping from user => staking balance\n  mapping(address => uint256) internal _stakingAmount;\n  /// @dev Mapping from period number => slashed\n  mapping(uint256 => bool) internal _periodSlashed;\n\n  uint256 internal _stakingTotal;\n\n  uint256 public lastUpdatedPeriod;\n  uint256 public pendingReward;\n  address public poolAddr;\n\n  constructor(address _poolAddr) {\n    poolAddr = _poolAddr;\n  }\n\n  function firstEverWrapup() external {\n    delete pendingReward;\n    lastUpdatedPeriod = block.timestamp / PERIOD_DURATION + 1;\n  }\n\n  function endPeriod() external {\n    address[] memory _addrs = new address[](1);\n    uint256[] memory _rewards = new uint256[](1);\n    _addrs[0] = poolAddr;\n    _rewards[0] = pendingReward;\n    this.execRecordRewards(_addrs, _rewards);\n\n    pendingReward = 0;\n    lastUpdatedPeriod++;\n  }\n\n  function increasePeriod() external {\n    lastUpdatedPeriod++;\n  }\n\n  function stake(address _user, uint256 _amount) external {\n    uint256 _lastStakingAmount = _stakingAmount[_user];\n    uint256 _newStakingAmount = _lastStakingAmount + _amount;\n    _syncUserReward(poolAddr, _user, _newStakingAmount);\n    _stakingAmount[_user] = _newStakingAmount;\n    _stakingTotal += _amount;\n  }\n\n  function unstake(address _user, uint256 _amount) external {\n    uint256 _lastStakingAmount = _stakingAmount[_user];\n    uint256 _newStakingAmount = _lastStakingAmount - _amount;\n    _syncUserReward(poolAddr, _user, _newStakingAmount);\n    _stakingAmount[_user] = _newStakingAmount;\n    _stakingTotal -= _amount;\n  }\n\n  function increaseReward(uint256 _amount) external {\n    pendingReward += _amount;\n  }\n\n  function decreaseReward(uint256 _amount) external {\n    pendingReward -= _amount;\n  }\n\n  function execRecordRewards(address[] calldata _addrList, uint256[] calldata _rewards) external {\n    _recordRewards(_addrList, _rewards, _currentPeriod());\n  }\n\n  function getPeriod() public view returns (uint256) {\n    return _currentPeriod();\n  }\n\n  function claimReward(address _user) external returns (uint256 _amount) {\n    _amount = _claimReward(poolAddr, _user, getPeriod());\n  }\n\n  function getStakingAmount(address, address _user) public view override returns (uint256) {\n    return _stakingAmount[_user];\n  }\n\n  function getManyStakingAmounts(address[] calldata _poolAddrs, address[] calldata _userList)\n    external\n    view\n    override\n    returns (uint256[] memory)\n  {}\n\n  function getStakingTotal(address _addr) public view virtual override returns (uint256) {\n    return _addr == poolAddr ? _stakingTotal : 0;\n  }\n\n  function _currentPeriod() internal view override returns (uint256 _period) {\n    return lastUpdatedPeriod;\n  }\n\n  function getManyStakingTotals(address[] calldata _poolAddr) external view override returns (uint256[] memory) {}\n}\n"
    },
    "contracts/mocks/precompile-usages/MockPCUValidateDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../precompile-usages/PCUValidateDoubleSign.sol\";\n\ncontract MockPCUValidateDoubleSign is PCUValidateDoubleSign {\n  address internal _precompileValidateDoubleSignAddress;\n\n  constructor(address _precompile) {\n    setPrecompileValidateDoubleSignAddress(_precompile);\n  }\n\n  function setPrecompileValidateDoubleSignAddress(address _addr) public {\n    _precompileValidateDoubleSignAddress = _addr;\n  }\n\n  function precompileValidateDoubleSignAddress() public view override returns (address) {\n    return _precompileValidateDoubleSignAddress;\n  }\n\n  function callPrecompile(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) public view returns (bool) {\n    return _pcValidateEvidence(_consensusAddr, _header1, _header2);\n  }\n}\n"
    },
    "contracts/mocks/precompile-usages/MockPCUSortValidators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../precompile-usages/PCUSortValidators.sol\";\n\ncontract MockPCUSortValidators is PCUSortValidators {\n  address internal _precompileSortValidatorAddress;\n\n  constructor(address _precompile) {\n    setPrecompileSortValidatorAddress(_precompile);\n  }\n\n  function setPrecompileSortValidatorAddress(address _addr) public {\n    _precompileSortValidatorAddress = _addr;\n  }\n\n  function precompileSortValidatorsAddress() public view override returns (address) {\n    return _precompileSortValidatorAddress;\n  }\n\n  function callPrecompile(address[] calldata _validators, uint256[] calldata _weights)\n    public\n    view\n    returns (address[] memory _result)\n  {\n    return _pcSortCandidates(_validators, _weights);\n  }\n}\n"
    },
    "contracts/mocks/precompile-usages/MockPCUPickValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../precompile-usages/PCUPickValidatorSet.sol\";\n\ncontract MockPCUPickValidatorSet is PCUPickValidatorSet {\n  address internal _precompileSortValidatorAddress;\n\n  constructor(address _precompile) {\n    setPrecompileSortValidatorAddress(_precompile);\n  }\n\n  function setPrecompileSortValidatorAddress(address _addr) public {\n    _precompileSortValidatorAddress = _addr;\n  }\n\n  function precompilePickValidatorSetAddress() public view override returns (address) {\n    return _precompileSortValidatorAddress;\n  }\n\n  function callPrecompile(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) public view returns (address[] memory _result) {\n    (_result, ) = _pcPickValidatorSet(\n      _candidates,\n      _weights,\n      _trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n  }\n}\n"
    },
    "contracts/mocks/ronin/MockRoninGatewayV2Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../ronin/gateway/RoninGatewayV2.sol\";\n\ncontract MockRoninGatewayV2Extended is RoninGatewayV2 {\n  /*\n   * @dev Returns the vote weight for a deposit based on its corressponding hash.\n   */\n  function getDepositVoteWeight(\n    uint256 _chainId,\n    uint256 _depositId,\n    bytes32 _hash\n  ) external view returns (uint256, uint256) {\n    return _getVoteWeight(depositVote[_chainId][_depositId], _hash);\n  }\n\n  /**\n   * @dev Returns the vote weight for a mainchain withdrew acknowledgement based on its corressponding hash.\n   */\n  function getMainchainWithdrewVoteWeight(uint256 _withdrawalId, bytes32 _hash)\n    external\n    view\n    returns (uint256, uint256)\n  {\n    return _getVoteWeight(mainchainWithdrewVote[_withdrawalId], _hash);\n  }\n\n  /**\n   * @dev Returns the vote weight for a withdraw stats based on its corressponding hash.\n   */\n  function getWithdrawalStatVoteWeight(uint256 _withdrawalId, bytes32 _hash) external view returns (uint256, uint256) {\n    return _getVoteWeight(withdrawalStatVote[_withdrawalId], _hash);\n  }\n}\n"
    },
    "contracts/mocks/MockTransferFallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../extensions/RONTransferHelper.sol\";\n\ncontract MockPaymentFallback {\n  event SafeReceived(address indexed sender, uint256 value);\n\n  /// @dev Fallback function accepts ether transactions.\n  receive() external payable {\n    emit SafeReceived(msg.sender, msg.value);\n  }\n}\n\ncontract MockPaymentFallbackExpensive {\n  uint[] public array;\n  event SafeReceived(address indexed sender, uint256 value);\n\n  constructor() {\n    array.push(0);\n  }\n\n  /// @dev Fallback function accepts ether transactions and set non-zero value to a zero value slot.\n  receive() external payable {\n    array.push(block.number);\n    emit SafeReceived(msg.sender, msg.value);\n  }\n}\n\ncontract MockTransfer is RONTransferHelper {\n  uint256 public track;\n\n  constructor() payable {}\n\n  function fooTransfer(\n    address payable _recipient,\n    uint256 _amount,\n    uint256 _gas\n  ) external {\n    if (_unsafeSendRON(_recipient, _amount, _gas)) {\n      track++;\n    }\n  }\n}\n"
    },
    "contracts/mocks/forwarder/MockForwarderTarget.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/RONTransferHelper.sol\";\n\ncontract MockForwarderTarget is RONTransferHelper {\n  address public owner;\n  uint256 public data;\n\n  event TargetWithdrawn(address indexed _origin, address indexed _caller, address indexed _recipient);\n\n  error ErrIntentionally();\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"MockForwarderContract: only owner can call method\");\n    _;\n  }\n\n  fallback() external payable {\n    _fallback();\n  }\n\n  receive() external payable {\n    _fallback();\n  }\n\n  constructor(address _owner, uint256 _data) payable {\n    owner = _owner;\n    data = _data;\n  }\n\n  function foo(uint256 _data) external onlyOwner {\n    data = _data;\n  }\n\n  function fooPayable(uint256 _data) external payable onlyOwner {\n    data = _data;\n  }\n\n  function fooSilentRevert() external view onlyOwner {\n    revert();\n  }\n\n  function fooCustomErrorRevert() external view onlyOwner {\n    revert ErrIntentionally();\n  }\n\n  function fooRevert() external view onlyOwner {\n    revert(\"MockForwarderContract: revert intentionally\");\n  }\n\n  function getBalance() external view returns (uint256) {\n    return address(this).balance;\n  }\n\n  function withdrawAll() external onlyOwner {\n    emit TargetWithdrawn(tx.origin, msg.sender, msg.sender);\n    _transferRON(payable(msg.sender), address(this).balance);\n  }\n\n  function _fallback() private pure {\n    revert(\"MockForwardTarget: hello from fallback\");\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}