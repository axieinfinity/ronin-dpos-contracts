{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/extensions/collections/HasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { HasProxyAdmin } from \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasContracts.sol\";\nimport { IdentityGuard } from \"../../utils/IdentityGuard.sol\";\nimport { ErrUnexpectedInternalCall } from \"../../utils/CommonErrors.sol\";\n\n/**\n * @title HasContracts\n * @dev A contract that provides functionality to manage multiple contracts with different roles.\n */\nabstract contract HasContracts is HasProxyAdmin, IHasContracts, IdentityGuard {\n  /// @dev value is equal to keccak256(\"@ronin.dpos.collections.HasContracts.slot\") - 1\n  bytes32 private constant _STORAGE_SLOT = 0xdea3103d22025c269050bea94c0c84688877f12fa22b7e6d2d5d78a9a49aa1cb;\n\n  /**\n   * @dev Modifier to restrict access to functions only to contracts with a specific role.\n   * @param contractType The contract type that allowed to call\n   */\n  modifier onlyContract(ContractType contractType) virtual {\n    _requireContract(contractType);\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function setContract(ContractType contractType, address addr) external virtual onlyAdmin {\n    _requireHasCode(addr);\n    _setContract(contractType, addr);\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function getContract(ContractType contractType) public view returns (address contract_) {\n    contract_ = _getContractMap()[uint8(contractType)];\n    if (contract_ == address(0)) revert ErrContractTypeNotFound(contractType);\n  }\n\n  /**\n   * @dev Internal function to set the address of a contract with a specific role.\n   * @param contractType The contract type of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function _setContract(ContractType contractType, address addr) internal virtual {\n    _getContractMap()[uint8(contractType)] = addr;\n    emit ContractUpdated(contractType, addr);\n  }\n\n  /**\n   * @dev Internal function to access the mapping of contract addresses with roles.\n   * @return contracts_ The mapping of contract addresses with roles.\n   */\n  function _getContractMap() private pure returns (mapping(uint8 => address) storage contracts_) {\n    assembly {\n      contracts_.slot := _STORAGE_SLOT\n    }\n  }\n\n  /**\n   * @dev Internal function to check if the calling contract has a specific role.\n   * @param contractType The contract type that the calling contract must have.\n   * @dev Throws an error if the calling contract does not have the specified role.\n   */\n  function _requireContract(ContractType contractType) private view {\n    if (msg.sender != getContract(contractType)) {\n      revert ErrUnexpectedInternalCall(msg.sig, contractType, msg.sender);\n    }\n  }\n}\n"
    },
    "contracts/extensions/collections/HasProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../utils/CommonErrors.sol\";\n\nabstract contract HasProxyAdmin {\n  // bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n  bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  modifier onlyAdmin() {\n    _requireAdmin();\n    _;\n  }\n\n  /**\n   * @dev Returns proxy admin.\n   */\n  function _getAdmin() internal view virtual returns (address) {\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  function _requireAdmin() internal view {\n    if (msg.sender != _getAdmin()) revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\n  }\n}\n"
    },
    "contracts/extensions/consumers/PercentageConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract PercentageConsumer {\n  uint256 internal constant _MAX_PERCENTAGE = 100_00;\n}\n"
    },
    "contracts/extensions/TransparentUpgradeableProxyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract TransparentUpgradeableProxyV2 is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n\n  /**\n   * @dev Calls a function from the current implementation as specified by `_data`, which should be an encoded function call.\n   *\n   * Requirements:\n   * - Only the admin can call this function.\n   *\n   * Note: The proxy admin is not allowed to interact with the proxy logic through the fallback function to avoid\n   * triggering some unexpected logic. This is to allow the administrator to explicitly call the proxy, please consider\n   * reviewing the encoded data `_data` and the method which is called before using this.\n   *\n   */\n  function functionDelegateCall(bytes memory _data) public payable ifAdmin {\n    address _addr = _implementation();\n    assembly {\n      let _result := delegatecall(gas(), _addr, add(_data, 32), mload(_data), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch _result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/interfaces/collections/IHasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { ContractType } from \"../../utils/ContractType.sol\";\n\ninterface IHasContracts {\n  /// @dev Error of invalid role.\n  error ErrContractTypeNotFound(ContractType contractType);\n\n  /// @dev Emitted when a contract is updated.\n  event ContractUpdated(ContractType indexed contractType, address indexed addr);\n\n  /**\n   * @dev Returns the address of a contract with a specific role.\n   * Throws an error if no contract is set for the specified role.\n   *\n   * @param contractType The role of the contract to retrieve.\n   * @return contract_ The address of the contract with the specified role.\n   */\n  function getContract(ContractType contractType) external view returns (address contract_);\n\n  /**\n   * @dev Sets the address of a contract with a specific role.\n   * Emits the event {ContractUpdated}.\n   * @param contractType The role of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function setContract(ContractType contractType, address addr) external;\n}\n"
    },
    "contracts/interfaces/IBridgeAdminProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { BridgeOperatorsBallot } from \"../libraries/BridgeOperatorsBallot.sol\";\n\ninterface IBridgeAdminProposal {\n  /// @dev Emitted when the bridge operators are approved.\n  event BridgeOperatorsApproved(uint256 period, uint256 epoch, address[] operators);\n\n  /**\n   * @dev Returns the last voted block of the bridge voter.\n   */\n  function lastVotedBlock(address bridgeVoter) external view returns (uint256);\n\n  /**\n   * @dev Returns the synced bridge operator set info.\n   */\n  function lastSyncedBridgeOperatorSetInfo()\n    external\n    view\n    returns (BridgeOperatorsBallot.BridgeOperatorSet memory bridgeOperatorSetInfo);\n}\n"
    },
    "contracts/interfaces/IMaintenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IMaintenance {\n  /**\n   * @dev Error thrown when attempting to schedule an already scheduled event.\n   */\n  error ErrAlreadyScheduled();\n\n  /**\n   * @dev Error thrown when referring to a non-existent schedule.\n   */\n  error ErrUnexistedSchedule();\n\n  /**\n   * @dev Error thrown when the end block of a schedule is out of range.\n   */\n  error ErrEndBlockOutOfRange();\n\n  /**\n   * @dev Error thrown when the start block of a schedule is out of range.\n   */\n  error ErrStartBlockOutOfRange();\n\n  /**\n   * @dev Error thrown when attempting to initiate maintenance while already in maintenance mode.\n   */\n  error ErrAlreadyOnMaintenance();\n\n  /**\n   * @dev Error thrown when attempting an action before the cooldown period has ended.\n   */\n  error ErrCooldownTimeNotYetEnded();\n\n  /**\n   * @dev Error thrown when the total number of schedules exceeds the limit.\n   */\n  error ErrTotalOfSchedulesExceeded();\n\n  /**\n   * @dev Error thrown when an invalid maintenance duration is specified.\n   */\n  error ErrInvalidMaintenanceDuration();\n\n  /**\n   * @dev Error thrown when an invalid maintenance duration configuration is provided.\n   */\n  error ErrInvalidMaintenanceDurationConfig();\n\n  /**\n   * @dev Error thrown when an invalid offset is specified to start the schedule configurations.\n   */\n  error ErrInvalidOffsetToStartScheduleConfigs();\n\n  struct Schedule {\n    uint256 from;\n    uint256 to;\n    uint256 lastUpdatedBlock;\n    uint256 requestTimestamp;\n  }\n\n  /// @dev Emitted when a maintenance is scheduled.\n  event MaintenanceScheduled(address indexed consensusAddr, Schedule);\n  /// @dev Emitted when a schedule of maintenance is cancelled.\n  event MaintenanceScheduleCancelled(address indexed consensusAddr);\n  /// @dev Emitted when the maintenance config is updated.\n  event MaintenanceConfigUpdated(\n    uint256 minMaintenanceDurationInBlock,\n    uint256 maxMaintenanceDurationInBlock,\n    uint256 minOffsetToStartSchedule,\n    uint256 maxOffsetToStartSchedule,\n    uint256 maxSchedules,\n    uint256 cooldownSecsToMaintain\n  );\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr` maintained at the block number `_block`.\n   */\n  function checkMaintained(address _consensusAddr, uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr` maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks.\n   */\n  function checkMaintainedInBlockRange(\n    address _consensusAddr,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool);\n\n  /**\n   * @dev Returns the bool array indicating the validators maintained at block number `_block` or not.\n   */\n  function checkManyMaintained(address[] calldata _addrList, uint256 _block) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns a bool array indicating the validators maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks or not.\n   */\n  function checkManyMaintainedInBlockRange(\n    address[] calldata _addrList,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr` has scheduled.\n   */\n  function checkScheduled(address _consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr`\n   */\n  function checkCooldownEnded(address _consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns the detailed schedule of the validator `_consensusAddr`.\n   */\n  function getSchedule(address _consensusAddr) external view returns (Schedule memory);\n\n  /**\n   * @dev Returns the total of current schedules.\n   */\n  function totalSchedule() external view returns (uint256 _count);\n\n  /**\n   * @dev Sets the duration restriction, start time restriction, and max allowed for maintenance.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The max duration is larger than the min duration.\n   * - The max offset is larger than the min offset.\n   *\n   * Emits the event `MaintenanceConfigUpdated`.\n   *\n   */\n  function setMaintenanceConfig(\n    uint256 _minMaintenanceDurationInBlock,\n    uint256 _maxMaintenanceDurationInBlock,\n    uint256 _minOffsetToStartSchedule,\n    uint256 _maxOffsetToStartSchedule,\n    uint256 _maxSchedules,\n    uint256 _cooldownSecsToMaintain\n  ) external;\n\n  /**\n   * @dev Returns the min duration for maintenance in block.\n   */\n  function minMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the max duration for maintenance in block.\n   */\n  function maxMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev The offset to the min block number that the schedule can start\n   */\n  function minOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev The offset to the max block number that the schedule can start\n   */\n  function maxOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev Returns the max number of scheduled maintenances.\n   */\n  function maxSchedule() external view returns (uint256);\n\n  /**\n   * @dev Schedules for maintenance from `_startedAtBlock` to `_startedAtBlock`.\n   *\n   * Requirements:\n   * - The candidate `_consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `_consensusAddr`.\n   * - The candidate `_consensusAddr` has no schedule yet or the previous is done.\n   * - The total number of schedules is not larger than `maxSchedules()`.\n   * - The start block must be at least `minOffsetToStartSchedule()` and at most `maxOffsetToStartSchedule()` blocks from the current block.\n   * - The end block is larger than the start block.\n   * - The scheduled duration is larger than the `minMaintenanceDurationInBlock()` and less than the `maxMaintenanceDurationInBlock()`.\n   * - The start block is at the start of an epoch.\n   * - The end block is at the end of an epoch.\n   *\n   * Emits the event `MaintenanceScheduled`.\n   *\n   */\n  function schedule(address _consensusAddr, uint256 _startedAtBlock, uint256 _endedAtBlock) external;\n\n  /**\n   * @dev Cancel the schedule of maintenance for the `_consensusAddr`.\n   *\n   * Requirements:\n   * - The candidate `_consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `_consensusAddr`.\n   * - A schedule for the `_consensusAddr` must be existent and not executed yet.\n   *\n   * Emits the event `MaintenanceScheduleCancelled`.\n   */\n  function cancelSchedule(address _consensusAddr) external;\n}\n"
    },
    "contracts/interfaces/IProfile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../utils/RoleAccess.sol\";\n\ninterface IProfile {\n  struct CandidateProfile {\n    /**\n     * @dev Primary key of the profile, use for backward querying.\n     *\n     * {Staking} Contract: index of pool\n     * {RoninValidatorSet} Contract: index of almost all data related to a validator\n     *\n     */\n    address id;\n    /// @dev Consensus address.\n    address consensus;\n    /// @dev Pool admin address.\n    address admin;\n    /// @dev Treasury address.\n    address payable treasury;\n    /// @dev Address to voting proposal.\n    address governor;\n    /// @dev Public key for fast finality.\n    bytes pubkey;\n  }\n\n  /// @dev Event emitted when a profile with `id` is added.\n  event ProfileAdded(address indexed id);\n  /// @dev Event emitted when a address in a profile is changed.\n  event ProfileAddressChanged(address indexed id, RoleAccess indexed addressType);\n\n  /// @dev Error of already existed profile.\n  error ErrExistentProfile();\n  /// @dev Error of non existed profile.\n  error ErrNonExistentProfile();\n\n  /// @dev Getter to query full `profile` from `id` address.\n  function getId2Profile(address id) external view returns (CandidateProfile memory profile);\n\n  /**\n   * @notice Add a new profile.\n   *\n   * @dev Requirements:\n   * - The profile must not be existent before.\n   * - Only contract admin can call this method.\n   */\n  function addNewProfile(CandidateProfile memory profile) external;\n}\n"
    },
    "contracts/interfaces/IQuorum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IQuorum {\n  /// @dev Emitted when the threshold is updated\n  event ThresholdUpdated(\n    uint256 indexed nonce,\n    uint256 indexed numerator,\n    uint256 indexed denominator,\n    uint256 previousNumerator,\n    uint256 previousDenominator\n  );\n\n  /**\n   * @dev Returns the threshold.\n   */\n  function getThreshold() external view returns (uint256 _num, uint256 _denom);\n\n  /**\n   * @dev Checks whether the `_voteWeight` passes the threshold.\n   */\n  function checkThreshold(uint256 _voteWeight) external view returns (bool);\n\n  /**\n   * @dev Returns the minimum vote weight to pass the threshold.\n   */\n  function minimumVoteWeight() external view returns (uint256);\n\n  /**\n   * @dev Sets the threshold.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `ThresholdUpdated` event.\n   *\n   */\n  function setThreshold(\n    uint256 _numerator,\n    uint256 _denominator\n  ) external returns (uint256 _previousNum, uint256 _previousDenom);\n}\n"
    },
    "contracts/interfaces/IRoninTrustedOrganization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IQuorum.sol\";\n\ninterface IRoninTrustedOrganization is IQuorum {\n  /**\n   * @dev Error indicating that a query for a duplicate entry was made.\n   */\n  error ErrQueryForDupplicated();\n\n  /**\n   * @dev Error indicating that a query was made for a non-existent consensus address.\n   */\n  error ErrQueryForNonExistentConsensusAddress();\n\n  /**\n   * @dev Error indicating that a bridge voter has already been added.\n   * @param voter The address of the bridge voter that is already added.\n   */\n  error ErrBridgeVoterIsAlreadyAdded(address voter);\n\n  /**\n   * @dev Error indicating that a governor address has already been added.\n   * @param addr The address of the governor that is already added.\n   */\n  error ErrGovernorAddressIsAlreadyAdded(address addr);\n\n  /**\n   * @dev Error indicating that a consensus address is not added.\n   * @param addr The address of the consensus contract that is not added.\n   */\n  error ErrConsensusAddressIsNotAdded(address addr);\n\n  /**\n   * @dev Error indicating that a consensus address is already added.\n   * @param addr The address of the consensus contract that is already added.\n   */\n  error ErrConsensusAddressIsAlreadyAdded(address addr);\n\n  struct TrustedOrganization {\n    // Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n    address consensusAddr;\n    // Address to voting proposal\n    address governor;\n    // Address to voting bridge operators\n    address bridgeVoter;\n    // Its Weight\n    uint256 weight;\n    // The block that the organization was added\n    uint256 addedBlock;\n  }\n\n  /// @dev Emitted when the trusted organization is added.\n  event TrustedOrganizationsAdded(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is updated.\n  event TrustedOrganizationsUpdated(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is removed.\n  event TrustedOrganizationsRemoved(address[] orgs);\n\n  /**\n   * @dev Adds a list of addresses into the trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   * - The field `addedBlock` should be blank.\n   *\n   * Emits the event `TrustedOrganizationAdded` once an organization is added.\n   *\n   */\n  function addTrustedOrganizations(TrustedOrganization[] calldata) external;\n\n  /**\n   * @dev Updates weights for a list of existent trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   *\n   * Emits the `TrustedOrganizationUpdated` event.\n   *\n   */\n  function updateTrustedOrganizations(TrustedOrganization[] calldata _list) external;\n\n  /**\n   * @dev Removes a list of addresses from the trusted organization.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `TrustedOrganizationRemoved` once an organization is removed.\n   *\n   * @param _consensusAddrs The list of consensus addresses linked to corresponding trusted organization that to be removed.\n   */\n  function removeTrustedOrganizations(address[] calldata _consensusAddrs) external;\n\n  /**\n   * @dev Returns total weights.\n   */\n  function totalWeight() external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a consensus.\n   */\n  function getConsensusWeight(address _consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a governor.\n   */\n  function getGovernorWeight(address _governor) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a bridge voter.\n   */\n  function getBridgeVoterWeight(address _addr) external view returns (uint256);\n\n  /**\n   * @dev Returns the weights of a list of consensus addresses.\n   */\n  function getConsensusWeights(address[] calldata _list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of governor addresses.\n   */\n  function getGovernorWeights(address[] calldata _list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of bridge voter addresses.\n   */\n  function getBridgeVoterWeights(address[] calldata _list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns total weights of the consensus list.\n   */\n  function sumConsensusWeight(address[] calldata _list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns total weights of the governor list.\n   */\n  function sumGovernorWeight(address[] calldata _list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns total weights of the bridge voter list.\n   */\n  function sumBridgeVoterWeight(address[] calldata _list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns the trusted organization at `_index`.\n   */\n  function getTrustedOrganizationAt(uint256 _index) external view returns (TrustedOrganization memory);\n\n  /**\n   * @dev Returns the number of trusted organizations.\n   */\n  function countTrustedOrganization() external view returns (uint256);\n\n  /**\n   * @dev Returns all of the trusted organizations.\n   */\n  function getAllTrustedOrganizations() external view returns (TrustedOrganization[] memory);\n\n  /**\n   * @dev Returns the trusted organization by consensus address.\n   *\n   * Reverts once the consensus address is non-existent.\n   */\n  function getTrustedOrganization(address _consensusAddr) external view returns (TrustedOrganization memory);\n}\n"
    },
    "contracts/interfaces/slash-indicator/IBaseSlash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IBaseSlash {\n  enum SlashType {\n    UNKNOWN,\n    UNAVAILABILITY_TIER_1,\n    UNAVAILABILITY_TIER_2,\n    DOUBLE_SIGNING,\n    BRIDGE_VOTING,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_1,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_2,\n    UNAVAILABILITY_TIER_3,\n    FAST_FINALITY\n  }\n\n  /// @dev Error thrown when evidence has already been submitted.\n  error ErrEvidenceAlreadySubmitted();\n\n  /// @dev Emitted when the validator is slashed.\n  event Slashed(address indexed validator, SlashType slashType, uint256 period);\n}\n"
    },
    "contracts/interfaces/slash-indicator/ICreditScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ICreditScore {\n  /**\n   * @dev Error thrown when an invalid credit score configuration is provided.\n   */\n  error ErrInvalidCreditScoreConfig();\n\n  /**\n   * @dev Error thrown when an invalid cut-off percentage configuration is provided.\n   */\n  error ErrInvalidCutOffPercentageConfig();\n\n  /**\n   * @dev Error thrown when the caller's credit score is insufficient to bail out a situation.\n   */\n  error ErrInsufficientCreditScoreToBailOut();\n\n  /**\n   * @dev Error thrown when a validator has previously bailed out.\n   */\n  error ErrValidatorHasBailedOutPreviously();\n\n  /**\n   * @dev Error thrown when the caller must be jailed in the current period.\n   */\n  error ErrCallerMustBeJailedInTheCurrentPeriod();\n\n  /// @dev Emitted when the configs to credit score is updated. See the method `setCreditScoreConfigs` for param details.\n  event CreditScoreConfigsUpdated(\n    uint256 gainCreditScore,\n    uint256 maxCreditScore,\n    uint256 bailOutCostMultiplier,\n    uint256 cutOffPercentageAfterBailout\n  );\n  /// @dev Emitted the credit score of validators is updated.\n  event CreditScoresUpdated(address[] validators, uint256[] creditScores);\n  /// @dev Emitted when a validator bailed out of jail.\n  event BailedOut(address indexed validator, uint256 period, uint256 usedCreditScore);\n\n  /**\n   * @dev Updates the credit score for the validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function updateCreditScores(address[] calldata _validators, uint256 _period) external;\n\n  /**\n   * @dev Resets the credit score for the revoked validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function execResetCreditScores(address[] calldata _validators) external;\n\n  /**\n   * @dev A slashed validator use this method to get out of jail.\n   *\n   * Requirements:\n   * - The `_consensusAddr` must be a validator.\n   * - Only validator's admin can call this method.\n   *\n   * Emits the event `BailedOut`.\n   *\n   */\n  function bailOut(address _consensusAddr) external;\n\n  /**\n   * @dev Sets the configs to credit score.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CreditScoreConfigsUpdated`.\n   *\n   * @param _gainScore The score to gain per period.\n   * @param _maxScore The max number of credit score that a validator can hold.\n   * @param _bailOutMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @param _cutOffPercentage The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) external;\n\n  /**\n   * @dev Returns the configs related to credit score.\n   *\n   * @return _gainCreditScore The score to gain per period.\n   * @return _maxCreditScore The max number of credit score that a validator can hold.\n   * @return _bailOutCostMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @return _cutOffPercentageAfterBailout The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function getCreditScoreConfigs()\n    external\n    view\n    returns (\n      uint256 _gainCreditScore,\n      uint256 _maxCreditScore,\n      uint256 _bailOutCostMultiplier,\n      uint256 _cutOffPercentageAfterBailout\n    );\n\n  /**\n   * @dev Returns the current credit score of the validator.\n   */\n  function getCreditScore(address _validator) external view returns (uint256);\n\n  /**\n   * @dev Returns the current credit score of a list of validators.\n   */\n  function getManyCreditScores(address[] calldata _validators) external view returns (uint256[] memory _resultList);\n\n  /**\n   * @dev Returns the whether the `_validator` has been bailed out at the `_period`.\n   */\n  function checkBailedOutAtPeriod(address _validator, uint256 _period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashBridgeOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashBridgeOperator is IBaseSlash {\n  /**\n   * @dev Error thrown when invalid ratios are provided.\n   */\n  error ErrInvalidRatios();\n\n  /**\n   * @dev Emitted when the configs to slash bridge operator is updated. See the method\n   * `getBridgeOperatorSlashingConfigs` for param details.\n   */\n  event BridgeOperatorSlashingConfigsUpdated(\n    uint256 missingVotesRatioTier1,\n    uint256 missingVotesRatioTier2,\n    uint256 jailDurationForMissingVotesRatioTier2,\n    uint256 skipBridgeOperatorSlashingThreshold\n  );\n\n  /**\n   * @dev Acknowledges bridge operator slash and emit `Slashed` event correspondingly.\n   * @param _tier The tier of the slash, in value of {1, 2}, corresponding to `SlashType.BRIDGE_OPERATOR_MISSING_VOTE_TIER_1`\n   * and `SlashType.BRIDGE_OPERATOR_MISSING_VOTE_TIER_2`\n   *\n   * Requirements:\n   * - Only validator contract can invoke this method.\n   * - Should be called only at the end of period.\n   * - Should be called only when there is slash of bridge operator.\n   *\n   * Emits the event `Slashed`.\n   */\n  function execSlashBridgeOperator(address _consensusAddr, uint256 _tier, uint256 _period) external;\n\n  /**\n   * @dev Returns the configs related to bridge operator slashing.\n   *\n   * @return _missingVotesRatioTier1 The bridge reward will be deprecated if (s)he missed more than this ratio.\n   * @return _missingVotesRatioTier2 The bridge reward and mining reward will be deprecated and the corresponding\n   * block producer will be put in jail if (s)he misses more than this ratio.\n   * @return _jailDurationForMissingVotesRatioTier2 The number of blocks to jail the corresponding block producer when\n   * its bridge operator is slashed tier-2.\n   * @return _skipBridgeOperatorSlashingThreshold The threshold to skip slashing the bridge operator in case the total\n   * number of votes in the bridge is too small.\n   *\n   */\n  function getBridgeOperatorSlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _missingVotesRatioTier1,\n      uint256 _missingVotesRatioTier2,\n      uint256 _jailDurationForMissingVotesRatioTier2,\n      uint256 _skipBridgeOperatorSlashingThreshold\n    );\n\n  /**\n   * @dev Sets the configs to slash bridge operators.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeOperatorSlashingConfigsUpdated`.\n   *\n   * @param _ratioTier1 The bridge reward will be deprecated if (s)he missed more than this ratio. Values 0-10,000 map\n   * to 0%-100%.\n   * @param _ratioTier2 The bridge reward and mining reward will be deprecated and the corresponding block producer will\n   * be put in jail if (s)he misses more than this ratio. Values 0-10,000 map to 0%-100%.\n   * @param _jailDurationTier2 The number of blocks to jail the corresponding block producer when its bridge operator is\n   * slashed tier-2.\n   * @param _skipSlashingThreshold The threshold to skip slashing the bridge operator in case the total number of votes\n   * in the bridge is too small.\n   *\n   */\n  function setBridgeOperatorSlashingConfigs(\n    uint256 _ratioTier1,\n    uint256 _ratioTier2,\n    uint256 _jailDurationTier2,\n    uint256 _skipSlashingThreshold\n  ) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashBridgeVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashBridgeVoting is IBaseSlash {\n  /**\n   * @dev Error thrown when an invalid slash is encountered.\n   */\n  error ErrInvalidSlash();\n\n  /**\n   * @dev Emitted when the configs to slash bridge voting is updated. See the method `getBridgeVotingSlashingConfigs` for param\n   * details.\n   */\n  event BridgeVotingSlashingConfigsUpdated(uint256 bridgeVotingThreshold, uint256 bridgeVotingSlashAmount);\n\n  /**\n   * @dev Slashes for bridge voter governance.\n   *\n   * Emits the event `Slashed`.\n   */\n  function slashBridgeVoting(address _consensusAddr) external;\n\n  /**\n   * @dev Returns the configs related to bridge voting slashing.\n   *\n   * @return _bridgeVotingThreshold The threshold to slash when a trusted organization does not vote for bridge\n   * operators.\n   * @return _bridgeVotingSlashAmount The amount of RON to slash bridge voting.\n   *\n   */\n  function getBridgeVotingSlashingConfigs()\n    external\n    view\n    returns (uint256 _bridgeVotingThreshold, uint256 _bridgeVotingSlashAmount);\n\n  /**\n   * @dev Sets the configs to slash bridge voting.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeVotingSlashingConfigsUpdated`.\n   *\n   * @param _threshold The threshold to slash when a trusted organization does not vote for bridge operators.\n   * @param _slashAmount The amount of RON to slash bridge voting.\n   *\n   */\n  function setBridgeVotingSlashingConfigs(uint256 _threshold, uint256 _slashAmount) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashDoubleSign is IBaseSlash {\n  /**\n   * @dev Emitted when the configs to slash double sign is updated. See the method `getDoubleSignSlashingConfigs`\n   * for param details.\n   */\n  event DoubleSignSlashingConfigsUpdated(\n    uint256 slashDoubleSignAmount,\n    uint256 doubleSigningJailUntilBlock,\n    uint256 doubleSigningOffsetLimitBlock\n  );\n\n  /**\n   * @dev Slashes for double signing.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` if the double signing evidence of the two headers valid.\n   */\n  function slashDoubleSign(address _validatorAddr, bytes calldata _header1, bytes calldata _header2) external;\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return _slashDoubleSignAmount The amount of RON to slash double sign.\n   * @return _doubleSigningJailUntilBlock The block number that the punished validator will be jailed until, due to\n   * double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function getDoubleSignSlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _slashDoubleSignAmount,\n      uint256 _doubleSigningJailUntilBlock,\n      uint256 _doubleSigningOffsetLimitBlock\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `DoubleSignSlashingConfigsUpdated`.\n   *\n   * @param _slashAmount The amount of RON to slash double sign.\n   * @param _jailUntilBlock The block number that the punished validator will be jailed until, due to double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _doubleSigningOffsetLimitBlock\n  ) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashFastFinality is IBaseSlash {\n  /**\n   * @dev Emitted when the configs to slash fast finality is updated. See the method `getFastFinalitySlashingConfigs`\n   * for param details.\n   */\n  event FastFinalitySlashingConfigsUpdated(uint256 slashFastFinalityAmount, uint256 fastFinalityJailUntilBlock);\n\n  /**\n   * @dev Slashes for fast finality.\n   *\n   * Requirements:\n   * - Only whitelisted addresses are allowed to call.\n   *\n   * Emits the event `Slashed` if the fast finality evidence of the two headers valid.\n   */\n  function slashFastFinality(\n    address consensusAddr,\n    bytes calldata voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] calldata targetBlockHash,\n    bytes[][2] calldata listOfPublicKey,\n    bytes[2] calldata aggregatedSignature\n  ) external;\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return slashFastFinalityAmount The amount of RON to slash fast finality.\n   * @return fastFinalityJailUntilBlock The block number that the punished validator will be jailed until, due to\n   * malicious fast finality.\n   */\n  function getFastFinalitySlashingConfigs()\n    external\n    view\n    returns (uint256 slashFastFinalityAmount, uint256 fastFinalityJailUntilBlock);\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `FastFinalitySlashingConfigsUpdated`.\n   *\n   * @param slashAmount The amount of RON to slash fast finality.\n   * @param jailUntilBlock The block number that the punished validator will be jailed until, due to fast finality.\n   *\n   */\n  function setFastFinalitySlashingConfigs(uint256 slashAmount, uint256 jailUntilBlock) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashIndicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashDoubleSign.sol\";\nimport \"./ISlashBridgeVoting.sol\";\nimport \"./ISlashBridgeOperator.sol\";\nimport \"./ISlashUnavailability.sol\";\nimport \"./ICreditScore.sol\";\n\ninterface ISlashIndicator is\n  ISlashDoubleSign,\n  ISlashBridgeVoting,\n  ISlashBridgeOperator,\n  ISlashUnavailability,\n  ICreditScore\n{}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashUnavailability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashUnavailability is IBaseSlash {\n  /**\n   * @dev Error thrown when attempting to slash a validator twice or slash more than one validator in one block.\n   */\n  error ErrCannotSlashAValidatorTwiceOrSlashMoreThanOneValidatorInOneBlock();\n\n  /**\n   * @dev Emitted when the configs to slash bridge operator is updated. See the method `getUnavailabilitySlashingConfigs`\n   * for param details.\n   */\n  event UnavailabilitySlashingConfigsUpdated(\n    uint256 unavailabilityTier1Threshold,\n    uint256 unavailabilityTier2Threshold,\n    uint256 slashAmountForUnavailabilityTier2Threshold,\n    uint256 jailDurationForUnavailabilityTier2Threshold\n  );\n\n  /**\n   * @dev Returns the last block that a block producer is slashed for unavailability.\n   */\n  function lastUnavailabilitySlashedBlock() external view returns (uint256);\n\n  /**\n   * @dev Slashes for unavailability by increasing the counter of block producer `_consensusAddr`.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` when the threshold is reached.\n   *\n   */\n  function slashUnavailability(address _consensusAddr) external;\n\n  /**\n   * @dev Returns the current unavailability indicator of a block producer.\n   */\n  function currentUnavailabilityIndicator(address _validator) external view returns (uint256);\n\n  /**\n   * @dev Returns the unavailability indicator in the period `_period` of a block producer.\n   */\n  function getUnavailabilityIndicator(address _validator, uint256 _period) external view returns (uint256);\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return _unavailabilityTier1Threshold The mining reward will be deprecated, if (s)he missed more than this\n   * threshold. This threshold is applied for tier-1 and tier-3 slash.\n   * @return _unavailabilityTier2Threshold  The mining reward will be deprecated, (s)he will be put in jailed, and will\n   * be deducted self-staking if (s)he misses more than this threshold. This threshold is applied for tier-2 slash.\n   * @return _slashAmountForUnavailabilityTier2Threshold The amount of RON to deduct from self-staking of a block\n   * producer when (s)he is slashed with tier-2 or tier-3.\n   * @return _jailDurationForUnavailabilityTier2Threshold The number of blocks to jail a block producer when (s)he is\n   * slashed with tier-2 or tier-3.\n   *\n   */\n  function getUnavailabilitySlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _unavailabilityTier1Threshold,\n      uint256 _unavailabilityTier2Threshold,\n      uint256 _slashAmountForUnavailabilityTier2Threshold,\n      uint256 _jailDurationForUnavailabilityTier2Threshold\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeOperatorSlashingConfigsUpdated`.\n   *\n   * @param _tier1Threshold The mining reward will be deprecated, if (s)he missed more than this threshold.\n   * @param _tier2Threshold The mining reward will be deprecated, (s)he will be put in jailed, and will be deducted\n   * self-staking if (s)he misses more than this threshold.\n   * @param _slashAmountForTier2Threshold The amount of RON to deduct from self-staking of a block producer when (s)he\n   * is slashed tier-2.\n   * @param _jailDurationForTier2Threshold The number of blocks to jail a block producer when (s)he is slashed tier-2.\n   *\n   */\n  function setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) external;\n}\n"
    },
    "contracts/interfaces/validator/ICandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ICandidateManager {\n  struct ValidatorCandidate {\n    // Admin of the candidate\n    address admin;\n    // Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n    address consensusAddr;\n    // Address that receives mining reward of the validator\n    address payable treasuryAddr;\n    // Address of the bridge operator corresponding to the candidate\n    address ______deprecatedbridgeOperatorAddr;\n    // The percentage of reward that validators can be received, the rest goes to the delegators.\n    // Values in range [0; 100_00] stands for 0-100%\n    uint256 commissionRate;\n    // The timestamp that scheduled to revoke the candidate (no schedule=0)\n    uint256 revokingTimestamp;\n    // The deadline that the candidate must top up staking amount to keep it larger than or equal to the threshold (no deadline=0)\n    uint256 topupDeadline;\n  }\n\n  struct CommissionSchedule {\n    // The timestamp that the commission schedule gets affected (no schedule=0).\n    uint256 effectiveTimestamp;\n    // The new commission rate. Value is in range [0; 100_00], stands for 0-100%\n    uint256 commissionRate;\n  }\n\n  /// @dev Emitted when the maximum number of validator candidates is updated.\n  event MaxValidatorCandidateUpdated(uint256 threshold);\n  /// @dev Emitted when the min offset to the effective date of commission rate change is updated.\n  event MinEffectiveDaysOnwardsUpdated(uint256 numOfDays);\n  /// @dev Emitted when the validator candidate is granted.\n  event CandidateGranted(address indexed consensusAddr, address indexed treasuryAddr, address indexed admin);\n  /// @dev Emitted when the revoking timestamp of a candidate is updated.\n  event CandidateRevokingTimestampUpdated(address indexed consensusAddr, uint256 revokingTimestamp);\n  /// @dev Emitted when the topup deadline of a candidate is updated.\n  event CandidateTopupDeadlineUpdated(address indexed consensusAddr, uint256 topupDeadline);\n  /// @dev Emitted when the validator candidate is revoked.\n  event CandidatesRevoked(address[] consensusAddrs);\n\n  /// @dev Emitted when a schedule for updating commission rate is set.\n  event CommissionRateUpdateScheduled(address indexed consensusAddr, uint256 effectiveTimestamp, uint256 rate);\n  /// @dev Emitted when the commission rate of a validator is updated.\n  event CommissionRateUpdated(address indexed consensusAddr, uint256 rate);\n\n  /// @dev Error of exceeding maximum number of candidates.\n  error ErrExceedsMaxNumberOfCandidate();\n  /// @dev Error of querying for already existent candidate.\n  error ErrExistentCandidate();\n  /// @dev Error of querying for non-existent candidate.\n  error ErrNonExistentCandidate();\n  /// @dev Error of candidate admin already exists.\n  error ErrExistentCandidateAdmin(address _candidateAdminAddr);\n  /// @dev Error of treasury already exists.\n  error ErrExistentTreasury(address _treasuryAddr);\n  /// @dev Error of invalid commission rate.\n  error ErrInvalidCommissionRate();\n  /// @dev Error of invalid effective days onwards.\n  error ErrInvalidEffectiveDaysOnwards();\n  /// @dev Error of invalid min effective days onwards.\n  error ErrInvalidMinEffectiveDaysOnwards();\n  /// @dev Error of already requested revoking candidate before.\n  error ErrAlreadyRequestedRevokingCandidate();\n  /// @dev Error of commission change schedule exists.\n  error ErrAlreadyRequestedUpdatingCommissionRate();\n  /// @dev Error of trusted org cannot renounce.\n  error ErrTrustedOrgCannotRenounce();\n\n  /**\n   * @dev Returns the maximum number of validator candidate.\n   */\n  function maxValidatorCandidate() external view returns (uint256);\n\n  /**\n   * @dev Returns the minimum number of days to the effective date of commission rate change.\n   */\n  function minEffectiveDaysOnward() external view returns (uint256);\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function setMaxValidatorCandidate(uint256) external;\n\n  /**\n   * @dev Sets the minimum number of days to the effective date of commision rate change.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external;\n\n  /**\n   * @dev Grants a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateGranted`.\n   *\n   */\n  function execApplyValidatorCandidate(\n    address _admin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    uint256 _commissionRate\n  ) external;\n\n  /**\n   * @dev Requests to revoke a validator candidate in next `_secsLeft` seconds.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateRevokingTimestampUpdated`.\n   *\n   */\n  function execRequestRenounceCandidate(address, uint256 _secsLeft) external;\n\n  /**\n   * @dev Fallback function of `CandidateStaking-requestUpdateCommissionRate`.\n   *\n   * Requirements:\n   * - The method caller is the staking contract.\n   * - The `_effectiveTimestamp` must be the beginning of a UTC day, and at least from 7 days onwards\n   * - The `_rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdateScheduled`.\n   *\n   */\n  function execRequestUpdateCommissionRate(address _consensusAddr, uint256 _effectiveTimestamp, uint256 _rate) external;\n\n  /**\n   * @dev Returns whether the address is a validator (candidate).\n   */\n  function isValidatorCandidate(address _addr) external view returns (bool);\n\n  /**\n   * @dev Returns the validator candidate.\n   */\n  function getValidatorCandidates() external view returns (address[] memory);\n\n  /**\n   * @dev Returns all candidate info.\n   */\n  function getCandidateInfos() external view returns (ValidatorCandidate[] memory);\n\n  /**\n   * @dev Returns the info of a candidate.\n   */\n  function getCandidateInfo(address _candidate) external view returns (ValidatorCandidate memory);\n\n  /**\n   * @dev Returns whether the address is the candidate admin.\n   */\n  function isCandidateAdmin(address _candidate, address _admin) external view returns (bool);\n\n  /**\n   * @dev Returns the schedule of changing commission rate of a candidate address.\n   */\n  function getCommissionChangeSchedule(address _candidate) external view returns (CommissionSchedule memory);\n}\n"
    },
    "contracts/interfaces/validator/ICoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashingExecution.sol\";\n\ninterface ICoinbaseExecution is ISlashingExecution {\n  enum BlockRewardDeprecatedType {\n    UNKNOWN,\n    UNAVAILABILITY,\n    AFTER_BAILOUT\n  }\n\n  /// @dev Emitted when the validator set is updated\n  event ValidatorSetUpdated(uint256 indexed period, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated, to mirror the in-jail and maintaining status of the validator.\n  event BlockProducerSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated.\n  event BridgeOperatorSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] bridgeOperators);\n\n  /// @dev Emitted when the reward of the block producer is deprecated.\n  event BlockRewardDeprecated(\n    address indexed coinbaseAddr,\n    uint256 rewardAmount,\n    BlockRewardDeprecatedType deprecatedType\n  );\n  /// @dev Emitted when the block reward is submitted.\n  event BlockRewardSubmitted(address indexed coinbaseAddr, uint256 submittedAmount, uint256 bonusAmount);\n\n  /// @dev Emitted when the block producer reward is distributed.\n  event MiningRewardDistributed(address indexed consensusAddr, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the block producer reward.\n  event MiningRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the bridge operator reward is distributed.\n  event BridgeOperatorRewardDistributed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipientAddr,\n    uint256 amount\n  );\n  /// @dev Emitted when the contract fails when distributing the bridge operator reward.\n  event BridgeOperatorRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the fast finality reward is distributed.\n  event FastFinalityRewardDistributed(address indexed consensusAddr, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the fast finality reward.\n  event FastFinalityRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the amount of RON reward is distributed to staking contract.\n  event StakingRewardDistributed(uint256 totalAmount, address[] consensusAddrs, uint256[] amounts);\n  /// @dev Emitted when the contracts fails when distributing the amount of RON to the staking contract.\n  event StakingRewardDistributionFailed(\n    uint256 totalAmount,\n    address[] consensusAddrs,\n    uint256[] amounts,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the epoch is wrapped up.\n  event WrappedUpEpoch(uint256 indexed periodNumber, uint256 indexed epochNumber, bool periodEnding);\n\n  /// @dev Error of only allowed at the end of epoch\n  error ErrAtEndOfEpochOnly();\n  /// @dev Error of query for already wrapped up epoch\n  error ErrAlreadyWrappedEpoch();\n\n  /**\n   * @dev Submits reward of the current block.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDeprecated` if the coinbase is slashed or no longer be a block producer.\n   * Emits the event `BlockRewardSubmitted` for the valid call.\n   *\n   */\n  function submitBlockReward() external payable;\n\n  /**\n   * @dev Wraps up the current epoch.\n   *\n   * Requirements:\n   * - The method must be called when the current epoch is ending.\n   * - The epoch is not wrapped yet.\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDistributed` when some validator has reward distributed.\n   * Emits the event `StakingRewardDistributed` when some staking pool has reward distributed.\n   * Emits the event `BlockProducerSetUpdated` when the epoch is wrapped up.\n   * Emits the event `BridgeOperatorSetUpdated` when the epoch is wrapped up at period ending.\n   * Emits the event `ValidatorSetUpdated` when the epoch is wrapped up at period ending, and the validator set gets updated.\n   * Emits the event `WrappedUpEpoch`.\n   *\n   */\n  function wrapUpEpoch() external payable;\n}\n"
    },
    "contracts/interfaces/validator/IEmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IEmergencyExit {\n  /// @dev Emitted when the fund is locked from an emergency exit request\n  event EmergencyExitRequested(address indexed consensusAddr, uint256 lockedAmount);\n  /// @dev Emitted when the fund that locked from an emergency exit request is transferred to the recipient.\n  event EmergencyExitLockedFundReleased(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount\n  );\n  /// @dev Emitted when the fund that locked from an emergency exit request is failed to transferred back.\n  event EmergencyExitLockedFundReleasingFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the emergency exit locked amount is updated.\n  event EmergencyExitLockedAmountUpdated(uint256 amount);\n  /// @dev Emitted when the emergency expiry duration is updated.\n  event EmergencyExpiryDurationUpdated(uint256 amount);\n\n  /// @dev Error of already requested emergency exit before.\n  error ErrAlreadyRequestedEmergencyExit();\n\n  /**\n   * @dev Returns the amount of RON to lock from a consensus address.\n   */\n  function emergencyExitLockedAmount() external returns (uint256);\n\n  /**\n   * @dev Returns the duration that an emergency request is expired and the fund will be recycled.\n   */\n  function emergencyExpiryDuration() external returns (uint256);\n\n  /**\n   * @dev Sets the amount of RON to lock from a consensus address.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedAmountUpdated`.\n   *\n   */\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external;\n\n  /**\n   * @dev Sets the duration that an emergency request is expired and the fund will be recycled.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExpiryDurationUpdated`.\n   *\n   */\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external;\n\n  /**\n   * @dev Unlocks fund for emergency exit request.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedFundReleased` if the fund is successfully unlocked.\n   * Emits the event `EmergencyExitLockedFundReleasingFailed` if the fund is failed to unlock.\n   *\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(address _consensusAddr, address payable _recipient) external;\n\n  /**\n   * @dev Fallback function of `IStaking-requestEmergencyExit`.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   */\n  function execEmergencyExit(address _consensusAddr, uint256 _secLeftToRevoke) external;\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ICommonInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IJailingInfo.sol\";\nimport \"./ITimingInfo.sol\";\nimport \"./IValidatorInfoV2.sol\";\n\ninterface ICommonInfo is ITimingInfo, IJailingInfo, IValidatorInfoV2 {\n  struct EmergencyExitInfo {\n    uint256 lockedAmount;\n    // The timestamp that this locked amount will be recycled to staking vesting contract\n    uint256 recyclingAt;\n  }\n\n  /// @dev Emitted when the deprecated reward is withdrawn.\n  event DeprecatedRewardRecycled(address indexed recipientAddr, uint256 amount);\n  /// @dev Emitted when the deprecated reward withdrawal is failed\n  event DeprecatedRewardRecycleFailed(address indexed recipientAddr, uint256 amount, uint256 balance);\n\n  /// @dev Error thrown when receives RON from neither staking vesting contract nor staking contract\n  error ErrUnauthorizedReceiveRON();\n  /// @dev Error thrown when queries for a non existent info.\n  error NonExistentRecyclingInfo();\n\n  /**\n   * @dev Returns the total deprecated reward, which includes reward that is not sent for slashed validators and unsastified bridge operators\n   */\n  function totalDeprecatedReward() external view returns (uint256);\n\n  /**\n   * @dev Returns the emergency exit request.\n   */\n  function getEmergencyExitInfo(address _consensusAddr) external view returns (EmergencyExitInfo memory);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IJailingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IJailingInfo {\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkJailed(address) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeft(\n    address _addr\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) at a specific block.\n   */\n  function checkJailedAtBlock(address _addr, uint256 _blockNum) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail at a specific block and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeftAtBlock(\n    address _addr,\n    uint256 _blockNum\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validators are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkManyJailed(address[] calldata) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during the current period.\n   */\n  function checkMiningRewardDeprecated(address _blockProducer) external view returns (bool);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during a specific period.\n   */\n  function checkMiningRewardDeprecatedAtPeriod(address _blockProducer, uint256 _period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ITimingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ITimingInfo {\n  /**\n   * @dev Returns the block that validator set was updated.\n   */\n  function getLastUpdatedBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of blocks in a epoch.\n   */\n  function numberOfBlocksInEpoch() external view returns (uint256 _numberOfBlocks);\n\n  /**\n   * @dev Returns the epoch index from the block number.\n   */\n  function epochOf(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Returns whether the epoch ending is at the block number `_block`.\n   */\n  function epochEndingAt(uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Tries to get the period index from the epoch number.\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber);\n\n  /**\n   * @dev Returns whether the period ending at the current block number.\n   */\n  function isPeriodEnding() external view returns (bool);\n\n  /**\n   * @dev Returns the period index from the current block.\n   */\n  function currentPeriod() external view returns (uint256);\n\n  /**\n   * @dev Returns the block number that the current period starts at.\n   */\n  function currentPeriodStartAtBlock() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IValidatorInfoV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\n\ninterface IValidatorInfoV2 {\n  /**\n   * @dev Error thrown when an invalid maximum prioritized validator number is provided.\n   */\n  error ErrInvalidMaxPrioritizedValidatorNumber();\n\n  /// @dev Emitted when the number of max validator is updated.\n  event MaxValidatorNumberUpdated(uint256);\n  /// @dev Emitted when the number of reserved slots for prioritized validators is updated.\n  event MaxPrioritizedValidatorNumberUpdated(uint256);\n\n  /**\n   * @dev Returns the maximum number of validators in the epoch.\n   */\n  function maxValidatorNumber() external view returns (uint256 _maximumValidatorNumber);\n\n  /**\n   * @dev Returns the number of reserved slots for prioritized validators.\n   */\n  function maxPrioritizedValidatorNumber() external view returns (uint256 _maximumPrioritizedValidatorNumber);\n\n  /**\n   * @dev Returns the current validator list.\n   */\n  function getValidators() external view returns (address[] memory _validatorList);\n\n  /**\n   * @dev Returns the current block producer list.\n   */\n  function getBlockProducers() external view returns (address[] memory);\n\n  /**\n   * @dev Returns whether the address is block producer or not.\n   */\n  function isBlockProducer(address _addr) external view returns (bool);\n\n  /**\n   * @dev Returns total numbers of the block producers.\n   */\n  function totalBlockProducer() external view returns (uint256);\n\n  /**\n   * @dev Updates the max validator number\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxValidatorNumberUpdated`\n   *\n   */\n  function setMaxValidatorNumber(uint256 _maxValidatorNumber) external;\n\n  /**\n   * @dev Updates the number of reserved slots for prioritized validators\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxPrioritizedValidatorNumberUpdated`\n   *\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _maxPrioritizedValidatorNumber) external;\n}\n"
    },
    "contracts/interfaces/validator/IRoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ICandidateManager.sol\";\nimport \"./info-fragments/ICommonInfo.sol\";\nimport \"./ICoinbaseExecution.sol\";\nimport \"./ISlashingExecution.sol\";\nimport \"./IEmergencyExit.sol\";\n\ninterface IRoninValidatorSet is\n  ICandidateManager,\n  ICommonInfo,\n  ISlashingExecution,\n  ICoinbaseExecution,\n  IEmergencyExit\n{}\n"
    },
    "contracts/interfaces/validator/ISlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISlashingExecution {\n  /// @dev Emitted when the validator is punished.\n  event ValidatorPunished(\n    address indexed consensusAddr,\n    uint256 indexed period,\n    uint256 jailedUntil,\n    uint256 deductedStakingAmount,\n    bool blockProducerRewardDeprecated,\n    bool bridgeOperatorRewardDeprecated\n  );\n  /// @dev Emitted when the validator get out of jail by bailout.\n  event ValidatorUnjailed(address indexed validator, uint256 period);\n\n  /// @dev Error of cannot bailout due to high tier slash.\n  error ErrCannotBailout(address validator);\n\n  /**\n   * @dev Finalize the slash request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorPunished`.\n   *\n   */\n  function execSlash(address validatorAddr, uint256 newJailedUntil, uint256 slashAmount, bool cannotBailout) external;\n\n  /**\n   * @dev Finalize the bailout request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorUnjailed`.\n   *\n   */\n  function execBailOut(address _validatorAddr, uint256 _period) external;\n}\n"
    },
    "contracts/libraries/AddressArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary AddressArrayUtils {\n  /**\n   * @dev Error thrown when a duplicated element is detected in an array.\n   * @param msgSig The function signature that invoke the error.\n   */\n  error ErrDuplicated(bytes4 msgSig);\n\n  /**\n   * @dev Returns whether or not there's a duplicate. Runs in O(n^2).\n   * @param A Array to search\n   * @return Returns true if duplicate, false otherwise\n   */\n  function hasDuplicate(address[] memory A) internal pure returns (bool) {\n    if (A.length == 0) {\n      return false;\n    }\n    unchecked {\n      for (uint256 i = 0; i < A.length - 1; i++) {\n        for (uint256 j = i + 1; j < A.length; j++) {\n          if (A[i] == A[j]) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @dev Returns whether two arrays of addresses are equal or not.\n   */\n  function isEqual(address[] memory _this, address[] memory _other) internal pure returns (bool yes_) {\n    // Hashing two arrays and compare their hash\n    assembly {\n      let _thisHash := keccak256(add(_this, 32), mul(mload(_this), 32))\n      let _otherHash := keccak256(add(_other, 32), mul(mload(_other), 32))\n      yes_ := eq(_thisHash, _otherHash)\n    }\n  }\n\n  /**\n   * @dev Return the concatenated array from a and b.\n   */\n  function extend(address[] memory a, address[] memory b) internal pure returns (address[] memory c) {\n    uint256 lengthA = a.length;\n    uint256 lengthB = b.length;\n    unchecked {\n      c = new address[](lengthA + lengthB);\n    }\n    uint256 i;\n    for (; i < lengthA; ) {\n      c[i] = a[i];\n      unchecked {\n        ++i;\n      }\n    }\n    for (uint256 j; j < lengthB; ) {\n      c[i] = b[j];\n      unchecked {\n        ++i;\n        ++j;\n      }\n    }\n  }\n}\n"
    },
    "contracts/libraries/BridgeOperatorsBallot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../utils/CommonErrors.sol\";\n\nlibrary BridgeOperatorsBallot {\n  /**\n   * @dev Error thrown when an invalid order of the bridge operator is detected.\n   */\n  error ErrInvalidOrderOfBridgeOperator();\n\n  struct BridgeOperatorSet {\n    uint256 period;\n    uint256 epoch;\n    address[] operators;\n  }\n\n  // keccak256(\"BridgeOperatorsBallot(uint256 period,uint256 epoch,address[] operators)\");\n  bytes32 public constant BRIDGE_OPERATORS_BALLOT_TYPEHASH =\n    0xd679a49e9e099fa9ed83a5446aaec83e746b03ec6723d6f5efb29d37d7f0b78a;\n\n  /**\n   * @dev Verifies whether the ballot is valid or not.\n   *\n   * Requirements:\n   * - The ballot is not for an empty operator set.\n   * - The operator address list is in order.\n   *\n   */\n  function verifyBallot(BridgeOperatorSet calldata _ballot) internal pure {\n    if (_ballot.operators.length == 0) revert ErrEmptyArray();\n\n    address _addr = _ballot.operators[0];\n    for (uint _i = 1; _i < _ballot.operators.length; ) {\n      if (_addr >= _ballot.operators[_i]) revert ErrInvalidOrderOfBridgeOperator();\n      _addr = _ballot.operators[_i];\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @dev Returns hash of the ballot.\n   */\n  function hash(BridgeOperatorSet memory self) internal pure returns (bytes32 digest_) {\n    bytes32 operatorsHash;\n    address[] memory operators = self.operators;\n\n    // return keccak256(abi.encode(BRIDGE_OPERATORS_BALLOT_TYPEHASH, _ballot.period, _ballot.epoch, _operatorsHash));\n    assembly {\n      operatorsHash := keccak256(add(operators, 32), mul(mload(operators), 32))\n      let ptr := mload(0x40)\n      mstore(ptr, BRIDGE_OPERATORS_BALLOT_TYPEHASH)\n      mstore(add(ptr, 0x20), mload(self)) // _ballot.period\n      mstore(add(ptr, 0x40), mload(add(self, 0x20))) // _ballot.epoch\n      mstore(add(ptr, 0x60), operatorsHash)\n      digest_ := keccak256(ptr, 0x80)\n    }\n  }\n}\n"
    },
    "contracts/libraries/EnumFlags.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This library implements checking flag of an enumerated value.\n * The originated idea is inherited from [Enum.HashFlag(Enum)](https://learn.microsoft.com/en-us/dotnet/api/system.enum.hasflag?view=net-6.0) method of C#.\n */\nlibrary EnumFlags {\n  enum ValidatorFlag {\n    None, // bit(00)\n    BlockProducer, // bit(01)\n    DeprecatedBridgeOperator, // bit(10)\n    Both // bit(11)\n  }\n\n  function isNone(ValidatorFlag _value) internal pure returns (bool) {\n    return uint8(_value) == 0;\n  }\n\n  /**\n   * @dev Checks if `_value` has `_flag`.\n   */\n  function hasFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (bool) {\n    return (uint8(_value) & uint8(_flag)) != 0;\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after adding `_flag`.\n   */\n  function addFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) | uint8(_flag));\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after remove `_flag`.\n   */\n  function removeFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) & ~uint8(_flag));\n  }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary Math {\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns whether the number `c` is in range of [a; b].\n   */\n  function inRange(uint256 c, uint256 a, uint256 b) internal pure returns (bool) {\n    return a <= c && c <= b;\n  }\n\n  /**\n   * @dev Returns whether two inclusive ranges [x1;x2] and [y1;y2] overlap.\n   */\n  function twoRangeOverlap(uint256 x1, uint256 x2, uint256 y1, uint256 y2) internal pure returns (bool) {\n    return x1 <= y2 && y1 <= x2;\n  }\n\n  /**\n   * @dev Returns value of a + b; in case result is larger than upperbound, upperbound is returned.\n   */\n  function addWithUpperbound(uint256 a, uint256 b, uint256 upperbound) internal pure returns (uint256) {\n    return min(a + b, upperbound);\n  }\n\n  /**\n   * @dev Returns value of a - b; in case of negative result, 0 is returned.\n   */\n  function subNonNegative(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a - b : 0;\n  }\n\n  /**\n   * @dev Returns value of `a + zeroable` if zerobale is not 0; otherwise, return 0.\n   */\n  function addIfNonZero(uint256 a, uint256 zeroable) internal pure returns (uint256) {\n    return zeroable != 0 ? a + zeroable : 0;\n  }\n}\n"
    },
    "contracts/mocks/libraries/Sorting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary Sorting {\n  struct Node {\n    uint key;\n    uint value;\n  }\n\n  struct Node3 {\n    uint key;\n    uint value;\n    uint otherKey;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                   VALUE SORTING                                   //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sort(uint[] memory data) internal pure returns (uint[] memory) {\n    return _quickSort(data, int(0), int(data.length - 1));\n  }\n\n  function _quickSort(uint[] memory arr, int left, int right) private pure returns (uint[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return arr;\n    uint pivot = arr[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (arr[uint(i)] > pivot) i++;\n      while (pivot > arr[uint(j)]) j--;\n      if (i <= j) {\n        (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) arr = _quickSort(arr, left, j);\n    if (i < right) arr = _quickSort(arr, i, right);\n\n    return arr;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                   NODE SORTING                                    //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sort(address[] memory _keys, uint256[] memory _values) internal pure returns (address[] memory) {\n    require(_values.length == _keys.length, \"Sorting: invalid array length\");\n    if (_keys.length == 0) {\n      return _keys;\n    }\n\n    Node[] memory _nodes = new Node[](_keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node(uint256(uint160(_keys[_i])), _values[_i]);\n    }\n    _quickSortNodes(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _keys[_i] = address(uint160(_nodes[_i].key)); // Casting?\n    }\n\n    return _keys;\n  }\n\n  function sort(uint256[] memory keys, uint256[] memory values) internal pure returns (uint256[] memory) {\n    require(values.length == keys.length, \"Sorting: invalid array length\");\n    if (keys.length == 0) {\n      return keys;\n    }\n\n    Node[] memory _nodes = new Node[](keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node(keys[_i], values[_i]);\n    }\n    _quickSortNodes(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      keys[_i] = _nodes[_i].key; // Casting?\n    }\n\n    return keys;\n  }\n\n  function sortNodes(Node[] memory nodes) internal pure returns (Node[] memory) {\n    return _quickSortNodes(nodes, int(0), int(nodes.length - 1));\n  }\n\n  function _quickSortNodes(Node[] memory nodes, int left, int right) private pure returns (Node[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return nodes;\n    Node memory pivot = nodes[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (nodes[uint(i)].value > pivot.value) i++;\n      while (pivot.value > nodes[uint(j)].value) j--;\n      if (i <= j) {\n        (nodes[uint(i)], nodes[uint(j)]) = __swapNodes(nodes[uint(i)], nodes[uint(j)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) nodes = _quickSortNodes(nodes, left, j);\n    if (i < right) nodes = _quickSortNodes(nodes, i, right);\n\n    return nodes;\n  }\n\n  function _bubbleSortNodes(Node[] memory nodes) private pure returns (Node[] memory) {\n    uint length = nodes.length;\n    for (uint i = 0; i < length - 1; i++) {\n      for (uint j = i + 1; j < length; j++) {\n        if (nodes[j].value > nodes[i].value) {\n          (nodes[i], nodes[j]) = __swapNodes(nodes[i], nodes[j]);\n        }\n      }\n    }\n    return nodes;\n  }\n\n  function __swapNodes(Node memory x, Node memory y) private pure returns (Node memory, Node memory) {\n    Node memory tmp = x;\n    (x, y) = (y, tmp);\n    return (x, y);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                  NODE3 SORTING                                    //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sortWithExternalKeys(\n    address[] memory _keys,\n    uint256[] memory _values,\n    uint256[] memory _otherKeys\n  ) internal pure returns (address[] memory keys_, uint256[] memory otherKeys_) {\n    require((_values.length == _keys.length) && (_otherKeys.length == _keys.length), \"Sorting: invalid array length\");\n    if (_keys.length == 0) {\n      return (_keys, _otherKeys);\n    }\n\n    Node3[] memory _nodes = new Node3[](_keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node3(uint256(uint160(_keys[_i])), _values[_i], _otherKeys[_i]);\n    }\n    _quickSortNode3s(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _keys[_i] = address(uint160(_nodes[_i].key)); // Casting?\n    }\n\n    return (_keys, _otherKeys);\n  }\n\n  function sortNode3s(Node3[] memory nodes) internal pure returns (Node3[] memory) {\n    return _quickSortNode3s(nodes, int(0), int(nodes.length - 1));\n  }\n\n  function _quickSortNode3s(Node3[] memory nodes, int left, int right) private pure returns (Node3[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return nodes;\n    Node3 memory pivot = nodes[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (nodes[uint(i)].value > pivot.value) i++;\n      while (pivot.value > nodes[uint(j)].value) j--;\n      if (i <= j) {\n        (nodes[uint(i)], nodes[uint(j)]) = __swapNode3s(nodes[uint(i)], nodes[uint(j)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) nodes = _quickSortNode3s(nodes, left, j);\n    if (i < right) nodes = _quickSortNode3s(nodes, i, right);\n\n    return nodes;\n  }\n\n  function _bubbleSortNode3s(Node3[] memory nodes) private pure returns (Node3[] memory) {\n    uint length = nodes.length;\n    for (uint i = 0; i < length - 1; i++) {\n      for (uint j = i + 1; j < length; j++) {\n        if (nodes[j].value > nodes[i].value) {\n          (nodes[i], nodes[j]) = __swapNode3s(nodes[i], nodes[j]);\n        }\n      }\n    }\n    return nodes;\n  }\n\n  function __swapNode3s(Node3 memory x, Node3 memory y) private pure returns (Node3 memory, Node3 memory) {\n    Node3 memory tmp = x;\n    (x, y) = (y, tmp);\n    return (x, y);\n  }\n}\n"
    },
    "contracts/mocks/MockPrecompile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./libraries/Sorting.sol\";\nimport \"../libraries/Math.sol\";\n\ncontract MockPrecompile {\n  function sortValidators(\n    address[] memory _validators,\n    uint256[] memory _weights\n  ) public pure returns (address[] memory) {\n    return Sorting.sort(_validators, _weights);\n  }\n\n  function validatingDoubleSignProof(\n    address /*consensusAddr*/,\n    bytes calldata /*_header1*/,\n    bytes calldata /*_header2*/\n  ) public pure returns (bool _validEvidence) {\n    return true;\n  }\n\n  function validateFinaltyVoteProof(\n    bytes calldata,\n    uint256,\n    bytes32[2] calldata,\n    bytes[][2] calldata,\n    bytes[2] calldata\n  ) public pure returns (bool) {\n    return true;\n  }\n\n  function pickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) public pure returns (address[] memory _result) {\n    (_result, _trustedWeights) = Sorting.sortWithExternalKeys(_candidates, _weights, _trustedWeights);\n    uint256 _newValidatorCount = Math.min(_maxValidatorNumber, _result.length);\n    _arrangeValidatorCandidates(_result, _trustedWeights, _newValidatorCount, _maxPrioritizedValidatorNumber);\n  }\n\n  /**\n   * @dev Arranges the sorted candidates to list of validators, by asserting prioritized and non-prioritized candidates\n   *\n   * @param _candidates A sorted list of candidates\n   */\n  function _arrangeValidatorCandidates(\n    address[] memory _candidates,\n    uint256[] memory _trustedWeights,\n    uint _newValidatorCount,\n    uint _maxPrioritizedValidatorNumber\n  ) internal pure {\n    address[] memory _waitingCandidates = new address[](_candidates.length);\n    uint _waitingCounter;\n    uint _prioritySlotCounter;\n\n    for (uint _i = 0; _i < _candidates.length; _i++) {\n      if (_trustedWeights[_i] > 0 && _prioritySlotCounter < _maxPrioritizedValidatorNumber) {\n        _candidates[_prioritySlotCounter++] = _candidates[_i];\n        continue;\n      }\n      _waitingCandidates[_waitingCounter++] = _candidates[_i];\n    }\n\n    _waitingCounter = 0;\n    for (uint _i = _prioritySlotCounter; _i < _newValidatorCount; _i++) {\n      _candidates[_i] = _waitingCandidates[_waitingCounter++];\n    }\n\n    assembly {\n      mstore(_candidates, _newValidatorCount)\n    }\n  }\n}\n"
    },
    "contracts/mocks/MockSlashIndicatorExtended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./MockPrecompile.sol\";\nimport \"../ronin/slash-indicator/SlashIndicator.sol\";\nimport \"../interfaces/validator/IRoninValidatorSet.sol\";\n\ncontract MockSlashIndicatorExtended is SlashIndicator, MockPrecompile {\n  function slashFelony(address _validatorAddr) external {\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execSlash(_validatorAddr, 0, 0, false);\n  }\n\n  function slashMisdemeanor(address _validatorAddr) external {\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execSlash(_validatorAddr, 0, 0, false);\n  }\n\n  function _pcValidateEvidence(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) internal pure override returns (bool _validEvidence) {\n    return validatingDoubleSignProof(_consensusAddr, _header1, _header2);\n  }\n}\n"
    },
    "contracts/mocks/precompile-usages/MockPCUValidateFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../precompile-usages/PCUValidateFastFinality.sol\";\n\ncontract MockPCUValidateFastFinality is PCUValidateFastFinality {\n  address internal _precompileValidateFastFinalityAddress;\n\n  constructor(address _precompile) {\n    setPrecompileValidateFastFinalityAddress(_precompile);\n  }\n\n  function setPrecompileValidateFastFinalityAddress(address _addr) public {\n    _precompileValidateFastFinalityAddress = _addr;\n  }\n\n  function precompileValidateFastFinalityAddress() public view override returns (address) {\n    return _precompileValidateFastFinalityAddress;\n  }\n\n  function callPrecompile(\n    bytes memory voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] memory targetBlockHash,\n    bytes[][2] memory listOfPublicKey,\n    bytes[2] memory aggregatedSignature\n  ) public view returns (bool) {\n    return\n      _pcValidateFastFinalityEvidence(\n        voterPublicKey,\n        targetBlockNumber,\n        targetBlockHash,\n        listOfPublicKey,\n        aggregatedSignature\n      );\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUValidateDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUValidateDoubleSign is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of validating double sign evidence\n  function precompileValidateDoubleSignAddress() public view virtual returns (address) {\n    return address(0x67);\n  }\n\n  /**\n   * @dev Validates the two submitted block header if they are produced by the same address\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcValidateEvidence(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) internal view virtual returns (bool _validEvidence) {\n    address _smc = precompileValidateDoubleSignAddress();\n    bool _success = true;\n\n    bytes memory _payload = abi.encodeWithSignature(\n      \"validatingDoubleSignProof(address,bytes,bytes)\",\n      _consensusAddr,\n      _header1,\n      _header2\n    );\n    uint _payloadLength = _payload.length;\n    uint[1] memory _output;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _output, 0x20)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n    return (_output[0] != 0);\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUValidateFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUValidateFastFinality is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of validating double sign evidence\n  function precompileValidateFastFinalityAddress() public view virtual returns (address) {\n    return address(0x69);\n  }\n\n  /**\n   * @dev Validates the proof of malicious voting on fast finality\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcValidateFastFinalityEvidence(\n    bytes memory voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] memory targetBlockHash,\n    bytes[][2] memory listOfPublicKey,\n    bytes[2] memory aggregatedSignature\n  ) internal view virtual returns (bool validEvidence) {\n    address smc = precompileValidateFastFinalityAddress();\n    bool success = true;\n\n    bytes memory payload = abi.encodeWithSignature(\n      \"validateFinalityVoteProof(bytes,uint256,bytes32[2],bytes[][2],bytes[2])\",\n      voterPublicKey,\n      targetBlockNumber,\n      targetBlockHash,\n      listOfPublicKey,\n      aggregatedSignature\n    );\n    uint payloadLength = payload.length;\n    uint[1] memory output;\n\n    assembly {\n      let payloadStart := add(payload, 0x20)\n      if iszero(staticcall(gas(), smc, payloadStart, payloadLength, output, 0x20)) {\n        success := 0\n      }\n\n      if iszero(returndatasize()) {\n        success := 0\n      }\n    }\n\n    if (!success) revert ErrCallPrecompiled();\n    return (output[0] != 0);\n  }\n}\n"
    },
    "contracts/precompile-usages/PrecompiledUsage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PrecompiledUsage {\n  /// @dev Error of call to precompile fails.\n  error ErrCallPrecompiled();\n}\n"
    },
    "contracts/ronin/slash-indicator/CreditScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/IMaintenance.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/slash-indicator/ICreditScore.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasValidatorDeprecated, HasMaintenanceDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport { ErrUnauthorized, RoleAccess } from \"../../utils/CommonErrors.sol\";\n\nabstract contract CreditScore is\n  ICreditScore,\n  HasContracts,\n  HasValidatorDeprecated,\n  HasMaintenanceDeprecated,\n  PercentageConsumer\n{\n  /// @dev Mapping from validator address => period index => whether bailed out before\n  mapping(address => mapping(uint256 => bool)) internal _checkBailedOutAtPeriod;\n  /// @dev Mapping from validator address => credit score\n  mapping(address => uint256) internal _creditScore;\n\n  /// @dev The max gained number of credit score per period.\n  uint256 internal _gainCreditScore;\n  /// @dev The max number of credit score that a validator can hold.\n  uint256 internal _maxCreditScore;\n  /// @dev The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n  uint256 internal _bailOutCostMultiplier;\n  /// @dev The percentage of reward to be cut off from the validator in the rest of the period after bailed out.\n  uint256 internal _cutOffPercentageAfterBailout;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function updateCreditScores(\n    address[] calldata _validators,\n    uint256 _period\n  ) external override onlyContract(ContractType.VALIDATOR) {\n    IRoninValidatorSet _validatorContract = IRoninValidatorSet(msg.sender);\n    uint256 _periodStartAtBlock = _validatorContract.currentPeriodStartAtBlock();\n\n    bool[] memory _jaileds = _validatorContract.checkManyJailed(_validators);\n    bool[] memory _maintaineds = IMaintenance(getContract(ContractType.MAINTENANCE)).checkManyMaintainedInBlockRange(\n      _validators,\n      _periodStartAtBlock,\n      block.number\n    );\n    uint256[] memory _updatedCreditScores = new uint256[](_validators.length);\n\n    for (uint _i = 0; _i < _validators.length; ) {\n      address _validator = _validators[_i];\n\n      uint256 _indicator = getUnavailabilityIndicator(_validator, _period);\n      bool _isJailedInPeriod = _jaileds[_i];\n      bool _isMaintainingInPeriod = _maintaineds[_i];\n\n      uint256 _actualGain = (_isJailedInPeriod || _isMaintainingInPeriod)\n        ? 0\n        : Math.subNonNegative(_gainCreditScore, _indicator);\n\n      _creditScore[_validator] = Math.addWithUpperbound(_creditScore[_validator], _actualGain, _maxCreditScore);\n      _updatedCreditScores[_i] = _creditScore[_validator];\n      unchecked {\n        ++_i;\n      }\n    }\n\n    emit CreditScoresUpdated(_validators, _updatedCreditScores);\n  }\n\n  function execResetCreditScores(\n    address[] calldata _validators\n  ) external override onlyContract(ContractType.VALIDATOR) {\n    uint256[] memory _updatedCreditScores = new uint256[](_validators.length);\n    for (uint _i = 0; _i < _validators.length; ) {\n      address _validator = _validators[_i];\n      delete _creditScore[_validator];\n      delete _updatedCreditScores[_i];\n\n      unchecked {\n        ++_i;\n      }\n    }\n    emit CreditScoresUpdated(_validators, _updatedCreditScores);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function bailOut(address _consensusAddr) external override {\n    IRoninValidatorSet _validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    if (!_validatorContract.isValidatorCandidate(_consensusAddr))\n      revert ErrUnauthorized(msg.sig, RoleAccess.VALIDATOR_CANDIDATE);\n\n    if (!_validatorContract.isCandidateAdmin(_consensusAddr, msg.sender))\n      revert ErrUnauthorized(msg.sig, RoleAccess.CANDIDATE_ADMIN);\n\n    (bool _isJailed, , uint256 _jailedEpochLeft) = _validatorContract.getJailedTimeLeft(_consensusAddr);\n    if (!_isJailed) revert ErrCallerMustBeJailedInTheCurrentPeriod();\n\n    uint256 _period = _validatorContract.currentPeriod();\n    if (_checkBailedOutAtPeriod[_consensusAddr][_period]) revert ErrValidatorHasBailedOutPreviously();\n\n    uint256 _score = _creditScore[_consensusAddr];\n    uint256 _cost = _jailedEpochLeft * _bailOutCostMultiplier;\n    if (_score < _cost) revert ErrInsufficientCreditScoreToBailOut();\n\n    _validatorContract.execBailOut(_consensusAddr, _period);\n\n    _creditScore[_consensusAddr] -= _cost;\n    _setUnavailabilityIndicator(_consensusAddr, _period, 0);\n    _checkBailedOutAtPeriod[_consensusAddr][_period] = true;\n    emit BailedOut(_consensusAddr, _period, _cost);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) external override onlyAdmin {\n    _setCreditScoreConfigs(_gainScore, _maxScore, _bailOutMultiplier, _cutOffPercentage);\n  }\n\n  /**\n   * @dev See `ISlashUnavailability`\n   */\n  function getUnavailabilityIndicator(address _validator, uint256 _period) public view virtual returns (uint256);\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getCreditScoreConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 gainCreditScore_,\n      uint256 maxCreditScore_,\n      uint256 bailOutCostMultiplier_,\n      uint256 cutOffPercentageAfterBailout_\n    )\n  {\n    return (_gainCreditScore, _maxCreditScore, _bailOutCostMultiplier, _cutOffPercentageAfterBailout);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getCreditScore(address _validator) external view override returns (uint256) {\n    return _creditScore[_validator];\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getManyCreditScores(\n    address[] calldata _validators\n  ) public view override returns (uint256[] memory _resultList) {\n    _resultList = new uint256[](_validators.length);\n\n    for (uint _i = 0; _i < _resultList.length; ) {\n      _resultList[_i] = _creditScore[_validators[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function checkBailedOutAtPeriod(address _validator, uint256 _period) public view virtual override returns (bool) {\n    return _checkBailedOutAtPeriod[_validator][_period];\n  }\n\n  /**\n   * @dev See `SlashUnavailability`.\n   */\n  function _setUnavailabilityIndicator(address _validator, uint256 _period, uint256 _indicator) internal virtual;\n\n  /**\n   * @dev See `ICreditScore-setCreditScoreConfigs`.\n   */\n  function _setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) internal {\n    if (_gainScore > _maxScore) revert ErrInvalidCreditScoreConfig();\n    if (_cutOffPercentage > _MAX_PERCENTAGE) revert ErrInvalidCutOffPercentageConfig();\n\n    _gainCreditScore = _gainScore;\n    _maxCreditScore = _maxScore;\n    _bailOutCostMultiplier = _bailOutMultiplier;\n    _cutOffPercentageAfterBailout = _cutOffPercentage;\n    emit CreditScoreConfigsUpdated(_gainScore, _maxScore, _bailOutMultiplier, _cutOffPercentage);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashBridgeOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../extensions/collections/HasProxyAdmin.sol\";\nimport \"../../interfaces/slash-indicator/ISlashBridgeOperator.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\nabstract contract SlashBridgeOperator is\n  ISlashBridgeOperator,\n  HasProxyAdmin,\n  HasContracts,\n  HasValidatorDeprecated,\n  PercentageConsumer\n{\n  /**\n   * @dev The bridge operators will be deprecated reward if (s)he missed more than the ratio.\n   * Values 0-10,000 map to 0%-100%.\n   */\n  uint256 internal _missingVotesRatioTier1;\n  /**\n   * @dev The bridge operators will be deprecated all rewards including bridge reward and mining reward if (s)he missed\n   * more than the ratio. Values 0-10,000 map to 0%-100%.\n   */\n  uint256 internal _missingVotesRatioTier2;\n  /// @dev The number of blocks to jail the corresponding block producer when its bridge operator is slashed tier-2.\n  uint256 internal _jailDurationForMissingVotesRatioTier2;\n  /// @dev The threshold to skip slashing the bridge operator in case the total number of votes in the bridge is too small.\n  uint256 internal _skipBridgeOperatorSlashingThreshold;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc ISlashBridgeOperator\n   */\n  function getBridgeOperatorSlashingConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 missingVotesRatioTier1_,\n      uint256 missingVotesRatioTier2_,\n      uint256 jailDurationForMissingVotesRatioTier2_,\n      uint256 skipBridgeOperatorSlashingThreshold_\n    )\n  {\n    return (\n      _missingVotesRatioTier1,\n      _missingVotesRatioTier2,\n      _jailDurationForMissingVotesRatioTier2,\n      _skipBridgeOperatorSlashingThreshold\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashBridgeOperator\n   */\n  function setBridgeOperatorSlashingConfigs(\n    uint256 _ratioTier1,\n    uint256 _ratioTier2,\n    uint256 _jailDurationTier2,\n    uint256 _skipSlashingThreshold\n  ) external override onlyAdmin {\n    _setBridgeOperatorSlashingConfigs(_ratioTier1, _ratioTier2, _jailDurationTier2, _skipSlashingThreshold);\n  }\n\n  /**\n   * @inheritdoc ISlashBridgeOperator\n   */\n  function execSlashBridgeOperator(\n    address _consensusAddr,\n    uint256 _tier,\n    uint256 _period\n  ) external onlyContract(ContractType.VALIDATOR) {\n    if (_tier == 1) {\n      emit Slashed(_consensusAddr, SlashType.BRIDGE_OPERATOR_MISSING_VOTE_TIER_1, _period);\n    } else if (_tier == 2) {\n      emit Slashed(_consensusAddr, SlashType.BRIDGE_OPERATOR_MISSING_VOTE_TIER_2, _period);\n    }\n  }\n\n  /**\n   * @dev See `ISlashBridgeOperator-setBridgeOperatorSlashingConfigs`.\n   */\n  function _setBridgeOperatorSlashingConfigs(\n    uint256 _ratioTier1,\n    uint256 _ratioTier2,\n    uint256 _jailDurationTier2,\n    uint256 _skipSlashingThreshold\n  ) internal {\n    if (_ratioTier1 > _ratioTier2 || _ratioTier1 > _MAX_PERCENTAGE || _ratioTier2 > _MAX_PERCENTAGE) {\n      revert ErrInvalidRatios();\n    }\n\n    _missingVotesRatioTier1 = _ratioTier1;\n    _missingVotesRatioTier2 = _ratioTier2;\n    _jailDurationForMissingVotesRatioTier2 = _jailDurationTier2;\n    _skipBridgeOperatorSlashingThreshold = _skipSlashingThreshold;\n    emit BridgeOperatorSlashingConfigsUpdated(_ratioTier1, _ratioTier2, _jailDurationTier2, _skipSlashingThreshold);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashBridgeVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../libraries/Math.sol\";\nimport { HasValidatorDeprecated, HasTrustedOrgDeprecated, HasGovernanceAdminDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport { IBridgeAdminProposal } from \"../../interfaces/IBridgeAdminProposal.sol\";\nimport \"../../interfaces/slash-indicator/ISlashBridgeVoting.sol\";\nimport \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\n\n// TODO: remove this from slashing logic of consensus contract\nabstract contract SlashBridgeVoting is\n  ISlashBridgeVoting,\n  HasContracts,\n  HasValidatorDeprecated,\n  HasTrustedOrgDeprecated,\n  HasGovernanceAdminDeprecated\n{\n  /// @dev Mapping from validator address => period index => bridge voting slashed\n  mapping(address => mapping(uint256 => bool)) internal _bridgeVotingSlashed;\n  /// @dev The threshold to slash when a trusted organization does not vote for bridge operators.\n  uint256 internal _bridgeVotingThreshold;\n  /// @dev The amount of RON to slash bridge voting.\n  uint256 internal _bridgeVotingSlashAmount;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc ISlashBridgeVoting\n   */\n  function slashBridgeVoting(address _consensusAddr) external onlyAdmin {\n    IRoninTrustedOrganization.TrustedOrganization memory _org = IRoninTrustedOrganization(\n      getContract(ContractType.RONIN_TRUSTED_ORGANIZATION)\n    ).getTrustedOrganization(_consensusAddr);\n    uint256 _lastVotedBlock = Math.max(\n      IBridgeAdminProposal(getContract(ContractType.BRIDGE_MANAGER)).lastVotedBlock(_org.bridgeVoter),\n      _org.addedBlock\n    );\n    IRoninValidatorSet _validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    uint256 _period = _validatorContract.currentPeriod();\n\n    if (block.number - _lastVotedBlock <= _bridgeVotingThreshold || _bridgeVotingSlashed[_consensusAddr][_period])\n      revert ErrInvalidSlash();\n\n    _bridgeVotingSlashed[_consensusAddr][_period] = true;\n    emit Slashed(_consensusAddr, SlashType.BRIDGE_VOTING, _period);\n    _validatorContract.execSlash(_consensusAddr, 0, _bridgeVotingSlashAmount, false);\n  }\n\n  /**\n   * @inheritdoc ISlashBridgeVoting\n   */\n  function getBridgeVotingSlashingConfigs()\n    external\n    view\n    override\n    returns (uint256 bridgeVotingThreshold_, uint256 bridgeVotingSlashAmount_)\n  {\n    return (_bridgeVotingThreshold, _bridgeVotingSlashAmount);\n  }\n\n  /**\n   * @inheritdoc ISlashBridgeVoting\n   */\n  function setBridgeVotingSlashingConfigs(uint256 _threshold, uint256 _slashAmount) external override onlyAdmin {\n    _setBridgeVotingSlashingConfigs(_threshold, _slashAmount);\n  }\n\n  /**\n   * @dev See `ISlashBridgeVoting-setBridgeVotingSlashingConfigs`.\n   */\n  function _setBridgeVotingSlashingConfigs(uint256 _threshold, uint256 _slashAmount) internal {\n    _bridgeVotingThreshold = _threshold;\n    _bridgeVotingSlashAmount = _slashAmount;\n    emit BridgeVotingSlashingConfigsUpdated(_threshold, _slashAmount);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/slash-indicator/ISlashDoubleSign.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../precompile-usages/PCUValidateDoubleSign.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\nabstract contract SlashDoubleSign is ISlashDoubleSign, HasContracts, HasValidatorDeprecated, PCUValidateDoubleSign {\n  /// @dev The amount of RON to slash double sign.\n  uint256 internal _slashDoubleSignAmount;\n  /// @dev The block number that the punished validator will be jailed until, due to double signing.\n  uint256 internal _doubleSigningJailUntilBlock;\n  /** @dev The offset from the submitted block to the current block, from which double signing will be invalidated.\n   * This parameter is exposed for system transaction.\n   **/\n  uint256 internal _doubleSigningOffsetLimitBlock;\n  /// @dev Recording of submitted proof to prevent relay attack.\n  mapping(bytes32 => bool) _submittedEvidence;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[24] private ______gap;\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function slashDoubleSign(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) external override onlyAdmin {\n    bytes32 _header1Checksum = keccak256(_header1);\n    bytes32 _header2Checksum = keccak256(_header2);\n\n    if (_submittedEvidence[_header1Checksum] || _submittedEvidence[_header2Checksum]) {\n      revert ErrEvidenceAlreadySubmitted();\n    }\n\n    if (_pcValidateEvidence(_consensusAddr, _header1, _header2)) {\n      IRoninValidatorSet _validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n      uint256 _period = _validatorContract.currentPeriod();\n      _submittedEvidence[_header1Checksum] = true;\n      _submittedEvidence[_header2Checksum] = true;\n      emit Slashed(_consensusAddr, SlashType.DOUBLE_SIGNING, _period);\n      _validatorContract.execSlash(_consensusAddr, _doubleSigningJailUntilBlock, _slashDoubleSignAmount, true);\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function getDoubleSignSlashingConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 slashDoubleSignAmount_,\n      uint256 doubleSigningJailUntilBlock_,\n      uint256 doubleSigningOffsetLimitBlock_\n    )\n  {\n    return (_slashDoubleSignAmount, _doubleSigningJailUntilBlock, _doubleSigningOffsetLimitBlock);\n  }\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _offsetLimitBlock\n  ) external override onlyAdmin {\n    _setDoubleSignSlashingConfigs(_slashAmount, _jailUntilBlock, _offsetLimitBlock);\n  }\n\n  /**\n   * @dev See `ISlashDoubleSign-setDoubleSignSlashingConfigs`.\n   */\n  function _setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _offsetLimitBlock\n  ) internal {\n    _slashDoubleSignAmount = _slashAmount;\n    _doubleSigningJailUntilBlock = _jailUntilBlock;\n    _doubleSigningOffsetLimitBlock = _offsetLimitBlock;\n    emit DoubleSignSlashingConfigsUpdated(_slashAmount, _jailUntilBlock, _doubleSigningOffsetLimitBlock);\n  }\n\n  /**\n   * @dev Returns whether the account `_addr` should be slashed or not.\n   */\n  function _shouldSlash(address _addr) internal view virtual returns (bool);\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/slash-indicator/ISlashFastFinality.sol\";\nimport { IRoninValidatorSet } from \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport { IProfile } from \"../../interfaces/IProfile.sol\";\nimport { IRoninTrustedOrganization } from \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../precompile-usages/PCUValidateFastFinality.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../utils/CommonErrors.sol\";\n\nabstract contract SlashFastFinality is ISlashFastFinality, HasContracts, PCUValidateFastFinality {\n  /// @dev The amount of RON to slash fast finality.\n  uint256 internal _slashFastFinalityAmount;\n  /// @dev The block number that the punished validator will be jailed until, due to malicious fast finality.\n  uint256 internal _fastFinalityJailUntilBlock;\n  /// @dev Recording of submitted proof to prevent relay attack.\n  mapping(bytes32 => bool) internal _processedEvidence;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[21] private ______gap;\n\n  modifier onlyGoverningValidator() {\n    if (_getGovernorWeight(msg.sender) == 0) revert ErrUnauthorized(msg.sig, RoleAccess.GOVERNOR);\n    _;\n  }\n\n  /**\n   * @inheritdoc ISlashFastFinality\n   */\n  function slashFastFinality(\n    address consensusAddr,\n    bytes calldata voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] calldata targetBlockHash,\n    bytes[][2] calldata listOfPublicKey,\n    bytes[2] calldata aggregatedSignature\n  ) external override onlyGoverningValidator {\n    IProfile profileContract = IProfile(getContract(ContractType.PROFILE));\n    bytes memory expectingPubKey = (profileContract.getId2Profile(consensusAddr)).pubkey;\n    if (keccak256(voterPublicKey) != keccak256(expectingPubKey)) revert ErrInvalidArguments(msg.sig);\n\n    bytes32 evidenceHash = keccak256(abi.encodePacked(consensusAddr, targetBlockNumber));\n    if (_processedEvidence[evidenceHash]) revert ErrEvidenceAlreadySubmitted();\n\n    if (\n      _pcValidateFastFinalityEvidence(\n        voterPublicKey,\n        targetBlockNumber,\n        targetBlockHash,\n        listOfPublicKey,\n        aggregatedSignature\n      )\n    ) {\n      _processedEvidence[evidenceHash] = true;\n\n      IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n      uint256 period = validatorContract.currentPeriod();\n      emit Slashed(consensusAddr, SlashType.FAST_FINALITY, period);\n      validatorContract.execSlash({\n        validatorAddr: consensusAddr,\n        newJailedUntil: _fastFinalityJailUntilBlock,\n        slashAmount: _slashFastFinalityAmount,\n        cannotBailout: true\n      });\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashFastFinality\n   */\n  function getFastFinalitySlashingConfigs()\n    external\n    view\n    override\n    returns (uint256 slashFastFinalityAmount_, uint256 fastFinalityJailUntilBlock_)\n  {\n    return (_slashFastFinalityAmount, _fastFinalityJailUntilBlock);\n  }\n\n  /**\n   * @inheritdoc ISlashFastFinality\n   */\n  function setFastFinalitySlashingConfigs(uint256 slashAmount, uint256 jailUntilBlock) external override onlyAdmin {\n    _setFastFinalitySlashingConfigs(slashAmount, jailUntilBlock);\n  }\n\n  /**\n   * @dev See `ISlashFastFinality-setFastFinalitySlashingConfigs`.\n   */\n  function _setFastFinalitySlashingConfigs(uint256 slashAmount, uint256 jailUntilBlock) internal {\n    _slashFastFinalityAmount = slashAmount;\n    _fastFinalityJailUntilBlock = jailUntilBlock;\n    emit FastFinalitySlashingConfigsUpdated(slashAmount, jailUntilBlock);\n  }\n\n  /**\n   * @dev Get governor, i.e. governing validator's weight, of the `addr`.\n   */\n  function _getGovernorWeight(address addr) internal view returns (uint256) {\n    return IRoninTrustedOrganization(getContract(ContractType.RONIN_TRUSTED_ORGANIZATION)).getGovernorWeight(addr);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashIndicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/slash-indicator/ISlashIndicator.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/IMaintenance.sol\";\nimport \"./SlashDoubleSign.sol\";\nimport \"./SlashFastFinality.sol\";\nimport \"./SlashBridgeVoting.sol\";\nimport \"./SlashBridgeOperator.sol\";\nimport \"./SlashUnavailability.sol\";\nimport \"./CreditScore.sol\";\n\ncontract SlashIndicator is\n  ISlashIndicator,\n  SlashDoubleSign,\n  SlashFastFinality,\n  SlashBridgeVoting,\n  SlashBridgeOperator,\n  SlashUnavailability,\n  CreditScore,\n  Initializable\n{\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __validatorContract,\n    address __maintenanceContract,\n    address __roninTrustedOrganizationContract,\n    address __roninGovernanceAdminContract,\n    // _bridgeOperatorSlashingConfigs[0]: _missingVotesRatioTier1\n    // _bridgeOperatorSlashingConfigs[1]: _missingVotesRatioTier2\n    // _bridgeOperatorSlashingConfigs[2]: _jailDurationForMissingVotesRatioTier2\n    // _bridgeOperatorSlashingConfigs[3]: _skipBridgeOperatorSlashingThreshold\n    uint256[4] calldata _bridgeOperatorSlashingConfigs,\n    // _bridgeVotingSlashingConfigs[0]: _bridgeVotingThreshold\n    // _bridgeVotingSlashingConfigs[1]: _bridgeVotingSlashAmount\n    uint256[2] calldata _bridgeVotingSlashingConfigs,\n    // _doubleSignSlashingConfigs[0]: _slashDoubleSignAmount\n    // _doubleSignSlashingConfigs[1]: _doubleSigningJailUntilBlock\n    // _doubleSignSlashingConfigs[2]: _doubleSigningOffsetLimitBlock\n    uint256[3] calldata _doubleSignSlashingConfigs,\n    // _unavailabilitySlashingConfigs[0]: _unavailabilityTier1Threshold\n    // _unavailabilitySlashingConfigs[1]: _unavailabilityTier2Threshold\n    // _unavailabilitySlashingConfigs[2]: _slashAmountForUnavailabilityTier2Threshold\n    // _unavailabilitySlashingConfigs[3]: _jailDurationForUnavailabilityTier2Threshold\n    uint256[4] calldata _unavailabilitySlashingConfigs,\n    // _creditScoreConfigs[0]: _gainCreditScore\n    // _creditScoreConfigs[1]: _maxCreditScore\n    // _creditScoreConfigs[2]: _bailOutCostMultiplier\n    // _creditScoreConfigs[3]: _cutOffPercentageAfterBailout\n    uint256[4] calldata _creditScoreConfigs\n  ) external initializer {\n    _setContract(ContractType.VALIDATOR, __validatorContract);\n    _setContract(ContractType.MAINTENANCE, __maintenanceContract);\n    _setContract(ContractType.GOVERNANCE_ADMIN, __roninGovernanceAdminContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, __roninTrustedOrganizationContract);\n\n    _setBridgeOperatorSlashingConfigs(\n      _bridgeOperatorSlashingConfigs[0],\n      _bridgeOperatorSlashingConfigs[1],\n      _bridgeOperatorSlashingConfigs[2],\n      _bridgeOperatorSlashingConfigs[3]\n    );\n    _setBridgeVotingSlashingConfigs(_bridgeVotingSlashingConfigs[0], _bridgeVotingSlashingConfigs[1]);\n    _setDoubleSignSlashingConfigs(\n      _doubleSignSlashingConfigs[0],\n      _doubleSignSlashingConfigs[1],\n      _doubleSignSlashingConfigs[2]\n    );\n    _setUnavailabilitySlashingConfigs(\n      _unavailabilitySlashingConfigs[0],\n      _unavailabilitySlashingConfigs[1],\n      _unavailabilitySlashingConfigs[2],\n      _unavailabilitySlashingConfigs[3]\n    );\n    _setCreditScoreConfigs(\n      _creditScoreConfigs[0],\n      _creditScoreConfigs[1],\n      _creditScoreConfigs[2],\n      _creditScoreConfigs[3]\n    );\n  }\n\n  function initializeV2(address roninGovernanceAdminContract) external reinitializer(2) {\n    _setContract(ContractType.VALIDATOR, ______deprecatedValidator);\n    _setContract(ContractType.MAINTENANCE, ______deprecatedMaintenance);\n    _setContract(ContractType.GOVERNANCE_ADMIN, roninGovernanceAdminContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, ______deprecatedTrustedOrg);\n\n    delete ______deprecatedValidator;\n    delete ______deprecatedMaintenance;\n    delete ______deprecatedTrustedOrg;\n    delete ______deprecatedGovernanceAdmin;\n  }\n\n  function initializeV3(address profileContract) external reinitializer(3) {\n    _setContract(ContractType.PROFILE, profileContract);\n    _setFastFinalitySlashingConfigs(_slashDoubleSignAmount, _doubleSigningJailUntilBlock);\n  }\n\n  /**\n   * @dev Helper for CreditScore contract to reset the indicator of the validator after bailing out.\n   */\n  function _setUnavailabilityIndicator(\n    address _validator,\n    uint256 _period,\n    uint256 _indicator\n  ) internal override(CreditScore, SlashUnavailability) {\n    SlashUnavailability._setUnavailabilityIndicator(_validator, _period, _indicator);\n  }\n\n  /**\n   * @dev Helper for CreditScore contract to query indicator of the validator.\n   */\n  function getUnavailabilityIndicator(\n    address _validator,\n    uint256 _period\n  ) public view override(CreditScore, ISlashUnavailability, SlashUnavailability) returns (uint256) {\n    return SlashUnavailability.getUnavailabilityIndicator(_validator, _period);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function checkBailedOutAtPeriod(\n    address _validator,\n    uint256 _period\n  ) public view override(CreditScore, ICreditScore, SlashUnavailability) returns (bool) {\n    return CreditScore.checkBailedOutAtPeriod(_validator, _period);\n  }\n\n  /**\n   * @dev Sanity check the address to be slashed\n   */\n  function _shouldSlash(address _addr) internal view override(SlashDoubleSign, SlashUnavailability) returns (bool) {\n    return\n      (msg.sender != _addr) &&\n      IRoninValidatorSet(getContract(ContractType.VALIDATOR)).isBlockProducer(_addr) &&\n      !IMaintenance(getContract(ContractType.MAINTENANCE)).checkMaintained(_addr, block.number);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashUnavailability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./CreditScore.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/slash-indicator/ISlashUnavailability.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport { ErrInvalidThreshold } from \"../../utils/CommonErrors.sol\";\n\nabstract contract SlashUnavailability is ISlashUnavailability, HasContracts, HasValidatorDeprecated {\n  /// @dev The last block that a validator is slashed for unavailability.\n  uint256 public lastUnavailabilitySlashedBlock;\n  /// @dev Mapping from validator address => period index => unavailability indicator.\n  mapping(address => mapping(uint256 => uint256)) internal _unavailabilityIndicator;\n\n  /**\n   * @dev The mining reward will be deprecated, if (s)he missed more than this threshold.\n   * This threshold is applied for tier-1 and tier-3 of unavailability slash.\n   */\n  uint256 internal _unavailabilityTier1Threshold;\n  /**\n   * @dev The mining reward will be deprecated, (s)he will be put in jailed, and will be deducted\n   * self-staking if (s)he misses more than this threshold. This threshold is applied for tier-2 slash.\n   */\n  uint256 internal _unavailabilityTier2Threshold;\n  /**\n   * @dev The amount of RON to deduct from self-staking of a block producer when (s)he is slashed with\n   * tier-2 or tier-3.\n   **/\n  uint256 internal _slashAmountForUnavailabilityTier2Threshold;\n  /// @dev The number of blocks to jail a block producer when (s)he is slashed with tier-2 or tier-3.\n  uint256 internal _jailDurationForUnavailabilityTier2Threshold;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  modifier oncePerBlock() {\n    if (block.number <= lastUnavailabilitySlashedBlock) {\n      revert ErrCannotSlashAValidatorTwiceOrSlashMoreThanOneValidatorInOneBlock();\n    }\n\n    lastUnavailabilitySlashedBlock = block.number;\n    _;\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function slashUnavailability(address _validatorAddr) external override oncePerBlock {\n    if (msg.sender != block.coinbase) revert ErrUnauthorized(msg.sig, RoleAccess.COINBASE);\n\n    if (!_shouldSlash(_validatorAddr)) {\n      // Should return instead of throwing error since this is a part of system transaction.\n      return;\n    }\n\n    IRoninValidatorSet _validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    uint256 _period = _validatorContract.currentPeriod();\n    uint256 _count;\n    unchecked {\n      _count = ++_unavailabilityIndicator[_validatorAddr][_period];\n    }\n    uint256 _newJailedUntilBlock = Math.addIfNonZero(block.number, _jailDurationForUnavailabilityTier2Threshold);\n\n    if (_count == _unavailabilityTier2Threshold) {\n      emit Slashed(_validatorAddr, SlashType.UNAVAILABILITY_TIER_2, _period);\n      _validatorContract.execSlash(\n        _validatorAddr,\n        _newJailedUntilBlock,\n        _slashAmountForUnavailabilityTier2Threshold,\n        false\n      );\n    } else if (_count == _unavailabilityTier1Threshold) {\n      bool _tier1SecondTime = checkBailedOutAtPeriod(_validatorAddr, _period);\n      if (!_tier1SecondTime) {\n        emit Slashed(_validatorAddr, SlashType.UNAVAILABILITY_TIER_1, _period);\n        _validatorContract.execSlash(_validatorAddr, 0, 0, false);\n      } else {\n        /// Handles tier-3\n        emit Slashed(_validatorAddr, SlashType.UNAVAILABILITY_TIER_3, _period);\n        _validatorContract.execSlash(\n          _validatorAddr,\n          _newJailedUntilBlock,\n          _slashAmountForUnavailabilityTier2Threshold,\n          true\n        );\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) external override onlyAdmin {\n    _setUnavailabilitySlashingConfigs(\n      _tier1Threshold,\n      _tier2Threshold,\n      _slashAmountForTier2Threshold,\n      _jailDurationForTier2Threshold\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function getUnavailabilitySlashingConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 unavailabilityTier1Threshold_,\n      uint256 unavailabilityTier2Threshold_,\n      uint256 slashAmountForUnavailabilityTier2Threshold_,\n      uint256 jailDurationForUnavailabilityTier2Threshold_\n    )\n  {\n    return (\n      _unavailabilityTier1Threshold,\n      _unavailabilityTier2Threshold,\n      _slashAmountForUnavailabilityTier2Threshold,\n      _jailDurationForUnavailabilityTier2Threshold\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function currentUnavailabilityIndicator(address _validator) external view override returns (uint256) {\n    return\n      getUnavailabilityIndicator(_validator, IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod());\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function getUnavailabilityIndicator(\n    address _validator,\n    uint256 _period\n  ) public view virtual override returns (uint256) {\n    return _unavailabilityIndicator[_validator][_period];\n  }\n\n  /**\n   * @dev Sets the unavailability indicator of the `_validator` at `_period`.\n   */\n  function _setUnavailabilityIndicator(address _validator, uint256 _period, uint256 _indicator) internal virtual {\n    _unavailabilityIndicator[_validator][_period] = _indicator;\n  }\n\n  /**\n   * @dev See `ISlashUnavailability-setUnavailabilitySlashingConfigs`.\n   */\n  function _setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) internal {\n    if (_unavailabilityTier1Threshold > _unavailabilityTier2Threshold) revert ErrInvalidThreshold(msg.sig);\n\n    _unavailabilityTier1Threshold = _tier1Threshold;\n    _unavailabilityTier2Threshold = _tier2Threshold;\n    _slashAmountForUnavailabilityTier2Threshold = _slashAmountForTier2Threshold;\n    _jailDurationForUnavailabilityTier2Threshold = _jailDurationForTier2Threshold;\n    emit UnavailabilitySlashingConfigsUpdated(\n      _tier1Threshold,\n      _tier2Threshold,\n      _slashAmountForTier2Threshold,\n      _jailDurationForTier2Threshold\n    );\n  }\n\n  /**\n   * @dev Returns whether the account `_addr` should be slashed or not.\n   */\n  function _shouldSlash(address _addr) internal view virtual returns (bool);\n\n  /**\n   * @dev See `ICreditScore-checkBailedOutAtPeriod`\n   */\n  function checkBailedOutAtPeriod(address _validator, uint256 _period) public view virtual returns (bool);\n}\n"
    },
    "contracts/utils/CommonErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ContractType } from \"./ContractType.sol\";\nimport { RoleAccess } from \"./RoleAccess.sol\";\n\nerror ErrSyncTooFarPeriod(uint256 period, uint256 latestRewardedPeriod);\n/**\n * @dev Error thrown when an address is expected to be an already created externally owned account (EOA).\n * This error indicates that the provided address is invalid for certain contract operations that require already created EOA.\n */\nerror ErrAddressIsNotCreatedEOA(address addr, bytes32 codehash);\n/**\n * @dev Error raised when a bridge operator update operation fails.\n * @param bridgeOperator The address of the bridge operator that failed to update.\n */\nerror ErrBridgeOperatorUpdateFailed(address bridgeOperator);\n/**\n * @dev Error thrown when attempting to add a bridge operator that already exists in the contract.\n * This error indicates that the provided bridge operator address is already registered as a bridge operator in the contract.\n */\nerror ErrBridgeOperatorAlreadyExisted(address bridgeOperator);\n/**\n * @dev The error indicating an unsupported interface.\n * @param interfaceId The bytes4 interface identifier that is not supported.\n * @param addr The address where the unsupported interface was encountered.\n */\nerror ErrUnsupportedInterface(bytes4 interfaceId, address addr);\n/**\n * @dev Error thrown when the return data from a callback function is invalid.\n * @param callbackFnSig The signature of the callback function that returned invalid data.\n * @param register The address of the register where the callback function was invoked.\n * @param returnData The invalid return data received from the callback function.\n */\nerror ErrInvalidReturnData(bytes4 callbackFnSig, address register, bytes returnData);\n/**\n * @dev Error of set to non-contract.\n */\nerror ErrZeroCodeContract(address addr);\n/**\n * @dev Error indicating that arguments are invalid.\n */\nerror ErrInvalidArguments(bytes4 msgSig);\n/**\n * @dev Error indicating that given address is null when it should not.\n */\nerror ErrZeroAddress(bytes4 msgSig);\n/**\n * @dev Error indicating that the provided threshold is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that the invalid threshold applies to.\n */\nerror ErrInvalidThreshold(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a function can only be called by the contract itself.\n * @param msgSig The function signature (bytes4) that can only be called by the contract itself.\n */\nerror ErrOnlySelfCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n * @param expectedRole The role required to perform the function.\n */\nerror ErrUnauthorized(bytes4 msgSig, RoleAccess expectedRole);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n */\nerror ErrUnauthorizedCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4).\n * @param expectedContractType The contract type required to perform the function.\n * @param actual The actual address that called to the function.\n */\nerror ErrUnexpectedInternalCall(bytes4 msgSig, ContractType expectedContractType, address actual);\n\n/**\n * @dev Error indicating that an array is empty when it should contain elements.\n */\nerror ErrEmptyArray();\n\n/**\n * @dev Error indicating a mismatch in the length of input parameters or arrays for a specific function.\n * @param msgSig The function signature (bytes4) that has a length mismatch.\n */\nerror ErrLengthMismatch(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a proxy call to an external contract has failed.\n * @param msgSig The function signature (bytes4) of the proxy call that failed.\n * @param extCallSig The function signature (bytes4) of the external contract call that failed.\n */\nerror ErrProxyCallFailed(bytes4 msgSig, bytes4 extCallSig);\n\n/**\n * @dev Error indicating that a function tried to call a precompiled contract that is not allowed.\n * @param msgSig The function signature (bytes4) that attempted to call a precompiled contract.\n */\nerror ErrCallPrecompiled(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a native token transfer has failed.\n * @param msgSig The function signature (bytes4) of the token transfer that failed.\n */\nerror ErrNativeTransferFailed(bytes4 msgSig);\n\n/**\n * @dev Error indicating that an order is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid order.\n */\nerror ErrInvalidOrder(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the chain ID is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid chain ID.\n * @param actual Current chain ID that executing function.\n * @param expected Expected chain ID required for the tx to success.\n */\nerror ErrInvalidChainId(bytes4 msgSig, uint256 actual, uint256 expected);\n\n/**\n * @dev Error indicating that a vote type is not supported.\n * @param msgSig The function signature (bytes4) of the operation that encountered an unsupported vote type.\n */\nerror ErrUnsupportedVoteType(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the proposal nonce is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid proposal nonce.\n */\nerror ErrInvalidProposalNonce(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a voter has already voted.\n * @param voter The address of the voter who has already voted.\n */\nerror ErrAlreadyVoted(address voter);\n\n/**\n * @dev Error indicating that a signature is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid signature.\n */\nerror ErrInvalidSignatures(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a relay call has failed.\n * @param msgSig The function signature (bytes4) of the relay call that failed.\n */\nerror ErrRelayFailed(bytes4 msgSig);\n/**\n * @dev Error indicating that a vote weight is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid vote weight.\n */\nerror ErrInvalidVoteWeight(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a query was made for an outdated bridge operator set.\n */\nerror ErrQueryForOutdatedBridgeOperatorSet();\n\n/**\n * @dev Error indicating that a request is invalid.\n */\nerror ErrInvalidRequest();\n\n/**\n * @dev Error indicating that a token standard is invalid.\n */\nerror ErrInvalidTokenStandard();\n\n/**\n * @dev Error indicating that a token is not supported.\n */\nerror ErrUnsupportedToken();\n\n/**\n * @dev Error indicating that a receipt kind is invalid.\n */\nerror ErrInvalidReceiptKind();\n\n/**\n * @dev Error indicating that a receipt is invalid.\n */\nerror ErrInvalidReceipt();\n\n/**\n * @dev Error indicating that an address is not payable.\n */\nerror ErrNonpayableAddress(address);\n\n/**\n * @dev Error indicating that the period is already processed, i.e. scattered reward.\n */\nerror ErrPeriodAlreadyProcessed(uint256 requestingPeriod, uint256 latestPeriod);\n\n/**\n * @dev Error thrown when an invalid vote hash is provided.\n */\nerror ErrInvalidVoteHash();\n\n/**\n * @dev Error thrown when querying for an empty vote.\n */\nerror ErrQueryForEmptyVote();\n\n/**\n * @dev Error thrown when querying for an expired vote.\n */\nerror ErrQueryForExpiredVote();\n\n/**\n * @dev Error thrown when querying for a non-existent vote.\n */\nerror ErrQueryForNonExistentVote();\n\n/**\n * @dev Error indicating that the method is only called once per block.\n */\nerror ErrOncePerBlock();\n\n/**\n * @dev Error of method caller must be coinbase\n */\nerror ErrCallerMustBeCoinbase();\n"
    },
    "contracts/utils/ContractType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum ContractType {\n  /*  0 */ UNKNOWN,\n  /*  1 */ PAUSE_ENFORCER,\n  /*  2 */ BRIDGE,\n  /*  3 */ BRIDGE_TRACKING,\n  /*  4 */ GOVERNANCE_ADMIN,\n  /*  5 */ MAINTENANCE,\n  /*  6 */ SLASH_INDICATOR,\n  /*  7 */ STAKING_VESTING,\n  /*  8 */ VALIDATOR,\n  /*  9 */ STAKING,\n  /* 10 */ RONIN_TRUSTED_ORGANIZATION,\n  /* 11 */ BRIDGE_MANAGER,\n  /* 12 */ BRIDGE_SLASH,\n  /* 13 */ BRIDGE_REWARD,\n  /* 14 */ FAST_FINALTIY_TRACKING,\n  /* 15 */ PROFILE\n}\n"
    },
    "contracts/utils/DeprecatedSlots.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Deprecated Contracts\n * @dev These abstract contracts are deprecated and should not be used in new implementations.\n * They provide functionality related to various aspects of a smart contract but have been marked\n * as deprecated to indicate that they are no longer actively maintained or recommended for use.\n * The purpose of these contracts is to preserve the slots for already deployed contracts.\n */\ncontract HasSlashIndicatorDeprecated {\n  /// @custom:deprecated Previously `_slashIndicatorContract` (non-zero value)\n  address internal ______deprecatedSlashIndicator;\n}\n\ncontract HasStakingVestingDeprecated {\n  /// @custom:deprecated Previously `_stakingVestingContract` (non-zero value)\n  address internal ______deprecatedStakingVesting;\n}\n\ncontract HasBridgeDeprecated {\n  /// @custom:deprecated Previously `_bridgeContract` (non-zero value)\n  address internal ______deprecatedBridge;\n}\n\ncontract HasValidatorDeprecated {\n  /// @custom:deprecated Previously `_validatorContract` (non-zero value)\n  address internal ______deprecatedValidator;\n}\n\ncontract HasStakingDeprecated {\n  /// @custom:deprecated Previously `_stakingContract` (non-zero value)\n  address internal ______deprecatedStakingContract;\n}\n\ncontract HasMaintenanceDeprecated {\n  /// @custom:deprecated Previously `_maintenanceContract` (non-zero value)\n  address internal ______deprecatedMaintenance;\n}\n\ncontract HasTrustedOrgDeprecated {\n  /// @custom:deprecated Previously `_trustedOrgContract` (non-zero value)\n  address internal ______deprecatedTrustedOrg;\n}\n\ncontract HasGovernanceAdminDeprecated {\n  /// @custom:deprecated Previously `_governanceAdminContract` (non-zero value)\n  address internal ______deprecatedGovernanceAdmin;\n}\n\ncontract HasBridgeTrackingDeprecated {\n  /// @custom:deprecated Previously `_bridgeTrackingContract` (non-zero value)\n  address internal ______deprecatedBridgeTracking;\n}\n"
    },
    "contracts/utils/IdentityGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { AddressArrayUtils } from \"../libraries/AddressArrayUtils.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { TransparentUpgradeableProxyV2 } from \"../extensions/TransparentUpgradeableProxyV2.sol\";\nimport { ErrAddressIsNotCreatedEOA, ErrZeroAddress, ErrOnlySelfCall, ErrZeroCodeContract, ErrUnsupportedInterface } from \"./CommonErrors.sol\";\n\nabstract contract IdentityGuard {\n  using AddressArrayUtils for address[];\n\n  /// @dev value is equal to keccak256(abi.encode())\n  /// @dev see: https://eips.ethereum.org/EIPS/eip-1052\n  bytes32 internal constant CREATED_ACCOUNT_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n  /**\n   * @dev Modifier to restrict functions to only be called by this contract.\n   * @dev Reverts if the caller is not this contract.\n   */\n  modifier onlySelfCall() virtual {\n    _requireSelfCall();\n    _;\n  }\n\n  /**\n   * @dev Modifier to ensure that the elements in the `arr` array are non-duplicates.\n   * It calls the internal `_checkDuplicate` function to perform the duplicate check.\n   *\n   * Requirements:\n   * - The elements in the `arr` array must not contain any duplicates.\n   */\n  modifier nonDuplicate(address[] memory arr) virtual {\n    _requireNonDuplicate(arr);\n    _;\n  }\n\n  /**\n   * @dev Internal method to check the method caller.\n   * @dev Reverts if the method caller is not this contract.\n   */\n  function _requireSelfCall() internal view virtual {\n    if (msg.sender != address(this)) revert ErrOnlySelfCall(msg.sig);\n  }\n\n  /**\n   * @dev Internal function to check if a contract address has code.\n   * @param addr The address of the contract to check.\n   * @dev Throws an error if the contract address has no code.\n   */\n  function _requireHasCode(address addr) internal view {\n    if (addr.code.length == 0) revert ErrZeroCodeContract(addr);\n  }\n\n  /**\n   * @dev Checks if an address is zero and reverts if it is.\n   * @param addr The address to check.\n   */\n  function _requireNonZeroAddress(address addr) internal pure {\n    if (addr == address(0)) revert ErrZeroAddress(msg.sig);\n  }\n\n  /**\n   * @dev Check if arr is empty and revert if it is.\n   * Checks if an array contains any duplicate addresses and reverts if duplicates are found.\n   * @param arr The array of addresses to check.\n   */\n  function _requireNonDuplicate(address[] memory arr) internal pure {\n    if (arr.hasDuplicate()) revert AddressArrayUtils.ErrDuplicated(msg.sig);\n  }\n\n  /**\n   * @dev Internal function to require that the provided address is a created externally owned account (EOA).\n   * This internal function is used to ensure that the provided address is a valid externally owned account (EOA).\n   * It checks the codehash of the address against a predefined constant to confirm that the address is a created EOA.\n   * @notice This method only works with non-state EOA accounts\n   */\n  function _requireCreatedEOA(address addr) internal view {\n    _requireNonZeroAddress(addr);\n    bytes32 codehash = addr.codehash;\n    if (codehash != CREATED_ACCOUNT_HASH) revert ErrAddressIsNotCreatedEOA(addr, codehash);\n  }\n\n  /**\n   * @dev Internal function to require that the specified contract supports the given interface. This method handle in\n   * both case that the callee is either or not the proxy admin of the caller. If the contract does not support the\n   * interface `interfaceId` or EIP165, a revert with the corresponding error message is triggered.\n   *\n   * @param contractAddr The address of the contract to check for interface support.\n   * @param interfaceId The interface ID to check for support.\n   */\n  function _requireSupportsInterface(address contractAddr, bytes4 interfaceId) internal view {\n    bytes memory supportsInterfaceParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n    (bool success, bytes memory returnOrRevertData) = contractAddr.staticcall(supportsInterfaceParams);\n    if (!success) {\n      (success, returnOrRevertData) = contractAddr.staticcall(\n        abi.encodeCall(TransparentUpgradeableProxyV2.functionDelegateCall, (supportsInterfaceParams))\n      );\n      if (!success) revert ErrUnsupportedInterface(interfaceId, contractAddr);\n    }\n    if (!abi.decode(returnOrRevertData, (bool))) revert ErrUnsupportedInterface(interfaceId, contractAddr);\n  }\n}\n"
    },
    "contracts/utils/RoleAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum RoleAccess {\n  /* 0 */ UNKNOWN,\n  /* 1 */ ADMIN,\n  /* 2 */ COINBASE,\n  /* 3 */ GOVERNOR,\n  /* 4 */ CANDIDATE_ADMIN,\n  /* 5 */ WITHDRAWAL_MIGRATOR,\n  /* 6 */ __DEPRECATED_BRIDGE_OPERATOR,\n  /* 7 */ BLOCK_PRODUCER,\n  /* 8 */ VALIDATOR_CANDIDATE\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}