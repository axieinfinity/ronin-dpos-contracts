{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/extensions/collections/HasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { HasProxyAdmin } from \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasContracts.sol\";\nimport { IdentityGuard } from \"../../utils/IdentityGuard.sol\";\nimport { ErrUnexpectedInternalCall } from \"../../utils/CommonErrors.sol\";\n\n/**\n * @title HasContracts\n * @dev A contract that provides functionality to manage multiple contracts with different roles.\n */\nabstract contract HasContracts is HasProxyAdmin, IHasContracts, IdentityGuard {\n  /// @dev value is equal to keccak256(\"@ronin.dpos.collections.HasContracts.slot\") - 1\n  bytes32 private constant _STORAGE_SLOT = 0xdea3103d22025c269050bea94c0c84688877f12fa22b7e6d2d5d78a9a49aa1cb;\n\n  /**\n   * @dev Modifier to restrict access to functions only to contracts with a specific role.\n   * @param contractType The contract type that allowed to call\n   */\n  modifier onlyContract(ContractType contractType) virtual {\n    _requireContract(contractType);\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function setContract(ContractType contractType, address addr) external virtual onlyAdmin {\n    _requireHasCode(addr);\n    _setContract(contractType, addr);\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function getContract(ContractType contractType) public view returns (address contract_) {\n    contract_ = _getContractMap()[uint8(contractType)];\n    if (contract_ == address(0)) revert ErrContractTypeNotFound(contractType);\n  }\n\n  /**\n   * @dev Internal function to set the address of a contract with a specific role.\n   * @param contractType The contract type of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function _setContract(ContractType contractType, address addr) internal virtual {\n    _getContractMap()[uint8(contractType)] = addr;\n    emit ContractUpdated(contractType, addr);\n  }\n\n  /**\n   * @dev Internal function to access the mapping of contract addresses with roles.\n   * @return contracts_ The mapping of contract addresses with roles.\n   */\n  function _getContractMap() private pure returns (mapping(uint8 => address) storage contracts_) {\n    assembly {\n      contracts_.slot := _STORAGE_SLOT\n    }\n  }\n\n  /**\n   * @dev Internal function to check if the calling contract has a specific role.\n   * @param contractType The contract type that the calling contract must have.\n   * @dev Throws an error if the calling contract does not have the specified role.\n   */\n  function _requireContract(ContractType contractType) private view {\n    if (msg.sender != getContract(contractType)) {\n      revert ErrUnexpectedInternalCall(msg.sig, contractType, msg.sender);\n    }\n  }\n}\n"
    },
    "contracts/extensions/collections/HasProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../utils/CommonErrors.sol\";\n\nabstract contract HasProxyAdmin {\n  // bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  modifier onlyAdmin() {\n    _requireAdmin();\n    _;\n  }\n\n  /**\n   * @dev Returns proxy admin.\n   */\n  function _getAdmin() internal view returns (address) {\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  function _requireAdmin() internal view {\n    if (msg.sender != _getAdmin()) revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\n  }\n}\n"
    },
    "contracts/extensions/consumers/GlobalConfigConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nabstract contract GlobalConfigConsumer {\n  /// @dev The addition amount of gas sending along in external calls. Total gas stipend is added with default 2300 gas.\n  uint256 public constant DEFAULT_ADDITION_GAS = 1200;\n  /// @dev The length of a period in second.\n  uint256 public constant PERIOD_DURATION = 1 days;\n}\n"
    },
    "contracts/extensions/consumers/PercentageConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract PercentageConsumer {\n  uint256 internal constant _MAX_PERCENTAGE = 100_00;\n}\n"
    },
    "contracts/extensions/RONTransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nabstract contract RONTransferHelper {\n  /// @dev Error of sender has insufficient balance.\n  error ErrInsufficientBalance(bytes4 msgSig, uint256 currentBalance, uint256 sendAmount);\n  /// @dev Error of recipient not accepting RON when transfer RON.\n  error ErrRecipientRevert(bytes4 msgSig);\n\n  /**\n   * @dev See `_sendRON`.\n   * Reverts if the recipient does not receive RON.\n   */\n  function _transferRON(address payable recipient, uint256 amount) internal {\n    if (!_sendRON(recipient, amount)) revert ErrRecipientRevert(msg.sig);\n  }\n\n  /**\n   * @dev Send `amount` RON to the address `recipient`.\n   * Returns whether the recipient receives RON or not.\n   * Reverts once the contract balance is insufficient.\n   *\n   * Note: consider using `ReentrancyGuard` before calling this function.\n   *\n   */\n  function _sendRON(address payable recipient, uint256 amount) internal returns (bool success) {\n    if (address(this).balance < amount) revert ErrInsufficientBalance(msg.sig, address(this).balance, amount);\n    return _unsafeSendRON(recipient, amount);\n  }\n\n  /**\n   * @dev Unsafe send `amount` RON to the address `recipient`. If the sender's balance is insufficient,\n   * the call does not revert.\n   *\n   * Note:\n   * - Does not assert whether the balance of sender is sufficient.\n   * - Does not assert whether the recipient accepts RON.\n   * - Consider using `ReentrancyGuard` before calling this function.\n   *\n   */\n  function _unsafeSendRON(address payable recipient, uint256 amount) internal returns (bool success) {\n    (success, ) = recipient.call{ value: amount }(\"\");\n  }\n\n  /**\n   * @dev Same purpose with {_unsafeSendRONLimitGas(address,uin256)} but containing gas limit stipend forwarded in the call.\n   */\n  function _unsafeSendRONLimitGas(\n    address payable recipient,\n    uint256 amount,\n    uint256 gas\n  ) internal returns (bool success) {\n    (success, ) = recipient.call{ value: amount, gas: gas }(\"\");\n  }\n}\n"
    },
    "contracts/extensions/TransparentUpgradeableProxyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract TransparentUpgradeableProxyV2 is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n\n  /**\n   * @dev Calls a function from the current implementation as specified by `_data`, which should be an encoded function call.\n   *\n   * Requirements:\n   * - Only the admin can call this function.\n   *\n   * Note: The proxy admin is not allowed to interact with the proxy logic through the fallback function to avoid\n   * triggering some unexpected logic. This is to allow the administrator to explicitly call the proxy, please consider\n   * reviewing the encoded data `_data` and the method which is called before using this.\n   *\n   */\n  function functionDelegateCall(bytes memory _data) public payable ifAdmin {\n    address _addr = _implementation();\n    assembly {\n      let _result := delegatecall(gas(), _addr, add(_data, 32), mload(_data), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch _result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/interfaces/collections/IHasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { ContractType } from \"../../utils/ContractType.sol\";\n\ninterface IHasContracts {\n  /// @dev Error of invalid role.\n  error ErrContractTypeNotFound(ContractType contractType);\n\n  /// @dev Emitted when a contract is updated.\n  event ContractUpdated(ContractType indexed contractType, address indexed addr);\n\n  /**\n   * @dev Returns the address of a contract with a specific role.\n   * Throws an error if no contract is set for the specified role.\n   *\n   * @param contractType The role of the contract to retrieve.\n   * @return contract_ The address of the contract with the specified role.\n   */\n  function getContract(ContractType contractType) external view returns (address contract_);\n\n  /**\n   * @dev Sets the address of a contract with a specific role.\n   * Emits the event {ContractUpdated}.\n   * @param contractType The role of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function setContract(ContractType contractType, address addr) external;\n}\n"
    },
    "contracts/interfaces/consumers/PeriodWrapperConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PeriodWrapperConsumer {\n  struct PeriodWrapper {\n    // Inner value.\n    uint256 inner;\n    // Last period number that the info updated.\n    uint256 lastPeriod;\n  }\n}\n"
    },
    "contracts/interfaces/IMaintenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IMaintenance {\n  /**\n   * @dev Error thrown when attempting to schedule an already scheduled event.\n   */\n  error ErrAlreadyScheduled();\n\n  /**\n   * @dev Error thrown when referring to a non-existent schedule.\n   */\n  error ErrUnexistedSchedule();\n\n  /**\n   * @dev Error thrown when the end block of a schedule is out of range.\n   */\n  error ErrEndBlockOutOfRange();\n\n  /**\n   * @dev Error thrown when the start block of a schedule is out of range.\n   */\n  error ErrStartBlockOutOfRange();\n\n  /**\n   * @dev Error thrown when attempting to initiate maintenance while already in maintenance mode.\n   */\n  error ErrAlreadyOnMaintenance();\n\n  /**\n   * @dev Error thrown when attempting an action before the cooldown period has ended.\n   */\n  error ErrCooldownTimeNotYetEnded();\n\n  /**\n   * @dev Error thrown when the total number of schedules exceeds the limit.\n   */\n  error ErrTotalOfSchedulesExceeded();\n\n  /**\n   * @dev Error thrown when an invalid maintenance duration is specified.\n   */\n  error ErrInvalidMaintenanceDuration();\n\n  /**\n   * @dev Error thrown when an invalid maintenance duration configuration is provided.\n   */\n  error ErrInvalidMaintenanceDurationConfig();\n\n  /**\n   * @dev Error thrown when an invalid offset is specified to start the schedule configurations.\n   */\n  error ErrInvalidOffsetToStartScheduleConfigs();\n\n  struct Schedule {\n    uint256 from;\n    uint256 to;\n    uint256 lastUpdatedBlock;\n    uint256 requestTimestamp;\n  }\n\n  /// @dev Emitted when a maintenance is scheduled.\n  event MaintenanceScheduled(address indexed consensusAddr, Schedule);\n  /// @dev Emitted when a schedule of maintenance is cancelled.\n  event MaintenanceScheduleCancelled(address indexed consensusAddr);\n  /// @dev Emitted when the maintenance config is updated.\n  event MaintenanceConfigUpdated(\n    uint256 minMaintenanceDurationInBlock,\n    uint256 maxMaintenanceDurationInBlock,\n    uint256 minOffsetToStartSchedule,\n    uint256 maxOffsetToStartSchedule,\n    uint256 maxSchedules,\n    uint256 cooldownSecsToMaintain\n  );\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr` maintained at the block number `_block`.\n   */\n  function checkMaintained(address _consensusAddr, uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr` maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks.\n   */\n  function checkMaintainedInBlockRange(\n    address _consensusAddr,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool);\n\n  /**\n   * @dev Returns the bool array indicating the validators maintained at block number `_block` or not.\n   */\n  function checkManyMaintained(address[] calldata _addrList, uint256 _block) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns a bool array indicating the validators maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks or not.\n   */\n  function checkManyMaintainedInBlockRange(\n    address[] calldata _addrList,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr` has scheduled.\n   */\n  function checkScheduled(address _consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr`\n   */\n  function checkCooldownEnds(address _consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns the detailed schedule of the validator `_consensusAddr`.\n   */\n  function getSchedule(address _consensusAddr) external view returns (Schedule memory);\n\n  /**\n   * @dev Returns the total of current schedules.\n   */\n  function totalSchedules() external view returns (uint256 _count);\n\n  /**\n   * @dev Sets the duration restriction, start time restriction, and max allowed for maintenance.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The max duration is larger than the min duration.\n   * - The max offset is larger than the min offset.\n   *\n   * Emits the event `MaintenanceConfigUpdated`.\n   *\n   */\n  function setMaintenanceConfig(\n    uint256 _minMaintenanceDurationInBlock,\n    uint256 _maxMaintenanceDurationInBlock,\n    uint256 _minOffsetToStartSchedule,\n    uint256 _maxOffsetToStartSchedule,\n    uint256 _maxSchedules,\n    uint256 _cooldownSecsToMaintain\n  ) external;\n\n  /**\n   * @dev Returns the min duration for maintenance in block.\n   */\n  function minMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the max duration for maintenance in block.\n   */\n  function maxMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev The offset to the min block number that the schedule can start\n   */\n  function minOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev The offset to the max block number that the schedule can start\n   */\n  function maxOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev Returns the max number of scheduled maintenances.\n   */\n  function maxSchedules() external view returns (uint256);\n\n  /**\n   * @dev Schedules for maintenance from `_startedAtBlock` to `_startedAtBlock`.\n   *\n   * Requirements:\n   * - The candidate `_consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `_consensusAddr`.\n   * - The candidate `_consensusAddr` has no schedule yet or the previous is done.\n   * - The total number of schedules is not larger than `maxSchedules()`.\n   * - The start block must be at least `minOffsetToStartSchedule()` and at most `maxOffsetToStartSchedule()` blocks from the current block.\n   * - The end block is larger than the start block.\n   * - The scheduled duration is larger than the `minMaintenanceDurationInBlock()` and less than the `maxMaintenanceDurationInBlock()`.\n   * - The start block is at the start of an epoch.\n   * - The end block is at the end of an epoch.\n   *\n   * Emits the event `MaintenanceScheduled`.\n   *\n   */\n  function schedule(address _consensusAddr, uint256 _startedAtBlock, uint256 _endedAtBlock) external;\n\n  /**\n   * @dev Cancel the schedule of maintenance for the `_consensusAddr`.\n   *\n   * Requirements:\n   * - The candidate `_consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `_consensusAddr`.\n   * - A schedule for the `_consensusAddr` must be existent and not executed yet.\n   *\n   * Emits the event `MaintenanceScheduleCancelled`.\n   */\n  function cancelSchedule(address _consensusAddr) external;\n}\n"
    },
    "contracts/interfaces/IQuorum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IQuorum {\n  /// @dev Emitted when the threshold is updated\n  event ThresholdUpdated(\n    uint256 indexed nonce,\n    uint256 indexed numerator,\n    uint256 indexed denominator,\n    uint256 previousNumerator,\n    uint256 previousDenominator\n  );\n\n  /**\n   * @dev Returns the threshold.\n   */\n  function getThreshold() external view returns (uint256 _num, uint256 _denom);\n\n  /**\n   * @dev Checks whether the `_voteWeight` passes the threshold.\n   */\n  function checkThreshold(uint256 _voteWeight) external view returns (bool);\n\n  /**\n   * @dev Returns the minimum vote weight to pass the threshold.\n   */\n  function minimumVoteWeight() external view returns (uint256);\n\n  /**\n   * @dev Sets the threshold.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `ThresholdUpdated` event.\n   *\n   */\n  function setThreshold(\n    uint256 _numerator,\n    uint256 _denominator\n  ) external returns (uint256 _previousNum, uint256 _previousDenom);\n}\n"
    },
    "contracts/interfaces/IRoninGovernanceAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/CommonErrors.sol\";\n\ninterface IRoninGovernanceAdmin {\n  /// @dev Emitted when an emergency exit poll is created.\n  event EmergencyExitPollCreated(\n    bytes32 _voteHash,\n    address _consensusAddr,\n    address _recipientAfterUnlockedFund,\n    uint256 _requestedAt,\n    uint256 _expiredAt\n  );\n  /// @dev Emitted when an emergency exit poll is approved.\n  event EmergencyExitPollApproved(bytes32 _voteHash);\n  /// @dev Emitted when an emergency exit poll is expired.\n  event EmergencyExitPollExpired(bytes32 _voteHash);\n  /// @dev Emitted when an emergency exit poll is voted.\n  event EmergencyExitPollVoted(bytes32 indexed _voteHash, address indexed _voter);\n\n  /**\n   * @dev Create a vote to agree that an emergency exit is valid and should return the locked funds back.a\n   *\n   * Requirements:\n   * - The method caller is validator contract.\n   *\n   */\n  function createEmergencyExitPoll(\n    address _consensusAddr,\n    address _recipientAfterUnlockedFund,\n    uint256 _requestedAt,\n    uint256 _expiredAt\n  ) external;\n}\n"
    },
    "contracts/interfaces/IRoninTrustedOrganization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IQuorum.sol\";\n\ninterface IRoninTrustedOrganization is IQuorum {\n  /**\n   * @dev Error indicating that a query for a duplicate entry was made.\n   */\n  error ErrQueryForDupplicated();\n\n  /**\n   * @dev Error indicating that a query was made for a non-existent consensus address.\n   */\n  error ErrQueryForNonExistentConsensusAddress();\n\n  /**\n   * @dev Error indicating that a bridge voter has already been added.\n   * @param voter The address of the bridge voter that is already added.\n   */\n  error ErrBridgeVoterIsAlreadyAdded(address voter);\n\n  /**\n   * @dev Error indicating that a governor address has already been added.\n   * @param addr The address of the governor that is already added.\n   */\n  error ErrGovernorAddressIsAlreadyAdded(address addr);\n\n  /**\n   * @dev Error indicating that a consensus address is not added.\n   * @param addr The address of the consensus contract that is not added.\n   */\n  error ErrConsensusAddressIsNotAdded(address addr);\n\n  /**\n   * @dev Error indicating that a consensus address is already added.\n   * @param addr The address of the consensus contract that is already added.\n   */\n  error ErrConsensusAddressIsAlreadyAdded(address addr);\n\n  struct TrustedOrganization {\n    // Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n    address consensusAddr;\n    // Address to voting proposal\n    address governor;\n    // Address to voting bridge operators\n    address bridgeVoter;\n    // Its Weight\n    uint256 weight;\n    // The block that the organization was added\n    uint256 addedBlock;\n  }\n\n  /// @dev Emitted when the trusted organization is added.\n  event TrustedOrganizationsAdded(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is updated.\n  event TrustedOrganizationsUpdated(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is removed.\n  event TrustedOrganizationsRemoved(address[] orgs);\n\n  /**\n   * @dev Adds a list of addresses into the trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   * - The field `addedBlock` should be blank.\n   *\n   * Emits the event `TrustedOrganizationAdded` once an organization is added.\n   *\n   */\n  function addTrustedOrganizations(TrustedOrganization[] calldata) external;\n\n  /**\n   * @dev Updates weights for a list of existent trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   *\n   * Emits the `TrustedOrganizationUpdated` event.\n   *\n   */\n  function updateTrustedOrganizations(TrustedOrganization[] calldata _list) external;\n\n  /**\n   * @dev Removes a list of addresses from the trusted organization.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `TrustedOrganizationRemoved` once an organization is removed.\n   *\n   * @param _consensusAddrs The list of consensus addresses linked to corresponding trusted organization that to be removed.\n   */\n  function removeTrustedOrganizations(address[] calldata _consensusAddrs) external;\n\n  /**\n   * @dev Returns total weights.\n   */\n  function totalWeights() external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a consensus.\n   */\n  function getConsensusWeight(address _consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a governor.\n   */\n  function getGovernorWeight(address _governor) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a bridge voter.\n   */\n  function getBridgeVoterWeight(address _addr) external view returns (uint256);\n\n  /**\n   * @dev Returns the weights of a list of consensus addresses.\n   */\n  function getConsensusWeights(address[] calldata _list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of governor addresses.\n   */\n  function getGovernorWeights(address[] calldata _list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of bridge voter addresses.\n   */\n  function getBridgeVoterWeights(address[] calldata _list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns total weights of the consensus list.\n   */\n  function sumConsensusWeights(address[] calldata _list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns total weights of the governor list.\n   */\n  function sumGovernorWeights(address[] calldata _list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns total weights of the bridge voter list.\n   */\n  function sumBridgeVoterWeights(address[] calldata _list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns the trusted organization at `_index`.\n   */\n  function getTrustedOrganizationAt(uint256 _index) external view returns (TrustedOrganization memory);\n\n  /**\n   * @dev Returns the number of trusted organizations.\n   */\n  function countTrustedOrganizations() external view returns (uint256);\n\n  /**\n   * @dev Returns all of the trusted organizations.\n   */\n  function getAllTrustedOrganizations() external view returns (TrustedOrganization[] memory);\n\n  /**\n   * @dev Returns the trusted organization by consensus address.\n   *\n   * Reverts once the consensus address is non-existent.\n   */\n  function getTrustedOrganization(address _consensusAddr) external view returns (TrustedOrganization memory);\n}\n"
    },
    "contracts/interfaces/IStakingVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IStakingVesting {\n  /**\n   * @dev Error thrown when attempting to send a bonus that has already been sent.\n   */\n  error ErrBonusAlreadySent();\n\n  /// @dev Emitted when the block bonus for block producer is transferred.\n  event BonusTransferred(\n    uint256 indexed blockNumber,\n    address indexed recipient,\n    uint256 blockProducerAmount,\n    uint256 bridgeOperatorAmount\n  );\n  /// @dev Emitted when the transfer of block bonus for block producer is failed.\n  event BonusTransferFailed(\n    uint256 indexed blockNumber,\n    address indexed recipient,\n    uint256 blockProducerAmount,\n    uint256 bridgeOperatorAmount,\n    uint256 contractBalance\n  );\n  /// @dev Emitted when the block bonus for block producer is updated\n  event BlockProducerBonusPerBlockUpdated(uint256);\n  /// @dev Emitted when the block bonus for bridge operator is updated\n  event BridgeOperatorBonusPerBlockUpdated(uint256);\n\n  /**\n   * @dev Returns the bonus amount for the block producer at `_block`.\n   */\n  function blockProducerBlockBonus(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Returns the bonus amount for the bridge validator at `_block`.\n   */\n  function bridgeOperatorBlockBonus(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Receives RON from any address.\n   */\n  function receiveRON() external payable;\n\n  /**\n   * @dev Returns the last block number that the staking vesting is sent.\n   */\n  function lastBlockSendingBonus() external view returns (uint256);\n\n  /**\n   * @dev Transfers the staking vesting for the block producer and the bridge operator whenever a new block is mined.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   * - The method must be called only once per block.\n   *\n   * Emits the event `BonusTransferred` or `BonusTransferFailed`.\n   *\n   * Notes:\n   * - The method does not revert when the contract balance is insufficient to send bonus. This assure the submit reward method\n   * will not be reverted, and the underlying nodes does not hang.\n   *\n   * @param _forBlockProducer Indicates whether requesting the bonus for the block procucer, in case of being in jail or relevance.\n   * @param _forBridgeOperator Indicates whether requesting the bonus for the bridge operator.\n   *\n   * @return _success Whether the transfer is successfully. This returns false mostly because this contract is out of balance.\n   * @return _blockProducerBonus The amount of bonus actually sent for the block producer, returns 0 when the transfer is failed.\n   * @return _bridgeOperatorBonus The amount of bonus actually sent for the bridge operator, returns 0 when the transfer is failed.\n   *\n   */\n  function requestBonus(\n    bool _forBlockProducer,\n    bool _forBridgeOperator\n  ) external returns (bool _success, uint256 _blockProducerBonus, uint256 _bridgeOperatorBonus);\n\n  /**\n   * @dev Sets the bonus amount per block for block producer.\n   *\n   * Emits the event `BlockProducerBonusPerBlockUpdated`.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   */\n  function setBlockProducerBonusPerBlock(uint256 _amount) external;\n\n  /**\n   * @dev Sets the bonus amount per block for bridge operator.\n   *\n   * Emits the event `BridgeOperatorBonusPerBlockUpdated`.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   */\n  function setBridgeOperatorBonusPerBlock(uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/IBaseSlash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IBaseSlash {\n  enum SlashType {\n    UNKNOWN,\n    UNAVAILABILITY_TIER_1,\n    UNAVAILABILITY_TIER_2,\n    DOUBLE_SIGNING,\n    BRIDGE_VOTING,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_1,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_2,\n    UNAVAILABILITY_TIER_3\n  }\n\n  /// @dev Emitted when the validator is slashed.\n  event Slashed(address indexed validator, SlashType slashType, uint256 period);\n}\n"
    },
    "contracts/interfaces/slash-indicator/ICreditScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ICreditScore {\n  /**\n   * @dev Error thrown when an invalid credit score configuration is provided.\n   */\n  error ErrInvalidCreditScoreConfig();\n\n  /**\n   * @dev Error thrown when an invalid cut-off percentage configuration is provided.\n   */\n  error ErrInvalidCutOffPercentageConfig();\n\n  /**\n   * @dev Error thrown when the caller's credit score is insufficient to bail out a situation.\n   */\n  error ErrInsufficientCreditScoreToBailOut();\n\n  /**\n   * @dev Error thrown when a validator has previously bailed out.\n   */\n  error ErrValidatorHasBailedOutPreviously();\n\n  /**\n   * @dev Error thrown when the caller must be jailed in the current period.\n   */\n  error ErrCallerMustBeJailedInTheCurrentPeriod();\n\n  /// @dev Emitted when the configs to credit score is updated. See the method `setCreditScoreConfigs` for param details.\n  event CreditScoreConfigsUpdated(\n    uint256 gainCreditScore,\n    uint256 maxCreditScore,\n    uint256 bailOutCostMultiplier,\n    uint256 cutOffPercentageAfterBailout\n  );\n  /// @dev Emitted the credit score of validators is updated.\n  event CreditScoresUpdated(address[] validators, uint256[] creditScores);\n  /// @dev Emitted when a validator bailed out of jail.\n  event BailedOut(address indexed validator, uint256 period, uint256 usedCreditScore);\n\n  /**\n   * @dev Updates the credit score for the validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function updateCreditScores(address[] calldata _validators, uint256 _period) external;\n\n  /**\n   * @dev Resets the credit score for the revoked validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function execResetCreditScores(address[] calldata _validators) external;\n\n  /**\n   * @dev A slashed validator use this method to get out of jail.\n   *\n   * Requirements:\n   * - The `_consensusAddr` must be a validator.\n   * - Only validator's admin can call this method.\n   *\n   * Emits the event `BailedOut`.\n   *\n   */\n  function bailOut(address _consensusAddr) external;\n\n  /**\n   * @dev Sets the configs to credit score.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CreditScoreConfigsUpdated`.\n   *\n   * @param _gainScore The score to gain per period.\n   * @param _maxScore The max number of credit score that a validator can hold.\n   * @param _bailOutMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @param _cutOffPercentage The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) external;\n\n  /**\n   * @dev Returns the configs related to credit score.\n   *\n   * @return _gainCreditScore The score to gain per period.\n   * @return _maxCreditScore The max number of credit score that a validator can hold.\n   * @return _bailOutCostMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @return _cutOffPercentageAfterBailout The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function getCreditScoreConfigs()\n    external\n    view\n    returns (\n      uint256 _gainCreditScore,\n      uint256 _maxCreditScore,\n      uint256 _bailOutCostMultiplier,\n      uint256 _cutOffPercentageAfterBailout\n    );\n\n  /**\n   * @dev Returns the current credit score of the validator.\n   */\n  function getCreditScore(address _validator) external view returns (uint256);\n\n  /**\n   * @dev Returns the current credit score of a list of validators.\n   */\n  function getManyCreditScores(address[] calldata _validators) external view returns (uint256[] memory _resultList);\n\n  /**\n   * @dev Returns the whether the `_validator` has been bailed out at the `_period`.\n   */\n  function checkBailedOutAtPeriod(address _validator, uint256 _period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashBridgeOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashBridgeOperator is IBaseSlash {\n  /**\n   * @dev Error thrown when invalid ratios are provided.\n   */\n  error ErrInvalidRatios();\n\n  /**\n   * @dev Emitted when the configs to slash bridge operator is updated. See the method\n   * `getBridgeOperatorSlashingConfigs` for param details.\n   */\n  event BridgeOperatorSlashingConfigsUpdated(\n    uint256 missingVotesRatioTier1,\n    uint256 missingVotesRatioTier2,\n    uint256 jailDurationForMissingVotesRatioTier2,\n    uint256 skipBridgeOperatorSlashingThreshold\n  );\n\n  /**\n   * @dev Acknowledges bridge operator slash and emit `Slashed` event correspondingly.\n   * @param _tier The tier of the slash, in value of {1, 2}, corresponding to `SlashType.BRIDGE_OPERATOR_MISSING_VOTE_TIER_1`\n   * and `SlashType.BRIDGE_OPERATOR_MISSING_VOTE_TIER_2`\n   *\n   * Requirements:\n   * - Only validator contract can invoke this method.\n   * - Should be called only at the end of period.\n   * - Should be called only when there is slash of bridge operator.\n   *\n   * Emits the event `Slashed`.\n   */\n  function execSlashBridgeOperator(address _consensusAddr, uint256 _tier, uint256 _period) external;\n\n  /**\n   * @dev Returns the configs related to bridge operator slashing.\n   *\n   * @return _missingVotesRatioTier1 The bridge reward will be deprecated if (s)he missed more than this ratio.\n   * @return _missingVotesRatioTier2 The bridge reward and mining reward will be deprecated and the corresponding\n   * block producer will be put in jail if (s)he misses more than this ratio.\n   * @return _jailDurationForMissingVotesRatioTier2 The number of blocks to jail the corresponding block producer when\n   * its bridge operator is slashed tier-2.\n   * @return _skipBridgeOperatorSlashingThreshold The threshold to skip slashing the bridge operator in case the total\n   * number of votes in the bridge is too small.\n   *\n   */\n  function getBridgeOperatorSlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _missingVotesRatioTier1,\n      uint256 _missingVotesRatioTier2,\n      uint256 _jailDurationForMissingVotesRatioTier2,\n      uint256 _skipBridgeOperatorSlashingThreshold\n    );\n\n  /**\n   * @dev Sets the configs to slash bridge operators.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeOperatorSlashingConfigsUpdated`.\n   *\n   * @param _ratioTier1 The bridge reward will be deprecated if (s)he missed more than this ratio. Values 0-10,000 map\n   * to 0%-100%.\n   * @param _ratioTier2 The bridge reward and mining reward will be deprecated and the corresponding block producer will\n   * be put in jail if (s)he misses more than this ratio. Values 0-10,000 map to 0%-100%.\n   * @param _jailDurationTier2 The number of blocks to jail the corresponding block producer when its bridge operator is\n   * slashed tier-2.\n   * @param _skipSlashingThreshold The threshold to skip slashing the bridge operator in case the total number of votes\n   * in the bridge is too small.\n   *\n   */\n  function setBridgeOperatorSlashingConfigs(\n    uint256 _ratioTier1,\n    uint256 _ratioTier2,\n    uint256 _jailDurationTier2,\n    uint256 _skipSlashingThreshold\n  ) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashBridgeVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashBridgeVoting is IBaseSlash {\n  /**\n   * @dev Error thrown when an invalid slash is encountered.\n   */\n  error ErrInvalidSlash();\n\n  /**\n   * @dev Emitted when the configs to slash bridge voting is updated. See the method `getBridgeVotingSlashingConfigs` for param\n   * details.\n   */\n  event BridgeVotingSlashingConfigsUpdated(uint256 bridgeVotingThreshold, uint256 bridgeVotingSlashAmount);\n\n  /**\n   * @dev Slashes for bridge voter governance.\n   *\n   * Emits the event `Slashed`.\n   */\n  function slashBridgeVoting(address _consensusAddr) external;\n\n  /**\n   * @dev Returns the configs related to bridge voting slashing.\n   *\n   * @return _bridgeVotingThreshold The threshold to slash when a trusted organization does not vote for bridge\n   * operators.\n   * @return _bridgeVotingSlashAmount The amount of RON to slash bridge voting.\n   *\n   */\n  function getBridgeVotingSlashingConfigs()\n    external\n    view\n    returns (uint256 _bridgeVotingThreshold, uint256 _bridgeVotingSlashAmount);\n\n  /**\n   * @dev Sets the configs to slash bridge voting.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeVotingSlashingConfigsUpdated`.\n   *\n   * @param _threshold The threshold to slash when a trusted organization does not vote for bridge operators.\n   * @param _slashAmount The amount of RON to slash bridge voting.\n   *\n   */\n  function setBridgeVotingSlashingConfigs(uint256 _threshold, uint256 _slashAmount) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashDoubleSign is IBaseSlash {\n  /**\n   * @dev Error thrown when evidence has already been submitted.\n   */\n  error ErrEvidenceAlreadySubmitted();\n\n  /**\n   * @dev Emitted when the configs to slash double sign is updated. See the method `getDoubleSignSlashingConfigs`\n   * for param details.\n   */\n  event DoubleSignSlashingConfigsUpdated(\n    uint256 slashDoubleSignAmount,\n    uint256 doubleSigningJailUntilBlock,\n    uint256 doubleSigningOffsetLimitBlock\n  );\n\n  /**\n   * @dev Slashes for double signing.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` if the double signing evidence of the two headers valid.\n   */\n  function slashDoubleSign(address _validatorAddr, bytes calldata _header1, bytes calldata _header2) external;\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return _slashDoubleSignAmount The amount of RON to slash double sign.\n   * @return _doubleSigningJailUntilBlock The block number that the punished validator will be jailed until, due to\n   * double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function getDoubleSignSlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _slashDoubleSignAmount,\n      uint256 _doubleSigningJailUntilBlock,\n      uint256 _doubleSigningOffsetLimitBlock\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `DoubleSignSlashingConfigsUpdated`.\n   *\n   * @param _slashAmount The amount of RON to slash double sign.\n   * @param _jailUntilBlock The block number that the punished validator will be jailed until, due to double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _doubleSigningOffsetLimitBlock\n  ) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashIndicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashDoubleSign.sol\";\nimport \"./ISlashBridgeVoting.sol\";\nimport \"./ISlashBridgeOperator.sol\";\nimport \"./ISlashUnavailability.sol\";\nimport \"./ICreditScore.sol\";\n\ninterface ISlashIndicator is\n  ISlashDoubleSign,\n  ISlashBridgeVoting,\n  ISlashBridgeOperator,\n  ISlashUnavailability,\n  ICreditScore\n{}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashUnavailability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashUnavailability is IBaseSlash {\n  /**\n   * @dev Error thrown when attempting to slash a validator twice or slash more than one validator in one block.\n   */\n  error ErrCannotSlashAValidatorTwiceOrSlashMoreThanOneValidatorInOneBlock();\n\n  /**\n   * @dev Emitted when the configs to slash bridge operator is updated. See the method `getUnavailabilitySlashingConfigs`\n   * for param details.\n   */\n  event UnavailabilitySlashingConfigsUpdated(\n    uint256 unavailabilityTier1Threshold,\n    uint256 unavailabilityTier2Threshold,\n    uint256 slashAmountForUnavailabilityTier2Threshold,\n    uint256 jailDurationForUnavailabilityTier2Threshold\n  );\n\n  /**\n   * @dev Returns the last block that a block producer is slashed for unavailability.\n   */\n  function lastUnavailabilitySlashedBlock() external view returns (uint256);\n\n  /**\n   * @dev Slashes for unavailability by increasing the counter of block producer `_consensusAddr`.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` when the threshold is reached.\n   *\n   */\n  function slashUnavailability(address _consensusAddr) external;\n\n  /**\n   * @dev Returns the current unavailability indicator of a block producer.\n   */\n  function currentUnavailabilityIndicator(address _validator) external view returns (uint256);\n\n  /**\n   * @dev Returns the unavailability indicator in the period `_period` of a block producer.\n   */\n  function getUnavailabilityIndicator(address _validator, uint256 _period) external view returns (uint256);\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return _unavailabilityTier1Threshold The mining reward will be deprecated, if (s)he missed more than this\n   * threshold. This threshold is applied for tier-1 and tier-3 slash.\n   * @return _unavailabilityTier2Threshold  The mining reward will be deprecated, (s)he will be put in jailed, and will\n   * be deducted self-staking if (s)he misses more than this threshold. This threshold is applied for tier-2 slash.\n   * @return _slashAmountForUnavailabilityTier2Threshold The amount of RON to deduct from self-staking of a block\n   * producer when (s)he is slashed with tier-2 or tier-3.\n   * @return _jailDurationForUnavailabilityTier2Threshold The number of blocks to jail a block producer when (s)he is\n   * slashed with tier-2 or tier-3.\n   *\n   */\n  function getUnavailabilitySlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _unavailabilityTier1Threshold,\n      uint256 _unavailabilityTier2Threshold,\n      uint256 _slashAmountForUnavailabilityTier2Threshold,\n      uint256 _jailDurationForUnavailabilityTier2Threshold\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeOperatorSlashingConfigsUpdated`.\n   *\n   * @param _tier1Threshold The mining reward will be deprecated, if (s)he missed more than this threshold.\n   * @param _tier2Threshold The mining reward will be deprecated, (s)he will be put in jailed, and will be deducted\n   * self-staking if (s)he misses more than this threshold.\n   * @param _slashAmountForTier2Threshold The amount of RON to deduct from self-staking of a block producer when (s)he\n   * is slashed tier-2.\n   * @param _jailDurationForTier2Threshold The number of blocks to jail a block producer when (s)he is slashed tier-2.\n   *\n   */\n  function setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) external;\n}\n"
    },
    "contracts/interfaces/staking/IBaseStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IBaseStaking {\n  struct PoolDetail {\n    // Address of the pool i.e. consensus address of the validator\n    address addr;\n    // Pool admin address\n    address admin;\n    // Self-staking amount\n    uint256 stakingAmount;\n    // Total number of RON staking for the pool\n    uint256 stakingTotal;\n    // Mapping from delegator => delegating amount\n    mapping(address => uint256) delegatingAmount;\n    // Mapping from delegator => the last timestamp that delegator staked\n    mapping(address => uint256) lastDelegatingTimestamp;\n  }\n\n  /// @dev Emitted when the minium number of seconds to undelegate is updated.\n  event CooldownSecsToUndelegateUpdated(uint256 minSecs);\n  /// @dev Emitted when the number of seconds that a candidate must wait to be revoked.\n  event WaitingSecsToRevokeUpdated(uint256 secs);\n\n  /// @dev Error of cannot transfer RON.\n  error ErrCannotTransferRON();\n  /// @dev Error of receiving zero message value.\n  error ErrZeroValue();\n  /// @dev Error of pool admin is not allowed to call.\n  error ErrPoolAdminForbidden();\n  /// @dev Error of no one is allowed to call but the pool's admin.\n  error ErrOnlyPoolAdminAllowed();\n  /// @dev Error of admin of any active pool cannot delegate.\n  error ErrAdminOfAnyActivePoolForbidden(address admin);\n  /// @dev Error of querying inactive pool.\n  error ErrInactivePool(address poolAddr);\n  /// @dev Error of length of input arrays are not of the same.\n  error ErrInvalidArrays();\n\n  /**\n   * @dev Returns whether the `_poolAdminAddr` is currently active.\n   */\n  function isAdminOfActivePool(address _poolAdminAddr) external view returns (bool);\n\n  /**\n   * @dev Returns the consensus address corresponding to the pool admin.\n   */\n  function getPoolAddressOf(address _poolAdminAddr) external view returns (address);\n\n  /**\n   * @dev Returns the staking pool detail.\n   */\n  function getPoolDetail(address) external view returns (address _admin, uint256 _stakingAmount, uint256 _stakingTotal);\n\n  /**\n   * @dev Returns the self-staking amounts of the pools.\n   */\n  function getManySelfStakings(address[] calldata) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns The cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n   */\n  function cooldownSecsToUndelegate() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of seconds that a candidate must wait for the renounce request gets affected.\n   */\n  function waitingSecsToRevoke() external view returns (uint256);\n\n  /**\n   * @dev Sets the cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CooldownSecsToUndelegateUpdated`.\n   *\n   */\n  function setCooldownSecsToUndelegate(uint256 _cooldownSecs) external;\n\n  /**\n   * @dev Sets the number of seconds that a candidate must wait to be revoked.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `WaitingSecsToRevokeUpdated`.\n   *\n   */\n  function setWaitingSecsToRevoke(uint256 _secs) external;\n}\n"
    },
    "contracts/interfaces/staking/ICandidateStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IRewardPool.sol\";\n\ninterface ICandidateStaking is IRewardPool {\n  /// @dev Emitted when the minimum staking amount for being a validator is updated.\n  event MinValidatorStakingAmountUpdated(uint256 threshold);\n  /// @dev Emitted when the commission rate range is updated.\n  event CommissionRateRangeUpdated(uint256 minRate, uint256 maxRate);\n\n  /// @dev Emitted when the pool admin staked for themself.\n  event Staked(address indexed consensuAddr, uint256 amount);\n  /// @dev Emitted when the pool admin unstaked the amount of RON from themself.\n  event Unstaked(address indexed consensuAddr, uint256 amount);\n\n  /// @dev Emitted when the validator pool is approved.\n  event PoolApproved(address indexed validator, address indexed admin);\n  /// @dev Emitted when the validator pool is deprecated.\n  event PoolsDeprecated(address[] validator);\n  /// @dev Emitted when the staking amount transfer failed.\n  event StakingAmountTransferFailed(\n    address indexed validator,\n    address indexed admin,\n    uint256 amount,\n    uint256 contractBalance\n  );\n  /// @dev Emitted when the staking amount deducted failed, e.g. when the validator gets slashed.\n  event StakingAmountDeductFailed(\n    address indexed validator,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Error of cannot transfer RON to specified target.\n  error ErrCannotInitTransferRON(address addr, string extraInfo);\n  /// @dev Error of three interaction addresses must be of the same in applying for validator candidate.\n  error ErrThreeInteractionAddrsNotEqual();\n  /// @dev Error of unstaking zero amount.\n  error ErrUnstakeZeroAmount();\n  /// @dev Error of invalid staking amount left after deducted.\n  error ErrStakingAmountLeft();\n  /// @dev Error of insufficient staking amount for unstaking.\n  error ErrInsufficientStakingAmount();\n  /// @dev Error of unstaking too early.\n  error ErrUnstakeTooEarly();\n  /// @dev Error of setting commission rate exceeds max allowed.\n  error ErrInvalidCommissionRate();\n\n  /**\n   * @dev Returns the minimum threshold for being a validator candidate.\n   */\n  function minValidatorStakingAmount() external view returns (uint256);\n\n  /**\n   * @dev Returns the commission rate range that the candidate can set.\n   */\n  function getCommissionRateRange() external view returns (uint256 _minRange, uint256 _maxRange);\n\n  /**\n   * @dev Sets the minimum threshold for being a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinValidatorStakingAmountUpdated` event.\n   *\n   */\n  function setMinValidatorStakingAmount(uint256) external;\n\n  /**\n   * @dev Sets the commission rate range that a candidate can set.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `CommissionRateRangeUpdated` event.\n   *\n   */\n  function setCommissionRateRange(uint256 _minRate, uint256 _maxRate) external;\n\n  /**\n   * @dev Proposes a candidate to become a validator.\n   *\n   * Requirements:\n   * - The method caller is able to receive RON.\n   * - The treasury is able to receive RON.\n   * - The amount is larger than or equal to the minimum validator staking amount `minValidatorStakingAmount()`.\n   *\n   * Emits the event `PoolApproved`.\n   *\n   * @param _candidateAdmin the candidate admin will be stored in the validator contract, used for calling function that affects\n   * to its candidate, e.g. scheduling maintenance.\n   *\n   */\n  function applyValidatorCandidate(\n    address _candidateAdmin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    uint256 _commissionRate\n  ) external payable;\n\n  /**\n   * @dev Deprecates the pool.\n   * - Deduct self-staking amount of the pool admin to zero.\n   * - Transfer the deducted amount to the pool admin.\n   * - Deactivate the pool admin address in the mapping of active pool admins\n   *\n   * Requirements:\n   * - The method caller is validator contract.\n   *\n   * Emits the event `PoolsDeprecated` and `Unstaked` events.\n   * Emits the event `StakingAmountTransferFailed` if the contract cannot transfer RON back to the pool admin.\n   *\n   */\n  function execDeprecatePools(address[] calldata _pools, uint256 _period) external;\n\n  /**\n   * @dev Self-delegates to the validator candidate `_consensusAddr`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   * - The `msg.value` is larger than 0.\n   *\n   * Emits the event `Staked`.\n   *\n   */\n  function stake(address _consensusAddr) external payable;\n\n  /**\n   * @dev Unstakes from the validator candidate `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   * Emits the event `Unstaked`.\n   *\n   */\n  function unstake(address _consensusAddr, uint256 _amount) external;\n\n  /**\n   * @dev Pool admin requests update validator commission rate. The request will be forwarded to the candidate manager\n   * contract, and the value is getting updated in {ICandidateManager-execRequestUpdateCommissionRate}.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   * - The `_effectiveDaysOnwards` must be equal to or larger than the {CandidateManager-_minEffectiveDaysOnwards}.\n   * - The `_rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdated`.\n   *\n   */\n  function requestUpdateCommissionRate(\n    address _consensusAddr,\n    uint256 _effectiveDaysOnwards,\n    uint256 _commissionRate\n  ) external;\n\n  /**\n   * @dev Renounces being a validator candidate and takes back the delegating/staking amount.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   */\n  function requestRenounce(address _consensusAddr) external;\n\n  /**\n   * @dev Renounces being a validator candidate and takes back the delegating/staking amount.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   */\n  function requestEmergencyExit(address _consensusAddr) external;\n}\n"
    },
    "contracts/interfaces/staking/IDelegatorStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IRewardPool.sol\";\n\ninterface IDelegatorStaking is IRewardPool {\n  /// @dev Emitted when the delegator staked for a validator candidate.\n  event Delegated(address indexed delegator, address indexed consensuAddr, uint256 amount);\n  /// @dev Emitted when the delegator unstaked from a validator candidate.\n  event Undelegated(address indexed delegator, address indexed consensuAddr, uint256 amount);\n\n  /// @dev Error of undelegating zero amount.\n  error ErrUndelegateZeroAmount();\n  /// @dev Error of undelegating insufficient amount.\n  error ErrInsufficientDelegatingAmount();\n  /// @dev Error of undelegating too early.\n  error ErrUndelegateTooEarly();\n\n  /**\n   * @dev Stakes for a validator candidate `_consensusAddr`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is not the pool admin.\n   *\n   * Emits the `Delegated` event.\n   *\n   */\n  function delegate(address _consensusAddr) external payable;\n\n  /**\n   * @dev Unstakes from a validator candidate `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   *\n   * Emits the `Undelegated` event.\n   *\n   */\n  function undelegate(address _consensusAddr, uint256 _amount) external;\n\n  /**\n   * @dev Bulk unstakes from a list of candidates.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   *\n   * Emits the events `Undelegated`.\n   *\n   */\n  function bulkUndelegate(address[] calldata _consensusAddrs, uint256[] calldata _amounts) external;\n\n  /**\n   * @dev Unstakes an amount of RON from the `_consensusAddrSrc` and stake for `_consensusAddrDst`.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   * - The consensus address `_consensusAddrDst` is a validator candidate.\n   *\n   * Emits the `Undelegated` event and the `Delegated` event.\n   *\n   */\n  function redelegate(address _consensusAddrSrc, address _consensusAddrDst, uint256 _amount) external;\n\n  /**\n   * @dev Returns the claimable reward of the user `_user`.\n   */\n  function getRewards(\n    address _user,\n    address[] calldata _poolAddrList\n  ) external view returns (uint256[] memory _rewards);\n\n  /**\n   * @dev Claims the reward of method caller.\n   *\n   * Emits the `RewardClaimed` event.\n   *\n   */\n  function claimRewards(address[] calldata _consensusAddrList) external returns (uint256 _amount);\n\n  /**\n   * @dev Claims the rewards and delegates them to the consensus address.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   * - The consensus address `_consensusAddrDst` is a validator candidate.\n   *\n   * Emits the `RewardClaimed` event and the `Delegated` event.\n   *\n   */\n  function delegateRewards(\n    address[] calldata _consensusAddrList,\n    address _consensusAddrDst\n  ) external returns (uint256 _amount);\n}\n"
    },
    "contracts/interfaces/staking/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/consumers/PeriodWrapperConsumer.sol\";\n\ninterface IRewardPool is PeriodWrapperConsumer {\n  struct UserRewardFields {\n    // Recorded reward amount.\n    uint256 debited;\n    // The last accumulated of the amount rewards per share (one unit staking) that the info updated.\n    uint256 aRps;\n    // Lowest staking amount in the period.\n    uint256 lowestAmount;\n    // Last period number that the info updated.\n    uint256 lastPeriod;\n  }\n\n  struct PoolFields {\n    // Accumulated of the amount rewards per share (one unit staking).\n    uint256 aRps;\n    // The staking total to share reward of the current period.\n    PeriodWrapper shares;\n  }\n\n  /// @dev Emitted when the fields to calculate pending reward for the user is updated.\n  event UserRewardUpdated(address indexed poolAddr, address indexed user, uint256 debited);\n  /// @dev Emitted when the user claimed their reward\n  event RewardClaimed(address indexed poolAddr, address indexed user, uint256 amount);\n\n  /// @dev Emitted when the pool shares are updated\n  event PoolSharesUpdated(uint256 indexed period, address indexed poolAddr, uint256 shares);\n  /// @dev Emitted when the pools are updated\n  event PoolsUpdated(uint256 indexed period, address[] poolAddrs, uint256[] aRps, uint256[] shares);\n  /// @dev Emitted when the contract fails when updating the pools\n  event PoolsUpdateFailed(uint256 indexed period, address[] poolAddrs, uint256[] rewards);\n  /// @dev Emitted when the contract fails when updating the pools that already set\n  event PoolsUpdateConflicted(uint256 indexed period, address[] poolAddrs);\n\n  /// @dev Error of invalid pool share.\n  error ErrInvalidPoolShare();\n\n  /**\n   * @dev Returns the reward amount that user claimable.\n   */\n  function getReward(address _poolAddr, address _user) external view returns (uint256);\n\n  /**\n   * @dev Returns the staking amount of an user.\n   */\n  function getStakingAmount(address _poolAddr, address _user) external view returns (uint256);\n\n  /**\n   * @dev Returns the staking amounts of the users.\n   */\n  function getManyStakingAmounts(\n    address[] calldata _poolAddrs,\n    address[] calldata _userList\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the total staking amount of all users for a pool.\n   */\n  function getStakingTotal(address _poolAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the total staking amounts of all users for the pools `_poolAddrs`.\n   */\n  function getManyStakingTotals(address[] calldata _poolAddrs) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/interfaces/staking/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseStaking.sol\";\nimport \"./ICandidateStaking.sol\";\nimport \"./IDelegatorStaking.sol\";\n\ninterface IStaking is IRewardPool, IBaseStaking, ICandidateStaking, IDelegatorStaking {\n  /**\n   * @dev Records the amount of rewards `_rewards` for the pools `_consensusAddrs`.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   *\n   * Emits the event `PoolsUpdated` once the contract recorded the rewards successfully.\n   * Emits the event `PoolsUpdateFailed` once the input array lengths are not equal.\n   * Emits the event `PoolsUpdateConflicted` when there are some pools which already updated in the period.\n   *\n   * Note: This method should be called once at the period ending.\n   *\n   */\n  function execRecordRewards(\n    address[] calldata _consensusAddrs,\n    uint256[] calldata _rewards,\n    uint256 _period\n  ) external payable;\n\n  /**\n   * @dev Deducts from staking amount of the validator `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   *\n   * Emits the event `Unstaked`.\n   *\n   */\n  function execDeductStakingAmount(\n    address _consensusAddr,\n    uint256 _amount\n  ) external returns (uint256 _actualDeductingAmount);\n}\n"
    },
    "contracts/interfaces/validator/ICandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ICandidateManager {\n  struct ValidatorCandidate {\n    // Admin of the candidate\n    address admin;\n    // Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n    address consensusAddr;\n    // Address that receives mining reward of the validator\n    address payable treasuryAddr;\n    // Address of the bridge operator corresponding to the candidate\n    address ______deprecatedbridgeOperatorAddr;\n    // The percentage of reward that validators can be received, the rest goes to the delegators.\n    // Values in range [0; 100_00] stands for 0-100%\n    uint256 commissionRate;\n    // The timestamp that scheduled to revoke the candidate (no schedule=0)\n    uint256 revokingTimestamp;\n    // The deadline that the candidate must top up staking amount to keep it larger than or equal to the threshold (no deadline=0)\n    uint256 topupDeadline;\n  }\n\n  struct CommissionSchedule {\n    // The timestamp that the commission schedule gets affected (no schedule=0).\n    uint256 effectiveTimestamp;\n    // The new commission rate. Value is in range [0; 100_00], stands for 0-100%\n    uint256 commissionRate;\n  }\n\n  /// @dev Emitted when the maximum number of validator candidates is updated.\n  event MaxValidatorCandidateUpdated(uint256 threshold);\n  /// @dev Emitted when the min offset to the effective date of commission rate change is updated.\n  event MinEffectiveDaysOnwardsUpdated(uint256 numOfDays);\n  /// @dev Emitted when the validator candidate is granted.\n  event CandidateGranted(address indexed consensusAddr, address indexed treasuryAddr, address indexed admin);\n  /// @dev Emitted when the revoking timestamp of a candidate is updated.\n  event CandidateRevokingTimestampUpdated(address indexed consensusAddr, uint256 revokingTimestamp);\n  /// @dev Emitted when the topup deadline of a candidate is updated.\n  event CandidateTopupDeadlineUpdated(address indexed consensusAddr, uint256 topupDeadline);\n  /// @dev Emitted when the validator candidate is revoked.\n  event CandidatesRevoked(address[] consensusAddrs);\n\n  /// @dev Emitted when a schedule for updating commission rate is set.\n  event CommissionRateUpdateScheduled(address indexed consensusAddr, uint256 effectiveTimestamp, uint256 rate);\n  /// @dev Emitted when the commission rate of a validator is updated.\n  event CommissionRateUpdated(address indexed consensusAddr, uint256 rate);\n\n  /// @dev Error of exceeding maximum number of candidates.\n  error ErrExceedsMaxNumberOfCandidate();\n  /// @dev Error of querying for already existent candidate.\n  error ErrExistentCandidate();\n  /// @dev Error of querying for non-existent candidate.\n  error ErrNonExistentCandidate();\n  /// @dev Error of candidate admin already exists.\n  error ErrExistentCandidateAdmin(address _candidateAdminAddr);\n  /// @dev Error of treasury already exists.\n  error ErrExistentTreasury(address _treasuryAddr);\n  /// @dev Error of invalid commission rate.\n  error ErrInvalidCommissionRate();\n  /// @dev Error of invalid effective days onwards.\n  error ErrInvalidEffectiveDaysOnwards();\n  /// @dev Error of invalid min effective days onwards.\n  error ErrInvalidMinEffectiveDaysOnwards();\n  /// @dev Error of already requested revoking candidate before.\n  error ErrAlreadyRequestedRevokingCandidate();\n  /// @dev Error of commission change schedule exists.\n  error ErrAlreadyRequestedUpdatingCommissionRate();\n  /// @dev Error of trusted org cannot renounce.\n  error ErrTrustedOrgCannotRenounce();\n\n  /**\n   * @dev Returns the maximum number of validator candidate.\n   */\n  function maxValidatorCandidate() external view returns (uint256);\n\n  /**\n   * @dev Returns the minimum number of days to the effective date of commission rate change.\n   */\n  function minEffectiveDaysOnwards() external view returns (uint256);\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function setMaxValidatorCandidate(uint256) external;\n\n  /**\n   * @dev Sets the minimum number of days to the effective date of commision rate change.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external;\n\n  /**\n   * @dev Grants a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateGranted`.\n   *\n   */\n  function execApplyValidatorCandidate(\n    address _admin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    uint256 _commissionRate\n  ) external;\n\n  /**\n   * @dev Requests to revoke a validator candidate in next `_secsLeft` seconds.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateRevokingTimestampUpdated`.\n   *\n   */\n  function execRequestRenounceCandidate(address, uint256 _secsLeft) external;\n\n  /**\n   * @dev Fallback function of `CandidateStaking-requestUpdateCommissionRate`.\n   *\n   * Requirements:\n   * - The method caller is the staking contract.\n   * - The `_effectiveTimestamp` must be the beginning of a UTC day, and at least from 7 days onwards\n   * - The `_rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdateScheduled`.\n   *\n   */\n  function execRequestUpdateCommissionRate(address _consensusAddr, uint256 _effectiveTimestamp, uint256 _rate) external;\n\n  /**\n   * @dev Returns whether the address is a validator (candidate).\n   */\n  function isValidatorCandidate(address _addr) external view returns (bool);\n\n  /**\n   * @dev Returns the validator candidate.\n   */\n  function getValidatorCandidates() external view returns (address[] memory);\n\n  /**\n   * @dev Returns all candidate info.\n   */\n  function getCandidateInfos() external view returns (ValidatorCandidate[] memory);\n\n  /**\n   * @dev Returns the info of a candidate.\n   */\n  function getCandidateInfo(address _candidate) external view returns (ValidatorCandidate memory);\n\n  /**\n   * @dev Returns whether the address is the candidate admin.\n   */\n  function isCandidateAdmin(address _candidate, address _admin) external view returns (bool);\n\n  /**\n   * @dev Returns the schedule of changing commission rate of a candidate address.\n   */\n  function getCommissionChangeSchedule(address _candidate) external view returns (CommissionSchedule memory);\n}\n"
    },
    "contracts/interfaces/validator/ICoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashingExecution.sol\";\n\ninterface ICoinbaseExecution is ISlashingExecution {\n  enum BlockRewardDeprecatedType {\n    UNKNOWN,\n    UNAVAILABILITY,\n    AFTER_BAILOUT\n  }\n\n  /// @dev Emitted when the validator set is updated\n  event ValidatorSetUpdated(uint256 indexed period, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated, to mirror the in-jail and maintaining status of the validator.\n  event BlockProducerSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated.\n  event BridgeOperatorSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] bridgeOperators);\n\n  /// @dev Emitted when the reward of the block producer is deprecated.\n  event BlockRewardDeprecated(\n    address indexed coinbaseAddr,\n    uint256 rewardAmount,\n    BlockRewardDeprecatedType deprecatedType\n  );\n  /// @dev Emitted when the block reward is submitted.\n  event BlockRewardSubmitted(address indexed coinbaseAddr, uint256 submittedAmount, uint256 bonusAmount);\n\n  /// @dev Emitted when the block producer reward is distributed.\n  event MiningRewardDistributed(address indexed consensusAddr, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the block producer reward.\n  event MiningRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the bridge operator reward is distributed.\n  event BridgeOperatorRewardDistributed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipientAddr,\n    uint256 amount\n  );\n  /// @dev Emitted when the contract fails when distributing the bridge operator reward.\n  event BridgeOperatorRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the amount of RON reward is distributed to staking contract.\n  event StakingRewardDistributed(uint256 totalAmount, address[] consensusAddrs, uint256[] amounts);\n  /// @dev Emitted when the contracts fails when distributing the amount of RON to the staking contract.\n  event StakingRewardDistributionFailed(\n    uint256 totalAmount,\n    address[] consensusAddrs,\n    uint256[] amounts,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the epoch is wrapped up.\n  event WrappedUpEpoch(uint256 indexed periodNumber, uint256 indexed epochNumber, bool periodEnding);\n\n  /// @dev Error of method caller must be coinbase\n  error ErrCallerMustBeCoinbase();\n  /// @dev Error of only allowed at the end of epoch\n  error ErrAtEndOfEpochOnly();\n  /// @dev Error of query for already wrapped up epoch\n  error ErrAlreadyWrappedEpoch();\n\n  /**\n   * @dev Submits reward of the current block.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDeprecated` if the coinbase is slashed or no longer be a block producer.\n   * Emits the event `BlockRewardSubmitted` for the valid call.\n   *\n   */\n  function submitBlockReward() external payable;\n\n  /**\n   * @dev Wraps up the current epoch.\n   *\n   * Requirements:\n   * - The method must be called when the current epoch is ending.\n   * - The epoch is not wrapped yet.\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDistributed` when some validator has reward distributed.\n   * Emits the event `StakingRewardDistributed` when some staking pool has reward distributed.\n   * Emits the event `BlockProducerSetUpdated` when the epoch is wrapped up.\n   * Emits the event `BridgeOperatorSetUpdated` when the epoch is wrapped up at period ending.\n   * Emits the event `ValidatorSetUpdated` when the epoch is wrapped up at period ending, and the validator set gets updated.\n   * Emits the event `WrappedUpEpoch`.\n   *\n   */\n  function wrapUpEpoch() external payable;\n}\n"
    },
    "contracts/interfaces/validator/IEmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IEmergencyExit {\n  /// @dev Emitted when the fund is locked from an emergency exit request\n  event EmergencyExitRequested(address indexed consensusAddr, uint256 lockedAmount);\n  /// @dev Emitted when the fund that locked from an emergency exit request is transferred to the recipient.\n  event EmergencyExitLockedFundReleased(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount\n  );\n  /// @dev Emitted when the fund that locked from an emergency exit request is failed to transferred back.\n  event EmergencyExitLockedFundReleasingFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the emergency exit locked amount is updated.\n  event EmergencyExitLockedAmountUpdated(uint256 amount);\n  /// @dev Emitted when the emergency expiry duration is updated.\n  event EmergencyExpiryDurationUpdated(uint256 amount);\n\n  /// @dev Error of already requested emergency exit before.\n  error ErrAlreadyRequestedEmergencyExit();\n\n  /**\n   * @dev Returns the amount of RON to lock from a consensus address.\n   */\n  function emergencyExitLockedAmount() external returns (uint256);\n\n  /**\n   * @dev Returns the duration that an emergency request is expired and the fund will be recycled.\n   */\n  function emergencyExpiryDuration() external returns (uint256);\n\n  /**\n   * @dev Sets the amount of RON to lock from a consensus address.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedAmountUpdated`.\n   *\n   */\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external;\n\n  /**\n   * @dev Sets the duration that an emergency request is expired and the fund will be recycled.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExpiryDurationUpdated`.\n   *\n   */\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external;\n\n  /**\n   * @dev Unlocks fund for emergency exit request.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedFundReleased` if the fund is successfully unlocked.\n   * Emits the event `EmergencyExitLockedFundReleasingFailed` if the fund is failed to unlock.\n   *\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(address _consensusAddr, address payable _recipient) external;\n\n  /**\n   * @dev Fallback function of `IStaking-requestEmergencyExit`.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   */\n  function execEmergencyExit(address _consensusAddr, uint256 _secLeftToRevoke) external;\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ICommonInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IJailingInfo.sol\";\nimport \"./ITimingInfo.sol\";\nimport \"./IValidatorInfoV2.sol\";\n\ninterface ICommonInfo is ITimingInfo, IJailingInfo, IValidatorInfoV2 {\n  struct EmergencyExitInfo {\n    uint256 lockedAmount;\n    // The timestamp that this locked amount will be recycled to staking vesting contract\n    uint256 recyclingAt;\n  }\n\n  /// @dev Emitted when the deprecated reward is withdrawn.\n  event DeprecatedRewardRecycled(address indexed recipientAddr, uint256 amount);\n  /// @dev Emitted when the deprecated reward withdrawal is failed\n  event DeprecatedRewardRecycleFailed(address indexed recipientAddr, uint256 amount, uint256 balance);\n\n  /// @dev Error thrown when receives RON from neither staking vesting contract nor staking contract\n  error ErrUnauthorizedReceiveRON();\n  /// @dev Error thrown when queries for a non existent info.\n  error NonExistentRecyclingInfo();\n\n  /**\n   * @dev Returns the total deprecated reward, which includes reward that is not sent for slashed validators and unsastified bridge operators\n   */\n  function totalDeprecatedReward() external view returns (uint256);\n\n  /**\n   * @dev Returns the emergency exit request.\n   */\n  function getEmergencyExitInfo(address _consensusAddr) external view returns (EmergencyExitInfo memory);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IJailingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IJailingInfo {\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkJailed(address) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeft(\n    address _addr\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) at a specific block.\n   */\n  function checkJailedAtBlock(address _addr, uint256 _blockNum) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail at a specific block and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeftAtBlock(\n    address _addr,\n    uint256 _blockNum\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validators are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkManyJailed(address[] calldata) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during the current period.\n   */\n  function checkMiningRewardDeprecated(address _blockProducer) external view returns (bool);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during a specific period.\n   */\n  function checkMiningRewardDeprecatedAtPeriod(address _blockProducer, uint256 _period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ITimingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ITimingInfo {\n  /**\n   * @dev Returns the block that validator set was updated.\n   */\n  function getLastUpdatedBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of blocks in a epoch.\n   */\n  function numberOfBlocksInEpoch() external view returns (uint256 _numberOfBlocks);\n\n  /**\n   * @dev Returns the epoch index from the block number.\n   */\n  function epochOf(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Returns whether the epoch ending is at the block number `_block`.\n   */\n  function epochEndingAt(uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Tries to get the period index from the epoch number.\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber);\n\n  /**\n   * @dev Returns whether the period ending at the current block number.\n   */\n  function isPeriodEnding() external view returns (bool);\n\n  /**\n   * @dev Returns the period index from the current block.\n   */\n  function currentPeriod() external view returns (uint256);\n\n  /**\n   * @dev Returns the block number that the current period starts at.\n   */\n  function currentPeriodStartAtBlock() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IValidatorInfoV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\n\ninterface IValidatorInfoV2 {\n  /**\n   * @dev Error thrown when an invalid maximum prioritized validator number is provided.\n   */\n  error ErrInvalidMaxPrioritizedValidatorNumber();\n\n  /// @dev Emitted when the number of max validator is updated.\n  event MaxValidatorNumberUpdated(uint256);\n  /// @dev Emitted when the number of reserved slots for prioritized validators is updated.\n  event MaxPrioritizedValidatorNumberUpdated(uint256);\n\n  /**\n   * @dev Returns the maximum number of validators in the epoch.\n   */\n  function maxValidatorNumber() external view returns (uint256 _maximumValidatorNumber);\n\n  /**\n   * @dev Returns the number of reserved slots for prioritized validators.\n   */\n  function maxPrioritizedValidatorNumber() external view returns (uint256 _maximumPrioritizedValidatorNumber);\n\n  /**\n   * @dev Returns the current validator list.\n   */\n  function getValidators() external view returns (address[] memory _validatorList);\n\n  /**\n   * @dev Returns the current block producer list.\n   */\n  function getBlockProducers() external view returns (address[] memory);\n\n  /**\n   * @dev Returns whether the address is block producer or not.\n   */\n  function isBlockProducer(address _addr) external view returns (bool);\n\n  /**\n   * @dev Returns total numbers of the block producers.\n   */\n  function totalBlockProducers() external view returns (uint256);\n\n  /**\n   * @dev Updates the max validator number\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxValidatorNumberUpdated`\n   *\n   */\n  function setMaxValidatorNumber(uint256 _maxValidatorNumber) external;\n\n  /**\n   * @dev Updates the number of reserved slots for prioritized validators\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxPrioritizedValidatorNumberUpdated`\n   *\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _maxPrioritizedValidatorNumber) external;\n}\n"
    },
    "contracts/interfaces/validator/IRoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ICandidateManager.sol\";\nimport \"./info-fragments/ICommonInfo.sol\";\nimport \"./ICoinbaseExecution.sol\";\nimport \"./ISlashingExecution.sol\";\nimport \"./IEmergencyExit.sol\";\n\ninterface IRoninValidatorSet is\n  ICandidateManager,\n  ICommonInfo,\n  ISlashingExecution,\n  ICoinbaseExecution,\n  IEmergencyExit\n{}\n"
    },
    "contracts/interfaces/validator/ISlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISlashingExecution {\n  /// @dev Emitted when the validator is punished.\n  event ValidatorPunished(\n    address indexed consensusAddr,\n    uint256 indexed period,\n    uint256 jailedUntil,\n    uint256 deductedStakingAmount,\n    bool blockProducerRewardDeprecated,\n    bool bridgeOperatorRewardDeprecated\n  );\n  /// @dev Emitted when the validator get out of jail by bailout.\n  event ValidatorUnjailed(address indexed validator, uint256 period);\n\n  /// @dev Error of cannot bailout due to high tier slash.\n  error ErrCannotBailout(address validator);\n\n  /**\n   * @dev Finalize the slash request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorPunished`.\n   *\n   */\n  function execSlash(\n    address _validatorAddr,\n    uint256 _newJailedUntil,\n    uint256 _slashAmount,\n    bool _cannotBailout\n  ) external;\n\n  /**\n   * @dev Finalize the bailout request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorUnjailed`.\n   *\n   */\n  function execBailOut(address _validatorAddr, uint256 _period) external;\n}\n"
    },
    "contracts/libraries/AddressArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary AddressArrayUtils {\n  /**\n   * @dev Error thrown when a duplicated element is detected in an array.\n   * @param msgSig The function signature that invoke the error.\n   */\n  error ErrDuplicated(bytes4 msgSig);\n\n  /**\n   * @dev Returns whether or not there's a duplicate. Runs in O(n^2).\n   * @param A Array to search\n   * @return Returns true if duplicate, false otherwise\n   */\n  function hasDuplicate(address[] memory A) internal pure returns (bool) {\n    if (A.length == 0) {\n      return false;\n    }\n    unchecked {\n      for (uint256 i = 0; i < A.length - 1; i++) {\n        for (uint256 j = i + 1; j < A.length; j++) {\n          if (A[i] == A[j]) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @dev Returns whether two arrays of addresses are equal or not.\n   */\n  function isEqual(address[] memory _this, address[] memory _other) internal pure returns (bool yes_) {\n    // Hashing two arrays and compare their hash\n    assembly {\n      let _thisHash := keccak256(add(_this, 32), mul(mload(_this), 32))\n      let _otherHash := keccak256(add(_other, 32), mul(mload(_other), 32))\n      yes_ := eq(_thisHash, _otherHash)\n    }\n  }\n\n  /**\n   * @dev Return the concatenated array from a and b.\n   */\n  function extend(address[] memory a, address[] memory b) internal pure returns (address[] memory c) {\n    uint256 lengthA = a.length;\n    uint256 lengthB = b.length;\n    unchecked {\n      c = new address[](lengthA + lengthB);\n    }\n    uint256 i;\n    for (; i < lengthA; ) {\n      c[i] = a[i];\n      unchecked {\n        ++i;\n      }\n    }\n    for (uint256 j; j < lengthB; ) {\n      c[i] = b[j];\n      unchecked {\n        ++i;\n        ++j;\n      }\n    }\n  }\n}\n"
    },
    "contracts/libraries/EnumFlags.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This library implements checking flag of an enumerated value.\n * The originated idea is inherited from [Enum.HashFlag(Enum)](https://learn.microsoft.com/en-us/dotnet/api/system.enum.hasflag?view=net-6.0) method of C#.\n */\nlibrary EnumFlags {\n  enum ValidatorFlag {\n    None, // bit(00)\n    BlockProducer, // bit(01)\n    DeprecatedBridgeOperator, // bit(10)\n    Both // bit(11)\n  }\n\n  function isNone(ValidatorFlag _value) internal pure returns (bool) {\n    return uint8(_value) == 0;\n  }\n\n  /**\n   * @dev Checks if `_value` has `_flag`.\n   */\n  function hasFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (bool) {\n    return (uint8(_value) & uint8(_flag)) != 0;\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after adding `_flag`.\n   */\n  function addFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) | uint8(_flag));\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after remove `_flag`.\n   */\n  function removeFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) & ~uint8(_flag));\n  }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary Math {\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns whether the number `c` is in range of [a; b].\n   */\n  function inRange(uint256 c, uint256 a, uint256 b) internal pure returns (bool) {\n    return a <= c && c <= b;\n  }\n\n  /**\n   * @dev Returns whether two inclusive ranges [x1;x2] and [y1;y2] overlap.\n   */\n  function twoRangeOverlap(uint256 x1, uint256 x2, uint256 y1, uint256 y2) internal pure returns (bool) {\n    return x1 <= y2 && y1 <= x2;\n  }\n\n  /**\n   * @dev Returns value of a + b; in case result is larger than upperbound, upperbound is returned.\n   */\n  function addWithUpperbound(uint256 a, uint256 b, uint256 upperbound) internal pure returns (uint256) {\n    return min(a + b, upperbound);\n  }\n\n  /**\n   * @dev Returns value of a - b; in case of negative result, 0 is returned.\n   */\n  function subNonNegative(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a - b : 0;\n  }\n\n  /**\n   * @dev Returns value of `a + zeroable` if zerobale is not 0; otherwise, return 0.\n   */\n  function addIfNonZero(uint256 a, uint256 zeroable) internal pure returns (uint256) {\n    return zeroable != 0 ? a + zeroable : 0;\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUPickValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUPickValidatorSet is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of picking validator set\n  function precompilePickValidatorSetAddress() public view virtual returns (address) {\n    return address(0x68);\n  }\n\n  /**\n   * @dev Sorts and arranges to return a new validator set.\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcPickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) internal view virtual returns (address[] memory _result, uint256 _newValidatorCount) {\n    address _smc = precompilePickValidatorSetAddress();\n    bytes memory _payload = abi.encodeWithSignature(\n      \"pickValidatorSet(address[],uint256[],uint256[],uint256,uint256)\",\n      _candidates,\n      _weights,\n      _trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n    bool _success = true;\n\n    uint256 _payloadLength = _payload.length;\n    uint256 _resultLength = 0x20 * _candidates.length + 0x40;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _result, _resultLength)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n\n      _result := add(_result, 0x20)\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n\n    _newValidatorCount = _result.length;\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUSortValidators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUSortValidators is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of sorting validators\n  function precompileSortValidatorsAddress() public view virtual returns (address) {\n    return address(0x66);\n  }\n\n  /**\n   * @dev Sorts candidates descending by their weights by calling precompile contract.\n   *\n   * Note: This function is marked as virtual for being wrapping in mock contract for testing purpose.\n   */\n  function _pcSortCandidates(\n    address[] memory _candidates,\n    uint256[] memory _weights\n  ) internal view virtual returns (address[] memory _result) {\n    address _smc = precompileSortValidatorsAddress();\n    bool _success = true;\n\n    bytes memory _payload = abi.encodeWithSignature(\"sortValidators(address[],uint256[])\", _candidates, _weights);\n    uint256 _payloadLength = _payload.length;\n    uint256 _resultLength = 0x20 * _candidates.length + 0x40;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _result, _resultLength)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n\n      _result := add(_result, 0x20)\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n  }\n}\n"
    },
    "contracts/precompile-usages/PrecompiledUsage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PrecompiledUsage {\n  /// @dev Error of call to precompile fails.\n  error ErrCallPrecompiled();\n}\n"
    },
    "contracts/ronin/validator/CandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../interfaces/validator/ICandidateManager.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport { HasStakingDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\nabstract contract CandidateManager is\n  ICandidateManager,\n  PercentageConsumer,\n  GlobalConfigConsumer,\n  HasContracts,\n  HasStakingDeprecated\n{\n  /// @dev Maximum number of validator candidate\n  uint256 private _maxValidatorCandidate;\n\n  /// @dev The validator candidate array\n  address[] internal _candidates;\n  /// @dev Mapping from candidate consensus address => bitwise negation of validator index in `_candidates`\n  mapping(address => uint256) internal _candidateIndex;\n  /// @dev Mapping from candidate consensus address => their info\n  mapping(address => ValidatorCandidate) internal _candidateInfo;\n\n  /**\n   * @dev The minimum offset in day from current date to the effective date of a new commission schedule.\n   * Value of 1 means the change gets affected at the beginning of the following day.\n   **/\n  uint256 internal _minEffectiveDaysOnwards;\n  /// @dev Mapping from candidate consensus address => schedule commission change.\n  mapping(address => CommissionSchedule) internal _candidateCommissionChangeSchedule;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] private ______gap;\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function maxValidatorCandidate() public view override returns (uint256) {\n    return _maxValidatorCandidate;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function minEffectiveDaysOnwards() external view override returns (uint256) {\n    return _minEffectiveDaysOnwards;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function setMaxValidatorCandidate(uint256 _number) external override onlyAdmin {\n    _setMaxValidatorCandidate(_number);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external override onlyAdmin {\n    _setMinEffectiveDaysOnwards(_numOfDays);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function execApplyValidatorCandidate(\n    address _candidateAdmin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    uint256 _commissionRate\n  ) external override onlyContract(ContractType.STAKING) {\n    uint256 _length = _candidates.length;\n    if (_length >= maxValidatorCandidate()) revert ErrExceedsMaxNumberOfCandidate();\n    if (isValidatorCandidate(_consensusAddr)) revert ErrExistentCandidate();\n    if (_commissionRate > _MAX_PERCENTAGE) revert ErrInvalidCommissionRate();\n\n    for (uint _i; _i < _candidates.length; ) {\n      ValidatorCandidate storage existentInfo = _candidateInfo[_candidates[_i]];\n      if (_candidateAdmin == existentInfo.admin) revert ErrExistentCandidateAdmin(_candidateAdmin);\n      if (_treasuryAddr == existentInfo.treasuryAddr) revert ErrExistentTreasury(_treasuryAddr);\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    _candidateIndex[_consensusAddr] = ~_length;\n    _candidates.push(_consensusAddr);\n\n    ValidatorCandidate storage _info = _candidateInfo[_consensusAddr];\n    _info.admin = _candidateAdmin;\n    _info.consensusAddr = _consensusAddr;\n    _info.treasuryAddr = _treasuryAddr;\n    _info.commissionRate = _commissionRate;\n    emit CandidateGranted(_consensusAddr, _treasuryAddr, _candidateAdmin);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function execRequestRenounceCandidate(\n    address _consensusAddr,\n    uint256 _secsLeft\n  ) external override onlyContract(ContractType.STAKING) {\n    if (_isTrustedOrg(_consensusAddr)) revert ErrTrustedOrgCannotRenounce();\n\n    ValidatorCandidate storage _info = _candidateInfo[_consensusAddr];\n    if (_info.revokingTimestamp != 0) revert ErrAlreadyRequestedRevokingCandidate();\n    _setRevokingTimestamp(_info, block.timestamp + _secsLeft);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function execRequestUpdateCommissionRate(\n    address _consensusAddr,\n    uint256 _effectiveDaysOnwards,\n    uint256 _commissionRate\n  ) external override onlyContract(ContractType.STAKING) {\n    if (_candidateCommissionChangeSchedule[_consensusAddr].effectiveTimestamp != 0) {\n      revert ErrAlreadyRequestedUpdatingCommissionRate();\n    }\n    if (_commissionRate > _MAX_PERCENTAGE) revert ErrInvalidCommissionRate();\n    if (_effectiveDaysOnwards < _minEffectiveDaysOnwards) revert ErrInvalidEffectiveDaysOnwards();\n\n    CommissionSchedule storage _schedule = _candidateCommissionChangeSchedule[_consensusAddr];\n    uint256 _effectiveTimestamp = ((block.timestamp / PERIOD_DURATION) + _effectiveDaysOnwards) * PERIOD_DURATION;\n    _schedule.effectiveTimestamp = _effectiveTimestamp;\n    _schedule.commissionRate = _commissionRate;\n\n    emit CommissionRateUpdateScheduled(_consensusAddr, _effectiveTimestamp, _commissionRate);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function isValidatorCandidate(address _addr) public view override returns (bool) {\n    return _candidateIndex[_addr] != 0;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCandidateInfos() external view override returns (ValidatorCandidate[] memory _list) {\n    _list = new ValidatorCandidate[](_candidates.length);\n    for (uint _i; _i < _list.length; ) {\n      _list[_i] = _candidateInfo[_candidates[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCandidateInfo(address _candidate) external view override returns (ValidatorCandidate memory) {\n    if (!isValidatorCandidate(_candidate)) revert ErrNonExistentCandidate();\n    return _candidateInfo[_candidate];\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getValidatorCandidates() public view override returns (address[] memory) {\n    return _candidates;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCommissionChangeSchedule(address _candidate) external view override returns (CommissionSchedule memory) {\n    return _candidateCommissionChangeSchedule[_candidate];\n  }\n\n  /**\n   * @dev Removes unsastisfied candidates, the ones who have insufficient minimum candidate staking amount,\n   * or the ones who requested to renounce their candidate role.\n   *\n   * Emits the event `CandidatesRevoked` when a candidate is revoked.\n   *\n   */\n  function _syncCandidateSet(uint256 _nextPeriod) internal returns (address[] memory _unsatisfiedCandidates) {\n    IStaking _staking = IStaking(getContract(ContractType.STAKING));\n    uint256 _waitingSecsToRevoke = _staking.waitingSecsToRevoke();\n    uint256 _minStakingAmount = _staking.minValidatorStakingAmount();\n    uint256[] memory _selfStakings = _staking.getManySelfStakings(_candidates);\n\n    uint256 _length = _candidates.length;\n    uint256 _unsatisfiedCount;\n    _unsatisfiedCandidates = new address[](_length);\n\n    {\n      uint256 _i;\n      address _addr;\n      ValidatorCandidate storage _info;\n      while (_i < _length) {\n        _addr = _candidates[_i];\n        _info = _candidateInfo[_addr];\n\n        // Checks for under-balance status of candidates\n        bool _hasTopupDeadline = _info.topupDeadline != 0;\n        if (_selfStakings[_i] < _minStakingAmount) {\n          // Updates deadline on the first time unsatisfied the staking amount condition\n          if (!_hasTopupDeadline) {\n            uint256 _topupDeadline = block.timestamp + _waitingSecsToRevoke;\n            _info.topupDeadline = _topupDeadline;\n            emit CandidateTopupDeadlineUpdated(_addr, _topupDeadline);\n          }\n        } else if (_hasTopupDeadline) {\n          // Removes the deadline if the staking amount condition is satisfied\n          delete _info.topupDeadline;\n          emit CandidateTopupDeadlineUpdated(_addr, 0);\n        }\n\n        // Removes unsastisfied candidates\n        bool _revokingActivated = (_info.revokingTimestamp != 0 && _info.revokingTimestamp <= block.timestamp) ||\n          _emergencyExitLockedFundReleased(_addr);\n        bool _topupDeadlineMissed = _info.topupDeadline != 0 && _info.topupDeadline <= block.timestamp;\n        if (_revokingActivated || _topupDeadlineMissed) {\n          _selfStakings[_i] = _selfStakings[--_length];\n          unchecked {\n            _unsatisfiedCandidates[_unsatisfiedCount++] = _addr;\n          }\n          _removeCandidate(_addr);\n          continue;\n        }\n\n        // Checks for schedule of commission change and updates commission rate\n        uint256 _scheduleTimestamp = _candidateCommissionChangeSchedule[_addr].effectiveTimestamp;\n        if (_scheduleTimestamp != 0 && _scheduleTimestamp <= block.timestamp) {\n          uint256 _commisionRate = _candidateCommissionChangeSchedule[_addr].commissionRate;\n          delete _candidateCommissionChangeSchedule[_addr];\n          _info.commissionRate = _commisionRate;\n          emit CommissionRateUpdated(_addr, _commisionRate);\n        }\n\n        unchecked {\n          _i++;\n        }\n      }\n    }\n\n    assembly {\n      mstore(_unsatisfiedCandidates, _unsatisfiedCount)\n    }\n\n    if (_unsatisfiedCount > 0) {\n      emit CandidatesRevoked(_unsatisfiedCandidates);\n      _staking.execDeprecatePools(_unsatisfiedCandidates, _nextPeriod);\n    }\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function isCandidateAdmin(address _candidate, address _admin) external view override returns (bool) {\n    return _candidateInfo[_candidate].admin == _admin;\n  }\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function _setMaxValidatorCandidate(uint256 _threshold) internal {\n    _maxValidatorCandidate = _threshold;\n    emit MaxValidatorCandidateUpdated(_threshold);\n  }\n\n  /**\n   * @dev Sets the minimum number of days onwards to the effective date of commission rate change.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function _setMinEffectiveDaysOnwards(uint256 _numOfDays) internal {\n    if (_numOfDays < 1) revert ErrInvalidMinEffectiveDaysOnwards();\n    _minEffectiveDaysOnwards = _numOfDays;\n    emit MinEffectiveDaysOnwardsUpdated(_numOfDays);\n  }\n\n  /**\n   * @dev Removes the candidate.\n   */\n  function _removeCandidate(address _addr) internal virtual {\n    uint256 _idx = _candidateIndex[_addr];\n    if (_idx == 0) {\n      return;\n    }\n\n    delete _candidateInfo[_addr];\n    delete _candidateIndex[_addr];\n    delete _candidateCommissionChangeSchedule[_addr];\n\n    address _lastCandidate = _candidates[_candidates.length - 1];\n    if (_lastCandidate != _addr) {\n      _candidateIndex[_lastCandidate] = _idx;\n      _candidates[~_idx] = _lastCandidate;\n    }\n\n    _candidates.pop();\n  }\n\n  /**\n   * @dev Sets timestamp to revoke a candidate.\n   */\n  function _setRevokingTimestamp(ValidatorCandidate storage _candidate, uint256 _timestamp) internal {\n    if (!isValidatorCandidate(_candidate.consensusAddr)) revert ErrNonExistentCandidate();\n    _candidate.revokingTimestamp = _timestamp;\n    emit CandidateRevokingTimestampUpdated(_candidate.consensusAddr, _timestamp);\n  }\n\n  /**\n   * @dev Returns a flag indicating whether the fund is unlocked.\n   */\n  function _emergencyExitLockedFundReleased(address _consensusAddr) internal virtual returns (bool);\n\n  /**\n   * @dev Returns whether the consensus address is a trusted org or not.\n   */\n  function _isTrustedOrg(address _consensusAddr) internal virtual returns (bool);\n}\n"
    },
    "contracts/ronin/validator/CoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../interfaces/IStakingVesting.sol\";\nimport \"../../interfaces/IMaintenance.sol\";\nimport \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../interfaces/slash-indicator/ISlashIndicator.sol\";\nimport \"../../interfaces/validator/ICoinbaseExecution.sol\";\nimport \"../../libraries/EnumFlags.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasStakingVestingDeprecated, HasBridgeTrackingDeprecated, HasMaintenanceDeprecated, HasSlashIndicatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"../../precompile-usages/PCUSortValidators.sol\";\nimport \"../../precompile-usages/PCUPickValidatorSet.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\nimport \"./CandidateManager.sol\";\nimport { EmergencyExit } from \"./EmergencyExit.sol\";\n\nabstract contract CoinbaseExecution is\n  ICoinbaseExecution,\n  RONTransferHelper,\n  PCUSortValidators,\n  PCUPickValidatorSet,\n  HasContracts,\n  HasStakingVestingDeprecated,\n  HasBridgeTrackingDeprecated,\n  HasMaintenanceDeprecated,\n  HasSlashIndicatorDeprecated,\n  EmergencyExit\n{\n  using EnumFlags for EnumFlags.ValidatorFlag;\n\n  modifier onlyCoinbase() {\n    _requireCoinbase();\n    _;\n  }\n\n  modifier whenEpochEnding() {\n    if (!epochEndingAt(block.number)) revert ErrAtEndOfEpochOnly();\n    _;\n  }\n\n  modifier oncePerEpoch() {\n    if (epochOf(_lastUpdatedBlock) >= epochOf(block.number)) revert ErrAlreadyWrappedEpoch();\n    _lastUpdatedBlock = block.number;\n    _;\n  }\n\n  function _requireCoinbase() private view {\n    if (msg.sender != block.coinbase) revert ErrCallerMustBeCoinbase();\n  }\n\n  /**\n   * @inheritdoc ICoinbaseExecution\n   */\n  function submitBlockReward() external payable override onlyCoinbase {\n    bool _requestForBlockProducer = isBlockProducer(msg.sender) &&\n      !_jailed(msg.sender) &&\n      !_miningRewardDeprecated(msg.sender, currentPeriod());\n\n    (, uint256 _blockProducerBonus, ) = IStakingVesting(getContract(ContractType.STAKING_VESTING)).requestBonus({\n      _forBlockProducer: _requestForBlockProducer,\n      _forBridgeOperator: false\n    });\n\n    // Deprecates reward for non-validator or slashed validator\n    if (!_requestForBlockProducer) {\n      _totalDeprecatedReward += msg.value;\n      emit BlockRewardDeprecated(msg.sender, msg.value, BlockRewardDeprecatedType.UNAVAILABILITY);\n      return;\n    }\n\n    emit BlockRewardSubmitted(msg.sender, msg.value, _blockProducerBonus);\n\n    uint256 _period = currentPeriod();\n    uint256 _reward = msg.value + _blockProducerBonus;\n    uint256 _cutOffReward;\n    if (_miningRewardBailoutCutOffAtPeriod[msg.sender][_period]) {\n      (, , , uint256 _cutOffPercentage) = ISlashIndicator(getContract(ContractType.SLASH_INDICATOR))\n        .getCreditScoreConfigs();\n      _cutOffReward = (_reward * _cutOffPercentage) / _MAX_PERCENTAGE;\n      _totalDeprecatedReward += _cutOffReward;\n      emit BlockRewardDeprecated(msg.sender, _cutOffReward, BlockRewardDeprecatedType.AFTER_BAILOUT);\n    }\n\n    _reward -= _cutOffReward;\n    (uint256 _minRate, uint256 _maxRate) = IStaking(getContract(ContractType.STAKING)).getCommissionRateRange();\n    uint256 _rate = Math.max(Math.min(_candidateInfo[msg.sender].commissionRate, _maxRate), _minRate);\n    uint256 _miningAmount = (_rate * _reward) / _MAX_PERCENTAGE;\n    _miningReward[msg.sender] += _miningAmount;\n\n    uint256 _delegatingAmount = _reward - _miningAmount;\n    _delegatingReward[msg.sender] += _delegatingAmount;\n  }\n\n  /**\n   * @inheritdoc ICoinbaseExecution\n   */\n  function wrapUpEpoch() external payable virtual override onlyCoinbase whenEpochEnding oncePerEpoch {\n    uint256 _newPeriod = _computePeriod(block.timestamp);\n    bool _periodEnding = _isPeriodEnding(_newPeriod);\n\n    address[] memory _currentValidators = getValidators();\n    address[] memory _revokedCandidates;\n    uint256 _epoch = epochOf(block.number);\n    uint256 _nextEpoch = _epoch + 1;\n    uint256 _lastPeriod = currentPeriod();\n\n    if (_periodEnding) {\n      (\n        uint256 _totalDelegatingReward,\n        uint256[] memory _delegatingRewards\n      ) = _distributeRewardToTreasuriesAndCalculateTotalDelegatingReward(_lastPeriod, _currentValidators);\n      _settleAndTransferDelegatingRewards(_lastPeriod, _currentValidators, _totalDelegatingReward, _delegatingRewards);\n      _tryRecycleLockedFundsFromEmergencyExits();\n      _recycleDeprecatedRewards();\n      ISlashIndicator _slashIndicatorContract = ISlashIndicator(getContract(ContractType.SLASH_INDICATOR));\n      _slashIndicatorContract.updateCreditScores(_currentValidators, _lastPeriod);\n      (_currentValidators, _revokedCandidates) = _syncValidatorSet(_newPeriod);\n      if (_revokedCandidates.length > 0) {\n        _slashIndicatorContract.execResetCreditScores(_revokedCandidates);\n      }\n      _currentPeriodStartAtBlock = block.number + 1;\n    }\n    _revampRoles(_newPeriod, _nextEpoch, _currentValidators);\n    emit WrappedUpEpoch(_lastPeriod, _epoch, _periodEnding);\n    _periodOf[_nextEpoch] = _newPeriod;\n    _lastUpdatedPeriod = _newPeriod;\n  }\n\n  /**\n   * @dev This loops over all current validators to:\n   * - Update delegating reward for and calculate total delegating rewards to be sent to the staking contract,\n   * - Distribute the reward of block producers and bridge operators to their treasury addresses,\n   * - Update the total deprecated reward if the two previous conditions do not sastify.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _distributeRewardToTreasuriesAndCalculateTotalDelegatingReward(\n    uint256 _lastPeriod,\n    address[] memory _currentValidators\n  ) private returns (uint256 _totalDelegatingReward, uint256[] memory _delegatingRewards) {\n    address _consensusAddr;\n    address payable _treasury;\n    _delegatingRewards = new uint256[](_currentValidators.length);\n    for (uint _i; _i < _currentValidators.length; ) {\n      _consensusAddr = _currentValidators[_i];\n      _treasury = _candidateInfo[_consensusAddr].treasuryAddr;\n\n      if (!_jailed(_consensusAddr) && !_miningRewardDeprecated(_consensusAddr, _lastPeriod)) {\n        _totalDelegatingReward += _delegatingReward[_consensusAddr];\n        _delegatingRewards[_i] = _delegatingReward[_consensusAddr];\n        _distributeMiningReward(_consensusAddr, _treasury);\n      } else {\n        _totalDeprecatedReward += _miningReward[_consensusAddr] + _delegatingReward[_consensusAddr];\n      }\n\n      delete _delegatingReward[_consensusAddr];\n      delete _miningReward[_consensusAddr];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @dev Distributes bonus of staking vesting and mining fee for the block producer.\n   *\n   * Emits the `MiningRewardDistributed` once the reward is distributed successfully.\n   * Emits the `MiningRewardDistributionFailed` once the contract fails to distribute reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _distributeMiningReward(address _consensusAddr, address payable _treasury) private {\n    uint256 _amount = _miningReward[_consensusAddr];\n    if (_amount > 0) {\n      if (_unsafeSendRONLimitGas(_treasury, _amount, DEFAULT_ADDITION_GAS)) {\n        emit MiningRewardDistributed(_consensusAddr, _treasury, _amount);\n        return;\n      }\n\n      emit MiningRewardDistributionFailed(_consensusAddr, _treasury, _amount, address(this).balance);\n    }\n  }\n\n  /**\n   * @dev Helper function to settle rewards for delegators of `_currentValidators` at the end of each period,\n   * then transfer the rewards from this contract to the staking contract, in order to finalize a period.\n   *\n   * Emits the `StakingRewardDistributed` once the reward is distributed successfully.\n   * Emits the `StakingRewardDistributionFailed` once the contract fails to distribute reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _settleAndTransferDelegatingRewards(\n    uint256 _period,\n    address[] memory _currentValidators,\n    uint256 _totalDelegatingReward,\n    uint256[] memory _delegatingRewards\n  ) private {\n    IStaking _staking = IStaking(getContract(ContractType.STAKING));\n    if (_totalDelegatingReward > 0) {\n      if (_unsafeSendRON(payable(address(_staking)), _totalDelegatingReward)) {\n        _staking.execRecordRewards(_currentValidators, _delegatingRewards, _period);\n        emit StakingRewardDistributed(_totalDelegatingReward, _currentValidators, _delegatingRewards);\n        return;\n      }\n\n      emit StakingRewardDistributionFailed(\n        _totalDelegatingReward,\n        _currentValidators,\n        _delegatingRewards,\n        address(this).balance\n      );\n    }\n  }\n\n  /**\n   * @dev Transfer the deprecated rewards e.g. the rewards that get deprecated when validator is slashed/maintained,\n   * to the staking vesting contract\n   *\n   * Note: This method should be called once in the end of each period.\n   */\n  function _recycleDeprecatedRewards() private {\n    uint256 _withdrawAmount = _totalDeprecatedReward;\n\n    if (_withdrawAmount != 0) {\n      address _withdrawTarget = getContract(ContractType.STAKING_VESTING);\n\n      delete _totalDeprecatedReward;\n\n      (bool _success, ) = _withdrawTarget.call{ value: _withdrawAmount }(\n        abi.encodeWithSelector(IStakingVesting.receiveRON.selector)\n      );\n\n      if (_success) {\n        emit DeprecatedRewardRecycled(_withdrawTarget, _withdrawAmount);\n      } else {\n        emit DeprecatedRewardRecycleFailed(_withdrawTarget, _withdrawAmount, address(this).balance);\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the validator set based on the validator candidates from the Staking contract.\n   *\n   * Emits the `ValidatorSetUpdated` event.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _syncValidatorSet(\n    uint256 _newPeriod\n  ) private returns (address[] memory _newValidators, address[] memory _unsastifiedCandidates) {\n    _unsastifiedCandidates = _syncCandidateSet(_newPeriod);\n    uint256[] memory _weights = IStaking(getContract(ContractType.STAKING)).getManyStakingTotals(_candidates);\n    uint256[] memory _trustedWeights = IRoninTrustedOrganization(getContract(ContractType.RONIN_TRUSTED_ORGANIZATION))\n      .getConsensusWeights(_candidates);\n    uint256 _newValidatorCount;\n    (_newValidators, _newValidatorCount) = _pcPickValidatorSet(\n      _candidates,\n      _weights,\n      _trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n    _setNewValidatorSet(_newValidators, _newValidatorCount, _newPeriod);\n  }\n\n  /**\n   * @dev Private helper function helps writing the new validator set into the contract storage.\n   *\n   * Emits the `ValidatorSetUpdated` event.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _setNewValidatorSet(\n    address[] memory _newValidators,\n    uint256 _newValidatorCount,\n    uint256 _newPeriod\n  ) private {\n    // Remove exceeding validators in the current set\n    for (uint256 _i = _newValidatorCount; _i < validatorCount; ) {\n      delete _validatorMap[_validators[_i]];\n      delete _validators[_i];\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // Remove flag for all validator in the current set\n    for (uint _i; _i < _newValidatorCount; ) {\n      delete _validatorMap[_validators[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // Update new validator set and set flag correspondingly.\n    for (uint256 _i; _i < _newValidatorCount; ) {\n      address _newValidator = _newValidators[_i];\n      _validatorMap[_newValidator] = EnumFlags.ValidatorFlag.Both;\n      _validators[_i] = _newValidator;\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    validatorCount = _newValidatorCount;\n    emit ValidatorSetUpdated(_newPeriod, _newValidators);\n  }\n\n  /**\n   * @dev Activate/Deactivate the validators from producing blocks, based on their in jail status and maintenance status.\n   *\n   * Requirements:\n   * - This method is called at the end of each epoch\n   *\n   * Emits the `BlockProducerSetUpdated` event.\n   * Emits the `BridgeOperatorSetUpdated` event.\n   *\n   */\n  function _revampRoles(uint256 _newPeriod, uint256 _nextEpoch, address[] memory _currentValidators) private {\n    bool[] memory _maintainedList = IMaintenance(getContract(ContractType.MAINTENANCE)).checkManyMaintained(\n      _currentValidators,\n      block.number + 1\n    );\n\n    for (uint _i; _i < _currentValidators.length; ) {\n      address _validator = _currentValidators[_i];\n      bool _emergencyExitRequested = block.timestamp <= _emergencyExitJailedTimestamp[_validator];\n      bool _isProducerBefore = isBlockProducer(_validator);\n      bool _isProducerAfter = !(_jailedAtBlock(_validator, block.number + 1) ||\n        _maintainedList[_i] ||\n        _emergencyExitRequested);\n\n      if (!_isProducerBefore && _isProducerAfter) {\n        _validatorMap[_validator] = _validatorMap[_validator].addFlag(EnumFlags.ValidatorFlag.BlockProducer);\n      } else if (_isProducerBefore && !_isProducerAfter) {\n        _validatorMap[_validator] = _validatorMap[_validator].removeFlag(EnumFlags.ValidatorFlag.BlockProducer);\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n    emit BlockProducerSetUpdated(_newPeriod, _nextEpoch, getBlockProducers());\n  }\n\n  /**\n   * @dev Override `CandidateManager-_isTrustedOrg`.\n   */\n  function _isTrustedOrg(address _consensusAddr) internal view override returns (bool) {\n    return\n      IRoninTrustedOrganization(getContract(ContractType.RONIN_TRUSTED_ORGANIZATION)).getConsensusWeight(\n        _consensusAddr\n      ) > 0;\n  }\n}\n"
    },
    "contracts/ronin/validator/EmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../interfaces/IRoninGovernanceAdmin.sol\";\nimport \"../../interfaces/validator/IEmergencyExit.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\nimport \"./CandidateManager.sol\";\n\nabstract contract EmergencyExit is IEmergencyExit, RONTransferHelper, CandidateManager, CommonStorage {\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function emergencyExitLockedAmount() external view returns (uint256) {\n    return _emergencyExitLockedAmount;\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function emergencyExpiryDuration() external view returns (uint256) {\n    return _emergencyExpiryDuration;\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function execEmergencyExit(\n    address _consensusAddr,\n    uint256 _secLeftToRevoke\n  ) external onlyContract(ContractType.STAKING) {\n    EmergencyExitInfo storage _info = _exitInfo[_consensusAddr];\n    if (_info.recyclingAt != 0) revert ErrAlreadyRequestedEmergencyExit();\n\n    uint256 _revokingTimestamp = block.timestamp + _secLeftToRevoke;\n    _setRevokingTimestamp(_candidateInfo[_consensusAddr], _revokingTimestamp);\n    _emergencyExitJailedTimestamp[_consensusAddr] = _revokingTimestamp;\n\n    uint256 _deductedAmount = IStaking(msg.sender).execDeductStakingAmount(_consensusAddr, _emergencyExitLockedAmount);\n    if (_deductedAmount > 0) {\n      uint256 _recyclingAt = block.timestamp + _emergencyExpiryDuration;\n      _lockedConsensusList.push(_consensusAddr);\n      _info.lockedAmount = _deductedAmount;\n      _info.recyclingAt = _recyclingAt;\n      IRoninGovernanceAdmin(_getAdmin()).createEmergencyExitPoll(\n        _consensusAddr,\n        _candidateInfo[_consensusAddr].treasuryAddr,\n        block.timestamp,\n        _recyclingAt\n      );\n    }\n    emit EmergencyExitRequested(_consensusAddr, _deductedAmount);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external onlyAdmin {\n    _setEmergencyExitLockedAmount(_emergencyExitLockedAmount);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external onlyAdmin {\n    _setEmergencyExpiryDuration(_emergencyExpiryDuration);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(\n    address _consensusAddr,\n    address payable _recipient\n  ) external onlyAdmin {\n    if (_exitInfo[_consensusAddr].recyclingAt == 0) {\n      return;\n    }\n\n    uint256 _length = _lockedConsensusList.length;\n    uint256 _index = _length;\n\n    for (uint _i; _i < _length; ) {\n      if (_lockedConsensusList[_i] == _consensusAddr) {\n        _index = _i;\n        break;\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // The locked amount might be recycled\n    if (_index == _length) {\n      return;\n    }\n\n    uint256 _amount = _exitInfo[_consensusAddr].lockedAmount;\n    if (_amount > 0) {\n      delete _exitInfo[_consensusAddr];\n      if (_length > 1) {\n        _lockedConsensusList[_index] = _lockedConsensusList[_length - 1];\n      }\n      _lockedConsensusList.pop();\n\n      _lockedFundReleased[_consensusAddr] = true;\n      if (_unsafeSendRONLimitGas(_recipient, _amount, DEFAULT_ADDITION_GAS)) {\n        emit EmergencyExitLockedFundReleased(_consensusAddr, _recipient, _amount);\n        return;\n      }\n\n      emit EmergencyExitLockedFundReleasingFailed(_consensusAddr, _recipient, _amount, address(this).balance);\n    }\n  }\n\n  /**\n   * @dev Tries to recycle the locked funds from emergency exit requests.\n   */\n  function _tryRecycleLockedFundsFromEmergencyExits() internal {\n    uint256 _length = _lockedConsensusList.length;\n\n    uint256 _i;\n    address _addr;\n    EmergencyExitInfo storage _info;\n\n    while (_i < _length) {\n      _addr = _lockedConsensusList[_i];\n      _info = _exitInfo[_addr];\n\n      if (_info.recyclingAt <= block.timestamp) {\n        _totalDeprecatedReward += _info.lockedAmount;\n\n        delete _exitInfo[_addr];\n        if (--_length > 0) {\n          _lockedConsensusList[_i] = _lockedConsensusList[_length];\n        }\n        _lockedConsensusList.pop();\n        continue;\n      }\n\n      unchecked {\n        _i++;\n      }\n    }\n  }\n\n  /**\n   * @dev Override `CandidateManager-_emergencyExitLockedFundReleased`.\n   */\n  function _emergencyExitLockedFundReleased(address _consensusAddr) internal virtual override returns (bool) {\n    return _lockedFundReleased[_consensusAddr];\n  }\n\n  /**\n   * @dev Override `CandidateManager-_removeCandidate`.\n   */\n  function _removeCandidate(address _consensusAddr) internal override {\n    delete _lockedFundReleased[_consensusAddr];\n    super._removeCandidate(_consensusAddr);\n  }\n\n  /**\n   * @dev See `setEmergencyExitLockedAmount.\n   */\n  function _setEmergencyExitLockedAmount(uint256 _amount) internal {\n    _emergencyExitLockedAmount = _amount;\n    emit EmergencyExitLockedAmountUpdated(_amount);\n  }\n\n  /**\n   * @dev See `setEmergencyExpiryDuration`.\n   */\n  function _setEmergencyExpiryDuration(uint256 _duration) internal {\n    _emergencyExpiryDuration = _duration;\n    emit EmergencyExpiryDurationUpdated(_duration);\n  }\n}\n"
    },
    "contracts/ronin/validator/RoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"./CoinbaseExecution.sol\";\nimport \"./SlashingExecution.sol\";\n\ncontract RoninValidatorSet is Initializable, CoinbaseExecution, SlashingExecution {\n  constructor() {\n    _disableInitializers();\n  }\n\n  fallback() external payable {\n    _fallback();\n  }\n\n  receive() external payable {\n    _fallback();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __slashIndicatorContract,\n    address __stakingContract,\n    address __stakingVestingContract,\n    address __maintenanceContract,\n    address __roninTrustedOrganizationContract,\n    address /* __bridgeTrackingContract */,\n    uint256 __maxValidatorNumber,\n    uint256 __maxValidatorCandidate,\n    uint256 __maxPrioritizedValidatorNumber,\n    uint256 __minEffectiveDaysOnwards,\n    uint256 __numberOfBlocksInEpoch,\n    // __emergencyExitConfigs[0]: emergencyExitLockedAmount\n    // __emergencyExitConfigs[1]: emergencyExpiryDuration\n    uint256[2] calldata __emergencyExitConfigs\n  ) external initializer {\n    _setContract(ContractType.SLASH_INDICATOR, __slashIndicatorContract);\n    _setContract(ContractType.STAKING, __stakingContract);\n    _setContract(ContractType.STAKING_VESTING, __stakingVestingContract);\n    _setContract(ContractType.MAINTENANCE, __maintenanceContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, __roninTrustedOrganizationContract);\n\n    _setMaxValidatorNumber(__maxValidatorNumber);\n    _setMaxValidatorCandidate(__maxValidatorCandidate);\n    _setMaxPrioritizedValidatorNumber(__maxPrioritizedValidatorNumber);\n    _setMinEffectiveDaysOnwards(__minEffectiveDaysOnwards);\n    _setEmergencyExitLockedAmount(__emergencyExitConfigs[0]);\n    _setEmergencyExpiryDuration(__emergencyExitConfigs[1]);\n    _numberOfBlocksInEpoch = __numberOfBlocksInEpoch;\n  }\n\n  function initializeV2() external reinitializer(2) {\n    _setContract(ContractType.STAKING, ______deprecatedStakingContract);\n    _setContract(ContractType.MAINTENANCE, ______deprecatedMaintenance);\n    _setContract(ContractType.SLASH_INDICATOR, ______deprecatedSlashIndicator);\n    _setContract(ContractType.STAKING_VESTING, ______deprecatedStakingVesting);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, ______deprecatedTrustedOrg);\n\n    delete ______deprecatedStakingContract;\n    delete ______deprecatedMaintenance;\n    delete ______deprecatedSlashIndicator;\n    delete ______deprecatedStakingVesting;\n    delete ______deprecatedBridgeTracking;\n    delete ______deprecatedTrustedOrg;\n  }\n\n  /**\n   * @dev Only receives RON from staking vesting contract (for topping up bonus), and from staking contract (for transferring\n   * deducting amount on slashing).\n   */\n  function _fallback() internal view {\n    if (msg.sender != getContract(ContractType.STAKING_VESTING) && msg.sender != getContract(ContractType.STAKING)) {\n      revert ErrUnauthorizedReceiveRON();\n    }\n  }\n}\n"
    },
    "contracts/ronin/validator/SlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../interfaces/validator/ISlashingExecution.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasSlashIndicatorDeprecated, HasStakingDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\n\nabstract contract SlashingExecution is\n  ISlashingExecution,\n  HasContracts,\n  HasSlashIndicatorDeprecated,\n  HasStakingDeprecated,\n  CommonStorage\n{\n  /**\n   * @inheritdoc ISlashingExecution\n   */\n  function execSlash(\n    address _validatorAddr,\n    uint256 _newJailedUntil,\n    uint256 _slashAmount,\n    bool _cannotBailout\n  ) external override onlyContract(ContractType.SLASH_INDICATOR) {\n    uint256 _period = currentPeriod();\n    _miningRewardDeprecatedAtPeriod[_validatorAddr][_period] = true;\n\n    _totalDeprecatedReward += _miningReward[_validatorAddr] + _delegatingReward[_validatorAddr];\n\n    delete _miningReward[_validatorAddr];\n    delete _delegatingReward[_validatorAddr];\n\n    _blockProducerJailedBlock[_validatorAddr] = Math.max(_newJailedUntil, _blockProducerJailedBlock[_validatorAddr]);\n\n    if (_slashAmount > 0) {\n      uint256 _actualAmount = IStaking(getContract(ContractType.STAKING)).execDeductStakingAmount(\n        _validatorAddr,\n        _slashAmount\n      );\n      _totalDeprecatedReward += _actualAmount;\n    }\n\n    if (_cannotBailout) {\n      _cannotBailoutUntilBlock[_validatorAddr] = Math.max(_newJailedUntil, _cannotBailoutUntilBlock[_validatorAddr]);\n    }\n\n    emit ValidatorPunished(\n      _validatorAddr,\n      _period,\n      _blockProducerJailedBlock[_validatorAddr],\n      _slashAmount,\n      true,\n      false\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashingExecution\n   */\n  function execBailOut(\n    address _validatorAddr,\n    uint256 _period\n  ) external override onlyContract(ContractType.SLASH_INDICATOR) {\n    if (block.number <= _cannotBailoutUntilBlock[_validatorAddr]) revert ErrCannotBailout(_validatorAddr);\n\n    // Note: Removing rewards of validator in `bailOut` function is not needed, since the rewards have been\n    // removed previously in the `slash` function.\n    _miningRewardBailoutCutOffAtPeriod[_validatorAddr][_period] = true;\n    _miningRewardDeprecatedAtPeriod[_validatorAddr][_period] = false;\n    _blockProducerJailedBlock[_validatorAddr] = block.number - 1;\n\n    emit ValidatorUnjailed(_validatorAddr, _period);\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/CommonStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../interfaces/validator/info-fragments/ICommonInfo.sol\";\nimport \"./JailingStorage.sol\";\nimport \"./TimingStorage.sol\";\nimport \"./ValidatorInfoStorageV2.sol\";\n\nabstract contract CommonStorage is ICommonInfo, TimingStorage, JailingStorage, ValidatorInfoStorageV2 {\n  /// @dev Mapping from consensus address => pending reward from producing block\n  mapping(address => uint256) internal _miningReward;\n  /// @dev Mapping from consensus address => pending reward from delegating\n  mapping(address => uint256) internal _delegatingReward;\n\n  /// @dev The total reward for bridge operators\n  uint256 internal ______deprecatedTotalBridgeReward;\n  /// @dev Mapping from consensus address => pending reward for being bridge operator\n  mapping(address => uint256) internal ______deprecatedBridgeOperatingReward;\n\n  /// @dev The deprecated reward that has not been withdrawn by admin\n  uint256 internal _totalDeprecatedReward;\n\n  /// @dev The amount of RON to lock from a consensus address.\n  uint256 internal _emergencyExitLockedAmount;\n  /// @dev The duration that an emergency request is expired and the fund will be recycled.\n  uint256 internal _emergencyExpiryDuration;\n  /// @dev The address list of consensus addresses that being locked fund.\n  address[] internal _lockedConsensusList;\n  /// @dev Mapping from consensus => request exist info\n  mapping(address => EmergencyExitInfo) internal _exitInfo;\n  /// @dev Mapping from consensus => flag indicating whether the locked fund is released\n  mapping(address => bool) internal _lockedFundReleased;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[44] private ______gap;\n\n  /**\n   * @inheritdoc ICommonInfo\n   */\n  function getEmergencyExitInfo(\n    address _consensusAddr\n  ) external view override returns (EmergencyExitInfo memory _info) {\n    _info = _exitInfo[_consensusAddr];\n    if (_info.recyclingAt == 0) revert NonExistentRecyclingInfo();\n  }\n\n  /**\n   * @inheritdoc ICommonInfo\n   */\n  function totalDeprecatedReward() external view override returns (uint256) {\n    return _totalDeprecatedReward;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochOf(\n    uint256 _block\n  ) public view virtual override(ITimingInfo, JailingStorage, TimingStorage) returns (uint256) {\n    return TimingStorage.epochOf(_block);\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriod() public view virtual override(ITimingInfo, JailingStorage, TimingStorage) returns (uint256) {\n    return TimingStorage.currentPeriod();\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/JailingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../interfaces/validator/info-fragments/IJailingInfo.sol\";\nimport \"./TimingStorage.sol\";\n\nabstract contract JailingStorage is IJailingInfo {\n  /// @dev Mapping from consensus address => period number => block producer has no pending reward.\n  mapping(address => mapping(uint256 => bool)) internal _miningRewardDeprecatedAtPeriod;\n  /// @dev Mapping from consensus address => period number => whether the block producer get cut off reward, due to bailout.\n  mapping(address => mapping(uint256 => bool)) internal _miningRewardBailoutCutOffAtPeriod;\n  /// @dev Mapping from consensus address => period number => block operator has no pending reward.\n  mapping(address => mapping(uint256 => bool)) internal ______deprecatedBridgeRewardDeprecatedAtPeriod;\n\n  /// @dev Mapping from consensus address => the last block that the block producer is jailed.\n  mapping(address => uint256) internal _blockProducerJailedBlock;\n  /// @dev Mapping from consensus address => the last timestamp that the bridge operator is jailed.\n  mapping(address => uint256) internal _emergencyExitJailedTimestamp;\n  /// @dev Mapping from consensus address => the last block that the block producer cannot bailout.\n  mapping(address => uint256) internal _cannotBailoutUntilBlock;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] private ______gap;\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkJailed(address _addr) external view override returns (bool) {\n    return checkJailedAtBlock(_addr, block.number);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function getJailedTimeLeft(\n    address _addr\n  ) external view override returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_) {\n    return getJailedTimeLeftAtBlock(_addr, block.number);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkJailedAtBlock(address _addr, uint256 _blockNum) public view override returns (bool) {\n    return _jailedAtBlock(_addr, _blockNum);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function getJailedTimeLeftAtBlock(\n    address _addr,\n    uint256 _blockNum\n  ) public view override returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_) {\n    uint256 _jailedBlock = _blockProducerJailedBlock[_addr];\n    if (_jailedBlock < _blockNum) {\n      return (false, 0, 0);\n    }\n\n    isJailed_ = true;\n    blockLeft_ = _jailedBlock - _blockNum + 1;\n    epochLeft_ = epochOf(_jailedBlock) - epochOf(_blockNum) + 1;\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkManyJailed(address[] calldata _addrList) external view override returns (bool[] memory _result) {\n    _result = new bool[](_addrList.length);\n    for (uint256 _i; _i < _addrList.length; ) {\n      _result[_i] = _jailed(_addrList[_i]);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkMiningRewardDeprecated(address _blockProducer) external view override returns (bool _result) {\n    uint256 _period = currentPeriod();\n    return _miningRewardDeprecated(_blockProducer, _period);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkMiningRewardDeprecatedAtPeriod(\n    address _blockProducer,\n    uint256 _period\n  ) external view override returns (bool _result) {\n    return _miningRewardDeprecated(_blockProducer, _period);\n  }\n\n  /**\n   * @dev See `ITimingInfo-epochOf`\n   */\n  function epochOf(uint256 _block) public view virtual returns (uint256);\n\n  /**\n   * @dev See `ITimingInfo-currentPeriod`\n   */\n  function currentPeriod() public view virtual returns (uint256);\n\n  /**\n   * @dev Returns whether the reward of the validator is put in jail (cannot join the set of validators) during the current period.\n   */\n  function _jailed(address _validatorAddr) internal view returns (bool) {\n    return _jailedAtBlock(_validatorAddr, block.number);\n  }\n\n  /**\n   * @dev Returns whether the reward of the validator is put in jail (cannot join the set of validators) at a specific block.\n   */\n  function _jailedAtBlock(address _validatorAddr, uint256 _blockNum) internal view returns (bool) {\n    return _blockNum <= _blockProducerJailedBlock[_validatorAddr];\n  }\n\n  /**\n   * @dev Returns whether the block producer has no pending reward in that period.\n   */\n  function _miningRewardDeprecated(address _validatorAddr, uint256 _period) internal view returns (bool) {\n    return _miningRewardDeprecatedAtPeriod[_validatorAddr][_period];\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/TimingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../../interfaces/validator/info-fragments/ITimingInfo.sol\";\n\nabstract contract TimingStorage is ITimingInfo, GlobalConfigConsumer {\n  /// @dev The number of blocks in a epoch\n  uint256 internal _numberOfBlocksInEpoch;\n  /// @dev The last updated block\n  uint256 internal _lastUpdatedBlock;\n  /// @dev The last updated period\n  uint256 internal _lastUpdatedPeriod;\n  /// @dev The starting block of the last updated period\n  uint256 internal _currentPeriodStartAtBlock;\n\n  /// @dev Mapping from epoch index => period index\n  mapping(uint256 => uint256) internal _periodOf;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[49] private ______gap;\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function getLastUpdatedBlock() external view override returns (uint256) {\n    return _lastUpdatedBlock;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochOf(uint256 _block) public view virtual override returns (uint256) {\n    return _block / _numberOfBlocksInEpoch + 1;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber) {\n    return (_epoch <= epochOf(block.number) || _periodOf[_epoch] > 0, _periodOf[_epoch]);\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function isPeriodEnding() external view override returns (bool) {\n    return _isPeriodEnding(_computePeriod(block.timestamp));\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochEndingAt(uint256 _block) public view virtual override returns (bool) {\n    return _block % _numberOfBlocksInEpoch == _numberOfBlocksInEpoch - 1;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriod() public view virtual override returns (uint256) {\n    return _lastUpdatedPeriod;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriodStartAtBlock() public view override returns (uint256) {\n    return _currentPeriodStartAtBlock;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function numberOfBlocksInEpoch() public view virtual override returns (uint256 _numberOfBlocks) {\n    return _numberOfBlocksInEpoch;\n  }\n\n  /**\n   * @dev See `ITimingInfo-isPeriodEnding`\n   */\n  function _isPeriodEnding(uint256 _newPeriod) internal view virtual returns (bool) {\n    return _newPeriod > _lastUpdatedPeriod;\n  }\n\n  /**\n   * @dev Returns the calculated period.\n   */\n  function _computePeriod(uint256 _timestamp) internal pure returns (uint256) {\n    return _timestamp / PERIOD_DURATION;\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/ValidatorInfoStorageV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\nimport { HasTrustedOrgDeprecated } from \"../../../utils/DeprecatedSlots.sol\";\nimport \"../../../extensions/collections/HasContracts.sol\";\nimport \"../../../interfaces/validator/info-fragments/IValidatorInfoV2.sol\";\n\nabstract contract ValidatorInfoStorageV2 is IValidatorInfoV2, HasContracts, HasTrustedOrgDeprecated {\n  using EnumFlags for EnumFlags.ValidatorFlag;\n\n  /// @dev The maximum number of validator.\n  uint256 internal _maxValidatorNumber;\n\n  /// @dev The total of validators\n  uint256 public validatorCount;\n  /// @dev Mapping from validator index => validator address\n  mapping(uint256 => address) internal _validators;\n  /// @dev Mapping from address => flag indicating the validator ability: producing block, operating bridge\n  mapping(address => EnumFlags.ValidatorFlag) internal _validatorMap;\n  /// @dev The number of slot that is reserved for prioritized validators\n  uint256 internal _maxPrioritizedValidatorNumber;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function getValidators() public view override returns (address[] memory _validatorList) {\n    _validatorList = new address[](validatorCount);\n    for (uint _i; _i < _validatorList.length; ) {\n      address _validator = _validators[_i];\n      _validatorList[_i] = _validator;\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function getBlockProducers() public view override returns (address[] memory _result) {\n    _result = new address[](validatorCount);\n    uint256 _count = 0;\n    for (uint _i; _i < _result.length; ) {\n      if (isBlockProducer(_validators[_i])) {\n        _result[_count++] = _validators[_i];\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    assembly {\n      mstore(_result, _count)\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function isBlockProducer(address _addr) public view override returns (bool) {\n    return _validatorMap[_addr].hasFlag(EnumFlags.ValidatorFlag.BlockProducer);\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function totalBlockProducers() external view returns (uint256 _total) {\n    unchecked {\n      for (uint _i; _i < validatorCount; _i++) {\n        if (isBlockProducer(_validators[_i])) {\n          _total++;\n        }\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function maxValidatorNumber() external view override returns (uint256 _maximumValidatorNumber) {\n    return _maxValidatorNumber;\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function maxPrioritizedValidatorNumber() external view override returns (uint256 _maximumPrioritizedValidatorNumber) {\n    return _maxPrioritizedValidatorNumber;\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function setMaxValidatorNumber(uint256 _max) external override onlyAdmin {\n    _setMaxValidatorNumber(_max);\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _number) external override onlyAdmin {\n    _setMaxPrioritizedValidatorNumber(_number);\n  }\n\n  /**\n   * @dev See `IValidatorInfoV2-setMaxValidatorNumber`\n   */\n  function _setMaxValidatorNumber(uint256 _number) internal {\n    _maxValidatorNumber = _number;\n    emit MaxValidatorNumberUpdated(_number);\n  }\n\n  /**\n   * @dev See `IValidatorInfoV2-setMaxPrioritizedValidatorNumber`\n   */\n  function _setMaxPrioritizedValidatorNumber(uint256 _number) internal {\n    if (_number > _maxValidatorNumber) revert ErrInvalidMaxPrioritizedValidatorNumber();\n    _maxPrioritizedValidatorNumber = _number;\n    emit MaxPrioritizedValidatorNumberUpdated(_number);\n  }\n}\n"
    },
    "contracts/utils/CommonErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ContractType } from \"./ContractType.sol\";\nimport { RoleAccess } from \"./RoleAccess.sol\";\n\nerror ErrSyncTooFarPeriod(uint256 period, uint256 latestRewardedPeriod);\n/**\n * @dev Error thrown when an address is expected to be an already created externally owned account (EOA).\n * This error indicates that the provided address is invalid for certain contract operations that require already created EOA.\n */\nerror ErrAddressIsNotCreatedEOA(address addr, bytes32 codehash);\n/**\n * @dev Error raised when a bridge operator update operation fails.\n * @param bridgeOperator The address of the bridge operator that failed to update.\n */\nerror ErrBridgeOperatorUpdateFailed(address bridgeOperator);\n/**\n * @dev Error thrown when attempting to add a bridge operator that already exists in the contract.\n * This error indicates that the provided bridge operator address is already registered as a bridge operator in the contract.\n */\nerror ErrBridgeOperatorAlreadyExisted(address bridgeOperator);\n/**\n * @dev The error indicating an unsupported interface.\n * @param interfaceId The bytes4 interface identifier that is not supported.\n * @param addr The address where the unsupported interface was encountered.\n */\nerror ErrUnsupportedInterface(bytes4 interfaceId, address addr);\n/**\n * @dev Error thrown when the return data from a callback function is invalid.\n * @param callbackFnSig The signature of the callback function that returned invalid data.\n * @param register The address of the register where the callback function was invoked.\n * @param returnData The invalid return data received from the callback function.\n */\nerror ErrInvalidReturnData(bytes4 callbackFnSig, address register, bytes returnData);\n/**\n * @dev Error of set to non-contract.\n */\nerror ErrZeroCodeContract(address addr);\n/**\n * @dev Error indicating that arguments are invalid.\n */\nerror ErrInvalidArguments(bytes4 msgSig);\n/**\n * @dev Error indicating that given address is null when it should not.\n */\nerror ErrZeroAddress(bytes4 msgSig);\n/**\n * @dev Error indicating that the provided threshold is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that the invalid threshold applies to.\n */\nerror ErrInvalidThreshold(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a function can only be called by the contract itself.\n * @param msgSig The function signature (bytes4) that can only be called by the contract itself.\n */\nerror ErrOnlySelfCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n * @param expectedRole The role required to perform the function.\n */\nerror ErrUnauthorized(bytes4 msgSig, RoleAccess expectedRole);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n */\nerror ErrUnauthorizedCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4).\n * @param expectedContractType The contract type required to perform the function.\n * @param actual The actual address that called to the function.\n */\nerror ErrUnexpectedInternalCall(bytes4 msgSig, ContractType expectedContractType, address actual);\n\n/**\n * @dev Error indicating that an array is empty when it should contain elements.\n */\nerror ErrEmptyArray();\n\n/**\n * @dev Error indicating a mismatch in the length of input parameters or arrays for a specific function.\n * @param msgSig The function signature (bytes4) that has a length mismatch.\n */\nerror ErrLengthMismatch(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a proxy call to an external contract has failed.\n * @param msgSig The function signature (bytes4) of the proxy call that failed.\n * @param extCallSig The function signature (bytes4) of the external contract call that failed.\n */\nerror ErrProxyCallFailed(bytes4 msgSig, bytes4 extCallSig);\n\n/**\n * @dev Error indicating that a function tried to call a precompiled contract that is not allowed.\n * @param msgSig The function signature (bytes4) that attempted to call a precompiled contract.\n */\nerror ErrCallPrecompiled(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a native token transfer has failed.\n * @param msgSig The function signature (bytes4) of the token transfer that failed.\n */\nerror ErrNativeTransferFailed(bytes4 msgSig);\n\n/**\n * @dev Error indicating that an order is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid order.\n */\nerror ErrInvalidOrder(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the chain ID is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid chain ID.\n * @param actual Current chain ID that executing function.\n * @param expected Expected chain ID required for the tx to success.\n */\nerror ErrInvalidChainId(bytes4 msgSig, uint256 actual, uint256 expected);\n\n/**\n * @dev Error indicating that a vote type is not supported.\n * @param msgSig The function signature (bytes4) of the operation that encountered an unsupported vote type.\n */\nerror ErrUnsupportedVoteType(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the proposal nonce is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid proposal nonce.\n */\nerror ErrInvalidProposalNonce(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a voter has already voted.\n * @param voter The address of the voter who has already voted.\n */\nerror ErrAlreadyVoted(address voter);\n\n/**\n * @dev Error indicating that a signature is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid signature.\n */\nerror ErrInvalidSignatures(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a relay call has failed.\n * @param msgSig The function signature (bytes4) of the relay call that failed.\n */\nerror ErrRelayFailed(bytes4 msgSig);\n/**\n * @dev Error indicating that a vote weight is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid vote weight.\n */\nerror ErrInvalidVoteWeight(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a query was made for an outdated bridge operator set.\n */\nerror ErrQueryForOutdatedBridgeOperatorSet();\n\n/**\n * @dev Error indicating that a request is invalid.\n */\nerror ErrInvalidRequest();\n\n/**\n * @dev Error indicating that a token standard is invalid.\n */\nerror ErrInvalidTokenStandard();\n\n/**\n * @dev Error indicating that a token is not supported.\n */\nerror ErrUnsupportedToken();\n\n/**\n * @dev Error indicating that a receipt kind is invalid.\n */\nerror ErrInvalidReceiptKind();\n\n/**\n * @dev Error indicating that a receipt is invalid.\n */\nerror ErrInvalidReceipt();\n\n/**\n * @dev Error indicating that an address is not payable.\n */\nerror ErrNonpayableAddress(address);\n\n/**\n * @dev Error indicating that the period is already processed, i.e. scattered reward.\n */\nerror ErrPeriodAlreadyProcessed(uint256 requestingPeriod, uint256 latestPeriod);\n\n/**\n * @dev Error thrown when an invalid vote hash is provided.\n */\nerror ErrInvalidVoteHash();\n\n/**\n * @dev Error thrown when querying for an empty vote.\n */\nerror ErrQueryForEmptyVote();\n\n/**\n * @dev Error thrown when querying for an expired vote.\n */\nerror ErrQueryForExpiredVote();\n\n/**\n * @dev Error thrown when querying for a non-existent vote.\n */\nerror ErrQueryForNonExistentVote();\n"
    },
    "contracts/utils/ContractType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum ContractType {\n  /*  0 */ UNKNOWN,\n  /*  1 */ PAUSE_ENFORCER,\n  /*  2 */ BRIDGE,\n  /*  3 */ BRIDGE_TRACKING,\n  /*  4 */ GOVERNANCE_ADMIN,\n  /*  5 */ MAINTENANCE,\n  /*  6 */ SLASH_INDICATOR,\n  /*  7 */ STAKING_VESTING,\n  /*  8 */ VALIDATOR,\n  /*  9 */ STAKING,\n  /* 10 */ RONIN_TRUSTED_ORGANIZATION,\n  /* 11 */ BRIDGE_MANAGER,\n  /* 12 */ BRIDGE_SLASH,\n  /* 13 */ BRIDGE_REWARD\n}\n"
    },
    "contracts/utils/DeprecatedSlots.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Deprecated Contracts\n * @dev These abstract contracts are deprecated and should not be used in new implementations.\n * They provide functionality related to various aspects of a smart contract but have been marked\n * as deprecated to indicate that they are no longer actively maintained or recommended for use.\n * The purpose of these contracts is to preserve the slots for already deployed contracts.\n */\ncontract HasSlashIndicatorDeprecated {\n  /// @custom:deprecated Previously `_slashIndicatorContract` (non-zero value)\n  address internal ______deprecatedSlashIndicator;\n}\n\ncontract HasStakingVestingDeprecated {\n  /// @custom:deprecated Previously `_stakingVestingContract` (non-zero value)\n  address internal ______deprecatedStakingVesting;\n}\n\ncontract HasBridgeDeprecated {\n  /// @custom:deprecated Previously `_bridgeContract` (non-zero value)\n  address internal ______deprecatedBridge;\n}\n\ncontract HasValidatorDeprecated {\n  /// @custom:deprecated Previously `_validatorContract` (non-zero value)\n  address internal ______deprecatedValidator;\n}\n\ncontract HasStakingDeprecated {\n  /// @custom:deprecated Previously `_stakingContract` (non-zero value)\n  address internal ______deprecatedStakingContract;\n}\n\ncontract HasMaintenanceDeprecated {\n  /// @custom:deprecated Previously `_maintenanceContract` (non-zero value)\n  address internal ______deprecatedMaintenance;\n}\n\ncontract HasTrustedOrgDeprecated {\n  /// @custom:deprecated Previously `_trustedOrgContract` (non-zero value)\n  address internal ______deprecatedTrustedOrg;\n}\n\ncontract HasGovernanceAdminDeprecated {\n  /// @custom:deprecated Previously `_governanceAdminContract` (non-zero value)\n  address internal ______deprecatedGovernanceAdmin;\n}\n\ncontract HasBridgeTrackingDeprecated {\n  /// @custom:deprecated Previously `_bridgeTrackingContract` (non-zero value)\n  address internal ______deprecatedBridgeTracking;\n}\n"
    },
    "contracts/utils/IdentityGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { AddressArrayUtils } from \"../libraries/AddressArrayUtils.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { TransparentUpgradeableProxyV2 } from \"../extensions/TransparentUpgradeableProxyV2.sol\";\nimport { ErrAddressIsNotCreatedEOA, ErrZeroAddress, ErrOnlySelfCall, ErrZeroCodeContract, ErrUnsupportedInterface } from \"./CommonErrors.sol\";\n\nabstract contract IdentityGuard {\n  using AddressArrayUtils for address[];\n\n  /// @dev value is equal to keccak256(abi.encode())\n  /// @dev see: https://eips.ethereum.org/EIPS/eip-1052\n  bytes32 internal constant CREATED_ACCOUNT_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n  /**\n   * @dev Modifier to restrict functions to only be called by this contract.\n   * @dev Reverts if the caller is not this contract.\n   */\n  modifier onlySelfCall() virtual {\n    _requireSelfCall();\n    _;\n  }\n\n  /**\n   * @dev Modifier to ensure that the elements in the `arr` array are non-duplicates.\n   * It calls the internal `_checkDuplicate` function to perform the duplicate check.\n   *\n   * Requirements:\n   * - The elements in the `arr` array must not contain any duplicates.\n   */\n  modifier nonDuplicate(address[] memory arr) virtual {\n    _requireNonDuplicate(arr);\n    _;\n  }\n\n  /**\n   * @dev Internal method to check the method caller.\n   * @dev Reverts if the method caller is not this contract.\n   */\n  function _requireSelfCall() internal view virtual {\n    if (msg.sender != address(this)) revert ErrOnlySelfCall(msg.sig);\n  }\n\n  /**\n   * @dev Internal function to check if a contract address has code.\n   * @param addr The address of the contract to check.\n   * @dev Throws an error if the contract address has no code.\n   */\n  function _requireHasCode(address addr) internal view {\n    if (addr.code.length == 0) revert ErrZeroCodeContract(addr);\n  }\n\n  /**\n   * @dev Checks if an address is zero and reverts if it is.\n   * @param addr The address to check.\n   */\n  function _requireNonZeroAddress(address addr) internal pure {\n    if (addr == address(0)) revert ErrZeroAddress(msg.sig);\n  }\n\n  /**\n   * @dev Check if arr is empty and revert if it is.\n   * Checks if an array contains any duplicate addresses and reverts if duplicates are found.\n   * @param arr The array of addresses to check.\n   */\n  function _requireNonDuplicate(address[] memory arr) internal pure {\n    if (arr.hasDuplicate()) revert AddressArrayUtils.ErrDuplicated(msg.sig);\n  }\n\n  /**\n   * @dev Internal function to require that the provided address is a created externally owned account (EOA).\n   * This internal function is used to ensure that the provided address is a valid externally owned account (EOA).\n   * It checks the codehash of the address against a predefined constant to confirm that the address is a created EOA.\n   * @notice This method only works with non-state EOA accounts\n   */\n  function _requireCreatedEOA(address addr) internal view {\n    _requireNonZeroAddress(addr);\n    bytes32 codehash = addr.codehash;\n    if (codehash != CREATED_ACCOUNT_HASH) revert ErrAddressIsNotCreatedEOA(addr, codehash);\n  }\n\n  /**\n   * @dev Internal function to require that the specified contract supports the given interface. This method handle in\n   * both case that the callee is either or not the proxy admin of the caller. If the contract does not support the\n   * interface `interfaceId` or EIP165, a revert with the corresponding error message is triggered.\n   *\n   * @param contractAddr The address of the contract to check for interface support.\n   * @param interfaceId The interface ID to check for support.\n   */\n  function _requireSupportsInterface(address contractAddr, bytes4 interfaceId) internal view {\n    bytes memory supportsInterfaceParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n    (bool success, bytes memory returnOrRevertData) = contractAddr.staticcall(supportsInterfaceParams);\n    if (!success) {\n      (success, returnOrRevertData) = contractAddr.staticcall(\n        abi.encodeCall(TransparentUpgradeableProxyV2.functionDelegateCall, (supportsInterfaceParams))\n      );\n      if (!success) revert ErrUnsupportedInterface(interfaceId, contractAddr);\n    }\n    if (!abi.decode(returnOrRevertData, (bool))) revert ErrUnsupportedInterface(interfaceId, contractAddr);\n  }\n}\n"
    },
    "contracts/utils/RoleAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum RoleAccess {\n  /* 0 */ UNKNOWN,\n  /* 1 */ ADMIN,\n  /* 2 */ COINBASE,\n  /* 3 */ GOVERNOR,\n  /* 4 */ CANDIDATE_ADMIN,\n  /* 5 */ WITHDRAWAL_MIGRATOR,\n  /* 6 */ __DEPRECATED_BRIDGE_OPERATOR,\n  /* 7 */ BLOCK_PRODUCER,\n  /* 8 */ VALIDATOR_CANDIDATE\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}