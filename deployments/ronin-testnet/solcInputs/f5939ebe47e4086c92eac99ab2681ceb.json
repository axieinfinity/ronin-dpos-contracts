{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/extensions/collections/HasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { HasProxyAdmin } from \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasContracts.sol\";\nimport { IdentityGuard } from \"../../utils/IdentityGuard.sol\";\nimport { ErrUnexpectedInternalCall } from \"../../utils/CommonErrors.sol\";\n\n/**\n * @title HasContracts\n * @dev A contract that provides functionality to manage multiple contracts with different roles.\n */\nabstract contract HasContracts is HasProxyAdmin, IHasContracts, IdentityGuard {\n  /// @dev value is equal to keccak256(\"@ronin.dpos.collections.HasContracts.slot\") - 1\n  bytes32 private constant _STORAGE_SLOT = 0xdea3103d22025c269050bea94c0c84688877f12fa22b7e6d2d5d78a9a49aa1cb;\n\n  /**\n   * @dev Modifier to restrict access to functions only to contracts with a specific role.\n   * @param contractType The contract type that allowed to call\n   */\n  modifier onlyContract(ContractType contractType) virtual {\n    _requireContract(contractType);\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function setContract(ContractType contractType, address addr) external virtual onlyAdmin {\n    _requireHasCode(addr);\n    _setContract(contractType, addr);\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function getContract(ContractType contractType) public view returns (address contract_) {\n    contract_ = _getContractMap()[uint8(contractType)];\n    if (contract_ == address(0)) revert ErrContractTypeNotFound(contractType);\n  }\n\n  /**\n   * @dev Internal function to set the address of a contract with a specific role.\n   * @param contractType The contract type of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function _setContract(ContractType contractType, address addr) internal virtual {\n    _getContractMap()[uint8(contractType)] = addr;\n    emit ContractUpdated(contractType, addr);\n  }\n\n  /**\n   * @dev Internal function to access the mapping of contract addresses with roles.\n   * @return contracts_ The mapping of contract addresses with roles.\n   */\n  function _getContractMap() private pure returns (mapping(uint8 => address) storage contracts_) {\n    assembly {\n      contracts_.slot := _STORAGE_SLOT\n    }\n  }\n\n  /**\n   * @dev Internal function to check if the calling contract has a specific role.\n   * @param contractType The contract type that the calling contract must have.\n   * @dev Throws an error if the calling contract does not have the specified role.\n   */\n  function _requireContract(ContractType contractType) private view {\n    if (msg.sender != getContract(contractType)) {\n      revert ErrUnexpectedInternalCall(msg.sig, contractType, msg.sender);\n    }\n  }\n}\n"
    },
    "contracts/extensions/collections/HasProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../utils/CommonErrors.sol\";\n\nabstract contract HasProxyAdmin {\n  // bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n  bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  modifier onlyAdmin() {\n    _requireAdmin();\n    _;\n  }\n\n  /**\n   * @dev Returns proxy admin.\n   */\n  function _getAdmin() internal view virtual returns (address) {\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  function _requireAdmin() internal view {\n    if (msg.sender != _getAdmin()) revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\n  }\n}\n"
    },
    "contracts/extensions/consumers/PercentageConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract PercentageConsumer {\n  uint256 internal constant _MAX_PERCENTAGE = 100_00;\n}\n"
    },
    "contracts/extensions/TransparentUpgradeableProxyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract TransparentUpgradeableProxyV2 is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n\n  /**\n   * @dev Calls a function from the current implementation as specified by `_data`, which should be an encoded function call.\n   *\n   * Requirements:\n   * - Only the admin can call this function.\n   *\n   * Note: The proxy admin is not allowed to interact with the proxy logic through the fallback function to avoid\n   * triggering some unexpected logic. This is to allow the administrator to explicitly call the proxy, please consider\n   * reviewing the encoded data `_data` and the method which is called before using this.\n   *\n   */\n  function functionDelegateCall(bytes memory _data) public payable ifAdmin {\n    address _addr = _implementation();\n    assembly {\n      let _result := delegatecall(gas(), _addr, add(_data, 32), mload(_data), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch _result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/interfaces/collections/IHasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { ContractType } from \"../../utils/ContractType.sol\";\n\ninterface IHasContracts {\n  /// @dev Error of invalid role.\n  error ErrContractTypeNotFound(ContractType contractType);\n\n  /// @dev Emitted when a contract is updated.\n  event ContractUpdated(ContractType indexed contractType, address indexed addr);\n\n  /**\n   * @dev Returns the address of a contract with a specific role.\n   * Throws an error if no contract is set for the specified role.\n   *\n   * @param contractType The role of the contract to retrieve.\n   * @return contract_ The address of the contract with the specified role.\n   */\n  function getContract(ContractType contractType) external view returns (address contract_);\n\n  /**\n   * @dev Sets the address of a contract with a specific role.\n   * Emits the event {ContractUpdated}.\n   * @param contractType The role of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function setContract(ContractType contractType, address addr) external;\n}\n"
    },
    "contracts/interfaces/consumers/PeriodWrapperConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PeriodWrapperConsumer {\n  struct PeriodWrapper {\n    // Inner value.\n    uint256 inner;\n    // Last period number that the info updated.\n    uint256 lastPeriod;\n  }\n}\n"
    },
    "contracts/interfaces/IMaintenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TConsensus } from \"../udvts/Types.sol\";\n\ninterface IMaintenance {\n  /**\n   * @dev Error thrown when attempting to schedule an already scheduled event.\n   */\n  error ErrAlreadyScheduled();\n\n  /**\n   * @dev Error thrown when referring to a non-existent schedule.\n   */\n  error ErrUnexistedSchedule();\n\n  /**\n   * @dev Error thrown when the end block of a schedule is out of range.\n   */\n  error ErrEndBlockOutOfRange();\n\n  /**\n   * @dev Error thrown when the start block of a schedule is out of range.\n   */\n  error ErrStartBlockOutOfRange();\n\n  /**\n   * @dev Error thrown when attempting to initiate maintenance while already in maintenance mode.\n   */\n  error ErrAlreadyOnMaintenance();\n\n  /**\n   * @dev Error thrown when attempting an action before the cooldown period has ended.\n   */\n  error ErrCooldownTimeNotYetEnded();\n\n  /**\n   * @dev Error thrown when the total number of schedules exceeds the limit.\n   */\n  error ErrTotalOfSchedulesExceeded();\n\n  /**\n   * @dev Error thrown when an invalid maintenance duration is specified.\n   */\n  error ErrInvalidMaintenanceDuration();\n\n  /**\n   * @dev Error thrown when an invalid maintenance duration configuration is provided.\n   */\n  error ErrInvalidMaintenanceDurationConfig();\n\n  /**\n   * @dev Error thrown when an invalid offset is specified to start the schedule configurations.\n   */\n  error ErrInvalidOffsetToStartScheduleConfigs();\n\n  struct Schedule {\n    uint256 from;\n    uint256 to;\n    uint256 lastUpdatedBlock;\n    uint256 requestTimestamp;\n  }\n\n  /// @dev Emitted when a maintenance is scheduled.\n  event MaintenanceScheduled(TConsensus indexed consensusAddr, Schedule);\n  /// @dev Emitted when a schedule of maintenance is cancelled.\n  event MaintenanceScheduleCancelled(TConsensus indexed consensusAddr);\n  /// @dev Emitted when the maintenance config is updated.\n  event MaintenanceConfigUpdated(\n    uint256 minMaintenanceDurationInBlock,\n    uint256 maxMaintenanceDurationInBlock,\n    uint256 minOffsetToStartSchedule,\n    uint256 maxOffsetToStartSchedule,\n    uint256 maxSchedules,\n    uint256 cooldownSecsToMaintain\n  );\n\n  /**\n   * @dev Returns whether the validator `consensusAddr` maintained at the block number `_block`.\n   */\n  function checkMaintained(TConsensus consensusAddr, uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator whose id `validatorId` maintained at the block number `_block`.\n   */\n  function checkMaintainedById(address validatorId, uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `consensusAddr` maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks.\n   */\n  function checkMaintainedInBlockRange(\n    TConsensus consensusAddr,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool);\n\n  /**\n   * @dev Returns the bool array indicating the validators maintained at block number `k` or not.\n   */\n  function checkManyMaintained(\n    TConsensus[] calldata consensusAddrList,\n    uint256 atBlock\n  ) external view returns (bool[] memory);\n\n  function checkManyMaintainedById(\n    address[] calldata candidateIdList,\n    uint256 atBlock\n  ) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns a bool array indicating the validators maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks or not.\n   */\n  function checkManyMaintainedInBlockRange(\n    TConsensus[] calldata _consensusAddrList,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool[] memory);\n\n  function checkManyMaintainedInBlockRangeById(\n    address[] calldata idList,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the validator `consensusAddr` has finished cooldown.\n   */\n  function checkCooldownEnded(TConsensus consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `consensusAddr` has schedule.\n   */\n  function checkScheduled(TConsensus consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns the detailed schedule of the validator `consensusAddr`.\n   */\n  function getSchedule(TConsensus consensusAddr) external view returns (Schedule memory);\n\n  /**\n   * @dev Returns the total of current schedules.\n   */\n  function totalSchedule() external view returns (uint256 count);\n\n  /**\n   * @dev Returns the cooldown to maintain in seconds.\n   */\n  function cooldownSecsToMaintain() external view returns (uint256);\n\n  /**\n   * @dev Sets the duration restriction, start time restriction, and max allowed for maintenance.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The max duration is larger than the min duration.\n   * - The max offset is larger than the min offset.\n   *\n   * Emits the event `MaintenanceConfigUpdated`.\n   *\n   */\n  function setMaintenanceConfig(\n    uint256 minMaintenanceDurationInBlock_,\n    uint256 maxMaintenanceDurationInBlock_,\n    uint256 minOffsetToStartSchedule_,\n    uint256 maxOffsetToStartSchedule_,\n    uint256 maxSchedules_,\n    uint256 cooldownSecsToMaintain_\n  ) external;\n\n  /**\n   * @dev Returns the min duration for maintenance in block.\n   */\n  function minMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the max duration for maintenance in block.\n   */\n  function maxMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev The offset to the min block number that the schedule can start\n   */\n  function minOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev The offset to the max block number that the schedule can start\n   */\n  function maxOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev Returns the max number of scheduled maintenances.\n   */\n  function maxSchedule() external view returns (uint256);\n\n  /**\n   * @dev Schedules for maintenance from `startedAtBlock` to `endedAtBlock`.\n   *\n   * Requirements:\n   * - The candidate `consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `consensusAddr`.\n   * - The candidate `consensusAddr` has no schedule yet or the previous is done.\n   * - The total number of schedules is not larger than `maxSchedules()`.\n   * - The start block must be at least `minOffsetToStartSchedule()` and at most `maxOffsetToStartSchedule()` blocks from the current block.\n   * - The end block is larger than the start block.\n   * - The scheduled duration is larger than the `minMaintenanceDurationInBlock()` and less than the `maxMaintenanceDurationInBlock()`.\n   * - The start block is at the start of an epoch.\n   * - The end block is at the end of an epoch.\n   *\n   * Emits the event `MaintenanceScheduled`.\n   *\n   */\n  function schedule(TConsensus consensusAddr, uint256 startedAtBlock, uint256 endedAtBlock) external;\n\n  /**\n   * @dev Cancel the schedule of maintenance for the `consensusAddr`.\n   *\n   * Requirements:\n   * - The candidate `consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `consensusAddr`.\n   * - A schedule for the `consensusAddr` must be existent and not executed yet.\n   *\n   * Emits the event `MaintenanceScheduleCancelled`.\n   */\n  function cancelSchedule(TConsensus consensusAddr) external;\n}\n"
    },
    "contracts/interfaces/IProfile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TPoolId, TConsensus } from \"../udvts/Types.sol\";\nimport \"../utils/RoleAccess.sol\";\n\ninterface IProfile {\n  struct CandidateProfile {\n    /**\n     * @dev Primary key of the profile, use for backward querying.\n     *\n     * {Staking} Contract: index of pool\n     * {RoninValidatorSet} Contract: index of almost all data related to a validator\n     *\n     */\n    address id;\n    /// @dev Consensus address.\n    TConsensus consensus;\n    /// @dev Pool admin address.\n    address admin;\n    /// @dev Treasury address.\n    address payable treasury;\n    /// @dev Address to voting proposal.\n    address __reservedGovernor;\n    /// @dev Public key for fast finality.\n    bytes pubkey;\n  }\n\n  /// @dev Event emitted when a profile with `id` is added.\n  event ProfileAdded(address indexed id);\n  /// @dev Event emitted when a address in a profile is changed.\n  event ProfileAddressChanged(address indexed id, RoleAccess indexed addressType);\n  /// @dev Event emitted when the pubkey of the `id` is changed.\n  event PubkeyChanged(address indexed id, bytes pubkey);\n\n  /// @dev Error of already existed profile.\n  error ErrExistentProfile();\n  /// @dev Error of non existed profile.\n  error ErrNonExistentProfile();\n  /// @dev Error when create a new profile whose id and consensus are not identical.\n  error ErrIdAndConsensusDiffer();\n  /**\n   * @dev Error when there is a duplicated info of `value`, which is uin256-padding value of any address or hash of public key,\n   * and with value type of `infoType`.\n   */\n  error ErrDuplicatedInfo(RoleAccess infoType, uint256 value);\n  error ErrDuplicatedPubkey(bytes pubkey);\n  error ErrZeroAddress(RoleAccess infoType);\n  error ErrZeroPubkey();\n\n  /// @dev Getter to query full `profile` from `id` address.\n  function getId2Profile(address id) external view returns (CandidateProfile memory profile);\n\n  /// @dev Getter to batch query from `id` to `consensus`, return address(0) if the profile not exist.\n  function getManyId2Consensus(address[] calldata idList) external view returns (TConsensus[] memory consensusList);\n\n  /// @dev Getter to backward query from `consensus` address to `id` address.\n  function getConsensus2Id(TConsensus consensus) external view returns (address id);\n\n  /// @dev Getter to backward batch query from `consensus` address to `id` address.\n  function getManyConsensus2Id(TConsensus[] memory consensus) external view returns (address[] memory);\n\n  /**\n   * @notice Add a new profile.\n   *\n   * @dev Requirements:\n   * - The profile must not be existent before.\n   * - Only contract admin can call this method.\n   */\n  function addNewProfile(CandidateProfile memory profile) external;\n\n  /**\n   * @dev Cross-contract function to add/update new profile of a validator candidate when they\n   * applying for candidate role.\n   *\n   * Requirements:\n   * - Only `stakingContract` can call this method.\n   */\n  function execApplyValidatorCandidate(address admin, address id, address treasury, bytes calldata pubkey) external;\n\n  /**\n   * @dev Updated the treasury address of candidate id `id` immediately without waiting time.\n   *\n   * Emit an {ProfileAddressChanged}.\n   */\n  function requestChangeAdminAddress(address id, address newAdminAddr) external;\n\n  /**\n   * @dev Updated the treasury address of candidate id `id` immediately without waiting time.\n   *\n   * Emit an {ProfileAddressChanged}.\n   */\n  function requestChangeConsensusAddr(address id, TConsensus newConsensusAddr) external;\n\n  /**\n   * @dev Updated the treasury address of candidate id `id` immediately without waiting time.\n   *\n   * Emit an {ProfileAddressChanged}.\n   */\n  function requestChangeTreasuryAddr(address id, address payable newTreasury) external;\n\n  /**\n   * @notice The candidate admin changes the public key.\n   *\n   * @dev Requirements:\n   * - The profile must be existed.\n   * - Only user with candidate admin role can call this method.\n   * - New public key must not be duplicated.\n   */\n\n  function changePubkey(address id, bytes memory pubkey) external;\n}\n"
    },
    "contracts/interfaces/IQuorum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IQuorum {\n  /// @dev Emitted when the threshold is updated\n  event ThresholdUpdated(\n    uint256 indexed nonce,\n    uint256 indexed numerator,\n    uint256 indexed denominator,\n    uint256 previousNumerator,\n    uint256 previousDenominator\n  );\n\n  /**\n   * @dev Returns the threshold.\n   */\n  function getThreshold() external view returns (uint256 _num, uint256 _denom);\n\n  /**\n   * @dev Checks whether the `_voteWeight` passes the threshold.\n   */\n  function checkThreshold(uint256 _voteWeight) external view returns (bool);\n\n  /**\n   * @dev Returns the minimum vote weight to pass the threshold.\n   */\n  function minimumVoteWeight() external view returns (uint256);\n\n  /**\n   * @dev Sets the threshold.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `ThresholdUpdated` event.\n   *\n   */\n  function setThreshold(\n    uint256 _numerator,\n    uint256 _denominator\n  ) external returns (uint256 _previousNum, uint256 _previousDenom);\n}\n"
    },
    "contracts/interfaces/IRoninTrustedOrganization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IQuorum.sol\";\nimport \"../udvts/Types.sol\";\n\ninterface IRoninTrustedOrganization is IQuorum {\n  /**\n   * @dev Error indicating that a query for a duplicate entry was made.\n   */\n  error ErrQueryForDupplicated();\n\n  /**\n   * @dev Error indicating that a query was made for a non-existent consensus address.\n   */\n  error ErrQueryForNonExistentConsensusAddress();\n\n  /**\n   * @dev Error indicating that a governor address has already been added.\n   * @param addr The address of the governor that is already added.\n   */\n  error ErrGovernorAddressIsAlreadyAdded(address addr);\n\n  /**\n   * @dev Error indicating that a consensus address is not added.\n   * @param addr The address of the consensus contract that is not added.\n   */\n  error ErrConsensusAddressIsNotAdded(TConsensus addr);\n\n  /**\n   * @dev Error indicating that a consensus address is already added.\n   * @param addr The address of the consensus contract that is already added.\n   */\n  error ErrConsensusAddressIsAlreadyAdded(TConsensus addr);\n\n  struct TrustedOrganization {\n    // Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n    TConsensus consensusAddr;\n    // Address to voting proposal\n    address governor;\n    // Address to voting bridge operators\n    address __deprecatedBridgeVoter;\n    // Its Weight\n    uint256 weight;\n    // The block that the organization was added\n    uint256 addedBlock;\n  }\n\n  /// @dev Emitted when the trusted organization is added.\n  event TrustedOrganizationsAdded(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is updated.\n  event TrustedOrganizationsUpdated(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is removed.\n  event TrustedOrganizationsRemoved(TConsensus[] orgs);\n  /// @dev Emitted when the consensus address of a trusted organization is changed.\n  event ConsensusAddressOfTrustedOrgChanged(TrustedOrganization orgAfterChanged, TConsensus oldConsensus);\n\n  /**\n   * @dev Adds a list of addresses into the trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   * - The field `addedBlock` should be blank.\n   *\n   * Emits the event `TrustedOrganizationAdded` once an organization is added.\n   *\n   */\n  function addTrustedOrganizations(TrustedOrganization[] calldata) external;\n\n  /**\n   * @dev Updates weights for a list of existent trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   *\n   * Emits the `TrustedOrganizationUpdated` event.\n   *\n   */\n  function updateTrustedOrganizations(TrustedOrganization[] calldata list) external;\n\n  /**\n   * @dev Removes a list of addresses from the trusted organization.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `TrustedOrganizationRemoved` once an organization is removed.\n   *\n   * @param consensusAddrs The list of consensus addresses linked to corresponding trusted organization that to be removed.\n   */\n  function removeTrustedOrganizations(TConsensus[] calldata consensusAddrs) external;\n\n  /**\n   * @dev Fallback function of `Profile-requestChangeConsensusAddress`.\n   *\n   * Requirements:\n   * - The caller must be the Profile contract.\n   *\n   * Emits the event `ConsensusAddressOfTrustedOrgChanged` once an organization is removed.\n   */\n  function execChangeConsensusAddressForTrustedOrg(TConsensus oldConsensusAddr, TConsensus newConsensusAddr) external;\n\n  /**\n   * @dev Returns total weights.\n   */\n  function totalWeight() external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a consensus.\n   */\n  function getConsensusWeight(TConsensus consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a consensus.\n   */\n  function getConsensusWeightById(address cid) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a governor.\n   */\n  function getGovernorWeight(address governor) external view returns (uint256);\n\n  /**\n   * @dev Returns the weights of a list of consensus addresses.\n   */\n  function getConsensusWeights(TConsensus[] calldata list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of consensus addresses.\n   */\n  function getConsensusWeightsById(address[] calldata cids) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of governor addresses.\n   */\n  function getGovernorWeights(address[] calldata list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns total weights of the consensus list.\n   */\n  function sumConsensusWeight(TConsensus[] calldata list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns total weights of the governor list.\n   */\n  function sumGovernorWeight(address[] calldata list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns the trusted organization at `_index`.\n   */\n  function getTrustedOrganizationAt(uint256 index) external view returns (TrustedOrganization memory);\n\n  /**\n   * @dev Returns the number of trusted organizations.\n   */\n  function countTrustedOrganization() external view returns (uint256);\n\n  /**\n   * @dev Returns all of the trusted organizations.\n   */\n  function getAllTrustedOrganizations() external view returns (TrustedOrganization[] memory);\n\n  /**\n   * @dev Returns the trusted organization by consensus address.\n   *\n   * Reverts once the consensus address is non-existent.\n   */\n  function getTrustedOrganization(TConsensus consensusAddr) external view returns (TrustedOrganization memory);\n}\n"
    },
    "contracts/interfaces/slash-indicator/IBaseSlash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IBaseSlash {\n  enum SlashType {\n    UNKNOWN,\n    UNAVAILABILITY_TIER_1,\n    UNAVAILABILITY_TIER_2,\n    DOUBLE_SIGNING,\n    BRIDGE_VOTING,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_1,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_2,\n    UNAVAILABILITY_TIER_3,\n    FAST_FINALITY\n  }\n\n  /// @dev Error thrown when evidence has already been submitted.\n  error ErrEvidenceAlreadySubmitted();\n\n  /// @dev Emitted when the validator is slashed.\n  event Slashed(address indexed validator, SlashType slashType, uint256 period);\n}\n"
    },
    "contracts/interfaces/slash-indicator/ICreditScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ICreditScore {\n  /**\n   * @dev Error thrown when an invalid credit score configuration is provided.\n   */\n  error ErrInvalidCreditScoreConfig();\n\n  /**\n   * @dev Error thrown when an invalid cut-off percentage configuration is provided.\n   */\n  error ErrInvalidCutOffPercentageConfig();\n\n  /**\n   * @dev Error thrown when the caller's credit score is insufficient to bail out a situation.\n   */\n  error ErrInsufficientCreditScoreToBailOut();\n\n  /**\n   * @dev Error thrown when a validator has previously bailed out.\n   */\n  error ErrValidatorHasBailedOutPreviously();\n\n  /**\n   * @dev Error thrown when the caller must be jailed in the current period.\n   */\n  error ErrCallerMustBeJailedInTheCurrentPeriod();\n\n  /// @dev Emitted when the configs to credit score is updated. See the method `setCreditScoreConfigs` for param details.\n  event CreditScoreConfigsUpdated(\n    uint256 gainCreditScore,\n    uint256 maxCreditScore,\n    uint256 bailOutCostMultiplier,\n    uint256 cutOffPercentageAfterBailout\n  );\n  /// @dev Emitted the credit score of validators is updated.\n  event CreditScoresUpdated(address[] validators, uint256[] creditScores);\n  /// @dev Emitted when a validator bailed out of jail.\n  event BailedOut(TConsensus indexed consensus, uint256 period, uint256 usedCreditScore);\n\n  /**\n   * @dev Updates the credit score for the validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function execUpdateCreditScores(address[] calldata validatorIds, uint256 period) external;\n\n  /**\n   * @dev Resets the credit score for the revoked validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function execResetCreditScores(address[] calldata validatorIds) external;\n\n  /**\n   * @dev A slashed validator use this method to get out of jail.\n   *\n   * Requirements:\n   * - The `_consensusAddr` must be a validator.\n   * - Only validator's admin can call this method.\n   *\n   * Emits the event `BailedOut`.\n   *\n   */\n  function bailOut(TConsensus consensusAddr) external;\n\n  /**\n   * @dev Sets the configs to credit score.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CreditScoreConfigsUpdated`.\n   *\n   * @param _gainScore The score to gain per period.\n   * @param _maxScore The max number of credit score that a validator can hold.\n   * @param _bailOutMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @param _cutOffPercentage The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) external;\n\n  /**\n   * @dev Returns the configs related to credit score.\n   *\n   * @return _gainCreditScore The score to gain per period.\n   * @return _maxCreditScore The max number of credit score that a validator can hold.\n   * @return _bailOutCostMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @return _cutOffPercentageAfterBailout The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function getCreditScoreConfigs()\n    external\n    view\n    returns (\n      uint256 _gainCreditScore,\n      uint256 _maxCreditScore,\n      uint256 _bailOutCostMultiplier,\n      uint256 _cutOffPercentageAfterBailout\n    );\n\n  /**\n   * @dev Returns the current credit score of the validator.\n   */\n  function getCreditScore(TConsensus consensus) external view returns (uint256);\n\n  /**\n   * @dev Returns the current credit score of a list of validators.\n   */\n  function getManyCreditScores(\n    TConsensus[] calldata consensusAddrs\n  ) external view returns (uint256[] memory _resultList);\n\n  /**\n   * @dev Returns the whether the `consensus` has been bailed out at the `period`.\n   */\n  function checkBailedOutAtPeriod(TConsensus consensus, uint256 period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ISlashDoubleSign is IBaseSlash {\n  /**\n   * @dev Emitted when the configs to slash double sign is updated. See the method `getDoubleSignSlashingConfigs`\n   * for param details.\n   */\n  event DoubleSignSlashingConfigsUpdated(\n    uint256 slashDoubleSignAmount,\n    uint256 doubleSigningJailUntilBlock,\n    uint256 doubleSigningOffsetLimitBlock\n  );\n\n  /**\n   * @dev Slashes for double signing.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` if the double signing evidence of the two headers valid.\n   */\n  function slashDoubleSign(TConsensus _validatorAddr, bytes calldata _header1, bytes calldata _header2) external;\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return _slashDoubleSignAmount The amount of RON to slash double sign.\n   * @return _doubleSigningJailUntilBlock The block number that the punished validator will be jailed until, due to\n   * double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function getDoubleSignSlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _slashDoubleSignAmount,\n      uint256 _doubleSigningJailUntilBlock,\n      uint256 _doubleSigningOffsetLimitBlock\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `DoubleSignSlashingConfigsUpdated`.\n   *\n   * @param _slashAmount The amount of RON to slash double sign.\n   * @param _jailUntilBlock The block number that the punished validator will be jailed until, due to double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _doubleSigningOffsetLimitBlock\n  ) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ISlashFastFinality is IBaseSlash {\n  /**\n   * @dev Emitted when the configs to slash fast finality is updated. See the method `getFastFinalitySlashingConfigs`\n   * for param details.\n   */\n  event FastFinalitySlashingConfigsUpdated(uint256 slashFastFinalityAmount, uint256 fastFinalityJailUntilBlock);\n\n  /**\n   * @dev Slashes for fast finality.\n   *\n   * Requirements:\n   * - Only whitelisted addresses are allowed to call.\n   *\n   * Emits the event `Slashed` if the fast finality evidence of the two headers valid.\n   */\n  function slashFastFinality(\n    TConsensus consensusAddr,\n    bytes calldata voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] calldata targetBlockHash,\n    bytes[][2] calldata listOfPublicKey,\n    bytes[2] calldata aggregatedSignature\n  ) external;\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return slashFastFinalityAmount The amount of RON to slash fast finality.\n   * @return fastFinalityJailUntilBlock The block number that the punished validator will be jailed until, due to\n   * malicious fast finality.\n   */\n  function getFastFinalitySlashingConfigs()\n    external\n    view\n    returns (uint256 slashFastFinalityAmount, uint256 fastFinalityJailUntilBlock);\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `FastFinalitySlashingConfigsUpdated`.\n   *\n   * @param slashAmount The amount of RON to slash fast finality.\n   * @param jailUntilBlock The block number that the punished validator will be jailed until, due to fast finality.\n   *\n   */\n  function setFastFinalitySlashingConfigs(uint256 slashAmount, uint256 jailUntilBlock) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashIndicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashDoubleSign.sol\";\nimport \"./ISlashUnavailability.sol\";\nimport \"./ICreditScore.sol\";\n\ninterface ISlashIndicator is\n  ISlashDoubleSign,\n  ISlashUnavailability,\n  ICreditScore\n{}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashUnavailability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ISlashUnavailability is IBaseSlash {\n  /**\n   * @dev Error thrown when attempting to slash a validator twice or slash more than one validator in one block.\n   */\n  error ErrCannotSlashAValidatorTwiceOrSlashMoreThanOneValidatorInOneBlock();\n\n  /**\n   * @dev Emitted when the configs to slash bridge operator is updated. See the method `getUnavailabilitySlashingConfigs`\n   * for param details.\n   */\n  event UnavailabilitySlashingConfigsUpdated(\n    uint256 unavailabilityTier1Threshold,\n    uint256 unavailabilityTier2Threshold,\n    uint256 slashAmountForUnavailabilityTier2Threshold,\n    uint256 jailDurationForUnavailabilityTier2Threshold\n  );\n\n  /**\n   * @dev Returns the last block that a block producer is slashed for unavailability.\n   */\n  function lastUnavailabilitySlashedBlock() external view returns (uint256);\n\n  /**\n   * @dev Slashes for unavailability by increasing the counter of block producer `consensusAddr`.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` when the threshold is reached.\n   *\n   */\n  function slashUnavailability(TConsensus consensusAddr) external;\n\n  /**\n   * @dev Returns the current unavailability indicator of a block producer.\n   */\n  function currentUnavailabilityIndicator(TConsensus consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the unavailability indicator in the period `period` of a block producer.\n   */\n  function getUnavailabilityIndicator(TConsensus consensusAddr, uint256 period) external view returns (uint256);\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return unavailabilityTier1Threshold The mining reward will be deprecated, if (s)he missed more than this\n   * threshold. This threshold is applied for tier-1 and tier-3 slash.\n   * @return unavailabilityTier2Threshold  The mining reward will be deprecated, (s)he will be put in jailed, and will\n   * be deducted self-staking if (s)he misses more than this threshold. This threshold is applied for tier-2 slash.\n   * @return slashAmountForUnavailabilityTier2Threshold The amount of RON to deduct from self-staking of a block\n   * producer when (s)he is slashed with tier-2 or tier-3.\n   * @return jailDurationForUnavailabilityTier2Threshold The number of blocks to jail a block producer when (s)he is\n   * slashed with tier-2 or tier-3.\n   *\n   */\n  function getUnavailabilitySlashingConfigs()\n    external\n    view\n    returns (\n      uint256 unavailabilityTier1Threshold,\n      uint256 unavailabilityTier2Threshold,\n      uint256 slashAmountForUnavailabilityTier2Threshold,\n      uint256 jailDurationForUnavailabilityTier2Threshold\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeOperatorSlashingConfigsUpdated`.\n   *\n   * @param tier1Threshold The mining reward will be deprecated, if (s)he missed more than this threshold.\n   * @param tier2Threshold The mining reward will be deprecated, (s)he will be put in jailed, and will be deducted\n   * self-staking if (s)he misses more than this threshold.\n   * @param slashAmountForTier2Threshold The amount of RON to deduct from self-staking of a block producer when (s)he\n   * is slashed tier-2.\n   * @param jailDurationForTier2Threshold The number of blocks to jail a block producer when (s)he is slashed tier-2.\n   *\n   */\n  function setUnavailabilitySlashingConfigs(\n    uint256 tier1Threshold,\n    uint256 tier2Threshold,\n    uint256 slashAmountForTier2Threshold,\n    uint256 jailDurationForTier2Threshold\n  ) external;\n}\n"
    },
    "contracts/interfaces/staking/IBaseStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TPoolId, TConsensus } from \"../../udvts/Types.sol\";\n\ninterface IBaseStaking {\n  struct PoolDetail {\n    /**\n     * @dev Address of the pool.\n     * @custom non-volatile-storage Permanently set to the first consensus address of the candidate.\n     */\n    address pid;\n\n    /**\n     * @dev The address of the pool admin.\n     * @custom shadowed-storage This storage slot is always kept in sync with the admin in `Profile-CandidateProfile`.\n     */\n    address __shadowedPoolAdmin;\n\n    /// @dev Self-staking amount\n    uint256 stakingAmount;\n\n    /// @dev Total number of RON staking for the pool\n    uint256 stakingTotal;\n\n    /// @dev Mapping from delegator => delegating amount\n    mapping(address => uint256) delegatingAmount;\n\n    /// @dev Mapping from delegator => the last timestamp that delegator staked\n    mapping(address => uint256) lastDelegatingTimestamp;\n  }\n\n  /// @dev Emitted when the minium number of seconds to undelegate is updated.\n  event CooldownSecsToUndelegateUpdated(uint256 minSecs);\n  /// @dev Emitted when the number of seconds that a candidate must wait to be revoked.\n  event WaitingSecsToRevokeUpdated(uint256 secs);\n\n  /// @dev Error of cannot transfer RON.\n  error ErrCannotTransferRON();\n  /// @dev Error of receiving zero message value.\n  error ErrZeroValue();\n  /// @dev Error of pool admin is not allowed to call.\n  error ErrPoolAdminForbidden();\n  /// @dev Error of no one is allowed to call but the pool's admin.\n  error ErrOnlyPoolAdminAllowed();\n  /// @dev Error of admin of any active pool cannot delegate.\n  error ErrAdminOfAnyActivePoolForbidden(address admin);\n  /// @dev Error of querying inactive pool.\n  error ErrInactivePool(TConsensus consensusAddr, address poolAddr);\n  /// @dev Error of length of input arrays are not of the same.\n  error ErrInvalidArrays();\n\n  /**\n   * @dev Returns whether the `admin` is currently active.\n   */\n  function isAdminOfActivePool(address admin) external view returns (bool);\n\n  /**\n   * @dev Returns the consensus address corresponding to the pool admin.\n   */\n  function getPoolAddressOf(address admin) external view returns (address);\n\n  /**\n   * @dev Returns the staking pool details.\n   */\n  function getPoolDetail(\n    TConsensus consensusAddr\n  ) external view returns (address admin, uint256 stakingAmount, uint256 stakingTotal);\n\n  function getPoolDetailById(\n    address poolId\n  ) external view returns (address admin, uint256 stakingAmount, uint256 stakingTotal);\n\n  /**\n   * @dev Returns the self-staking amounts of the pools.\n   */\n  function getManySelfStakings(TConsensus[] calldata consensusAddrs) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the self-staking amounts of the pools.\n   */\n  function getManySelfStakingsById(address[] calldata poolIds) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns The cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n   */\n  function cooldownSecsToUndelegate() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of seconds that a candidate must wait for the renounce request gets affected.\n   */\n  function waitingSecsToRevoke() external view returns (uint256);\n\n  /**\n   * @dev Sets the cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CooldownSecsToUndelegateUpdated`.\n   *\n   */\n  function setCooldownSecsToUndelegate(uint256 cooldownSecs) external;\n\n  /**\n   * @dev Sets the number of seconds that a candidate must wait to be revoked.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `WaitingSecsToRevokeUpdated`.\n   *\n   */\n  function setWaitingSecsToRevoke(uint256 secs) external;\n}\n"
    },
    "contracts/interfaces/staking/ICandidateStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IRewardPool.sol\";\n\ninterface ICandidateStaking is IRewardPool {\n  /// @dev Emitted when the minimum staking amount for being a validator is updated.\n  event MinValidatorStakingAmountUpdated(uint256 threshold);\n  /// @dev Emitted when the commission rate range is updated.\n  event CommissionRateRangeUpdated(uint256 minRate, uint256 maxRate);\n\n  /// @dev Emitted when the pool admin staked for themself.\n  event Staked(address indexed poolId, uint256 amount);\n  /// @dev Emitted when the pool admin unstaked the amount of RON from themself.\n  event Unstaked(address indexed poolId, uint256 amount);\n\n  /// @dev Emitted when the validator pool is approved.\n  event PoolApproved(address indexed validator, address indexed admin);\n  /// @dev Emitted when the validator pool is deprecated.\n  event PoolsDeprecated(address[] validator);\n  /// @dev Emitted when the staking amount transfer failed.\n  event StakingAmountTransferFailed(\n    address indexed poolId,\n    address indexed admin,\n    uint256 amount,\n    uint256 contractBalance\n  );\n  /// @dev Emitted when the staking amount deducted failed, e.g. when the validator gets slashed.\n  event StakingAmountDeductFailed(\n    address indexed poolId,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Error of cannot transfer RON to specified target.\n  error ErrCannotInitTransferRON(address addr, string extraInfo);\n  /// @dev Error of three interaction addresses must be of the same in applying for validator candidate.\n  error ErrThreeInteractionAddrsNotEqual();\n  /// @dev Error of unstaking zero amount.\n  error ErrUnstakeZeroAmount();\n  /// @dev Error of invalid staking amount left after deducted.\n  error ErrStakingAmountLeft();\n  /// @dev Error of insufficient staking amount for unstaking.\n  error ErrInsufficientStakingAmount();\n  /// @dev Error of unstaking too early.\n  error ErrUnstakeTooEarly();\n  /// @dev Error of setting commission rate exceeds max allowed.\n  error ErrInvalidCommissionRate();\n\n  /**\n   * @dev Returns the minimum threshold for being a validator candidate.\n   */\n  function minValidatorStakingAmount() external view returns (uint256);\n\n  /**\n   * @dev Returns the commission rate range that the candidate can set.\n   */\n  function getCommissionRateRange() external view returns (uint256 minRange, uint256 maxRange);\n\n  /**\n   * @dev Sets the minimum threshold for being a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinValidatorStakingAmountUpdated` event.\n   *\n   */\n  function setMinValidatorStakingAmount(uint256) external;\n\n  /**\n   * @dev Sets the commission rate range that a candidate can set.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `CommissionRateRangeUpdated` event.\n   *\n   */\n  function setCommissionRateRange(uint256 minRate, uint256 maxRate) external;\n\n  /**\n   * @dev Proposes a candidate to become a validator.\n   *\n   * Requirements:\n   * - The method caller is able to receive RON.\n   * - The treasury is able to receive RON.\n   * - The amount is larger than or equal to the minimum validator staking amount `minValidatorStakingAmount()`.\n   *\n   * Emits the event `PoolApproved`.\n   *\n   * @param candidateAdmin the candidate admin will be stored in the validator contract, used for calling function that affects\n   * to its candidate, e.g. scheduling maintenance.\n   *\n   */\n  function applyValidatorCandidate(\n    address candidateAdmin,\n    TConsensus consensusAddr,\n    address payable treasuryAddr,\n    uint256 commissionRate,\n    bytes calldata pubkey\n  ) external payable;\n\n  /**\n   * @dev Deprecates the pool.\n   * - Deduct self-staking amount of the pool admin to zero.\n   * - Transfer the deducted amount to the pool admin.\n   * - Deactivate the pool admin address in the mapping of active pool admins\n   *\n   * Requirements:\n   * - The method caller is validator contract.\n   *\n   * Emits the event `PoolsDeprecated` and `Unstaked` events.\n   * Emits the event `StakingAmountTransferFailed` if the contract cannot transfer RON back to the pool admin.\n   *\n   */\n  function execDeprecatePools(address[] calldata pools, uint256 period) external;\n\n  /**\n   * @dev Self-delegates to the validator candidate `consensusAddr`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   * - The `msg.value` is larger than 0.\n   *\n   * Emits the event `Staked`.\n   *\n   */\n  function stake(TConsensus consensusAddr) external payable;\n\n  /**\n   * @dev Unstakes from the validator candidate `consensusAddr` for `amount`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   * Emits the event `Unstaked`.\n   *\n   */\n  function unstake(TConsensus consensusAddr, uint256 amount) external;\n\n  /**\n   * @dev Pool admin requests update validator commission rate. The request will be forwarded to the candidate manager\n   * contract, and the value is getting updated in {ICandidateManager-execRequestUpdateCommissionRate}.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   * - The `_effectiveDaysOnwards` must be equal to or larger than the {CandidateManager-_minEffectiveDaysOnwards}.\n   * - The `_rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdated`.\n   *\n   */\n  function requestUpdateCommissionRate(\n    TConsensus consensusAddr,\n    uint256 effectiveDaysOnwards,\n    uint256 commissionRate\n  ) external;\n\n  /**\n   * @dev Renounces being a validator candidate and takes back the delegating/staking amount.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   */\n  function requestRenounce(TConsensus consensusAddr) external;\n\n  /**\n   * @dev Renounces being a validator candidate and takes back the delegating/staking amount.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   */\n  function requestEmergencyExit(TConsensus consensusAddr) external;\n}\n"
    },
    "contracts/interfaces/staking/IDelegatorStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IRewardPool.sol\";\n\ninterface IDelegatorStaking is IRewardPool {\n  /// @dev Emitted when the delegator staked for a validator candidate.\n  event Delegated(address indexed delegator, address indexed poolId, uint256 amount);\n  /// @dev Emitted when the delegator unstaked from a validator candidate.\n  event Undelegated(address indexed delegator, address indexed poolId, uint256 amount);\n\n  /// @dev Error of undelegating zero amount.\n  error ErrUndelegateZeroAmount();\n  /// @dev Error of undelegating insufficient amount.\n  error ErrInsufficientDelegatingAmount();\n  /// @dev Error of undelegating too early.\n  error ErrUndelegateTooEarly();\n\n  /**\n   * @dev Stakes for a validator candidate `_consensusAddr`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is not the pool admin.\n   *\n   * Emits the `Delegated` event.\n   *\n   */\n  function delegate(TConsensus consensusAddr) external payable;\n\n  /**\n   * @dev Unstakes from a validator candidate `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   *\n   * Emits the `Undelegated` event.\n   *\n   */\n  function undelegate(TConsensus consensusAddr, uint256 amount) external;\n\n  /**\n   * @dev Bulk unstakes from a list of candidates.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   *\n   * Emits the events `Undelegated`.\n   *\n   */\n  function bulkUndelegate(TConsensus[] calldata consensusAddrs, uint256[] calldata amounts) external;\n\n  /**\n   * @dev Unstakes an amount of RON from the `_consensusAddrSrc` and stake for `_consensusAddrDst`.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   * - The consensus address `_consensusAddrDst` is a validator candidate.\n   *\n   * Emits the `Undelegated` event and the `Delegated` event.\n   *\n   */\n  function redelegate(TConsensus consensusAddrSrc, TConsensus consensusAddrDst, uint256 amount) external;\n\n  /**\n   * @dev Returns the claimable reward of the user `_user`.\n   */\n  function getRewards(\n    address user,\n    TConsensus[] calldata consensusAddrList\n  ) external view returns (uint256[] memory _rewards);\n\n  /**\n   * @dev Claims the reward of method caller.\n   *\n   * Emits the `RewardClaimed` event.\n   *\n   */\n  function claimRewards(TConsensus[] calldata consensusAddrList) external returns (uint256 amount);\n\n  /**\n   * @dev Claims the rewards and delegates them to the consensus address.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   * - The consensus address `_consensusAddrDst` is a validator candidate.\n   *\n   * Emits the `RewardClaimed` event and the `Delegated` event.\n   *\n   */\n  function delegateRewards(\n    TConsensus[] calldata consensusAddrList,\n    TConsensus consensusAddrDst\n  ) external returns (uint256 amount);\n}\n"
    },
    "contracts/interfaces/staking/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/consumers/PeriodWrapperConsumer.sol\";\n\nimport { TPoolId, TConsensus } from \"../../udvts/Types.sol\";\n\ninterface IRewardPool is PeriodWrapperConsumer {\n  struct UserRewardFields {\n    // Recorded reward amount.\n    uint256 debited;\n    // The last accumulated of the amount rewards per share (one unit staking) that the info updated.\n    uint256 aRps;\n    // Lowest staking amount in the period.\n    uint256 lowestAmount;\n    // Last period number that the info updated.\n    uint256 lastPeriod;\n  }\n\n  struct PoolFields {\n    // Accumulated of the amount rewards per share (one unit staking).\n    uint256 aRps;\n    // The staking total to share reward of the current period.\n    PeriodWrapper shares;\n  }\n\n  /// @dev Emitted when the fields to calculate pending reward for the user is updated.\n  event UserRewardUpdated(address indexed poolAddr, address indexed user, uint256 debited);\n  /// @dev Emitted when the user claimed their reward\n  event RewardClaimed(address indexed poolAddr, address indexed user, uint256 amount);\n\n  /// @dev Emitted when the pool shares are updated\n  event PoolSharesUpdated(uint256 indexed period, address indexed poolAddr, uint256 shares);\n  /// @dev Emitted when the pools are updated\n  event PoolsUpdated(uint256 indexed period, address[] poolAddrs, uint256[] aRps, uint256[] shares);\n  /// @dev Emitted when the contract fails when updating the pools\n  event PoolsUpdateFailed(uint256 indexed period, address[] poolAddrs, uint256[] rewards);\n  /// @dev Emitted when the contract fails when updating the pools that already set\n  event PoolsUpdateConflicted(uint256 indexed period, address[] poolAddrs);\n\n  /// @dev Error of invalid pool share.\n  error ErrInvalidPoolShare();\n\n  /**\n   * @dev Returns the reward amount that user claimable.\n   */\n  function getReward(TConsensus consensusAddr, address user) external view returns (uint256);\n\n  /**\n   * @dev Returns the staking amount of an user.\n   */\n  function getStakingAmount(TConsensus consensusAddr, address user) external view returns (uint256);\n\n  /**\n   * @dev Returns the staking amounts of the users.\n   */\n  function getManyStakingAmounts(\n    TConsensus[] calldata consensusAddrs,\n    address[] calldata userList\n  ) external view returns (uint256[] memory);\n\n  function getManyStakingAmountsById(\n    address[] calldata poolIds,\n    address[] calldata userList\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the total staking amount of all users for a pool.\n   */\n  function getStakingTotal(TConsensus consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the total staking amounts of all users for the pools `_poolAddrs`.\n   */\n  function getManyStakingTotals(TConsensus[] calldata consensusAddrs) external view returns (uint256[] memory);\n\n  function getManyStakingTotalsById(\n    address[] calldata poolIds\n  ) external view returns (uint256[] memory stakingAmounts_);\n}\n"
    },
    "contracts/interfaces/staking/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseStaking.sol\";\nimport \"./IStakingCallback.sol\";\nimport \"./ICandidateStaking.sol\";\nimport \"./IDelegatorStaking.sol\";\n\ninterface IStaking is IRewardPool, IBaseStaking, ICandidateStaking, IDelegatorStaking, IStakingCallback {\n  /**\n   * @dev Records the amount of rewards `_rewards` for the pools `_consensusAddrs`.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   *\n   * Emits the event `PoolsUpdated` once the contract recorded the rewards successfully.\n   * Emits the event `PoolsUpdateFailed` once the input array lengths are not equal.\n   * Emits the event `PoolsUpdateConflicted` when there are some pools which already updated in the period.\n   *\n   * Note: This method should be called once at the period ending.\n   *\n   */\n  function execRecordRewards(address[] calldata poolIds, uint256[] calldata rewards, uint256 period) external payable;\n\n  /**\n   * @dev Deducts from staking amount of the validator `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   *\n   * Emits the event `Unstaked`.\n   *\n   */\n  function execDeductStakingAmount(address poolId, uint256 amount) external returns (uint256 actualDeductingAmount);\n}\n"
    },
    "contracts/interfaces/staking/IStakingCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TPoolId } from \"../../udvts/Types.sol\";\n\ninterface IStakingCallback {\n  /**\n   * @dev Requirements:\n   * - Only Profile contract can call this method.\n   */\n  function execChangeAdminAddress(address poolAddr, address newAdminAddr) external;\n}\n"
    },
    "contracts/interfaces/validator/ICandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ICandidateManager {\n  struct ValidatorCandidate {\n    /**\n     * @dev The address of the candidate admin.\n     * @custom shadowed-storage This storage slot is always kept in sync with {Profile-CandidateProfile}.admin.\n     */\n    address __shadowedAdmin;\n    /**\n     * @dev Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n     * @custom shadowed-storage This storage slot is always kept in sync with {Profile-CandidateProfile}.consensus.\n     */\n    TConsensus __shadowedConsensus;\n    /**\n     * @dev Address that receives mining reward of the validator\n     * @custom shadowed-storage This storage slot is always kept in sync with {Profile-CandidateProfile}.treasury.\n     */\n    address payable __shadowedTreasury;\n    /// @dev Address of the bridge operator corresponding to the candidate\n    address ____deprecatedBridgeOperatorAddr;\n    /**\n     * @dev The percentage of reward that validators can be received, the rest goes to the delegators.\n     * Values in range [0; 100_00] stands for 0-100%\n     */\n    uint256 commissionRate;\n    /// @dev The timestamp that scheduled to revoke the candidate (no schedule=0)\n    uint256 revokingTimestamp;\n    /// @dev The deadline that the candidate must top up staking amount to keep it larger than or equal to the threshold (no deadline=0)\n    uint256 topupDeadline;\n  }\n\n  struct CommissionSchedule {\n    /// @dev The timestamp that the commission schedule gets affected (no schedule=0).\n    uint256 effectiveTimestamp;\n    /// @dev The new commission rate. Value is in range [0; 100_00], stands for 0-100%\n    uint256 commissionRate;\n  }\n\n  /// @dev Emitted when the maximum number of validator candidates is updated.\n  event MaxValidatorCandidateUpdated(uint256 threshold);\n  /// @dev Emitted when the min offset to the effective date of commission rate change is updated.\n  event MinEffectiveDaysOnwardsUpdated(uint256 numOfDays);\n  /// @dev Emitted when the validator candidate is granted.\n  event CandidateGranted(address indexed consensusAddr, address indexed treasuryAddr, address indexed admin);\n  /// @dev Emitted when the revoking timestamp of a candidate is updated.\n  event CandidateRevokingTimestampUpdated(address indexed cid, uint256 revokingTimestamp);\n  /// @dev Emitted when the topup deadline of a candidate is updated.\n  event CandidateTopupDeadlineUpdated(address indexed cid, uint256 topupDeadline);\n  /// @dev Emitted when the validator candidate is revoked.\n  event CandidatesRevoked(address[] consensusAddrs);\n\n  /// @dev Emitted when the commission rate of a validator is updated.\n  event CommissionRateUpdated(address indexed consensusAddr, uint256 rate);\n  /// @dev Error of exceeding maximum number of candidates.\n  error ErrExceedsMaxNumberOfCandidate();\n  /// @dev Error of querying for already existent candidate.\n  error ErrExistentCandidate();\n  /// @dev Error of querying for non-existent candidate.\n  error ErrNonExistentCandidate();\n  /// @dev Error of candidate admin already exists.\n  error ErrExistentCandidateAdmin(address candidateAdminAddr);\n  /// @dev Error of treasury already exists.\n  error ErrExistentTreasury(address _treasuryAddr);\n  /// @dev Error of invalid commission rate.\n  error ErrInvalidCommissionRate();\n    /// @dev Error of invalid min effective days onwards.\n  error ErrInvalidMinEffectiveDaysOnwards();\n\n  /**\n   * @dev Returns the maximum number of validator candidate.\n   */\n  function maxValidatorCandidate() external view returns (uint256);\n\n  /**\n   * @dev Returns the minimum number of days to the effective date of commission rate change.\n   */\n  function minEffectiveDaysOnward() external view returns (uint256);\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function setMaxValidatorCandidate(uint256) external;\n\n  /**\n   * @dev Sets the minimum number of days to the effective date of commision rate change.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external;\n\n  /**\n   * @dev Returns whether the address is a validator (candidate).\n   */\n  function isValidatorCandidate(TConsensus consensus) external view returns (bool);\n\n  /**\n   * @dev Returns the validator candidate.\n   */\n  function getValidatorCandidates() external view returns (address[] memory);\n\n  /**\n   * @dev Returns all candidate info.\n   */\n  function getCandidateInfos() external view returns (ValidatorCandidate[] memory);\n\n  /**\n   * @dev Returns the info of a candidate.\n   */\n  function getCandidateInfo(TConsensus consensus) external view returns (ValidatorCandidate memory);\n\n  /**\n   * @dev Returns whether the address is the candidate admin.\n   */\n  function isCandidateAdmin(TConsensus consensus, address admin) external view returns (bool);\n\n  /**\n   * @dev Returns the schedule of changing commission rate of a candidate address.\n   */\n  function getCommissionChangeSchedule(TConsensus consensus) external view returns (CommissionSchedule memory);\n}\n"
    },
    "contracts/interfaces/validator/ICandidateManagerCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ICandidateManagerCallback {\n  /// @dev Emitted when a schedule for updating commission rate is set.\n  event CommissionRateUpdateScheduled(address indexed consensusAddr, uint256 effectiveTimestamp, uint256 rate);\n  /// @dev Error of already requested revoking candidate before.\n  error ErrAlreadyRequestedRevokingCandidate();\n  /// @dev Error of commission change schedule exists.\n  error ErrAlreadyRequestedUpdatingCommissionRate();\n  /// @dev Error of trusted org cannot renounce.\n  error ErrTrustedOrgCannotRenounce();\n  /// @dev Error of invalid effective days onwards.\n  error ErrInvalidEffectiveDaysOnwards();\n\n  /**\n   * @dev Grants a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateGranted`.\n   *\n   */\n  function execApplyValidatorCandidate(\n    address candidateAdmin,\n    address cid,\n    address payable treasuryAddr,\n    uint256 commissionRate\n  ) external;\n\n  /**\n   * @dev Requests to revoke a validator candidate in next `secsLeft` seconds.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateRevokingTimestampUpdated`.\n   *\n   */\n  function execRequestRenounceCandidate(address, uint256 secsLeft) external;\n\n  /**\n   * @dev Fallback function of `CandidateStaking-requestUpdateCommissionRate`.\n   *\n   * Requirements:\n   * - The method caller is the staking contract.\n   * - The `effectiveTimestamp` must be the beginning of a UTC day, and at least from 7 days onwards\n   * - The `rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdateScheduled`.\n   *\n   */\n  function execRequestUpdateCommissionRate(address cid, uint256 effectiveTimestamp, uint256 rate) external;\n\n  /**\n   * @dev Fallback function of `Profile-requestChangeAdminAddress`.\n   * This updates the shadow storage slot of \"shadowedAdmin\" for candidate id `id` to `newAdmin`.\n   *\n   * Requirements:\n   * - The caller must be the Profile contract.\n   */\n  function execChangeAdminAddress(address cid, address newAdmin) external;\n\n  /**\n   * @dev Fallback function of `Profile-requestChangeConsensusAddress`.\n   * This updates the shadow storage slot of \"shadowedConsensus\" for candidate id `id` to `newAdmin`.\n   *\n   * Requirements:\n   * - The caller must be the Profile contract.\n   */\n  function execChangeConsensusAddress(address cid, TConsensus newConsensus) external;\n\n  /**\n   * @dev Fallback function of `Profile-requestChangeTreasuryAddress`.\n   * This updates the shadow storage slot of \"shadowedTreasury\" for candidate id `id` to `newAdmin`.\n   *\n   * Requirements:\n   * - The caller must be the Profile contract.\n   */\n  function execChangeTreasuryAddress(address cid, address payable newTreasury) external;\n}\n"
    },
    "contracts/interfaces/validator/ICoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashingExecution.sol\";\n\ninterface ICoinbaseExecution is ISlashingExecution {\n  enum BlockRewardDeprecatedType {\n    UNKNOWN,\n    UNAVAILABILITY,\n    AFTER_BAILOUT\n  }\n\n  /// @dev Emitted when the validator set is updated\n  event ValidatorSetUpdated(uint256 indexed period, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated, to mirror the in-jail and maintaining status of the validator.\n  event BlockProducerSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated.\n  event BridgeOperatorSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] bridgeOperators);\n\n  /// @dev Emitted when the reward of the block producer is deprecated.\n  event BlockRewardDeprecated(\n    address indexed coinbaseAddr,\n    uint256 rewardAmount,\n    BlockRewardDeprecatedType deprecatedType\n  );\n  /// @dev Emitted when the block reward is submitted.\n  event BlockRewardSubmitted(address indexed coinbaseAddr, uint256 submittedAmount, uint256 bonusAmount);\n\n  /// @dev Emitted when the block producer reward is distributed.\n  event MiningRewardDistributed(address indexed consensusAddr, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the block producer reward.\n  event MiningRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the bridge operator reward is distributed.\n  event BridgeOperatorRewardDistributed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipientAddr,\n    uint256 amount\n  );\n  /// @dev Emitted when the contract fails when distributing the bridge operator reward.\n  event BridgeOperatorRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the fast finality reward is distributed.\n  event FastFinalityRewardDistributed(address indexed consensusAddr, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the fast finality reward.\n  event FastFinalityRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the amount of RON reward is distributed to staking contract.\n  event StakingRewardDistributed(uint256 totalAmount, address[] consensusAddrs, uint256[] amounts);\n  /// @dev Emitted when the contracts fails when distributing the amount of RON to the staking contract.\n  event StakingRewardDistributionFailed(\n    uint256 totalAmount,\n    address[] consensusAddrs,\n    uint256[] amounts,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the epoch is wrapped up.\n  event WrappedUpEpoch(uint256 indexed periodNumber, uint256 indexed epochNumber, bool periodEnding);\n\n  /// @dev Error of only allowed at the end of epoch\n  error ErrAtEndOfEpochOnly();\n  /// @dev Error of query for already wrapped up epoch\n  error ErrAlreadyWrappedEpoch();\n\n  /**\n   * @dev Submits reward of the current block.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDeprecated` if the coinbase is slashed or no longer be a block producer.\n   * Emits the event `BlockRewardSubmitted` for the valid call.\n   *\n   */\n  function submitBlockReward() external payable;\n\n  /**\n   * @dev Wraps up the current epoch.\n   *\n   * Requirements:\n   * - The method must be called when the current epoch is ending.\n   * - The epoch is not wrapped yet.\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDistributed` when some validator has reward distributed.\n   * Emits the event `StakingRewardDistributed` when some staking pool has reward distributed.\n   * Emits the event `BlockProducerSetUpdated` when the epoch is wrapped up.\n   * Emits the event `BridgeOperatorSetUpdated` when the epoch is wrapped up at period ending.\n   * Emits the event `ValidatorSetUpdated` when the epoch is wrapped up at period ending, and the validator set gets updated.\n   * Emits the event `WrappedUpEpoch`.\n   *\n   */\n  function wrapUpEpoch() external payable;\n}\n"
    },
    "contracts/interfaces/validator/IEmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IEmergencyExit {\n  /// @dev Emitted when the fund is locked from an emergency exit request\n  event EmergencyExitRequested(address indexed consensusAddr, uint256 lockedAmount);\n  /// @dev Emitted when the fund that locked from an emergency exit request is transferred to the recipient.\n  event EmergencyExitLockedFundReleased(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount\n  );\n  /// @dev Emitted when the fund that locked from an emergency exit request is failed to transferred back.\n  event EmergencyExitLockedFundReleasingFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the emergency exit locked amount is updated.\n  event EmergencyExitLockedAmountUpdated(uint256 amount);\n  /// @dev Emitted when the emergency expiry duration is updated.\n  event EmergencyExpiryDurationUpdated(uint256 amount);\n\n  /// @dev Error of already requested emergency exit before.\n  error ErrAlreadyRequestedEmergencyExit();\n  /// @dev Error thrown when the info of releasing locked fund not exist.\n  error ErrLockedFundReleaseInfoNotFound(address cid);\n  /// @dev Error thrown when the the locked fund of emergency exit might be recycled.\n  error ErrLockedFundMightBeRecycled(address cid);\n\n  /**\n   * @dev Returns the amount of RON to lock from a consensus address.\n   */\n  function emergencyExitLockedAmount() external returns (uint256);\n\n  /**\n   * @dev Returns the duration that an emergency request is expired and the fund will be recycled.\n   */\n  function emergencyExpiryDuration() external returns (uint256);\n\n  /**\n   * @dev Sets the amount of RON to lock from a consensus address.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedAmountUpdated`.\n   *\n   */\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external;\n\n  /**\n   * @dev Sets the duration that an emergency request is expired and the fund will be recycled.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExpiryDurationUpdated`.\n   *\n   */\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external;\n\n  /**\n   * @dev Unlocks fund for emergency exit request.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedFundReleased` if the fund is successfully unlocked.\n   * Emits the event `EmergencyExitLockedFundReleasingFailed` if the fund is failed to unlock.\n   *\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(address validatorId, address payable recipient) external;\n\n  /**\n   * @dev Fallback function of `IStaking-requestEmergencyExit`.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   */\n  function execRequestEmergencyExit(address validatorId, uint256 secLeftToRevoke) external;\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ICommonInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IJailingInfo.sol\";\nimport \"./ITimingInfo.sol\";\nimport \"./IValidatorInfoV2.sol\";\n\ninterface ICommonInfo is ITimingInfo, IJailingInfo, IValidatorInfoV2 {\n  struct EmergencyExitInfo {\n    uint256 lockedAmount;\n    // The timestamp that this locked amount will be recycled to staking vesting contract\n    uint256 recyclingAt;\n  }\n\n  /// @dev Emitted when the deprecated reward is withdrawn.\n  event DeprecatedRewardRecycled(address indexed recipientAddr, uint256 amount);\n  /// @dev Emitted when the deprecated reward withdrawal is failed\n  event DeprecatedRewardRecycleFailed(address indexed recipientAddr, uint256 amount, uint256 balance);\n\n  /// @dev Error thrown when receives RON from neither staking vesting contract nor staking contract\n  error ErrUnauthorizedReceiveRON();\n  /// @dev Error thrown when queries for a non existent info.\n  error NonExistentRecyclingInfo();\n\n  /**\n   * @dev Returns the total deprecated reward, which includes reward that is not sent for slashed validators and unsastified bridge operators\n   */\n  function totalDeprecatedReward() external view returns (uint256);\n\n  /**\n   * @dev Returns the emergency exit request.\n   */\n  function getEmergencyExitInfo(TConsensus consensus) external view returns (EmergencyExitInfo memory);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IJailingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../udvts/Types.sol\";\n\ninterface IJailingInfo {\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkJailed(TConsensus) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeft(\n    TConsensus addr\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) at a specific block.\n   */\n  function checkJailedAtBlock(TConsensus addr, uint256 blockNum) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail at a specific block and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeftAtBlock(\n    TConsensus addr,\n    uint256 blockNum\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validators are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkManyJailed(TConsensus[] calldata) external view returns (bool[] memory);\n\n  function checkManyJailedById(address[] calldata candidateIds) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during the current period.\n   */\n  function checkMiningRewardDeprecated(TConsensus addr) external view returns (bool);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during a specific period.\n   */\n  function checkMiningRewardDeprecatedAtPeriod(TConsensus addr, uint256 period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ITimingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ITimingInfo {\n  /**\n   * @dev Returns the block that validator set was updated.\n   */\n  function getLastUpdatedBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of blocks in a epoch.\n   */\n  function numberOfBlocksInEpoch() external view returns (uint256 _numberOfBlocks);\n\n  /**\n   * @dev Returns the epoch index from the block number.\n   */\n  function epochOf(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Returns whether the epoch ending is at the block number `_block`.\n   */\n  function epochEndingAt(uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Tries to get the period index from the epoch number.\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber);\n\n  /**\n   * @dev Returns whether the period ending at the current block number.\n   */\n  function isPeriodEnding() external view returns (bool);\n\n  /**\n   * @dev Returns the period index from the current block.\n   */\n  function currentPeriod() external view returns (uint256);\n\n  /**\n   * @dev Returns the block number that the current period starts at.\n   */\n  function currentPeriodStartAtBlock() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IValidatorInfoV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\nimport { TConsensus } from \"../../../udvts/Types.sol\";\n\ninterface IValidatorInfoV2 {\n  /// @dev Error thrown when an invalid maximum prioritized validator number is provided.\n  error ErrInvalidMaxPrioritizedValidatorNumber();\n  /// @dev Emitted when the number of max validator is updated.\n  event MaxValidatorNumberUpdated(uint256);\n  /// @dev Emitted when the number of reserved slots for prioritized validators is updated.\n  event MaxPrioritizedValidatorNumberUpdated(uint256);\n\n  /**\n   * @dev Returns the maximum number of validators in the epoch.\n   */\n  function maxValidatorNumber() external view returns (uint256 _maximumValidatorNumber);\n\n  /**\n   * @dev Returns the number of reserved slots for prioritized validators.\n   */\n  function maxPrioritizedValidatorNumber() external view returns (uint256 _maximumPrioritizedValidatorNumber);\n\n  /**\n   * @dev Returns the current validator list.\n   */\n  function getValidators() external view returns (address[] memory _validatorList);\n\n  /**\n   * @dev Returns the current block producer list.\n   */\n  function getBlockProducers() external view returns (address[] memory);\n\n  /**\n   * @dev Returns whether the address is block producer or not.\n   */\n  function isBlockProducer(TConsensus consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns total numbers of the block producers.\n   */\n  function totalBlockProducer() external view returns (uint256);\n\n  /**\n   * @dev Updates the max validator number\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxValidatorNumberUpdated`\n   *\n   */\n  function setMaxValidatorNumber(uint256 _maxValidatorNumber) external;\n\n  /**\n   * @dev Updates the number of reserved slots for prioritized validators\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxPrioritizedValidatorNumberUpdated`\n   *\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _maxPrioritizedValidatorNumber) external;\n}\n"
    },
    "contracts/interfaces/validator/IRoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ICandidateManager.sol\";\nimport \"./ICandidateManagerCallback.sol\";\nimport \"./info-fragments/ICommonInfo.sol\";\nimport \"./ICoinbaseExecution.sol\";\nimport \"./ISlashingExecution.sol\";\nimport \"./IEmergencyExit.sol\";\n\ninterface IRoninValidatorSet is\n  ICandidateManagerCallback,\n  ICandidateManager,\n  ICommonInfo,\n  ISlashingExecution,\n  ICoinbaseExecution,\n  IEmergencyExit\n{}\n"
    },
    "contracts/interfaces/validator/ISlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISlashingExecution {\n  /// @dev Emitted when the validator is punished.\n  event ValidatorPunished(\n    address indexed cid,\n    uint256 indexed period,\n    uint256 jailedUntil,\n    uint256 deductedStakingAmount,\n    bool blockProducerRewardDeprecated,\n    bool bridgeOperatorRewardDeprecated\n  );\n  /// @dev Emitted when the validator get out of jail by bailout.\n  event ValidatorUnjailed(address indexed cid, uint256 period);\n\n  /// @dev Error of cannot bailout due to high tier slash.\n  error ErrCannotBailout(address validator);\n\n  /**\n   * @dev Finalize the slash request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorPunished`.\n   *\n   */\n  function execSlash(address cid, uint256 newJailedUntil, uint256 slashAmount, bool cannotBailout) external;\n\n  /**\n   * @dev Finalize the bailout request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorUnjailed`.\n   *\n   */\n  function execBailOut(address cid, uint256 period) external;\n}\n"
    },
    "contracts/libraries/AddressArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary AddressArrayUtils {\n  /**\n   * @dev Error thrown when a duplicated element is detected in an array.\n   * @param msgSig The function signature that invoke the error.\n   */\n  error ErrDuplicated(bytes4 msgSig);\n\n  /**\n   * @dev Returns whether or not there's a duplicate. Runs in O(n^2).\n   * @param A Array to search\n   * @return Returns true if duplicate, false otherwise\n   */\n  function hasDuplicate(address[] memory A) internal pure returns (bool) {\n    if (A.length == 0) {\n      return false;\n    }\n    unchecked {\n      for (uint256 i = 0; i < A.length - 1; i++) {\n        for (uint256 j = i + 1; j < A.length; j++) {\n          if (A[i] == A[j]) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @dev Returns whether two arrays of addresses are equal or not.\n   */\n  function isEqual(address[] memory _this, address[] memory _other) internal pure returns (bool yes_) {\n    // Hashing two arrays and compare their hash\n    assembly {\n      let _thisHash := keccak256(add(_this, 32), mul(mload(_this), 32))\n      let _otherHash := keccak256(add(_other, 32), mul(mload(_other), 32))\n      yes_ := eq(_thisHash, _otherHash)\n    }\n  }\n\n  /**\n   * @dev Return the concatenated array from a and b.\n   */\n  function extend(address[] memory a, address[] memory b) internal pure returns (address[] memory c) {\n    uint256 lengthA = a.length;\n    uint256 lengthB = b.length;\n    unchecked {\n      c = new address[](lengthA + lengthB);\n    }\n    uint256 i;\n    for (; i < lengthA; ) {\n      c[i] = a[i];\n      unchecked {\n        ++i;\n      }\n    }\n    for (uint256 j; j < lengthB; ) {\n      c[i] = b[j];\n      unchecked {\n        ++i;\n        ++j;\n      }\n    }\n  }\n}\n"
    },
    "contracts/libraries/EnumFlags.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This library implements checking flag of an enumerated value.\n * The originated idea is inherited from [Enum.HashFlag(Enum)](https://learn.microsoft.com/en-us/dotnet/api/system.enum.hasflag?view=net-6.0) method of C#.\n */\nlibrary EnumFlags {\n  enum ValidatorFlag {\n    None, // bit(00)\n    BlockProducer, // bit(01)\n    DeprecatedBridgeOperator, // bit(10)\n    Both // bit(11)\n  }\n\n  function isNone(ValidatorFlag _value) internal pure returns (bool) {\n    return uint8(_value) == 0;\n  }\n\n  /**\n   * @dev Checks if `_value` has `_flag`.\n   */\n  function hasFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (bool) {\n    return (uint8(_value) & uint8(_flag)) != 0;\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after adding `_flag`.\n   */\n  function addFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) | uint8(_flag));\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after remove `_flag`.\n   */\n  function removeFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) & ~uint8(_flag));\n  }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary Math {\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns whether the number `c` is in range of [a; b].\n   */\n  function inRange(uint256 c, uint256 a, uint256 b) internal pure returns (bool) {\n    return a <= c && c <= b;\n  }\n\n  /**\n   * @dev Returns whether two inclusive ranges [x1;x2] and [y1;y2] overlap.\n   */\n  function twoRangeOverlap(uint256 x1, uint256 x2, uint256 y1, uint256 y2) internal pure returns (bool) {\n    return x1 <= y2 && y1 <= x2;\n  }\n\n  /**\n   * @dev Returns value of a + b; in case result is larger than upperbound, upperbound is returned.\n   */\n  function addWithUpperbound(uint256 a, uint256 b, uint256 upperbound) internal pure returns (uint256) {\n    return min(a + b, upperbound);\n  }\n\n  /**\n   * @dev Returns value of a - b; in case of negative result, 0 is returned.\n   */\n  function subNonNegative(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a - b : 0;\n  }\n\n  /**\n   * @dev Returns value of `a + zeroable` if zerobale is not 0; otherwise, return 0.\n   */\n  function addIfNonZero(uint256 a, uint256 zeroable) internal pure returns (uint256) {\n    return zeroable != 0 ? a + zeroable : 0;\n  }\n}\n"
    },
    "contracts/mocks/libraries/Sorting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary Sorting {\n  struct Node {\n    uint key;\n    uint value;\n  }\n\n  struct Node3 {\n    uint key;\n    uint value;\n    uint otherKey;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                   VALUE SORTING                                   //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sort(uint[] memory data) internal pure returns (uint[] memory) {\n    return _quickSort(data, int(0), int(data.length - 1));\n  }\n\n  function _quickSort(uint[] memory arr, int left, int right) private pure returns (uint[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return arr;\n    uint pivot = arr[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (arr[uint(i)] > pivot) i++;\n      while (pivot > arr[uint(j)]) j--;\n      if (i <= j) {\n        (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) arr = _quickSort(arr, left, j);\n    if (i < right) arr = _quickSort(arr, i, right);\n\n    return arr;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                   NODE SORTING                                    //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sort(address[] memory _keys, uint256[] memory _values) internal pure returns (address[] memory) {\n    require(_values.length == _keys.length, \"Sorting: invalid array length\");\n    if (_keys.length == 0) {\n      return _keys;\n    }\n\n    Node[] memory _nodes = new Node[](_keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node(uint256(uint160(_keys[_i])), _values[_i]);\n    }\n    _quickSortNodes(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _keys[_i] = address(uint160(_nodes[_i].key)); // Casting?\n    }\n\n    return _keys;\n  }\n\n  function sort(uint256[] memory keys, uint256[] memory values) internal pure returns (uint256[] memory) {\n    require(values.length == keys.length, \"Sorting: invalid array length\");\n    if (keys.length == 0) {\n      return keys;\n    }\n\n    Node[] memory _nodes = new Node[](keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node(keys[_i], values[_i]);\n    }\n    _quickSortNodes(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      keys[_i] = _nodes[_i].key; // Casting?\n    }\n\n    return keys;\n  }\n\n  function sortNodes(Node[] memory nodes) internal pure returns (Node[] memory) {\n    return _quickSortNodes(nodes, int(0), int(nodes.length - 1));\n  }\n\n  function _quickSortNodes(Node[] memory nodes, int left, int right) private pure returns (Node[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return nodes;\n    Node memory pivot = nodes[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (nodes[uint(i)].value > pivot.value) i++;\n      while (pivot.value > nodes[uint(j)].value) j--;\n      if (i <= j) {\n        (nodes[uint(i)], nodes[uint(j)]) = __swapNodes(nodes[uint(i)], nodes[uint(j)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) nodes = _quickSortNodes(nodes, left, j);\n    if (i < right) nodes = _quickSortNodes(nodes, i, right);\n\n    return nodes;\n  }\n\n  function _bubbleSortNodes(Node[] memory nodes) private pure returns (Node[] memory) {\n    uint length = nodes.length;\n    for (uint i = 0; i < length - 1; i++) {\n      for (uint j = i + 1; j < length; j++) {\n        if (nodes[j].value > nodes[i].value) {\n          (nodes[i], nodes[j]) = __swapNodes(nodes[i], nodes[j]);\n        }\n      }\n    }\n    return nodes;\n  }\n\n  function __swapNodes(Node memory x, Node memory y) private pure returns (Node memory, Node memory) {\n    Node memory tmp = x;\n    (x, y) = (y, tmp);\n    return (x, y);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                  NODE3 SORTING                                    //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sortWithExternalKeys(\n    address[] memory _keys,\n    uint256[] memory _values,\n    uint256[] memory _otherKeys\n  ) internal pure returns (address[] memory keys_, uint256[] memory otherKeys_) {\n    require((_values.length == _keys.length) && (_otherKeys.length == _keys.length), \"Sorting: invalid array length\");\n    if (_keys.length == 0) {\n      return (_keys, _otherKeys);\n    }\n\n    Node3[] memory _nodes = new Node3[](_keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node3(uint256(uint160(_keys[_i])), _values[_i], _otherKeys[_i]);\n    }\n    _quickSortNode3s(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _keys[_i] = address(uint160(_nodes[_i].key)); // Casting?\n    }\n\n    return (_keys, _otherKeys);\n  }\n\n  function sortNode3s(Node3[] memory nodes) internal pure returns (Node3[] memory) {\n    return _quickSortNode3s(nodes, int(0), int(nodes.length - 1));\n  }\n\n  function _quickSortNode3s(Node3[] memory nodes, int left, int right) private pure returns (Node3[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return nodes;\n    Node3 memory pivot = nodes[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (nodes[uint(i)].value > pivot.value) i++;\n      while (pivot.value > nodes[uint(j)].value) j--;\n      if (i <= j) {\n        (nodes[uint(i)], nodes[uint(j)]) = __swapNode3s(nodes[uint(i)], nodes[uint(j)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) nodes = _quickSortNode3s(nodes, left, j);\n    if (i < right) nodes = _quickSortNode3s(nodes, i, right);\n\n    return nodes;\n  }\n\n  function _bubbleSortNode3s(Node3[] memory nodes) private pure returns (Node3[] memory) {\n    uint length = nodes.length;\n    for (uint i = 0; i < length - 1; i++) {\n      for (uint j = i + 1; j < length; j++) {\n        if (nodes[j].value > nodes[i].value) {\n          (nodes[i], nodes[j]) = __swapNode3s(nodes[i], nodes[j]);\n        }\n      }\n    }\n    return nodes;\n  }\n\n  function __swapNode3s(Node3 memory x, Node3 memory y) private pure returns (Node3 memory, Node3 memory) {\n    Node3 memory tmp = x;\n    (x, y) = (y, tmp);\n    return (x, y);\n  }\n}\n"
    },
    "contracts/mocks/MockPrecompile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./libraries/Sorting.sol\";\nimport \"../libraries/Math.sol\";\n\ncontract MockPrecompile {\n  function sortValidators(\n    address[] memory _validators,\n    uint256[] memory _weights\n  ) public pure returns (address[] memory) {\n    return Sorting.sort(_validators, _weights);\n  }\n\n  function validatingDoubleSignProof(\n    address /*consensusAddr*/,\n    bytes calldata /*_header1*/,\n    bytes calldata /*_header2*/\n  ) public pure returns (bool _validEvidence) {\n    return true;\n  }\n\n  function validateFinalityVoteProof(\n    bytes calldata,\n    uint256,\n    bytes32[2] calldata,\n    bytes[][2] calldata,\n    bytes[2] calldata\n  ) public pure returns (bool) {\n    return true;\n  }\n\n  function pickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) public pure returns (address[] memory _result) {\n    (_result, _trustedWeights) = Sorting.sortWithExternalKeys(_candidates, _weights, _trustedWeights);\n    uint256 _newValidatorCount = Math.min(_maxValidatorNumber, _result.length);\n    _arrangeValidatorCandidates(_result, _trustedWeights, _newValidatorCount, _maxPrioritizedValidatorNumber);\n  }\n\n  /**\n   * @dev Arranges the sorted candidates to list of validators, by asserting prioritized and non-prioritized candidates\n   *\n   * @param _candidates A sorted list of candidates\n   */\n  function _arrangeValidatorCandidates(\n    address[] memory _candidates,\n    uint256[] memory _trustedWeights,\n    uint _newValidatorCount,\n    uint _maxPrioritizedValidatorNumber\n  ) internal pure {\n    address[] memory _waitingCandidates = new address[](_candidates.length);\n    uint _waitingCounter;\n    uint _prioritySlotCounter;\n\n    for (uint _i = 0; _i < _candidates.length; _i++) {\n      if (_trustedWeights[_i] > 0 && _prioritySlotCounter < _maxPrioritizedValidatorNumber) {\n        _candidates[_prioritySlotCounter++] = _candidates[_i];\n        continue;\n      }\n      _waitingCandidates[_waitingCounter++] = _candidates[_i];\n    }\n\n    _waitingCounter = 0;\n    for (uint _i = _prioritySlotCounter; _i < _newValidatorCount; _i++) {\n      _candidates[_i] = _waitingCandidates[_waitingCounter++];\n    }\n\n    assembly {\n      mstore(_candidates, _newValidatorCount)\n    }\n  }\n}\n"
    },
    "contracts/mocks/MockSlashIndicatorExtended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./MockPrecompile.sol\";\nimport \"../ronin/slash-indicator/SlashIndicator.sol\";\nimport \"../interfaces/validator/IRoninValidatorSet.sol\";\n\ncontract MockSlashIndicatorExtended is SlashIndicator, MockPrecompile {\n  function slashFelony(address _validatorAddr) external {\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execSlash(_validatorAddr, 0, 0, false);\n  }\n\n  function slashMisdemeanor(address _validatorAddr) external {\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execSlash(_validatorAddr, 0, 0, false);\n  }\n\n  function _pcValidateEvidence(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) internal pure override returns (bool _validEvidence) {\n    return validatingDoubleSignProof(_consensusAddr, _header1, _header2);\n  }\n}\n"
    },
    "contracts/multi-chains/RoninTrustedOrganization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../libraries/AddressArrayUtils.sol\";\nimport \"../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../interfaces/IProfile.sol\";\nimport \"../extensions/collections/HasProxyAdmin.sol\";\nimport \"../extensions/collections/HasContracts.sol\";\nimport \"../udvts/Types.sol\";\n\ncontract RoninTrustedOrganization is IRoninTrustedOrganization, HasProxyAdmin, HasContracts, Initializable {\n  uint256 internal _num;\n  uint256 internal _denom;\n  uint256 internal _totalWeight;\n  uint256 internal _nonce;\n\n  /// @dev Mapping from consensus address => weight\n  mapping(TConsensus => uint256) internal _consensusWeight;\n  /// @dev Mapping from governor address => weight\n  mapping(address => uint256) internal _governorWeight;\n  /// @dev Mapping from bridge voter address => weight\n  mapping(address => uint256) internal __deprecatedBridgeVoterWeight;\n\n  /// @dev Mapping from consensus address => added block\n  mapping(TConsensus => uint256) internal _addedBlock;\n\n  /// @dev Consensus array\n  TConsensus[] internal _consensusList;\n  /// @dev Governors array\n  address[] internal _governorList;\n  /// @dev Bridge voters array\n  address[] internal __deprecatedBridgeVoterList;\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(TrustedOrganization[] calldata trustedOrgs, uint256 num, uint256 denom) external initializer {\n    if (trustedOrgs.length > 0) {\n      _addTrustedOrganizations(trustedOrgs);\n    }\n    _setThreshold(num, denom);\n  }\n\n  function initializeV2(address profileContract) external reinitializer(2) {\n    _setContract(ContractType.PROFILE, profileContract);\n    for (uint i; i < __deprecatedBridgeVoterList.length; ++i) {\n      delete __deprecatedBridgeVoterWeight[__deprecatedBridgeVoterList[i]];\n    }\n    delete __deprecatedBridgeVoterList;\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function getThreshold() external view virtual returns (uint256 num_, uint256 denom_) {\n    return (_num, _denom);\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function checkThreshold(uint256 _voteWeight) external view virtual returns (bool) {\n    return _voteWeight * _denom >= _num * _totalWeight;\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function minimumVoteWeight() external view virtual returns (uint256) {\n    return (_num * _totalWeight + _denom - 1) / _denom;\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function setThreshold(\n    uint256 _numerator,\n    uint256 _denominator\n  ) external override onlyAdmin returns (uint256, uint256) {\n    return _setThreshold(_numerator, _denominator);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function addTrustedOrganizations(TrustedOrganization[] calldata _list) external override onlyAdmin {\n    _addTrustedOrganizations(_list);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function updateTrustedOrganizations(TrustedOrganization[] calldata _list) external override onlyAdmin {\n    if (_list.length == 0) revert ErrEmptyArray();\n    for (uint256 _i; _i < _list.length; ) {\n      _updateTrustedOrganization(_list[_i]);\n\n      unchecked {\n        ++_i;\n      }\n    }\n    emit TrustedOrganizationsUpdated(_list);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function removeTrustedOrganizations(TConsensus[] calldata list) external override onlyAdmin {\n    if (list.length == 0) revert ErrEmptyArray();\n\n    for (uint _i = 0; _i < list.length; ) {\n      _removeTrustedOrganization(list[_i]);\n\n      unchecked {\n        ++_i;\n      }\n    }\n    emit TrustedOrganizationsRemoved(list);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function totalWeight() external view virtual returns (uint256) {\n    return _totalWeight;\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getConsensusWeight(TConsensus consensusAddr) external view returns (uint256) {\n    return _getConsensusWeightByConsensus(consensusAddr);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getConsensusWeightById(address cid) external view returns (uint256) {\n    return _getConsensusWeightByConsensus(__cid2css(cid));\n  }\n\n  function _getConsensusWeightByConsensus(TConsensus consensusAddr) internal view returns (uint256) {\n    return _consensusWeight[consensusAddr];\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getGovernorWeight(address _governor) external view returns (uint256) {\n    return _governorWeight[_governor];\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getConsensusWeights(TConsensus[] calldata list) external view returns (uint256[] memory) {\n    return _getManyConsensusWeightsByConsensus(list);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getConsensusWeightsById(address[] calldata cids) external view returns (uint256[] memory) {\n    TConsensus[] memory consensusList = __cid2cssBatch(cids);\n    return _getManyConsensusWeightsByConsensus(consensusList);\n  }\n\n  function _getManyConsensusWeightsByConsensus(TConsensus[] memory list) internal view returns (uint256[] memory res) {\n    res = new uint256[](list.length);\n    for (uint i = 0; i < res.length; ++i) {\n      res[i] = _getConsensusWeightByConsensus(list[i]);\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getGovernorWeights(address[] calldata _list) external view returns (uint256[] memory _res) {\n    _res = new uint256[](_list.length);\n    for (uint _i = 0; _i < _res.length; ) {\n      _res[_i] = _governorWeight[_list[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function sumConsensusWeight(TConsensus[] calldata _list) external view returns (uint256 _res) {\n    for (uint _i = 0; _i < _list.length; ) {\n      _res += _consensusWeight[_list[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function sumGovernorWeight(address[] calldata _list) external view returns (uint256 _res) {\n    for (uint _i = 0; _i < _list.length; ) {\n      _res += _governorWeight[_list[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function countTrustedOrganization() external view override returns (uint256) {\n    return _consensusList.length;\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getAllTrustedOrganizations() external view override returns (TrustedOrganization[] memory list) {\n    list = new TrustedOrganization[](_consensusList.length);\n    TConsensus consensus;\n    for (uint256 _i; _i < list.length; ) {\n      consensus = _consensusList[_i];\n      list[_i].consensusAddr = consensus;\n      list[_i].governor = _governorList[_i];\n      list[_i].__deprecatedBridgeVoter = address(0);\n      list[_i].weight = _consensusWeight[consensus];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getTrustedOrganization(TConsensus _consensusAddr) external view returns (TrustedOrganization memory) {\n    for (uint i = 0; i < _consensusList.length; ++i) {\n      if (_consensusList[i] == _consensusAddr) {\n        return getTrustedOrganizationAt(i);\n      }\n    }\n    revert ErrQueryForNonExistentConsensusAddress();\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getTrustedOrganizationAt(uint256 _idx) public view override returns (TrustedOrganization memory) {\n    TConsensus consensus = _consensusList[_idx];\n    return\n      TrustedOrganization(\n        consensus,\n        _governorList[_idx],\n        address(0),\n        _consensusWeight[consensus],\n        _addedBlock[consensus]\n      );\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function execChangeConsensusAddressForTrustedOrg(\n    TConsensus oldAddr,\n    TConsensus newAddr\n  ) external override onlyContract(ContractType.PROFILE) {\n    uint256 index = _findTrustedOrgIndexByConsensus(oldAddr);\n    _consensusList[index] = newAddr;\n    _consensusWeight[newAddr] = _consensusWeight[oldAddr];\n    _addedBlock[newAddr] = block.number;\n\n    _deleteConsensusInMappings(oldAddr);\n\n    emit ConsensusAddressOfTrustedOrgChanged(getTrustedOrganizationAt(index), oldAddr);\n  }\n\n  /**\n   * @dev Adds a list of trusted organizations.\n   */\n  function _addTrustedOrganizations(TrustedOrganization[] calldata _list) internal virtual {\n    for (uint256 _i; _i < _list.length; ) {\n      _addTrustedOrganization(_list[_i]);\n\n      unchecked {\n        ++_i;\n      }\n    }\n    emit TrustedOrganizationsAdded(_list);\n  }\n\n  /**\n   * @dev Adds a trusted organization.\n   *\n   * Requirements:\n   * - The weight is larger than 0.\n   * - The consensus address is not added.\n   * - The governor address is not added.\n   * - The bridge voter address is not added.\n   *\n   */\n  function _addTrustedOrganization(TrustedOrganization memory _v) internal virtual {\n    if (_v.addedBlock != 0) revert ErrInvalidRequest();\n    _sanityCheckTrustedOrganizationData(_v);\n\n    if (_consensusWeight[_v.consensusAddr] > 0) revert ErrConsensusAddressIsAlreadyAdded(_v.consensusAddr);\n\n    if (_governorWeight[_v.governor] > 0) revert ErrGovernorAddressIsAlreadyAdded(_v.governor);\n\n    _consensusList.push(_v.consensusAddr);\n    _consensusWeight[_v.consensusAddr] = _v.weight;\n\n    _governorList.push(_v.governor);\n    _governorWeight[_v.governor] = _v.weight;\n\n    _addedBlock[_v.consensusAddr] = block.number;\n\n    _totalWeight += _v.weight;\n  }\n\n  /**\n   * @dev Updates info of an existing trusted org.\n   * Replace the governor address if they are different, set all weights to the new weight.\n   *\n   * Requirements:\n   * - The weight is larger than 0.\n   * - The consensus address is already added.\n   *\n   */\n  function _updateTrustedOrganization(TrustedOrganization memory _v) internal virtual {\n    _sanityCheckTrustedOrganizationData(_v);\n\n    uint256 _weight = _consensusWeight[_v.consensusAddr];\n    if (_weight == 0) revert ErrConsensusAddressIsNotAdded(_v.consensusAddr);\n\n    uint256 _count = _consensusList.length;\n    for (uint256 _i = 0; _i < _count; ) {\n      if (_consensusList[_i] == _v.consensusAddr) {\n        _totalWeight -= _weight;\n        _totalWeight += _v.weight;\n\n        // Replace governor address\n        if (_governorList[_i] != _v.governor) {\n          if (_governorWeight[_v.governor] != 0) revert ErrQueryForDupplicated();\n\n          delete _governorWeight[_governorList[_i]];\n          _governorList[_i] = _v.governor;\n        }\n\n        // Add new weight for both consensus and governor address\n        _consensusWeight[_v.consensusAddr] = _v.weight;\n        _governorWeight[_v.governor] = _v.weight;\n        return;\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes a trusted organization by consensus address.\n   *\n   * Requirements:\n   * - The consensus address is added.\n   *\n   */\n  function _removeTrustedOrganization(TConsensus addr) internal virtual {\n    uint256 weight = _consensusWeight[addr];\n    if (weight == 0) revert ErrConsensusAddressIsNotAdded(addr);\n\n    uint256 index = _findTrustedOrgIndexByConsensus(addr);\n\n    _totalWeight -= weight;\n    _deleteConsensusInMappings(addr);\n\n    uint256 count = _consensusList.length;\n    _consensusList[index] = _consensusList[count - 1];\n    _consensusList.pop();\n\n    delete _governorWeight[_governorList[index]];\n    _governorList[index] = _governorList[count - 1];\n    _governorList.pop();\n  }\n\n  function _findTrustedOrgIndexByConsensus(TConsensus addr) private view returns (uint256 index) {\n    uint256 count = _consensusList.length;\n    for (uint256 i = 0; i < count; i++) {\n      if (_consensusList[i] == addr) {\n        return i;\n      }\n    }\n  }\n\n  function _deleteConsensusInMappings(TConsensus addr) private {\n    delete _addedBlock[addr];\n    delete _consensusWeight[addr];\n  }\n\n  /**\n   * @dev Sets threshold and returns the old one.\n   *\n   * Emits the `ThresholdUpdated` event.\n   *\n   */\n  function _setThreshold(\n    uint256 _numerator,\n    uint256 _denominator\n  ) internal virtual returns (uint256 _previousNum, uint256 _previousDenom) {\n    if (_numerator > _denominator) revert ErrInvalidThreshold(msg.sig);\n\n    _previousNum = _num;\n    _previousDenom = _denom;\n    _num = _numerator;\n    _denom = _denominator;\n    unchecked {\n      emit ThresholdUpdated(_nonce++, _numerator, _denominator, _previousNum, _previousDenom);\n    }\n  }\n\n  /**\n   * @dev Hook that checks trusted organization's data. Reverts if the requirements are not met.\n   *\n   * Requirements:\n   * - The weight must be larger than 0.\n   * - The consensus address, governor address, and bridge voter address are different.\n   */\n  function _sanityCheckTrustedOrganizationData(TrustedOrganization memory _v) private pure {\n    if (_v.weight == 0) revert ErrInvalidVoteWeight(msg.sig);\n\n    address[] memory _addresses = new address[](3);\n    _addresses[0] = TConsensus.unwrap(_v.consensusAddr);\n    _addresses[1] = _v.governor;\n    _addresses[2] = _v.__deprecatedBridgeVoter;\n\n    if (AddressArrayUtils.hasDuplicate(_addresses)) revert AddressArrayUtils.ErrDuplicated(msg.sig);\n  }\n\n  function __cid2css(address cid) internal view returns (TConsensus) {\n    return (IProfile(getContract(ContractType.PROFILE)).getId2Profile(cid)).consensus;\n  }\n\n  function __cid2cssBatch(address[] memory cids) internal view returns (TConsensus[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyId2Consensus(cids);\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUValidateDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUValidateDoubleSign is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of validating double sign evidence\n  function precompileValidateDoubleSignAddress() public view virtual returns (address) {\n    return address(0x67);\n  }\n\n  /**\n   * @dev Validates the two submitted block header if they are produced by the same address\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcValidateEvidence(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) internal view virtual returns (bool _validEvidence) {\n    address _smc = precompileValidateDoubleSignAddress();\n    bool _success = true;\n\n    bytes memory _payload = abi.encodeWithSignature(\n      \"validatingDoubleSignProof(address,bytes,bytes)\",\n      _consensusAddr,\n      _header1,\n      _header2\n    );\n    uint _payloadLength = _payload.length;\n    uint[1] memory _output;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _output, 0x20)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n    return (_output[0] != 0);\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUValidateFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUValidateFastFinality is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of validating double sign evidence\n  function precompileValidateFastFinalityAddress() public view virtual returns (address) {\n    return address(0x69);\n  }\n\n  /**\n   * @dev Validates the proof of malicious voting on fast finality\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcValidateFastFinalityEvidence(\n    bytes memory voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] memory targetBlockHash,\n    bytes[][2] memory listOfPublicKey,\n    bytes[2] memory aggregatedSignature\n  ) internal view virtual returns (bool validEvidence) {\n    address smc = precompileValidateFastFinalityAddress();\n    bool success = true;\n\n    bytes memory payload = abi.encodeWithSignature(\n      \"validateFinalityVoteProof(bytes,uint256,bytes32[2],bytes[][2],bytes[2])\",\n      voterPublicKey,\n      targetBlockNumber,\n      targetBlockHash,\n      listOfPublicKey,\n      aggregatedSignature\n    );\n    uint payloadLength = payload.length;\n    uint[1] memory output;\n\n    assembly {\n      let payloadStart := add(payload, 0x20)\n      if iszero(staticcall(gas(), smc, payloadStart, payloadLength, output, 0x20)) {\n        success := 0\n      }\n\n      if iszero(returndatasize()) {\n        success := 0\n      }\n    }\n\n    if (!success) revert ErrCallPrecompiled();\n    return (output[0] != 0);\n  }\n}\n"
    },
    "contracts/precompile-usages/PrecompiledUsage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PrecompiledUsage {\n  /// @dev Error of call to precompile fails.\n  error ErrCallPrecompiled();\n}\n"
    },
    "contracts/ronin/profile/Profile_Mainnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"./Profile.sol\";\n\npragma solidity ^0.8.9;\n\ncontract Profile_Mainnet is Profile {\n  function __migrationRenouncedCandidates() internal override onlyInitializing {\n    if (block.chainid != 2020) return;\n\n    CandidateProfile storage _profile;\n\n    address[4] memory lConsensus = __consensuses();\n    address[4] memory lAdmin = __admins();\n    address[4] memory lTreasury = __treasuries();\n\n    for (uint i; i < lConsensus.length; ++i) {\n      address id = lConsensus[i];\n\n      _profile = _id2Profile[id];\n      _profile.id = id;\n      _setConsensus(_profile, TConsensus.wrap(id));\n      _setAdmin(_profile, lAdmin[i]);\n      _setTreasury(_profile, payable(lTreasury[i]));\n    }\n  }\n\n  function __admins() private pure returns (address[4] memory list) {\n    return [\n      0xdb3b1F69259f88Ce9d58f3738e15e3CC1B5A8563,\n      0x335fE9EF827a9F27CBAb819b31e5eE182c2081d7,\n      0xbCcB3FDa2B9e3Ab5b824AA9D5c1C4A62A98Da937,\n      0x9bc1946f1Aa6DA4667a6Ee966e66b9ec60637E10\n    ];\n  }\n\n  function __consensuses() private pure returns (address[4] memory list) {\n    return [\n      0x07d28F88D677C4056EA6722aa35d92903b2a63da,\n      0x262B9fcfe8CFA900aF4D1f5c20396E969B9655DD,\n      0x20238eB5643d4D7b7Ab3C30f3bf7B8E2B85cA1e7,\n      0x03A7B98C226225e330d11D1B9177891391Fa4f80\n    ];\n  }\n\n  function __treasuries() private pure returns (address[4] memory list) {\n    return [\n      0xdb3b1F69259f88Ce9d58f3738e15e3CC1B5A8563,\n      0x335fE9EF827a9F27CBAb819b31e5eE182c2081d7,\n      0xbCcB3FDa2B9e3Ab5b824AA9D5c1C4A62A98Da937,\n      0x9bc1946f1Aa6DA4667a6Ee966e66b9ec60637E10\n    ];\n  }\n}\n"
    },
    "contracts/ronin/profile/Profile_Testnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"./Profile.sol\";\n\npragma solidity ^0.8.9;\n\ncontract Profile_Testnet is Profile {\n  function __migrationRenouncedCandidates() internal override onlyInitializing {\n    if (block.chainid != 2021) return;\n\n    CandidateProfile storage _profile;\n\n    address[74] memory lConsensus = __consensuses();\n    address[74] memory lAdmin = __admins();\n    address[74] memory lTreasury = __treasuries();\n\n    for (uint i; i < lConsensus.length; ++i) {\n      address id = lConsensus[i];\n\n      _profile = _id2Profile[id];\n      _profile.id = id;\n      _setConsensus(_profile, TConsensus.wrap(id));\n      _setAdmin(_profile, lAdmin[i]);\n      _setTreasury(_profile, payable(lTreasury[i]));\n    }\n  }\n\n  function __admins() private pure returns (address[74] memory list) {\n    return [\n      0xD682DC6D64710D6191512133dE957e146e9AA58f,\n      0xEFeaFf1d9f1E4EDB00c6084aE4016143B29Ed924,\n      0xC2caE7311FC0fe400A838d2dDe06A89E1d3e9Da7,\n      0xf90a912Fdb7Fd37572cD83325392d729e60Ef682,\n      0xAfB9554299491a34d303f2C5A91bebB162f6B2Cf,\n      0x8dA9d88F90141a03292d5e554691B1F6e7c6212c,\n      0xA87F9A2F0C7082FA2f1E3de1090D36047C7cD017,\n      0x6693dc258BDAAc5052ab678BA5de2440CA1cdAbe,\n      0x0B67dF5847aF7476B2EB46da328638E0fB2C6B29,\n      0xe91d1DCd0232BDa301379dE27bd0edE47Db3F750,\n      0xDc3de716C4430d598AC504c4685d69D0DcE1412F,\n      0x795CF28E5b71f1A50cC9E01077891C18D6587e53,\n      0xa3B3c71371331fD1901e316B67df2d16bF5535a0,\n      0x32Be208dE8A1595cC0ccf8E984CAB8759Ea1e5b2,\n      0x8136c74e94b08300d71Fa6C22087b821F73568c5,\n      0xda6c7342E90B77c5C77A8F7292765360099e30Ed,\n      0x95fC818CD7709fb6aD8920d0d14925010504876F,\n      0xe8E66b241414a40a3Db539eC7d864cD61938f817,\n      0xfD575770A68D5Af983b2A374981f604DdAD9D684,\n      0x9A54EDCb1D9a44e9f4235ea05c75B45b26679680,\n      0x6108570A29f500D6950fEbffC99ECB66a264A048,\n      0xdA071F710b0f82443866616E8a96069012A73ccf,\n      0x8A4ac64764238C71Ddf82F870BE6526e297Dc4Cd,\n      0x33f1727CaA54AE24CAdB2949881C3725eB61a100,\n      0x34DB532F09Ee1285DFEf26eD696c4eA25dcFce72,\n      0x302d51189FD89D7e72bcb26a65D16941d043F089,\n      0xFeb247F76E6F6C1Ec3455d04e6E3B694a577D57C,\n      0x05955d9e99f57E5574A1a9b73361DD14aEc8D641,\n      0xcf9F44dDB18a5538Efe2a2A28eF20300333f5a71,\n      0x779dCE1ddc28941Ec85bf2aE0dAC9F0f12836281,\n      0x0Bb270e5268a9E9a0742DdB027Fab7405Af56Fa7,\n      0x5b92Ea265597a7cf20C8dA56E6beb8485c1BA993,\n      0x0E3341Ae4Ed9dA65Fc30a7Fa6357e8B5Ac40b0A3,\n      0xf6fd5FcA4Bd769BA495B29B98dba5F2eCF4CEED3,\n      0x8d0a639BDD3b81dF264c4dB46476658858231510,\n      0xBB046932fEFCDD3Be4368444a1014F25DfEE83f2,\n      0x54e09bF04810f387347dA6D9687D6a37EC2aadC7,\n      0xDE5e1554e2bF5d0E54BafC74C932b8F2aD4e273F,\n      0xc68d0255e1b9C549C43c7181BD29684DC477edfc,\n      0x37920733DB9A5b45fC9CD5e3C80825bEfFC1a014,\n      0x7e9107480Bf92dd56c97118E20CdB3c1Ae9dD866,\n      0xC4F83A7b369070E32CEd4Bd6Fd647D19AEf828AC,\n      0x412D4d69122839FcCAd0180e9358d157C3876f3C,\n      0x355503B8E64205FDE9dBBAD269110991cf736a50,\n      0x306f23c32fdfC07850Bf242E8Ff59C5E79BFf812,\n      0x467c5425042C9D9f025265b72C93D73E0F2978C5,\n      0xEE992B0F5E9746fdb8e584Efa01AF79f6B1C0940,\n      0xBD6342c0009f55131b7a51f627CE8Cc87879DD66,\n      0x57018e929Eb6fe50355bF1BF9D1d39cA466b7Fa0,\n      0xAd4e3D2F85b4C095742B500751CEE5c4B8f65A5b,\n      0x89A6A074dB8BcD3Fd60626107eA2aE576693F7c5,\n      0xCB742186fA056444766fA7cc52a0479E8F6DEDEA,\n      0x60C8117901Ab35738fcFd7157D393207eFCe8055,\n      0xAD70AD152E27E0923C4f11C63490FCFD904A4C36,\n      0xd8b47b81648d9e81e50b8cA21EA81F2E1B6929BB,\n      0xeCB1374172970a613A1970370B3ddeAD8F844733,\n      0x0472dCa02318B532Fcb0B056661EE7fD2Adc8a20,\n      0xdd00ACc07F3F7AFa90B5a22cFd56c0808b6444dd,\n      0x4d3302c69fac489E2F7373bCB2f101d3B378c4Ce,\n      0xe7685E437F34De2D36eA2e9AB13E5Ab871711A2C,\n      0xAfB9554299491a34d303f2C5A91bebB162f6B2Cf,\n      0x3F9Df0717099BAaA95A14B3CAA285DAdDAFb0609,\n      0x23Dffc4a93c374A91Fbc1c33075af012b68663F7,\n      0x79eC4d83D40c1Bd1419D8f561BE851FDa1EA32a6,\n      0x2D3f28780bFb7Ed6FB5547c309E1a6837e5bD12B,\n      0xa164e8B5F90ce42B0F531E3882cdE3F698e1121f,\n      0x4a4bc674A97737376cFE990aE2fE0d2B6E738393,\n      0xF61806B65278fFDbF8b04f832C59b65076798Fb6,\n      0x836eeEdd931575CCE4285c74C15DBdA9Edc3Dc4F,\n      0xbd95B0581585E4151793b183ee75d509fDE528B6,\n      0xA75B1Ce2f8C447caB6c13F313dfd806287aA47e2,\n      0x4D546475321b4cA2a91B101f26750092C05350cF,\n      0xFC2d29Da710F45168DE11e5C051CaA558088D52a,\n      0x1C70B8160E92D56E550caf02e1f2e5EC0Fdb551A\n    ];\n  }\n\n  function __consensuses() private pure returns (address[74] memory list) {\n    return [\n      0xD682dc6D64710D6191512133De957e146e9Aa58e,\n      0xEFeaFf1d9f1e4eDB00C6084ae4016143B29eD925,\n      0x57b572A9de68Bd29074e1C51c790Fc45C592ba39,\n      0xC0C2A56F9606bA109d37A0d18AF8E5bAA1e1C0aD,\n      0xaFB9554299491a34d303F2C5A91bebb162f6b2C1,\n      0x533f61B360e81f58919faB5C653724F71faf12ab,\n      0xa87F9A2F0C7082FA2f1E3De1090d36047c7cD018,\n      0x6693Dc258bDAaC5052aB678Ba5de2440ca1cDAb2,\n      0x96f78323481fc9abdb8Cc4D8aa50C1500AC93b92,\n      0xe91D1DcD0232BDa301379de27BD0edE47Db3f751,\n      0x981676e5E5164524e70f79AC45b52099EbDA8781,\n      0x795cf28e5B71f1A50cc9E01077891C18D6587E54,\n      0xa3b3C71371331fD1901e316B67DF2d16Bf5535A1,\n      0x32be208de8A1595cC0CcF8E984Cab8759Ea1e5b9,\n      0x2dc14d542B5478f206B296AcbCBfBCCEE6E8D248,\n      0xDA6C7342E90B77c5c77a8F7292765360099E30EE,\n      0x9D7EA2223e89A55a4ef69Ca993eae6FDE6E63371,\n      0xe8e66b241414a40a3db539EC7d864cD61938f818,\n      0x8fFF45d4a6A27F8256dF19D0DaDF7787CfbE56AA,\n      0x9a54EdCb1D9a44e9F4235EA05C75B45B26679681,\n      0x6108570A29F500D6950FEbFFc99eCB66a264a049,\n      0xDA071f710B0f82443866616E8a96069012A73cCE,\n      0x5f7f2AE316ec5C092d201744fe8337353ADB2BB3,\n      0x771DEc03db66a566a1DfE3fd635B3f8D404b9291,\n      0x71f9154ADc0bef39Bbe8dB1D060E6F239D2E10AE,\n      0x95908d03bA55c2a44688330b59E746Fdb2f17E3E,\n      0x3DB3abc65F203788836C8D50F6923C56f3f0FF7c,\n      0x05955D9e99f57E5574a1A9B73361Dd14aEC8D642,\n      0x283b4Baa1d0415603C81edc1C68FadD3C790837C,\n      0x2A5EB3f9CD4D6Ef49dc2a30041e4421af3303929,\n      0x3B9F2587d55E96276B09b258ac909D809961F6C2,\n      0x2576e6BC92A493F4DA6335C5E69BC0c272381C3A,\n      0x0E3341Ae4Ed9dA65Fc30a7Fa6357e8B5Ac40b0A3,\n      0xf6fd5FcA4Bd769BA495B29B98dba5F2eCF4CEED3,\n      0xd9299FA321407a5d10c73d71C57Ca687A2A38Af6,\n      0x877eFEfFE7A23E42C39e2C99b977e4AA4BEC7517,\n      0x071b510C415d3f84C6F4C6291C49887cC56cac41,\n      0xDE5e1554e2bF5d0e54bAFC74c932b8f2Ad4E2730,\n      0xc68d0255E1b9C549C43C7181bd29684DC477eDf0,\n      0xC3fB7b95b874bfcBD1E722A2061f3adf217121d3,\n      0x36Fd0d4A075507a4E742631aA37DAD46a1F4c0da,\n      0x661549d7717C20ffa62AD359B7667Bbf5c82053B,\n      0x412d4d69122839fcCAd0180e9358D157C3876F3D,\n      0x355503B8E64205FDE9dBbAd269110991CF736a51,\n      0x12Cf444bf83Ed5B610d0089927EcD3baBC81Ff88,\n      0x467C5425042c9d9f025265b72c93D73e0f2978C6,\n      0xB6bc5bc0410773A3F86B1537ce7495C52e38f88B,\n      0xBd6342C0009f55131b7A51F627ce8Cc87879dD67,\n      0x35C78DefBd03E96b4E3eE6a73e9CD4C49d2b885a,\n      0xAD4e3d2f85b4C095742B500751CeE5C4b8F65A5C,\n      0x42c535deCcc071D9039b177Cb3AbF30411531b05,\n      0xb212F24D850a0Ed90F2889dee31870E7FF3fED6c,\n      0x60C8117901AB35738FcfD7157D393207Efce8056,\n      0x30b0215a442Ea3D3088Acd83cD5Fe2aA2bcd775A,\n      0xD21BeCe2D8206A3fFdBAeDb827f4D4bD0FF79e3d,\n      0x4EfA5C5Bbe7a257743335F200E86cD44eEa4dcD9,\n      0x0472dcA02318B532fcB0B056661ee7Fd2aDc8A21,\n      0xDD00ACc07f3f7Afa90B5A22CFd56c0808b6444Df,\n      0x4d3302c69fAc489E2f7373bCB2f101d3b378C4cF,\n      0x8c29604e1caE4af683c4fBdAD951F3F855890EA0,\n      0xAfB9554299491a34d303f2C5A91bebB162f6B2Cf,\n      0xF48C06c56D78F5106b8c5Fa234fCeB1d1c50096B,\n      0x626ECe2ad62F59700D2734A523FC6177005aC8b0,\n      0xc6C15480855add4eeBE365c89a9bb6f278E18254,\n      0xF6071F7905D4e4B6eBd27b819aAF8923d542FDDF,\n      0x8872fe6335267aDB4C40b9f8667095667B55dCD9,\n      0x4a4bc674A97737376cFE990aE2fE0d2B6E738393,\n      0x27550f4B37f0309C56ea67578Eb924B4c19eEEB7,\n      0x181A053fd961DC1377B84BE4E551ce277053e4C0,\n      0xf44C500a8515a5ACc900C921bC888b5b62DA6556,\n      0xF20293d569f0Ee7ECcdEF266D86EE382F8932866,\n      0xb1D4782962A407343Aa3765a599637932d241305,\n      0x7F53d703836abCaF1ca3D5607d80dd7d96e50d02,\n      0x78fD38faa30ea66702cc39383D2E84f9a4A56fA6\n    ];\n  }\n\n  function __treasuries() private pure returns (address[74] memory list) {\n    return [\n      0xD682DC6D64710D6191512133dE957e146e9AA58f,\n      0xEFeaFf1d9f1E4EDB00c6084aE4016143B29Ed924,\n      0xC2caE7311FC0fe400A838d2dDe06A89E1d3e9Da7,\n      0xf90a912Fdb7Fd37572cD83325392d729e60Ef682,\n      0xAfB9554299491a34d303f2C5A91bebB162f6B2Cf,\n      0x8dA9d88F90141a03292d5e554691B1F6e7c6212c,\n      0xA87F9A2F0C7082FA2f1E3de1090D36047C7cD017,\n      0x6693dc258BDAAc5052ab678BA5de2440CA1cdAbe,\n      0x0B67dF5847aF7476B2EB46da328638E0fB2C6B29,\n      0xe91d1DCd0232BDa301379dE27bd0edE47Db3F750,\n      0xDc3de716C4430d598AC504c4685d69D0DcE1412F,\n      0x795CF28E5b71f1A50cC9E01077891C18D6587e53,\n      0xa3B3c71371331fD1901e316B67df2d16bF5535a0,\n      0x32Be208dE8A1595cC0ccf8E984CAB8759Ea1e5b2,\n      0x8136c74e94b08300d71Fa6C22087b821F73568c5,\n      0xda6c7342E90B77c5C77A8F7292765360099e30Ed,\n      0x95fC818CD7709fb6aD8920d0d14925010504876F,\n      0xe8E66b241414a40a3Db539eC7d864cD61938f817,\n      0xfD575770A68D5Af983b2A374981f604DdAD9D684,\n      0x9A54EDCb1D9a44e9f4235ea05c75B45b26679680,\n      0x6108570A29f500D6950fEbffC99ECB66a264A048,\n      0xdA071F710b0f82443866616E8a96069012A73ccf,\n      0x8A4ac64764238C71Ddf82F870BE6526e297Dc4Cd,\n      0x33f1727CaA54AE24CAdB2949881C3725eB61a100,\n      0x34DB532F09Ee1285DFEf26eD696c4eA25dcFce72,\n      0x302d51189FD89D7e72bcb26a65D16941d043F089,\n      0xFeb247F76E6F6C1Ec3455d04e6E3B694a577D57C,\n      0x05955d9e99f57E5574A1a9b73361DD14aEc8D641,\n      0xcf9F44dDB18a5538Efe2a2A28eF20300333f5a71,\n      0x779dCE1ddc28941Ec85bf2aE0dAC9F0f12836281,\n      0x0Bb270e5268a9E9a0742DdB027Fab7405Af56Fa7,\n      0x5b92Ea265597a7cf20C8dA56E6beb8485c1BA993,\n      0x0E3341Ae4Ed9dA65Fc30a7Fa6357e8B5Ac40b0A3,\n      0xf6fd5FcA4Bd769BA495B29B98dba5F2eCF4CEED3,\n      0x8d0a639BDD3b81dF264c4dB46476658858231510,\n      0xBB046932fEFCDD3Be4368444a1014F25DfEE83f2,\n      0x54e09bF04810f387347dA6D9687D6a37EC2aadC7,\n      0xDE5e1554e2bF5d0E54BafC74C932b8F2aD4e273F,\n      0xc68d0255e1b9C549C43c7181BD29684DC477edfc,\n      0x37920733DB9A5b45fC9CD5e3C80825bEfFC1a014,\n      0x7e9107480Bf92dd56c97118E20CdB3c1Ae9dD866,\n      0xC4F83A7b369070E32CEd4Bd6Fd647D19AEf828AC,\n      0x412D4d69122839FcCAd0180e9358d157C3876f3C,\n      0x355503B8E64205FDE9dBBAD269110991cf736a50,\n      0x306f23c32fdfC07850Bf242E8Ff59C5E79BFf812,\n      0x467c5425042C9D9f025265b72C93D73E0F2978C5,\n      0xEE992B0F5E9746fdb8e584Efa01AF79f6B1C0940,\n      0xBD6342c0009f55131b7a51f627CE8Cc87879DD66,\n      0x57018e929Eb6fe50355bF1BF9D1d39cA466b7Fa0,\n      0xAd4e3D2F85b4C095742B500751CEE5c4B8f65A5b,\n      0x89A6A074dB8BcD3Fd60626107eA2aE576693F7c5,\n      0xCB742186fA056444766fA7cc52a0479E8F6DEDEA,\n      0x60C8117901Ab35738fcFd7157D393207eFCe8055,\n      0xAD70AD152E27E0923C4f11C63490FCFD904A4C36,\n      0xd8b47b81648d9e81e50b8cA21EA81F2E1B6929BB,\n      0xeCB1374172970a613A1970370B3ddeAD8F844733,\n      0x0472dCa02318B532Fcb0B056661EE7fD2Adc8a20,\n      0xdd00ACc07F3F7AFa90B5a22cFd56c0808b6444dd,\n      0x4d3302c69fac489E2F7373bCB2f101d3B378c4Ce,\n      0xe7685E437F34De2D36eA2e9AB13E5Ab871711A2C,\n      0xAfB9554299491a34d303f2C5A91bebB162f6B2Cf,\n      0x3F9Df0717099BAaA95A14B3CAA285DAdDAFb0609,\n      0x23Dffc4a93c374A91Fbc1c33075af012b68663F7,\n      0x79eC4d83D40c1Bd1419D8f561BE851FDa1EA32a6,\n      0x2D3f28780bFb7Ed6FB5547c309E1a6837e5bD12B,\n      0xa164e8B5F90ce42B0F531E3882cdE3F698e1121f,\n      0x4a4bc674A97737376cFE990aE2fE0d2B6E738393,\n      0xF61806B65278fFDbF8b04f832C59b65076798Fb6,\n      0x836eeEdd931575CCE4285c74C15DBdA9Edc3Dc4F,\n      0xbd95B0581585E4151793b183ee75d509fDE528B6,\n      0xA75B1Ce2f8C447caB6c13F313dfd806287aA47e2,\n      0x4D546475321b4cA2a91B101f26750092C05350cF,\n      0xFC2d29Da710F45168DE11e5C051CaA558088D52a,\n      0x1C70B8160E92D56E550caf02e1f2e5EC0Fdb551A\n    ];\n  }\n}\n"
    },
    "contracts/ronin/profile/Profile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/validator/ICandidateManager.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport \"./ProfileXComponents.sol\";\nimport { ErrUnauthorized, RoleAccess } from \"../../utils/CommonErrors.sol\";\nimport { ContractType } from \"../../utils/ContractType.sol\";\n\npragma solidity ^0.8.9;\n\ncontract Profile is IProfile, ProfileXComponents, Initializable {\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address validatorContract) external initializer {\n    _setContract(ContractType.VALIDATOR, validatorContract);\n  }\n\n  function initializeV2(address stakingContract, address trustedOrgContract) external reinitializer(2) {\n    _setContract(ContractType.STAKING, stakingContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, trustedOrgContract);\n\n    address[] memory validatorCandidates = IRoninValidatorSet(getContract(ContractType.VALIDATOR))\n      .getValidatorCandidates();\n    TConsensus[] memory consensuses;\n    assembly (\"memory-safe\") {\n      consensuses := validatorCandidates\n    }\n    for (uint256 i; i < validatorCandidates.length; ++i) {\n      _consensus2Id[consensuses[i]] = validatorCandidates[i];\n    }\n\n    __migrationRenouncedCandidates();\n  }\n\n  /**\n   * @dev Add addresses of renounced candidates into registry. Only called during {initializeV2}F.\n   */\n  function __migrationRenouncedCandidates() internal virtual {}\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getId2Profile(address id) external view returns (CandidateProfile memory) {\n    return _id2Profile[id];\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getManyId2Consensus(address[] calldata idList) external view returns (TConsensus[] memory consensusList) {\n    consensusList = new TConsensus[](idList.length);\n    unchecked {\n      for (uint i; i < idList.length; ++i) {\n        consensusList[i] = _id2Profile[idList[i]].consensus;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getConsensus2Id(TConsensus consensus) external view returns (address id) {\n    id = _consensus2Id[consensus];\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getManyConsensus2Id(TConsensus[] calldata consensusList) external view returns (address[] memory idList) {\n    idList = new address[](consensusList.length);\n    unchecked {\n      for (uint i; i < consensusList.length; ++i) {\n        idList[i] = _consensus2Id[consensusList[i]];\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function addNewProfile(CandidateProfile memory profile) external onlyAdmin {\n    CandidateProfile storage _profile = _id2Profile[profile.id];\n    if (_profile.id != address(0)) revert ErrExistentProfile();\n    _addNewProfile(_profile, profile);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   *\n   * @dev Side-effects on other contracts:\n   * - Update Staking contract:\n   *    + [x] Update (id => PoolDetail) mapping in {BaseStaking.sol}.\n   *    + [x] Update `_adminOfActivePoolMapping` in {BaseStaking.sol}.\n   * - Update Validator contract:\n   *    + [x] Update (id => ValidatorCandidate) mapping\n   */\n  function requestChangeAdminAddress(address id, address newAdminAddr) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    _requireCandidateAdmin(_profile);\n    _requireNonZeroAndNonDuplicated(RoleAccess.ADMIN, newAdminAddr);\n    _setAdmin(_profile, newAdminAddr);\n\n    IStaking stakingContract = IStaking(getContract(ContractType.STAKING));\n    stakingContract.execChangeAdminAddress(id, newAdminAddr);\n\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    validatorContract.execChangeAdminAddress(id, newAdminAddr);\n\n    emit ProfileAddressChanged(id, RoleAccess.ADMIN);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   *\n   * @dev Side-effects on other contracts:\n   * - Update in Staking contract for Consensus address mapping:\n   *   + [x] Keep the same previous pool address.\n   * - Update in Validator contract for:\n   *   + [x] Consensus Address mapping\n   *   + [x] Bridge Address mapping\n   *   + [x] Jail mapping\n   *   + [x] Pending reward mapping\n   *   + [x] Schedule mapping\n   * - Update in Slashing contract for:\n   *   + [x] Handling slash indicator\n   *   + [x] Handling slash fast finality\n   *   + [x] Handling slash double sign\n   * - Update in Proposal contract for:\n   *   + [-] Preserve the consensus address and recipient target of locked amount of emergency exit\n   * - Update Trusted Org contracts:\n   *   + [x] Remove and delete weight of the old consensus\n   *   + [x] Replace and add weight for the new consensus\n   */\n  function requestChangeConsensusAddr(address id, TConsensus newConsensusAddr) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    _requireCandidateAdmin(_profile);\n    _requireNonZeroAndNonDuplicated(RoleAccess.CONSENSUS, TConsensus.unwrap(newConsensusAddr));\n\n    TConsensus oldConsensusAddr = _profile.consensus;\n    _setConsensus(_profile, newConsensusAddr);\n\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    validatorContract.execChangeConsensusAddress(id, newConsensusAddr);\n\n    IRoninTrustedOrganization trustedOrgContract = IRoninTrustedOrganization(\n      getContract(ContractType.RONIN_TRUSTED_ORGANIZATION)\n    );\n    trustedOrgContract.execChangeConsensusAddressForTrustedOrg({\n      oldConsensusAddr: oldConsensusAddr,\n      newConsensusAddr: newConsensusAddr\n    });\n\n    emit ProfileAddressChanged(id, RoleAccess.CONSENSUS);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   *\n   * @dev Side-effects on other contracts:\n   * - Update Validator contract:\n   *    + [x] Update (id => ValidatorCandidate) mapping\n   * - Update governance admin:\n   *    + [-] Update recipient in the EmergencyExitBallot to the newTreasury.\n   *          Cannot impl since we cannot cancel the previous the ballot and\n   *          create a new ballot on behalf of the validator contract.\n   */\n  function requestChangeTreasuryAddr(address id, address payable newTreasury) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    _requireCandidateAdmin(_profile);\n    _requireNonZeroAndNonDuplicated(RoleAccess.TREASURY, newTreasury);\n    _setTreasury(_profile, newTreasury);\n\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    validatorContract.execChangeTreasuryAddress(id, newTreasury);\n\n    emit ProfileAddressChanged(id, RoleAccess.TREASURY);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function changePubkey(address id, bytes memory pubkey) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    _requireCandidateAdmin(_profile);\n    _requireNonDuplicatedPubkey(pubkey);\n    _setPubkey(_profile, pubkey);\n\n    emit PubkeyChanged(id, pubkey);\n  }\n\n  function _requireCandidateAdmin(CandidateProfile storage sProfile) internal view {\n    if (\n      msg.sender != sProfile.admin ||\n      !IRoninValidatorSet(getContract(ContractType.VALIDATOR)).isCandidateAdmin(sProfile.consensus, msg.sender)\n    ) revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\n  }\n}\n"
    },
    "contracts/ronin/profile/ProfileHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../udvts/Types.sol\";\nimport \"../../utils/RoleAccess.sol\";\nimport { ProfileStorage } from \"./ProfileStorage.sol\";\n\nabstract contract ProfileHandler is ProfileStorage {\n  /**\n   * @dev Checks each element in the new profile and reverts if there is duplication with any existing profile.\n   */\n  function _requireNonDuplicatedInRegistry(CandidateProfile memory profile) internal view {\n    _requireNonZeroAndNonDuplicated(RoleAccess.CONSENSUS, TConsensus.unwrap(profile.consensus));\n    _requireNonZeroAndNonDuplicated(RoleAccess.CANDIDATE_ADMIN, profile.admin);\n    _requireNonZeroAndNonDuplicated(RoleAccess.TREASURY, profile.treasury);\n    _requireNonDuplicated(RoleAccess.TREASURY, profile.__reservedGovernor);\n    _requireNonDuplicatedPubkey(profile.pubkey);\n  }\n\n  function _requireNonZeroAndNonDuplicated(RoleAccess addressType, address addr) internal view {\n    if (addr == address(0)) revert ErrZeroAddress(addressType);\n    _requireNonDuplicated(addressType, addr);\n  }\n\n  function _requireNonDuplicated(RoleAccess addressType, address addr) internal view {\n    if (_checkNonDuplicatedAddr(addr)) {\n      revert ErrDuplicatedInfo(addressType, uint256(uint160(addr)));\n    }\n  }\n\n  function _checkNonDuplicatedAddr(address addr) internal view returns (bool) {\n    return _registry[uint256(uint160(addr))];\n  }\n\n  function _requireNonDuplicatedPubkey(bytes memory pubkey) internal view {\n    if (_checkNonDuplicatedPubkey(pubkey)) {\n      revert ErrDuplicatedPubkey(pubkey);\n    }\n  }\n\n  function _checkNonDuplicatedPubkey(bytes memory pubkey) internal view returns (bool) {\n    return _registry[_hashPubkey(pubkey)];\n  }\n}\n"
    },
    "contracts/ronin/profile/ProfileStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../udvts/Types.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { IProfile } from \"../../interfaces/IProfile.sol\";\n\nabstract contract ProfileStorage is IProfile, HasContracts {\n  /// @dev Mapping from id address => candidate profile.\n  mapping(address => CandidateProfile) internal _id2Profile;\n\n  /**\n   * @dev Mapping from any address or keccak256(pubkey) => whether it is already registered.\n   * This registry can only be toggled to `true` and NOT vice versa. All registered values\n   * cannot be reused.\n   */\n  mapping(uint256 => bool) internal _registry;\n\n  /// @dev Mapping from consensus address => id address.\n  mapping(TConsensus => address) internal _consensus2Id;\n\n  /// @dev Upgradeable gap.\n  bytes32[48] __gap;\n\n  /**\n   * @dev Add a profile from memory to storage.\n   */\n  function _addNewProfile(CandidateProfile storage _profile, CandidateProfile memory newProfile) internal {\n    _profile.id = newProfile.id;\n\n    _setConsensus(_profile, newProfile.consensus);\n    _setAdmin(_profile, newProfile.admin);\n    _setTreasury(_profile, newProfile.treasury);\n    _setGovernor(_profile, newProfile.__reservedGovernor);\n    _setPubkey(_profile, newProfile.pubkey);\n\n    emit ProfileAdded(newProfile.id);\n  }\n\n  function _setConsensus(CandidateProfile storage _profile, TConsensus consensus) internal {\n    delete _consensus2Id[_profile.consensus];\n    _consensus2Id[consensus] = _profile.id;\n\n    _profile.consensus = consensus;\n    _registry[uint256(uint160(TConsensus.unwrap(consensus)))] = true;\n  }\n\n  function _setAdmin(CandidateProfile storage _profile, address admin) internal {\n    _profile.admin = admin;\n    _registry[uint256(uint160(admin))] = true;\n  }\n\n  function _setTreasury(CandidateProfile storage _profile, address payable treasury) internal {\n    _profile.treasury = treasury;\n    _registry[uint256(uint160(address(treasury)))] = true;\n  }\n\n  /**\n   * @dev Allow to registry a profile without governor address since not all validators are governing validators.\n   */\n  function _setGovernor(CandidateProfile storage _profile, address governor) internal {\n    _profile.__reservedGovernor = governor;\n    if (governor != address(0)) {\n      _registry[uint256(uint160(governor))] = true;\n    }\n  }\n\n  function _setPubkey(CandidateProfile storage _profile, bytes memory pubkey) internal {\n    _profile.pubkey = pubkey;\n    _registry[_hashPubkey(pubkey)] = true;\n  }\n\n  /**\n   * @dev Get an existed profile struct from `id`. Revert if the profile does not exists.\n   */\n  function _getId2ProfileHelper(address id) internal view returns (CandidateProfile storage _profile) {\n    _profile = _id2Profile[id];\n    if (_profile.id == address(0)) revert ErrNonExistentProfile();\n  }\n\n  /**\n   * @dev Returns hash of a public key.\n   */\n  function _hashPubkey(bytes memory pubkey) internal pure returns (uint256) {\n    return uint256(keccak256(pubkey));\n  }\n}\n"
    },
    "contracts/ronin/profile/ProfileXComponents.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../../interfaces/IProfile.sol\";\nimport { ContractType } from \"../../utils/ContractType.sol\";\nimport \"./ProfileHandler.sol\";\n\npragma solidity ^0.8.9;\n\nabstract contract ProfileXComponents is IProfile, ProfileHandler {\n  /**\n   * @inheritdoc IProfile\n   */\n  function execApplyValidatorCandidate(\n    address admin,\n    address id,\n    address treasury,\n    bytes calldata pubkey\n  ) external override onlyContract(ContractType.STAKING) {\n    // Check existent profile\n    CandidateProfile storage _profile = _id2Profile[id];\n    if (_profile.id != address(0)) revert ErrExistentProfile();\n\n    // Validate the info and add the profile\n    CandidateProfile memory profile = CandidateProfile({\n      id: id,\n      consensus: TConsensus.wrap(id),\n      admin: admin,\n      treasury: payable(treasury),\n      __reservedGovernor: address(0),\n      pubkey: pubkey\n    });\n    _requireNonDuplicatedInRegistry(profile);\n    _addNewProfile(_profile, profile);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/CreditScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/IMaintenance.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/slash-indicator/ICreditScore.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasValidatorDeprecated, HasMaintenanceDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport { ErrUnauthorized, RoleAccess } from \"../../utils/CommonErrors.sol\";\n\nabstract contract CreditScore is\n  ICreditScore,\n  HasContracts,\n  HasValidatorDeprecated,\n  HasMaintenanceDeprecated,\n  PercentageConsumer\n{\n  /// @dev Mapping from validator id => period index => whether bailed out before\n  mapping(address => mapping(uint256 => bool)) internal _checkBailedOutAtPeriod;\n  /// @dev Mapping from validator address => credit score\n  mapping(address => uint256) internal _creditScore;\n\n  /// @dev The max gained number of credit score per period.\n  uint256 internal _gainCreditScore;\n  /// @dev The max number of credit score that a validator can hold.\n  uint256 internal _maxCreditScore;\n  /// @dev The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n  uint256 internal _bailOutCostMultiplier;\n  /// @dev The percentage of reward to be cut off from the validator in the rest of the period after bailed out.\n  uint256 internal _cutOffPercentageAfterBailout;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function execUpdateCreditScores(\n    address[] calldata validatorIds,\n    uint256 period\n  ) external override onlyContract(ContractType.VALIDATOR) {\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(msg.sender);\n    uint256 periodStartAtBlock = validatorContract.currentPeriodStartAtBlock();\n\n    bool[] memory jaileds = validatorContract.checkManyJailedById(validatorIds);\n    bool[] memory maintaineds = IMaintenance(getContract(ContractType.MAINTENANCE)).checkManyMaintainedInBlockRangeById(\n      validatorIds,\n      periodStartAtBlock,\n      block.number\n    );\n    uint256[] memory updatedCreditScores = new uint256[](validatorIds.length);\n\n    for (uint i = 0; i < validatorIds.length; ) {\n      address vId = validatorIds[i];\n\n      uint256 indicator = _getUnavailabilityIndicatorById(vId, period);\n      bool isJailedInPeriod = jaileds[i];\n      bool isMaintainingInPeriod = maintaineds[i];\n\n      uint256 _actualGain = (isJailedInPeriod || isMaintainingInPeriod)\n        ? 0\n        : Math.subNonNegative(_gainCreditScore, indicator);\n\n      _creditScore[vId] = Math.addWithUpperbound(_creditScore[vId], _actualGain, _maxCreditScore);\n      updatedCreditScores[i] = _creditScore[vId];\n      unchecked {\n        ++i;\n      }\n    }\n\n    emit CreditScoresUpdated(validatorIds, updatedCreditScores);\n  }\n\n  function execResetCreditScores(\n    address[] calldata validatorIds\n  ) external override onlyContract(ContractType.VALIDATOR) {\n    uint256[] memory updatedCreditScores = new uint256[](validatorIds.length);\n    for (uint i = 0; i < validatorIds.length; ) {\n      address _validator = validatorIds[i];\n      delete _creditScore[_validator];\n      delete updatedCreditScores[i];\n\n      unchecked {\n        ++i;\n      }\n    }\n    emit CreditScoresUpdated(validatorIds, updatedCreditScores);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function bailOut(TConsensus consensusAddr) external override {\n    address validatorId = __css2cid(consensusAddr);\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    if (!validatorContract.isValidatorCandidate(consensusAddr))\n      revert ErrUnauthorized(msg.sig, RoleAccess.VALIDATOR_CANDIDATE);\n\n    if (!validatorContract.isCandidateAdmin(consensusAddr, msg.sender))\n      revert ErrUnauthorized(msg.sig, RoleAccess.CANDIDATE_ADMIN);\n\n    (bool isJailed, , uint256 jailedEpochLeft) = validatorContract.getJailedTimeLeft(consensusAddr);\n    if (!isJailed) revert ErrCallerMustBeJailedInTheCurrentPeriod();\n\n    uint256 period = validatorContract.currentPeriod();\n    if (_checkBailedOutAtPeriod[validatorId][period]) revert ErrValidatorHasBailedOutPreviously();\n\n    uint256 score = _creditScore[validatorId];\n    uint256 cost = jailedEpochLeft * _bailOutCostMultiplier;\n    if (score < cost) revert ErrInsufficientCreditScoreToBailOut();\n\n    validatorContract.execBailOut(validatorId, period);\n\n    _creditScore[validatorId] -= cost;\n    _setUnavailabilityIndicator(validatorId, period, 0);\n    _checkBailedOutAtPeriod[validatorId][period] = true;\n    emit BailedOut(consensusAddr, period, cost);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) external override onlyAdmin {\n    _setCreditScoreConfigs(_gainScore, _maxScore, _bailOutMultiplier, _cutOffPercentage);\n  }\n\n  /**\n   * @dev See `ISlashUnavailability`\n   */\n  function _getUnavailabilityIndicatorById(address validator, uint256 period) internal view virtual returns (uint256);\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getCreditScoreConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 gainCreditScore_,\n      uint256 maxCreditScore_,\n      uint256 bailOutCostMultiplier_,\n      uint256 cutOffPercentageAfterBailout_\n    )\n  {\n    return (_gainCreditScore, _maxCreditScore, _bailOutCostMultiplier, _cutOffPercentageAfterBailout);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getCreditScore(TConsensus consensusAddr) external view override returns (uint256) {\n    return _creditScore[__css2cid(consensusAddr)];\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getManyCreditScores(\n    TConsensus[] calldata consensusAddrs\n  ) public view override returns (uint256[] memory resultList) {\n    address[] memory validatorIds = __css2cidBatch(consensusAddrs);\n    resultList = new uint256[](validatorIds.length);\n\n    for (uint i = 0; i < resultList.length; ) {\n      resultList[i] = _creditScore[validatorIds[i]];\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function checkBailedOutAtPeriod(TConsensus consensus, uint256 period) external view override returns (bool) {\n    return _checkBailedOutAtPeriodById(__css2cid(consensus), period);\n  }\n\n  function _checkBailedOutAtPeriodById(address validatorId, uint256 period) internal view virtual returns (bool) {\n    return _checkBailedOutAtPeriod[validatorId][period];\n  }\n\n  /**\n   * @dev See `SlashUnavailability`.\n   */\n  function _setUnavailabilityIndicator(address _validator, uint256 period, uint256 _indicator) internal virtual;\n\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view virtual returns (address[] memory);\n\n  /**\n   * @dev See `ICreditScore-setCreditScoreConfigs`.\n   */\n  function _setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) internal {\n    if (_gainScore > _maxScore) revert ErrInvalidCreditScoreConfig();\n    if (_cutOffPercentage > _MAX_PERCENTAGE) revert ErrInvalidCutOffPercentageConfig();\n\n    _gainCreditScore = _gainScore;\n    _maxCreditScore = _maxScore;\n    _bailOutCostMultiplier = _bailOutMultiplier;\n    _cutOffPercentageAfterBailout = _cutOffPercentage;\n    emit CreditScoreConfigsUpdated(_gainScore, _maxScore, _bailOutMultiplier, _cutOffPercentage);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/DeprecatedSlashBridgeOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasProxyAdmin.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\nabstract contract DeprecatedSlashBridgeOperator is HasProxyAdmin, HasContracts, HasValidatorDeprecated {\n  /**\n   * @dev The bridge operators will be deprecated reward if (s)he missed more than the ratio.\n   * Values 0-10,000 map to 0%-100%.\n   */\n  uint256 private ____deprecatedMissingVotesRatioTier1;\n  /**\n   * @dev The bridge operators will be deprecated all rewards including bridge reward and mining reward if (s)he missed\n   * more than the ratio. Values 0-10,000 map to 0%-100%.\n   */\n  uint256 private ____deprecatedMissingVotesRatioTier2;\n  /// @dev The number of blocks to jail the corresponding block producer when its bridge operator is slashed tier-2.\n  uint256 private ____deprecatedJailDurationForMissingVotesRatioTier2;\n  /// @dev The threshold to skip slashing the bridge operator in case the total number of votes in the bridge is too small.\n  uint256 private ____deprecatedSkipBridgeOperatorSlashingThreshold;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/ronin/slash-indicator/DeprecatedSlashBridgeVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { HasValidatorDeprecated, HasTrustedOrgDeprecated, HasGovernanceAdminDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\n\n// TODO: remove this from slashing logic of consensus contract\nabstract contract DeprecatedSlashBridgeVoting is\n  HasContracts,\n  HasValidatorDeprecated,\n  HasTrustedOrgDeprecated,\n  HasGovernanceAdminDeprecated\n{\n  /// @dev Mapping from validator address => period index => bridge voting slashed\n  mapping(address => mapping(uint256 => bool)) private __deprecatedBridgeVotingSlashed;\n  /// @dev The threshold to slash when a trusted organization does not vote for bridge operators.\n  uint256 private __deprecatedBridgeVotingThreshold;\n  /// @dev The amount of RON to slash bridge voting.\n  uint256 private __deprecatedBridgeVotingSlashAmount;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/slash-indicator/ISlashDoubleSign.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../precompile-usages/PCUValidateDoubleSign.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\nabstract contract SlashDoubleSign is ISlashDoubleSign, HasContracts, HasValidatorDeprecated, PCUValidateDoubleSign {\n  /// @dev The amount of RON to slash double sign.\n  uint256 internal _slashDoubleSignAmount;\n  /// @dev The block number that the punished validator will be jailed until, due to double signing.\n  uint256 internal _doubleSigningJailUntilBlock;\n  /** @dev The offset from the submitted block to the current block, from which double signing will be invalidated.\n   * This parameter is exposed for system transaction.\n   **/\n  uint256 internal _doubleSigningOffsetLimitBlock;\n  /// @dev Recording of submitted proof to prevent relay attack.\n  mapping(bytes32 => bool) _submittedEvidence;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[24] private ______gap;\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function slashDoubleSign(\n    TConsensus consensusAddr,\n    bytes calldata header1,\n    bytes calldata header2\n  ) external override onlyAdmin {\n    bytes32 header1Checksum = keccak256(header1);\n    bytes32 header2Checksum = keccak256(header2);\n\n    if (_submittedEvidence[header1Checksum] || _submittedEvidence[header2Checksum]) {\n      revert ErrEvidenceAlreadySubmitted();\n    }\n\n    address validatorId = __css2cid(consensusAddr);\n\n    // NOTE: Edge case: non-validator who never apply for the candidate role, nor have a profile.\n    // Must be slashed by the consensus address, since the validatorId will be address(0).\n    if (validatorId == address(0)) {\n      validatorId = TConsensus.unwrap(consensusAddr);\n    }\n\n    if (_pcValidateEvidence(validatorId, header1, header2)) {\n      IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n      uint256 period = validatorContract.currentPeriod();\n      _submittedEvidence[header1Checksum] = true;\n      _submittedEvidence[header2Checksum] = true;\n      emit Slashed(validatorId, SlashType.DOUBLE_SIGNING, period);\n      validatorContract.execSlash(validatorId, _doubleSigningJailUntilBlock, _slashDoubleSignAmount, true);\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function getDoubleSignSlashingConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 slashDoubleSignAmount_,\n      uint256 doubleSigningJailUntilBlock_,\n      uint256 doubleSigningOffsetLimitBlock_\n    )\n  {\n    return (_slashDoubleSignAmount, _doubleSigningJailUntilBlock, _doubleSigningOffsetLimitBlock);\n  }\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _offsetLimitBlock\n  ) external override onlyAdmin {\n    _setDoubleSignSlashingConfigs(_slashAmount, _jailUntilBlock, _offsetLimitBlock);\n  }\n\n  /**\n   * @dev See `ISlashDoubleSign-setDoubleSignSlashingConfigs`.\n   */\n  function _setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _offsetLimitBlock\n  ) internal {\n    _slashDoubleSignAmount = _slashAmount;\n    _doubleSigningJailUntilBlock = _jailUntilBlock;\n    _doubleSigningOffsetLimitBlock = _offsetLimitBlock;\n    emit DoubleSignSlashingConfigsUpdated(_slashAmount, _jailUntilBlock, _doubleSigningOffsetLimitBlock);\n  }\n\n  /**\n   * @dev Returns whether the account `_addr` should be slashed or not.\n   */\n  function _shouldSlash(TConsensus consensus, address validatorId) internal view virtual returns (bool);\n\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/slash-indicator/ISlashFastFinality.sol\";\nimport { IRoninValidatorSet } from \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport { IProfile } from \"../../interfaces/IProfile.sol\";\nimport { IRoninTrustedOrganization } from \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../precompile-usages/PCUValidateFastFinality.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../utils/CommonErrors.sol\";\n\nabstract contract SlashFastFinality is ISlashFastFinality, HasContracts, PCUValidateFastFinality {\n  /// @dev The amount of RON to slash fast finality.\n  uint256 internal _slashFastFinalityAmount;\n  /// @dev The block number that the punished validator will be jailed until, due to malicious fast finality.\n  uint256 internal _fastFinalityJailUntilBlock;\n  /// @dev Recording of submitted proof to prevent relay attack.\n  mapping(bytes32 => bool) internal _processedEvidence;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[21] private ______gap;\n\n  modifier onlyGoverningValidator() {\n    if (_getGovernorWeight(msg.sender) == 0) revert ErrUnauthorized(msg.sig, RoleAccess.GOVERNOR);\n    _;\n  }\n\n  /**\n   * @inheritdoc ISlashFastFinality\n   */\n  function slashFastFinality(\n    TConsensus consensusAddr,\n    bytes calldata voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] calldata targetBlockHash,\n    bytes[][2] calldata listOfPublicKey,\n    bytes[2] calldata aggregatedSignature\n  ) external override onlyGoverningValidator {\n    address validatorId = __css2cid(consensusAddr);\n    IProfile profileContract = IProfile(getContract(ContractType.PROFILE));\n    bytes memory expectingPubKey = (profileContract.getId2Profile(validatorId)).pubkey;\n    if (keccak256(voterPublicKey) != keccak256(expectingPubKey)) revert ErrInvalidArguments(msg.sig);\n\n    bytes32 evidenceHash = keccak256(abi.encodePacked(consensusAddr, targetBlockNumber));\n    if (_processedEvidence[evidenceHash]) revert ErrEvidenceAlreadySubmitted();\n\n    if (\n      _pcValidateFastFinalityEvidence(\n        voterPublicKey,\n        targetBlockNumber,\n        targetBlockHash,\n        listOfPublicKey,\n        aggregatedSignature\n      )\n    ) {\n      _processedEvidence[evidenceHash] = true;\n\n      IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n      uint256 period = validatorContract.currentPeriod();\n      emit Slashed(validatorId, SlashType.FAST_FINALITY, period);\n      validatorContract.execSlash({\n        cid: validatorId,\n        newJailedUntil: _fastFinalityJailUntilBlock,\n        slashAmount: _slashFastFinalityAmount,\n        cannotBailout: true\n      });\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashFastFinality\n   */\n  function getFastFinalitySlashingConfigs()\n    external\n    view\n    override\n    returns (uint256 slashFastFinalityAmount_, uint256 fastFinalityJailUntilBlock_)\n  {\n    return (_slashFastFinalityAmount, _fastFinalityJailUntilBlock);\n  }\n\n  /**\n   * @inheritdoc ISlashFastFinality\n   */\n  function setFastFinalitySlashingConfigs(uint256 slashAmount, uint256 jailUntilBlock) external override onlyAdmin {\n    _setFastFinalitySlashingConfigs(slashAmount, jailUntilBlock);\n  }\n\n  /**\n   * @dev See `ISlashFastFinality-setFastFinalitySlashingConfigs`.\n   */\n  function _setFastFinalitySlashingConfigs(uint256 slashAmount, uint256 jailUntilBlock) internal {\n    _slashFastFinalityAmount = slashAmount;\n    _fastFinalityJailUntilBlock = jailUntilBlock;\n    emit FastFinalitySlashingConfigsUpdated(slashAmount, jailUntilBlock);\n  }\n\n  /**\n   * @dev Get governor, i.e. governing validator's weight, of the `addr`.\n   */\n  function _getGovernorWeight(address addr) internal view returns (uint256) {\n    return IRoninTrustedOrganization(getContract(ContractType.RONIN_TRUSTED_ORGANIZATION)).getGovernorWeight(addr);\n  }\n\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashIndicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/slash-indicator/ISlashIndicator.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/IMaintenance.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport \"./DeprecatedSlashBridgeOperator.sol\";\nimport \"./DeprecatedSlashBridgeVoting.sol\";\nimport \"./SlashDoubleSign.sol\";\nimport \"./SlashFastFinality.sol\";\nimport \"./SlashUnavailability.sol\";\nimport \"./CreditScore.sol\";\n\ncontract SlashIndicator is\n  ISlashIndicator,\n  SlashDoubleSign,\n  SlashFastFinality,\n  DeprecatedSlashBridgeVoting,\n  DeprecatedSlashBridgeOperator,\n  SlashUnavailability,\n  CreditScore,\n  Initializable\n{\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __validatorContract,\n    address __maintenanceContract,\n    address __roninTrustedOrganizationContract,\n    address __roninGovernanceAdminContract,\n    uint256[4] calldata /* _bridgeOperatorSlashingConfigs */,\n    uint256[2] calldata /* _bridgeVotingSlashingConfigs */,\n    // _doubleSignSlashingConfigs[0]: _slashDoubleSignAmount\n    // _doubleSignSlashingConfigs[1]: _doubleSigningJailUntilBlock\n    // _doubleSignSlashingConfigs[2]: _doubleSigningOffsetLimitBlock\n    uint256[3] calldata _doubleSignSlashingConfigs,\n    // _unavailabilitySlashingConfigs[0]: _unavailabilityTier1Threshold\n    // _unavailabilitySlashingConfigs[1]: _unavailabilityTier2Threshold\n    // _unavailabilitySlashingConfigs[2]: _slashAmountForUnavailabilityTier2Threshold\n    // _unavailabilitySlashingConfigs[3]: _jailDurationForUnavailabilityTier2Threshold\n    uint256[4] calldata _unavailabilitySlashingConfigs,\n    // _creditScoreConfigs[0]: _gainCreditScore\n    // _creditScoreConfigs[1]: _maxCreditScore\n    // _creditScoreConfigs[2]: _bailOutCostMultiplier\n    // _creditScoreConfigs[3]: _cutOffPercentageAfterBailout\n    uint256[4] calldata _creditScoreConfigs\n  ) external initializer {\n    _setContract(ContractType.VALIDATOR, __validatorContract);\n    _setContract(ContractType.MAINTENANCE, __maintenanceContract);\n    _setContract(ContractType.GOVERNANCE_ADMIN, __roninGovernanceAdminContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, __roninTrustedOrganizationContract);\n\n    _setDoubleSignSlashingConfigs(\n      _doubleSignSlashingConfigs[0],\n      _doubleSignSlashingConfigs[1],\n      _doubleSignSlashingConfigs[2]\n    );\n    _setUnavailabilitySlashingConfigs(\n      _unavailabilitySlashingConfigs[0],\n      _unavailabilitySlashingConfigs[1],\n      _unavailabilitySlashingConfigs[2],\n      _unavailabilitySlashingConfigs[3]\n    );\n    _setCreditScoreConfigs(\n      _creditScoreConfigs[0],\n      _creditScoreConfigs[1],\n      _creditScoreConfigs[2],\n      _creditScoreConfigs[3]\n    );\n  }\n\n  function initializeV2(address roninGovernanceAdminContract) external reinitializer(2) {\n    _setContract(ContractType.VALIDATOR, ______deprecatedValidator);\n    _setContract(ContractType.MAINTENANCE, ______deprecatedMaintenance);\n    _setContract(ContractType.GOVERNANCE_ADMIN, roninGovernanceAdminContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, ______deprecatedTrustedOrg);\n\n    delete ______deprecatedValidator;\n    delete ______deprecatedMaintenance;\n    delete ______deprecatedTrustedOrg;\n    delete ______deprecatedGovernanceAdmin;\n  }\n\n  function initializeV3(address profileContract) external reinitializer(3) {\n    _setContract(ContractType.PROFILE, profileContract);\n    _setFastFinalitySlashingConfigs(_slashDoubleSignAmount, _doubleSigningJailUntilBlock);\n  }\n\n  /**\n   * @dev Helper for CreditScore contract to reset the indicator of the validator after bailing out.\n   */\n  function _setUnavailabilityIndicator(\n    address validator,\n    uint256 period,\n    uint256 indicator\n  ) internal override(CreditScore, SlashUnavailability) {\n    SlashUnavailability._setUnavailabilityIndicator(validator, period, indicator);\n  }\n\n  /**\n   * @dev Helper for CreditScore contract to query indicator of the validator.\n   */\n  function _getUnavailabilityIndicatorById(\n    address validatorId,\n    uint256 period\n  ) internal view override(CreditScore, SlashUnavailability) returns (uint256) {\n    return SlashUnavailability._getUnavailabilityIndicatorById(validatorId, period);\n  }\n\n  function _checkBailedOutAtPeriodById(\n    address cid,\n    uint256 period\n  ) internal view override(CreditScore, SlashUnavailability) returns (bool) {\n    return CreditScore._checkBailedOutAtPeriodById(cid, period);\n  }\n\n  /**\n   * @dev Sanity check the address to be slashed\n   */\n  function _shouldSlash(\n    TConsensus consensus,\n    address validatorId\n  ) internal view override(SlashDoubleSign, SlashUnavailability) returns (bool) {\n    return\n      (msg.sender != TConsensus.unwrap(consensus)) &&\n      (msg.sender != validatorId) &&\n      IRoninValidatorSet(getContract(ContractType.VALIDATOR)).isBlockProducer(consensus) &&\n      !IMaintenance(getContract(ContractType.MAINTENANCE)).checkMaintainedById(validatorId, block.number);\n  }\n\n  function __css2cid(\n    TConsensus consensusAddr\n  ) internal view override(CreditScore, SlashDoubleSign, SlashUnavailability, SlashFastFinality) returns (address) {\n    return IProfile(getContract(ContractType.PROFILE)).getConsensus2Id(consensusAddr);\n  }\n\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view override returns (address[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyConsensus2Id(consensusAddrs);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashUnavailability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./CreditScore.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/slash-indicator/ISlashUnavailability.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport { ErrInvalidThreshold } from \"../../utils/CommonErrors.sol\";\n\nabstract contract SlashUnavailability is ISlashUnavailability, HasContracts, HasValidatorDeprecated {\n  /// @dev The last block that a validator is slashed for unavailability.\n  uint256 internal _lastUnavailabilitySlashedBlock;\n  /// @dev Mapping from validator address => period index => unavailability indicator.\n  mapping(address => mapping(uint256 => uint256)) internal _unavailabilityIndicator;\n\n  /**\n   * @dev The mining reward will be deprecated, if (s)he missed more than this threshold.\n   * This threshold is applied for tier-1 and tier-3 of unavailability slash.\n   */\n  uint256 internal _unavailabilityTier1Threshold;\n  /**\n   * @dev The mining reward will be deprecated, (s)he will be put in jailed, and will be deducted\n   * self-staking if (s)he misses more than this threshold. This threshold is applied for tier-2 slash.\n   */\n  uint256 internal _unavailabilityTier2Threshold;\n  /**\n   * @dev The amount of RON to deduct from self-staking of a block producer when (s)he is slashed with\n   * tier-2 or tier-3.\n   **/\n  uint256 internal _slashAmountForUnavailabilityTier2Threshold;\n  /// @dev The number of blocks to jail a block producer when (s)he is slashed with tier-2 or tier-3.\n  uint256 internal _jailDurationForUnavailabilityTier2Threshold;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  modifier oncePerBlock() {\n    if (block.number <= _lastUnavailabilitySlashedBlock) {\n      revert ErrCannotSlashAValidatorTwiceOrSlashMoreThanOneValidatorInOneBlock();\n    }\n\n    _lastUnavailabilitySlashedBlock = block.number;\n    _;\n  }\n\n  function lastUnavailabilitySlashedBlock() external view returns (uint256) {\n    return _lastUnavailabilitySlashedBlock;\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function slashUnavailability(TConsensus consensusAddr) external override oncePerBlock {\n    if (msg.sender != block.coinbase) revert ErrUnauthorized(msg.sig, RoleAccess.COINBASE);\n\n    address validatorId = __css2cid(consensusAddr);\n    if (!_shouldSlash(consensusAddr, validatorId)) {\n      // Should return instead of throwing error since this is a part of system transaction.\n      return;\n    }\n\n    IRoninValidatorSet _validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    uint256 period = _validatorContract.currentPeriod();\n    uint256 count;\n    unchecked {\n      count = ++_unavailabilityIndicator[validatorId][period];\n    }\n    uint256 newJailedUntilBlock = Math.addIfNonZero(block.number, _jailDurationForUnavailabilityTier2Threshold);\n\n    if (count == _unavailabilityTier2Threshold) {\n      emit Slashed(validatorId, SlashType.UNAVAILABILITY_TIER_2, period);\n      _validatorContract.execSlash(\n        validatorId,\n        newJailedUntilBlock,\n        _slashAmountForUnavailabilityTier2Threshold,\n        false\n      );\n    } else if (count == _unavailabilityTier1Threshold) {\n      bool tier1SecondTime = _checkBailedOutAtPeriodById(validatorId, period);\n      if (!tier1SecondTime) {\n        emit Slashed(validatorId, SlashType.UNAVAILABILITY_TIER_1, period);\n        _validatorContract.execSlash(validatorId, 0, 0, false);\n      } else {\n        /// Handles tier-3\n        emit Slashed(validatorId, SlashType.UNAVAILABILITY_TIER_3, period);\n        _validatorContract.execSlash(\n          validatorId,\n          newJailedUntilBlock,\n          _slashAmountForUnavailabilityTier2Threshold,\n          true\n        );\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) external override onlyAdmin {\n    _setUnavailabilitySlashingConfigs(\n      _tier1Threshold,\n      _tier2Threshold,\n      _slashAmountForTier2Threshold,\n      _jailDurationForTier2Threshold\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function getUnavailabilitySlashingConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 unavailabilityTier1Threshold_,\n      uint256 unavailabilityTier2Threshold_,\n      uint256 slashAmountForUnavailabilityTier2Threshold_,\n      uint256 jailDurationForUnavailabilityTier2Threshold_\n    )\n  {\n    return (\n      _unavailabilityTier1Threshold,\n      _unavailabilityTier2Threshold,\n      _slashAmountForUnavailabilityTier2Threshold,\n      _jailDurationForUnavailabilityTier2Threshold\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function currentUnavailabilityIndicator(TConsensus consensus) external view override returns (uint256) {\n    return\n      _getUnavailabilityIndicatorById(\n        __css2cid(consensus),\n        IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod()\n      );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function getUnavailabilityIndicator(\n    TConsensus consensus,\n    uint256 period\n  ) external view virtual override returns (uint256) {\n    return _getUnavailabilityIndicatorById(__css2cid(consensus), period);\n  }\n\n  function _getUnavailabilityIndicatorById(\n    address validatorId,\n    uint256 period\n  ) internal view virtual returns (uint256) {\n    return _unavailabilityIndicator[validatorId][period];\n  }\n\n  /**\n   * @dev Sets the unavailability indicator of the `_validator` at `_period`.\n   */\n  function _setUnavailabilityIndicator(address _validator, uint256 _period, uint256 _indicator) internal virtual {\n    _unavailabilityIndicator[_validator][_period] = _indicator;\n  }\n\n  /**\n   * @dev See `ISlashUnavailability-setUnavailabilitySlashingConfigs`.\n   */\n  function _setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) internal {\n    if (_unavailabilityTier1Threshold > _unavailabilityTier2Threshold) revert ErrInvalidThreshold(msg.sig);\n\n    _unavailabilityTier1Threshold = _tier1Threshold;\n    _unavailabilityTier2Threshold = _tier2Threshold;\n    _slashAmountForUnavailabilityTier2Threshold = _slashAmountForTier2Threshold;\n    _jailDurationForUnavailabilityTier2Threshold = _jailDurationForTier2Threshold;\n    emit UnavailabilitySlashingConfigsUpdated(\n      _tier1Threshold,\n      _tier2Threshold,\n      _slashAmountForTier2Threshold,\n      _jailDurationForTier2Threshold\n    );\n  }\n\n  /**\n   * @dev Returns whether the account `_addr` should be slashed or not.\n   */\n  function _shouldSlash(TConsensus consensus, address validatorId) internal view virtual returns (bool);\n\n  /**\n   * @dev See `ICreditScore-checkBailedOutAtPeriodById`\n   */\n  function _checkBailedOutAtPeriodById(address validatorId, uint256 period) internal view virtual returns (bool);\n\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n}\n"
    },
    "contracts/udvts/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ntype TPoolId is address;\ntype TConsensus is address;\n\nusing { TPoolIdEq as == } for TPoolId global;\nusing { TConsensusEq as == } for TConsensus global;\n\nfunction TPoolIdEq(TPoolId a, TPoolId b) pure returns (bool) {\n  return TPoolId.unwrap(a) == TPoolId.unwrap(b);\n}\n\nfunction TConsensusEq(TConsensus a, TConsensus b) pure returns (bool) {\n  return TConsensus.unwrap(a) == TConsensus.unwrap(b);\n}\n"
    },
    "contracts/utils/CommonErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ContractType } from \"./ContractType.sol\";\nimport { RoleAccess } from \"./RoleAccess.sol\";\n\nerror ErrSyncTooFarPeriod(uint256 period, uint256 latestRewardedPeriod);\n\n/**\n * @dev Error raised when a bridge operator update operation fails.\n * @param bridgeOperator The address of the bridge operator that failed to update.\n */\nerror ErrBridgeOperatorUpdateFailed(address bridgeOperator);\n\n/**\n * @dev Error thrown when an address is expected to be an already created externally owned account (EOA).\n * This error indicates that the provided address is invalid for certain contract operations that require already created EOA.\n */\nerror ErrAddressIsNotCreatedEOA(address addr, bytes32 codehash);\n\n/**\n * @dev Error thrown when attempting to add a bridge operator that already exists in the contract.\n * This error indicates that the provided bridge operator address is already registered as a bridge operator in the contract.\n */\nerror ErrBridgeOperatorAlreadyExisted(address bridgeOperator);\n\n/**\n * @dev The error indicating an unsupported interface.\n * @param interfaceId The bytes4 interface identifier that is not supported.\n * @param addr The address where the unsupported interface was encountered.\n */\nerror ErrUnsupportedInterface(bytes4 interfaceId, address addr);\n\n/**\n * @dev Error thrown when the return data from a callback function is invalid.\n * @param callbackFnSig The signature of the callback function that returned invalid data.\n * @param register The address of the register where the callback function was invoked.\n * @param returnData The invalid return data received from the callback function.\n */\nerror ErrInvalidReturnData(bytes4 callbackFnSig, address register, bytes returnData);\n\n/**\n * @dev Error of set to non-contract.\n */\nerror ErrZeroCodeContract(address addr);\n\n/**\n * @dev Error indicating that arguments are invalid.\n */\nerror ErrInvalidArguments(bytes4 msgSig);\n\n/**\n * @dev Error indicating that given address is null when it should not.\n */\nerror ErrZeroAddress(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the provided threshold is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that the invalid threshold applies to.\n */\nerror ErrInvalidThreshold(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a function can only be called by the contract itself.\n * @param msgSig The function signature (bytes4) that can only be called by the contract itself.\n */\nerror ErrOnlySelfCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n * @param expectedRole The role required to perform the function.\n */\nerror ErrUnauthorized(bytes4 msgSig, RoleAccess expectedRole);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n */\nerror ErrUnauthorizedCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4).\n * @param expectedContractType The contract type required to perform the function.\n * @param actual The actual address that called to the function.\n */\nerror ErrUnexpectedInternalCall(bytes4 msgSig, ContractType expectedContractType, address actual);\n\n/**\n * @dev Error indicating that an array is empty when it should contain elements.\n */\nerror ErrEmptyArray();\n\n/**\n * @dev Error indicating a mismatch in the length of input parameters or arrays for a specific function.\n * @param msgSig The function signature (bytes4) that has a length mismatch.\n */\nerror ErrLengthMismatch(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a proxy call to an external contract has failed.\n * @param msgSig The function signature (bytes4) of the proxy call that failed.\n * @param extCallSig The function signature (bytes4) of the external contract call that failed.\n */\nerror ErrProxyCallFailed(bytes4 msgSig, bytes4 extCallSig);\n\n/**\n * @dev Error indicating that a function tried to call a precompiled contract that is not allowed.\n * @param msgSig The function signature (bytes4) that attempted to call a precompiled contract.\n */\nerror ErrCallPrecompiled(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a native token transfer has failed.\n * @param msgSig The function signature (bytes4) of the token transfer that failed.\n */\nerror ErrNativeTransferFailed(bytes4 msgSig);\n\n/**\n * @dev Error indicating that an order is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid order.\n */\nerror ErrInvalidOrder(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the chain ID is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid chain ID.\n * @param actual Current chain ID that executing function.\n * @param expected Expected chain ID required for the tx to success.\n */\nerror ErrInvalidChainId(bytes4 msgSig, uint256 actual, uint256 expected);\n\n/**\n * @dev Error indicating that a vote type is not supported.\n * @param msgSig The function signature (bytes4) of the operation that encountered an unsupported vote type.\n */\nerror ErrUnsupportedVoteType(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the proposal nonce is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid proposal nonce.\n */\nerror ErrInvalidProposalNonce(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a voter has already voted.\n * @param voter The address of the voter who has already voted.\n */\nerror ErrAlreadyVoted(address voter);\n\n/**\n * @dev Error indicating that a signature is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid signature.\n */\nerror ErrInvalidSignatures(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a relay call has failed.\n * @param msgSig The function signature (bytes4) of the relay call that failed.\n */\nerror ErrRelayFailed(bytes4 msgSig);\n/**\n * @dev Error indicating that a vote weight is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid vote weight.\n */\nerror ErrInvalidVoteWeight(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a query was made for an outdated bridge operator set.\n */\nerror ErrQueryForOutdatedBridgeOperatorSet();\n\n/**\n * @dev Error indicating that a request is invalid.\n */\nerror ErrInvalidRequest();\n\n/**\n * @dev Error indicating that a token standard is invalid.\n */\nerror ErrInvalidTokenStandard();\n\n/**\n * @dev Error indicating that a token is not supported.\n */\nerror ErrUnsupportedToken();\n\n/**\n * @dev Error indicating that a receipt kind is invalid.\n */\nerror ErrInvalidReceiptKind();\n\n/**\n * @dev Error indicating that a receipt is invalid.\n */\nerror ErrInvalidReceipt();\n\n/**\n * @dev Error indicating that an address is not payable.\n */\nerror ErrNonpayableAddress(address);\n\n/**\n * @dev Error indicating that the period is already processed, i.e. scattered reward.\n */\nerror ErrPeriodAlreadyProcessed(uint256 requestingPeriod, uint256 latestPeriod);\n\n/**\n * @dev Error thrown when an invalid vote hash is provided.\n */\nerror ErrInvalidVoteHash();\n\n/**\n * @dev Error thrown when querying for an empty vote.\n */\nerror ErrQueryForEmptyVote();\n\n/**\n * @dev Error thrown when querying for an expired vote.\n */\nerror ErrQueryForExpiredVote();\n\n/**\n * @dev Error thrown when querying for a non-existent vote.\n */\nerror ErrQueryForNonExistentVote();\n\n/**\n * @dev Error indicating that the method is only called once per block.\n */\nerror ErrOncePerBlock();\n\n/**\n * @dev Error of method caller must be coinbase\n */\nerror ErrCallerMustBeCoinbase();\n"
    },
    "contracts/utils/ContractType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum ContractType {\n  /*  0 */ UNKNOWN,\n  /*  1 */ PAUSE_ENFORCER,\n  /*  2 */ BRIDGE,\n  /*  3 */ BRIDGE_TRACKING,\n  /*  4 */ GOVERNANCE_ADMIN,\n  /*  5 */ MAINTENANCE,\n  /*  6 */ SLASH_INDICATOR,\n  /*  7 */ STAKING_VESTING,\n  /*  8 */ VALIDATOR,\n  /*  9 */ STAKING,\n  /* 10 */ RONIN_TRUSTED_ORGANIZATION,\n  /* 11 */ BRIDGE_MANAGER,\n  /* 12 */ BRIDGE_SLASH,\n  /* 13 */ BRIDGE_REWARD,\n  /* 14 */ FAST_FINALITY_TRACKING,\n  /* 15 */ PROFILE\n}\n"
    },
    "contracts/utils/DeprecatedSlots.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Deprecated Contracts\n * @dev These abstract contracts are deprecated and should not be used in new implementations.\n * They provide functionality related to various aspects of a smart contract but have been marked\n * as deprecated to indicate that they are no longer actively maintained or recommended for use.\n * The purpose of these contracts is to preserve the slots for already deployed contracts.\n */\ncontract HasSlashIndicatorDeprecated {\n  /// @custom:deprecated Previously `_slashIndicatorContract` (non-zero value)\n  address internal ______deprecatedSlashIndicator;\n}\n\ncontract HasStakingVestingDeprecated {\n  /// @custom:deprecated Previously `_stakingVestingContract` (non-zero value)\n  address internal ______deprecatedStakingVesting;\n}\n\ncontract HasBridgeDeprecated {\n  /// @custom:deprecated Previously `_bridgeContract` (non-zero value)\n  address internal ______deprecatedBridge;\n}\n\ncontract HasValidatorDeprecated {\n  /// @custom:deprecated Previously `_validatorContract` (non-zero value)\n  address internal ______deprecatedValidator;\n}\n\ncontract HasStakingDeprecated {\n  /// @custom:deprecated Previously `_stakingContract` (non-zero value)\n  address internal ______deprecatedStakingContract;\n}\n\ncontract HasMaintenanceDeprecated {\n  /// @custom:deprecated Previously `_maintenanceContract` (non-zero value)\n  address internal ______deprecatedMaintenance;\n}\n\ncontract HasTrustedOrgDeprecated {\n  /// @custom:deprecated Previously `_trustedOrgContract` (non-zero value)\n  address internal ______deprecatedTrustedOrg;\n}\n\ncontract HasGovernanceAdminDeprecated {\n  /// @custom:deprecated Previously `_governanceAdminContract` (non-zero value)\n  address internal ______deprecatedGovernanceAdmin;\n}\n\ncontract HasBridgeTrackingDeprecated {\n  /// @custom:deprecated Previously `_bridgeTrackingContract` (non-zero value)\n  address internal ______deprecatedBridgeTracking;\n}\n"
    },
    "contracts/utils/IdentityGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { AddressArrayUtils } from \"../libraries/AddressArrayUtils.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { TransparentUpgradeableProxyV2 } from \"../extensions/TransparentUpgradeableProxyV2.sol\";\nimport { ErrAddressIsNotCreatedEOA, ErrZeroAddress, ErrOnlySelfCall, ErrZeroCodeContract, ErrUnsupportedInterface } from \"./CommonErrors.sol\";\n\nabstract contract IdentityGuard {\n  using AddressArrayUtils for address[];\n\n  /// @dev value is equal to keccak256(abi.encode())\n  /// @dev see: https://eips.ethereum.org/EIPS/eip-1052\n  bytes32 internal constant CREATED_ACCOUNT_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n  /**\n   * @dev Modifier to restrict functions to only be called by this contract.\n   * @dev Reverts if the caller is not this contract.\n   */\n  modifier onlySelfCall() virtual {\n    _requireSelfCall();\n    _;\n  }\n\n  /**\n   * @dev Modifier to ensure that the elements in the `arr` array are non-duplicates.\n   * It calls the internal `_checkDuplicate` function to perform the duplicate check.\n   *\n   * Requirements:\n   * - The elements in the `arr` array must not contain any duplicates.\n   */\n  modifier nonDuplicate(address[] memory arr) virtual {\n    _requireNonDuplicate(arr);\n    _;\n  }\n\n  /**\n   * @dev Internal method to check the method caller.\n   * @dev Reverts if the method caller is not this contract.\n   */\n  function _requireSelfCall() internal view virtual {\n    if (msg.sender != address(this)) revert ErrOnlySelfCall(msg.sig);\n  }\n\n  /**\n   * @dev Internal function to check if a contract address has code.\n   * @param addr The address of the contract to check.\n   * @dev Throws an error if the contract address has no code.\n   */\n  function _requireHasCode(address addr) internal view {\n    if (addr.code.length == 0) revert ErrZeroCodeContract(addr);\n  }\n\n  /**\n   * @dev Checks if an address is zero and reverts if it is.\n   * @param addr The address to check.\n   */\n  function _requireNonZeroAddress(address addr) internal pure {\n    if (addr == address(0)) revert ErrZeroAddress(msg.sig);\n  }\n\n  /**\n   * @dev Check if arr is empty and revert if it is.\n   * Checks if an array contains any duplicate addresses and reverts if duplicates are found.\n   * @param arr The array of addresses to check.\n   */\n  function _requireNonDuplicate(address[] memory arr) internal pure {\n    if (arr.hasDuplicate()) revert AddressArrayUtils.ErrDuplicated(msg.sig);\n  }\n\n  /**\n   * @dev Internal function to require that the provided address is a created externally owned account (EOA).\n   * This internal function is used to ensure that the provided address is a valid externally owned account (EOA).\n   * It checks the codehash of the address against a predefined constant to confirm that the address is a created EOA.\n   * @notice This method only works with non-state EOA accounts\n   */\n  function _requireCreatedEOA(address addr) internal view {\n    _requireNonZeroAddress(addr);\n    bytes32 codehash = addr.codehash;\n    if (codehash != CREATED_ACCOUNT_HASH) revert ErrAddressIsNotCreatedEOA(addr, codehash);\n  }\n\n  /**\n   * @dev Internal function to require that the specified contract supports the given interface. This method handle in\n   * both case that the callee is either or not the proxy admin of the caller. If the contract does not support the\n   * interface `interfaceId` or EIP165, a revert with the corresponding error message is triggered.\n   *\n   * @param contractAddr The address of the contract to check for interface support.\n   * @param interfaceId The interface ID to check for support.\n   */\n  function _requireSupportsInterface(address contractAddr, bytes4 interfaceId) internal view {\n    bytes memory supportsInterfaceParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n    (bool success, bytes memory returnOrRevertData) = contractAddr.staticcall(supportsInterfaceParams);\n    if (!success) {\n      (success, returnOrRevertData) = contractAddr.staticcall(\n        abi.encodeCall(TransparentUpgradeableProxyV2.functionDelegateCall, (supportsInterfaceParams))\n      );\n      if (!success) revert ErrUnsupportedInterface(interfaceId, contractAddr);\n    }\n    if (!abi.decode(returnOrRevertData, (bool))) revert ErrUnsupportedInterface(interfaceId, contractAddr);\n  }\n}\n"
    },
    "contracts/utils/RoleAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum RoleAccess {\n  /* 0 */ UNKNOWN,\n  /* 1 */ ADMIN,\n  /* 2 */ COINBASE,\n  /* 3 */ GOVERNOR,\n  /* 4 */ CANDIDATE_ADMIN,\n  /* 5 */ WITHDRAWAL_MIGRATOR,\n  /* 6 */ __DEPRECATED_BRIDGE_OPERATOR,\n  /* 7 */ BLOCK_PRODUCER,\n  /* 8 */ VALIDATOR_CANDIDATE,\n  /* 9 */ CONSENSUS,\n  /* 10 */ TREASURY\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}