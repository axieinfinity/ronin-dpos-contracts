{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/extensions/collections/HasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { HasProxyAdmin } from \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasContracts.sol\";\nimport { IdentityGuard } from \"../../utils/IdentityGuard.sol\";\nimport { ErrUnexpectedInternalCall } from \"../../utils/CommonErrors.sol\";\n\n/**\n * @title HasContracts\n * @dev A contract that provides functionality to manage multiple contracts with different roles.\n */\nabstract contract HasContracts is HasProxyAdmin, IHasContracts, IdentityGuard {\n  /// @dev value is equal to keccak256(\"@ronin.dpos.collections.HasContracts.slot\") - 1\n  bytes32 private constant _STORAGE_SLOT = 0xdea3103d22025c269050bea94c0c84688877f12fa22b7e6d2d5d78a9a49aa1cb;\n\n  /**\n   * @dev Modifier to restrict access to functions only to contracts with a specific role.\n   * @param contractType The contract type that allowed to call\n   */\n  modifier onlyContract(ContractType contractType) virtual {\n    _requireContract(contractType);\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function setContract(ContractType contractType, address addr) external virtual onlyAdmin {\n    _requireHasCode(addr);\n    _setContract(contractType, addr);\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function getContract(ContractType contractType) public view returns (address contract_) {\n    contract_ = _getContractMap()[uint8(contractType)];\n    if (contract_ == address(0)) revert ErrContractTypeNotFound(contractType);\n  }\n\n  /**\n   * @dev Internal function to set the address of a contract with a specific role.\n   * @param contractType The contract type of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function _setContract(ContractType contractType, address addr) internal virtual {\n    _getContractMap()[uint8(contractType)] = addr;\n    emit ContractUpdated(contractType, addr);\n  }\n\n  /**\n   * @dev Internal function to access the mapping of contract addresses with roles.\n   * @return contracts_ The mapping of contract addresses with roles.\n   */\n  function _getContractMap() private pure returns (mapping(uint8 => address) storage contracts_) {\n    assembly {\n      contracts_.slot := _STORAGE_SLOT\n    }\n  }\n\n  /**\n   * @dev Internal function to check if the calling contract has a specific role.\n   * @param contractType The contract type that the calling contract must have.\n   * @dev Throws an error if the calling contract does not have the specified role.\n   */\n  function _requireContract(ContractType contractType) private view {\n    if (msg.sender != getContract(contractType)) {\n      revert ErrUnexpectedInternalCall(msg.sig, contractType, msg.sender);\n    }\n  }\n}\n"
    },
    "contracts/extensions/collections/HasProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../utils/CommonErrors.sol\";\n\nabstract contract HasProxyAdmin {\n  // bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n  bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  modifier onlyAdmin() {\n    _requireAdmin();\n    _;\n  }\n\n  /**\n   * @dev Returns proxy admin.\n   */\n  function _getAdmin() internal view virtual returns (address) {\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  function _requireAdmin() internal view {\n    if (msg.sender != _getAdmin()) revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\n  }\n}\n"
    },
    "contracts/extensions/TransparentUpgradeableProxyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract TransparentUpgradeableProxyV2 is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n\n  /**\n   * @dev Calls a function from the current implementation as specified by `_data`, which should be an encoded function call.\n   *\n   * Requirements:\n   * - Only the admin can call this function.\n   *\n   * Note: The proxy admin is not allowed to interact with the proxy logic through the fallback function to avoid\n   * triggering some unexpected logic. This is to allow the administrator to explicitly call the proxy, please consider\n   * reviewing the encoded data `_data` and the method which is called before using this.\n   *\n   */\n  function functionDelegateCall(bytes memory _data) public payable ifAdmin {\n    address _addr = _implementation();\n    assembly {\n      let _result := delegatecall(gas(), _addr, add(_data, 32), mload(_data), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch _result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/interfaces/collections/IHasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { ContractType } from \"../../utils/ContractType.sol\";\n\ninterface IHasContracts {\n  /// @dev Error of invalid role.\n  error ErrContractTypeNotFound(ContractType contractType);\n\n  /// @dev Emitted when a contract is updated.\n  event ContractUpdated(ContractType indexed contractType, address indexed addr);\n\n  /**\n   * @dev Returns the address of a contract with a specific role.\n   * Throws an error if no contract is set for the specified role.\n   *\n   * @param contractType The role of the contract to retrieve.\n   * @return contract_ The address of the contract with the specified role.\n   */\n  function getContract(ContractType contractType) external view returns (address contract_);\n\n  /**\n   * @dev Sets the address of a contract with a specific role.\n   * Emits the event {ContractUpdated}.\n   * @param contractType The role of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function setContract(ContractType contractType, address addr) external;\n}\n"
    },
    "contracts/interfaces/IProfile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../utils/RoleAccess.sol\";\n\ninterface IProfile {\n  struct CandidateProfile {\n    /**\n     * @dev Primary key of the profile, use for backward querying.\n     *\n     * {Staking} Contract: index of pool\n     * {RoninValidatorSet} Contract: index of almost all data related to a validator\n     *\n     */\n    address id;\n    /// @dev Consensus address.\n    address consensus;\n    /// @dev Pool admin address.\n    address admin;\n    /// @dev Treasury address.\n    address payable treasury;\n    /// @dev Address to voting proposal.\n    address governor;\n    /// @dev Public key for fast finality.\n    bytes pubkey;\n  }\n\n  /// @dev Event emitted when a profile with `id` is added.\n  event ProfileAdded(address indexed id);\n  /// @dev Event emitted when a address in a profile is changed.\n  event ProfileAddressChanged(address indexed id, RoleAccess indexed addressType);\n  /// @dev Event emitted when the pubkey of the `id` is changed.\n  event PubkeyChanged(address indexed id, bytes pubkey);\n\n  /// @dev Error of already existed profile.\n  error ErrExistentProfile();\n  /// @dev Error of non existed profile.\n  error ErrNonExistentProfile();\n  /// @dev Error when create a new profile whose id and consensus are not identical.\n  error ErrIdAndConsensusDiffer();\n  /**\n   * @dev Error when there is a duplicated info of `value`, which is uin256-padding value of any address or hash of public key,\n   * and with value type of `infoType`.\n   */\n  error ErrDuplicatedInfo(RoleAccess infoType, uint256 value);\n  error ErrDuplicatedPubkey(bytes pubkey);\n  error ErrZeroAddress(RoleAccess infoType);\n  error ErrZeroPubkey();\n\n  /// @dev Getter to query full `profile` from `id` address.\n  function getId2Profile(address id) external view returns (CandidateProfile memory profile);\n\n  /**\n   * @notice Add a new profile.\n   *\n   * @dev Requirements:\n   * - The profile must not be existent before.\n   * - Only contract admin can call this method.\n   */\n  function addNewProfile(CandidateProfile memory profile) external;\n\n  /**\n   * @notice The candidate admin registers a new profile.\n   *\n   * @dev Requirements:\n   * - The profile must not be existent before.\n   * - Only user with candidate admin role can call this method.\n   */\n\n  function registerProfile(CandidateProfile memory profile) external;\n\n  /**\n   * @notice The candidate admin changes the public key.\n   *\n   * @dev Requirements:\n   * - The profile must be existed.\n   * - Only user with candidate admin role can call this method.\n   * - New public key must not be duplicated.\n   */\n\n  function changePubkey(address id, bytes memory pubkey) external;\n}\n"
    },
    "contracts/interfaces/validator/ICandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ICandidateManager {\n  struct ValidatorCandidate {\n    // Admin of the candidate\n    address admin;\n    // Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n    address consensusAddr;\n    // Address that receives mining reward of the validator\n    address payable treasuryAddr;\n    // Address of the bridge operator corresponding to the candidate\n    address ______deprecatedbridgeOperatorAddr;\n    // The percentage of reward that validators can be received, the rest goes to the delegators.\n    // Values in range [0; 100_00] stands for 0-100%\n    uint256 commissionRate;\n    // The timestamp that scheduled to revoke the candidate (no schedule=0)\n    uint256 revokingTimestamp;\n    // The deadline that the candidate must top up staking amount to keep it larger than or equal to the threshold (no deadline=0)\n    uint256 topupDeadline;\n  }\n\n  struct CommissionSchedule {\n    // The timestamp that the commission schedule gets affected (no schedule=0).\n    uint256 effectiveTimestamp;\n    // The new commission rate. Value is in range [0; 100_00], stands for 0-100%\n    uint256 commissionRate;\n  }\n\n  /// @dev Emitted when the maximum number of validator candidates is updated.\n  event MaxValidatorCandidateUpdated(uint256 threshold);\n  /// @dev Emitted when the min offset to the effective date of commission rate change is updated.\n  event MinEffectiveDaysOnwardsUpdated(uint256 numOfDays);\n  /// @dev Emitted when the validator candidate is granted.\n  event CandidateGranted(address indexed consensusAddr, address indexed treasuryAddr, address indexed admin);\n  /// @dev Emitted when the revoking timestamp of a candidate is updated.\n  event CandidateRevokingTimestampUpdated(address indexed consensusAddr, uint256 revokingTimestamp);\n  /// @dev Emitted when the topup deadline of a candidate is updated.\n  event CandidateTopupDeadlineUpdated(address indexed consensusAddr, uint256 topupDeadline);\n  /// @dev Emitted when the validator candidate is revoked.\n  event CandidatesRevoked(address[] consensusAddrs);\n\n  /// @dev Emitted when a schedule for updating commission rate is set.\n  event CommissionRateUpdateScheduled(address indexed consensusAddr, uint256 effectiveTimestamp, uint256 rate);\n  /// @dev Emitted when the commission rate of a validator is updated.\n  event CommissionRateUpdated(address indexed consensusAddr, uint256 rate);\n\n  /// @dev Error of exceeding maximum number of candidates.\n  error ErrExceedsMaxNumberOfCandidate();\n  /// @dev Error of querying for already existent candidate.\n  error ErrExistentCandidate();\n  /// @dev Error of querying for non-existent candidate.\n  error ErrNonExistentCandidate();\n  /// @dev Error of candidate admin already exists.\n  error ErrExistentCandidateAdmin(address _candidateAdminAddr);\n  /// @dev Error of treasury already exists.\n  error ErrExistentTreasury(address _treasuryAddr);\n  /// @dev Error of invalid commission rate.\n  error ErrInvalidCommissionRate();\n  /// @dev Error of invalid effective days onwards.\n  error ErrInvalidEffectiveDaysOnwards();\n  /// @dev Error of invalid min effective days onwards.\n  error ErrInvalidMinEffectiveDaysOnwards();\n  /// @dev Error of already requested revoking candidate before.\n  error ErrAlreadyRequestedRevokingCandidate();\n  /// @dev Error of commission change schedule exists.\n  error ErrAlreadyRequestedUpdatingCommissionRate();\n  /// @dev Error of trusted org cannot renounce.\n  error ErrTrustedOrgCannotRenounce();\n\n  /**\n   * @dev Returns the maximum number of validator candidate.\n   */\n  function maxValidatorCandidate() external view returns (uint256);\n\n  /**\n   * @dev Returns the minimum number of days to the effective date of commission rate change.\n   */\n  function minEffectiveDaysOnward() external view returns (uint256);\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function setMaxValidatorCandidate(uint256) external;\n\n  /**\n   * @dev Sets the minimum number of days to the effective date of commision rate change.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external;\n\n  /**\n   * @dev Grants a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateGranted`.\n   *\n   */\n  function execApplyValidatorCandidate(\n    address _admin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    uint256 _commissionRate\n  ) external;\n\n  /**\n   * @dev Requests to revoke a validator candidate in next `_secsLeft` seconds.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateRevokingTimestampUpdated`.\n   *\n   */\n  function execRequestRenounceCandidate(address, uint256 _secsLeft) external;\n\n  /**\n   * @dev Fallback function of `CandidateStaking-requestUpdateCommissionRate`.\n   *\n   * Requirements:\n   * - The method caller is the staking contract.\n   * - The `_effectiveTimestamp` must be the beginning of a UTC day, and at least from 7 days onwards\n   * - The `_rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdateScheduled`.\n   *\n   */\n  function execRequestUpdateCommissionRate(address _consensusAddr, uint256 _effectiveTimestamp, uint256 _rate) external;\n\n  /**\n   * @dev Returns whether the address is a validator (candidate).\n   */\n  function isValidatorCandidate(address _addr) external view returns (bool);\n\n  /**\n   * @dev Returns the validator candidate.\n   */\n  function getValidatorCandidates() external view returns (address[] memory);\n\n  /**\n   * @dev Returns all candidate info.\n   */\n  function getCandidateInfos() external view returns (ValidatorCandidate[] memory);\n\n  /**\n   * @dev Returns the info of a candidate.\n   */\n  function getCandidateInfo(address _candidate) external view returns (ValidatorCandidate memory);\n\n  /**\n   * @dev Returns whether the address is the candidate admin.\n   */\n  function isCandidateAdmin(address _candidate, address _admin) external view returns (bool);\n\n  /**\n   * @dev Returns the schedule of changing commission rate of a candidate address.\n   */\n  function getCommissionChangeSchedule(address _candidate) external view returns (CommissionSchedule memory);\n}\n"
    },
    "contracts/interfaces/validator/ICoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashingExecution.sol\";\n\ninterface ICoinbaseExecution is ISlashingExecution {\n  enum BlockRewardDeprecatedType {\n    UNKNOWN,\n    UNAVAILABILITY,\n    AFTER_BAILOUT\n  }\n\n  /// @dev Emitted when the validator set is updated\n  event ValidatorSetUpdated(uint256 indexed period, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated, to mirror the in-jail and maintaining status of the validator.\n  event BlockProducerSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated.\n  event BridgeOperatorSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] bridgeOperators);\n\n  /// @dev Emitted when the reward of the block producer is deprecated.\n  event BlockRewardDeprecated(\n    address indexed coinbaseAddr,\n    uint256 rewardAmount,\n    BlockRewardDeprecatedType deprecatedType\n  );\n  /// @dev Emitted when the block reward is submitted.\n  event BlockRewardSubmitted(address indexed coinbaseAddr, uint256 submittedAmount, uint256 bonusAmount);\n\n  /// @dev Emitted when the block producer reward is distributed.\n  event MiningRewardDistributed(address indexed consensusAddr, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the block producer reward.\n  event MiningRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the bridge operator reward is distributed.\n  event BridgeOperatorRewardDistributed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipientAddr,\n    uint256 amount\n  );\n  /// @dev Emitted when the contract fails when distributing the bridge operator reward.\n  event BridgeOperatorRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the fast finality reward is distributed.\n  event FastFinalityRewardDistributed(address indexed consensusAddr, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the fast finality reward.\n  event FastFinalityRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the amount of RON reward is distributed to staking contract.\n  event StakingRewardDistributed(uint256 totalAmount, address[] consensusAddrs, uint256[] amounts);\n  /// @dev Emitted when the contracts fails when distributing the amount of RON to the staking contract.\n  event StakingRewardDistributionFailed(\n    uint256 totalAmount,\n    address[] consensusAddrs,\n    uint256[] amounts,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the epoch is wrapped up.\n  event WrappedUpEpoch(uint256 indexed periodNumber, uint256 indexed epochNumber, bool periodEnding);\n\n  /// @dev Error of only allowed at the end of epoch\n  error ErrAtEndOfEpochOnly();\n  /// @dev Error of query for already wrapped up epoch\n  error ErrAlreadyWrappedEpoch();\n\n  /**\n   * @dev Submits reward of the current block.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDeprecated` if the coinbase is slashed or no longer be a block producer.\n   * Emits the event `BlockRewardSubmitted` for the valid call.\n   *\n   */\n  function submitBlockReward() external payable;\n\n  /**\n   * @dev Wraps up the current epoch.\n   *\n   * Requirements:\n   * - The method must be called when the current epoch is ending.\n   * - The epoch is not wrapped yet.\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDistributed` when some validator has reward distributed.\n   * Emits the event `StakingRewardDistributed` when some staking pool has reward distributed.\n   * Emits the event `BlockProducerSetUpdated` when the epoch is wrapped up.\n   * Emits the event `BridgeOperatorSetUpdated` when the epoch is wrapped up at period ending.\n   * Emits the event `ValidatorSetUpdated` when the epoch is wrapped up at period ending, and the validator set gets updated.\n   * Emits the event `WrappedUpEpoch`.\n   *\n   */\n  function wrapUpEpoch() external payable;\n}\n"
    },
    "contracts/interfaces/validator/IEmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IEmergencyExit {\n  /// @dev Emitted when the fund is locked from an emergency exit request\n  event EmergencyExitRequested(address indexed consensusAddr, uint256 lockedAmount);\n  /// @dev Emitted when the fund that locked from an emergency exit request is transferred to the recipient.\n  event EmergencyExitLockedFundReleased(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount\n  );\n  /// @dev Emitted when the fund that locked from an emergency exit request is failed to transferred back.\n  event EmergencyExitLockedFundReleasingFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the emergency exit locked amount is updated.\n  event EmergencyExitLockedAmountUpdated(uint256 amount);\n  /// @dev Emitted when the emergency expiry duration is updated.\n  event EmergencyExpiryDurationUpdated(uint256 amount);\n\n  /// @dev Error of already requested emergency exit before.\n  error ErrAlreadyRequestedEmergencyExit();\n\n  /**\n   * @dev Returns the amount of RON to lock from a consensus address.\n   */\n  function emergencyExitLockedAmount() external returns (uint256);\n\n  /**\n   * @dev Returns the duration that an emergency request is expired and the fund will be recycled.\n   */\n  function emergencyExpiryDuration() external returns (uint256);\n\n  /**\n   * @dev Sets the amount of RON to lock from a consensus address.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedAmountUpdated`.\n   *\n   */\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external;\n\n  /**\n   * @dev Sets the duration that an emergency request is expired and the fund will be recycled.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExpiryDurationUpdated`.\n   *\n   */\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external;\n\n  /**\n   * @dev Unlocks fund for emergency exit request.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedFundReleased` if the fund is successfully unlocked.\n   * Emits the event `EmergencyExitLockedFundReleasingFailed` if the fund is failed to unlock.\n   *\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(address _consensusAddr, address payable _recipient) external;\n\n  /**\n   * @dev Fallback function of `IStaking-requestEmergencyExit`.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   */\n  function execEmergencyExit(address _consensusAddr, uint256 _secLeftToRevoke) external;\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ICommonInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IJailingInfo.sol\";\nimport \"./ITimingInfo.sol\";\nimport \"./IValidatorInfoV2.sol\";\n\ninterface ICommonInfo is ITimingInfo, IJailingInfo, IValidatorInfoV2 {\n  struct EmergencyExitInfo {\n    uint256 lockedAmount;\n    // The timestamp that this locked amount will be recycled to staking vesting contract\n    uint256 recyclingAt;\n  }\n\n  /// @dev Emitted when the deprecated reward is withdrawn.\n  event DeprecatedRewardRecycled(address indexed recipientAddr, uint256 amount);\n  /// @dev Emitted when the deprecated reward withdrawal is failed\n  event DeprecatedRewardRecycleFailed(address indexed recipientAddr, uint256 amount, uint256 balance);\n\n  /// @dev Error thrown when receives RON from neither staking vesting contract nor staking contract\n  error ErrUnauthorizedReceiveRON();\n  /// @dev Error thrown when queries for a non existent info.\n  error NonExistentRecyclingInfo();\n\n  /**\n   * @dev Returns the total deprecated reward, which includes reward that is not sent for slashed validators and unsastified bridge operators\n   */\n  function totalDeprecatedReward() external view returns (uint256);\n\n  /**\n   * @dev Returns the emergency exit request.\n   */\n  function getEmergencyExitInfo(address _consensusAddr) external view returns (EmergencyExitInfo memory);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IJailingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IJailingInfo {\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkJailed(address) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeft(\n    address _addr\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) at a specific block.\n   */\n  function checkJailedAtBlock(address _addr, uint256 _blockNum) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail at a specific block and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeftAtBlock(\n    address _addr,\n    uint256 _blockNum\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validators are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkManyJailed(address[] calldata) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during the current period.\n   */\n  function checkMiningRewardDeprecated(address _blockProducer) external view returns (bool);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during a specific period.\n   */\n  function checkMiningRewardDeprecatedAtPeriod(address _blockProducer, uint256 _period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ITimingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ITimingInfo {\n  /**\n   * @dev Returns the block that validator set was updated.\n   */\n  function getLastUpdatedBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of blocks in a epoch.\n   */\n  function numberOfBlocksInEpoch() external view returns (uint256 _numberOfBlocks);\n\n  /**\n   * @dev Returns the epoch index from the block number.\n   */\n  function epochOf(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Returns whether the epoch ending is at the block number `_block`.\n   */\n  function epochEndingAt(uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Tries to get the period index from the epoch number.\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber);\n\n  /**\n   * @dev Returns whether the period ending at the current block number.\n   */\n  function isPeriodEnding() external view returns (bool);\n\n  /**\n   * @dev Returns the period index from the current block.\n   */\n  function currentPeriod() external view returns (uint256);\n\n  /**\n   * @dev Returns the block number that the current period starts at.\n   */\n  function currentPeriodStartAtBlock() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IValidatorInfoV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\n\ninterface IValidatorInfoV2 {\n  /**\n   * @dev Error thrown when an invalid maximum prioritized validator number is provided.\n   */\n  error ErrInvalidMaxPrioritizedValidatorNumber();\n\n  /// @dev Emitted when the number of max validator is updated.\n  event MaxValidatorNumberUpdated(uint256);\n  /// @dev Emitted when the number of reserved slots for prioritized validators is updated.\n  event MaxPrioritizedValidatorNumberUpdated(uint256);\n\n  /**\n   * @dev Returns the maximum number of validators in the epoch.\n   */\n  function maxValidatorNumber() external view returns (uint256 _maximumValidatorNumber);\n\n  /**\n   * @dev Returns the number of reserved slots for prioritized validators.\n   */\n  function maxPrioritizedValidatorNumber() external view returns (uint256 _maximumPrioritizedValidatorNumber);\n\n  /**\n   * @dev Returns the current validator list.\n   */\n  function getValidators() external view returns (address[] memory _validatorList);\n\n  /**\n   * @dev Returns the current block producer list.\n   */\n  function getBlockProducers() external view returns (address[] memory);\n\n  /**\n   * @dev Returns whether the address is block producer or not.\n   */\n  function isBlockProducer(address _addr) external view returns (bool);\n\n  /**\n   * @dev Returns total numbers of the block producers.\n   */\n  function totalBlockProducer() external view returns (uint256);\n\n  /**\n   * @dev Updates the max validator number\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxValidatorNumberUpdated`\n   *\n   */\n  function setMaxValidatorNumber(uint256 _maxValidatorNumber) external;\n\n  /**\n   * @dev Updates the number of reserved slots for prioritized validators\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxPrioritizedValidatorNumberUpdated`\n   *\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _maxPrioritizedValidatorNumber) external;\n}\n"
    },
    "contracts/interfaces/validator/IRoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ICandidateManager.sol\";\nimport \"./info-fragments/ICommonInfo.sol\";\nimport \"./ICoinbaseExecution.sol\";\nimport \"./ISlashingExecution.sol\";\nimport \"./IEmergencyExit.sol\";\n\ninterface IRoninValidatorSet is\n  ICandidateManager,\n  ICommonInfo,\n  ISlashingExecution,\n  ICoinbaseExecution,\n  IEmergencyExit\n{}\n"
    },
    "contracts/interfaces/validator/ISlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISlashingExecution {\n  /// @dev Emitted when the validator is punished.\n  event ValidatorPunished(\n    address indexed consensusAddr,\n    uint256 indexed period,\n    uint256 jailedUntil,\n    uint256 deductedStakingAmount,\n    bool blockProducerRewardDeprecated,\n    bool bridgeOperatorRewardDeprecated\n  );\n  /// @dev Emitted when the validator get out of jail by bailout.\n  event ValidatorUnjailed(address indexed validator, uint256 period);\n\n  /// @dev Error of cannot bailout due to high tier slash.\n  error ErrCannotBailout(address validator);\n\n  /**\n   * @dev Finalize the slash request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorPunished`.\n   *\n   */\n  function execSlash(address validatorAddr, uint256 newJailedUntil, uint256 slashAmount, bool cannotBailout) external;\n\n  /**\n   * @dev Finalize the bailout request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorUnjailed`.\n   *\n   */\n  function execBailOut(address _validatorAddr, uint256 _period) external;\n}\n"
    },
    "contracts/libraries/AddressArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary AddressArrayUtils {\n  /**\n   * @dev Error thrown when a duplicated element is detected in an array.\n   * @param msgSig The function signature that invoke the error.\n   */\n  error ErrDuplicated(bytes4 msgSig);\n\n  /**\n   * @dev Returns whether or not there's a duplicate. Runs in O(n^2).\n   * @param A Array to search\n   * @return Returns true if duplicate, false otherwise\n   */\n  function hasDuplicate(address[] memory A) internal pure returns (bool) {\n    if (A.length == 0) {\n      return false;\n    }\n    unchecked {\n      for (uint256 i = 0; i < A.length - 1; i++) {\n        for (uint256 j = i + 1; j < A.length; j++) {\n          if (A[i] == A[j]) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @dev Returns whether two arrays of addresses are equal or not.\n   */\n  function isEqual(address[] memory _this, address[] memory _other) internal pure returns (bool yes_) {\n    // Hashing two arrays and compare their hash\n    assembly {\n      let _thisHash := keccak256(add(_this, 32), mul(mload(_this), 32))\n      let _otherHash := keccak256(add(_other, 32), mul(mload(_other), 32))\n      yes_ := eq(_thisHash, _otherHash)\n    }\n  }\n\n  /**\n   * @dev Return the concatenated array from a and b.\n   */\n  function extend(address[] memory a, address[] memory b) internal pure returns (address[] memory c) {\n    uint256 lengthA = a.length;\n    uint256 lengthB = b.length;\n    unchecked {\n      c = new address[](lengthA + lengthB);\n    }\n    uint256 i;\n    for (; i < lengthA; ) {\n      c[i] = a[i];\n      unchecked {\n        ++i;\n      }\n    }\n    for (uint256 j; j < lengthB; ) {\n      c[i] = b[j];\n      unchecked {\n        ++i;\n        ++j;\n      }\n    }\n  }\n}\n"
    },
    "contracts/libraries/EnumFlags.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This library implements checking flag of an enumerated value.\n * The originated idea is inherited from [Enum.HashFlag(Enum)](https://learn.microsoft.com/en-us/dotnet/api/system.enum.hasflag?view=net-6.0) method of C#.\n */\nlibrary EnumFlags {\n  enum ValidatorFlag {\n    None, // bit(00)\n    BlockProducer, // bit(01)\n    DeprecatedBridgeOperator, // bit(10)\n    Both // bit(11)\n  }\n\n  function isNone(ValidatorFlag _value) internal pure returns (bool) {\n    return uint8(_value) == 0;\n  }\n\n  /**\n   * @dev Checks if `_value` has `_flag`.\n   */\n  function hasFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (bool) {\n    return (uint8(_value) & uint8(_flag)) != 0;\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after adding `_flag`.\n   */\n  function addFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) | uint8(_flag));\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after remove `_flag`.\n   */\n  function removeFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) & ~uint8(_flag));\n  }\n}\n"
    },
    "contracts/ronin/profile/Profile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/validator/ICandidateManager.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport { ErrUnauthorized, RoleAccess } from \"../../utils/CommonErrors.sol\";\nimport { ContractType } from \"../../utils/ContractType.sol\";\nimport \"./ProfileHandler.sol\";\n\npragma solidity ^0.8.9;\n\ncontract Profile is IProfile, ProfileHandler, Initializable {\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address validatorContract) external initializer {\n    _setContract(ContractType.VALIDATOR, validatorContract);\n  }\n\n  function migrateTestnet() external {\n    require(block.chainid == 2021, \"mismatch chainID\");\n    require(msg.sender == 0x968D0Cd7343f711216817E617d3f92a23dC91c07, \"not testnet admin\");\n\n    CandidateProfile storage _profile;\n\n    address[11] memory consensusList = [\n      0xCaba9D9424D6bAD99CE352A943F59279B533417a,\n      0x9f1Abc67beA4db5560371fF3089F4Bfe934c36Bc,\n      0xA85ddDdCeEaB43DccAa259dd4936aC104386F9aa,\n      0xAcf8Bf98D1632e602d0B1761771049aF21dd6597,\n      0xE9bf2A788C27dADc6B169d52408b710d267b9bff,\n      0xD086D2e3Fac052A3f695a4e8905Ce1722531163C,\n      0x9687e8C41fa369aD08FD278a43114C4207856a61,\n      0xa325Fd3a2f4f5CafE2c151eE428b5CeDeD628193,\n      0x9422d990AcDc3f2b3AA3B97303aD3060F09d7ffC,\n      0xc3C97512421BF3e339E9fd412f18584e53138bFA,\n      0x78fD38faa30ea66702cc39383D2E84f9a4A56fA6\n    ];\n\n    for (uint i; i < consensusList.length; i++) {\n      _migrateTestnetHelper(consensusList[i]);\n    }\n\n    {\n      _profile = _getId2ProfileHelper(0xCaba9D9424D6bAD99CE352A943F59279B533417a);\n      _setGovernor(_profile, 0xb033ba62EC622dC54D0ABFE0254e79692147CA26);\n    }\n    {\n      _profile = _getId2ProfileHelper(0x9f1Abc67beA4db5560371fF3089F4Bfe934c36Bc);\n      _setGovernor(_profile, 0x087D08e3ba42e64E3948962dd1371F906D1278b9);\n    }\n    {\n      _profile = _getId2ProfileHelper(0xA85ddDdCeEaB43DccAa259dd4936aC104386F9aa);\n      _setGovernor(_profile, 0x52ec2e6BBcE45AfFF8955Da6410bb13812F4289F);\n    }\n    {\n      _profile = _getId2ProfileHelper(0xAcf8Bf98D1632e602d0B1761771049aF21dd6597);\n      _setGovernor(_profile, 0xd24D87DDc1917165435b306aAC68D99e0F49A3Fa);\n    }\n  }\n\n  function migrateTestnetManual(address consensus, address governor) external {\n    require(block.chainid == 2021, \"mismatch chainID\");\n    require(msg.sender == 0x968D0Cd7343f711216817E617d3f92a23dC91c07, \"not testnet admin\");\n\n    _migrateTestnetHelper(consensus);\n    if (governor != address(0)) {\n      CandidateProfile storage _profile = _getId2ProfileHelper(consensus);\n      _setGovernor(_profile, governor);\n    }\n  }\n\n  function _migrateTestnetHelper(address consensus) internal {\n    CandidateProfile storage _profile = _getId2ProfileHelper(consensus);\n    ICandidateManager.ValidatorCandidate memory info = IRoninValidatorSet(getContract(ContractType.VALIDATOR))\n      .getCandidateInfo(consensus);\n    _setConsensus(_profile, consensus);\n    _setAdmin(_profile, info.admin);\n    _setTreasury(_profile, payable(info.treasuryAddr));\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getId2Profile(address id) external view returns (CandidateProfile memory) {\n    return _id2Profile[id];\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function addNewProfile(CandidateProfile memory profile) external onlyAdmin {\n    CandidateProfile storage _profile = _id2Profile[profile.id];\n    if (_profile.id != address(0)) revert ErrExistentProfile();\n    _addNewProfile(_profile, profile);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function registerProfile(CandidateProfile memory profile) external {\n    if (profile.id != profile.consensus) revert ErrIdAndConsensusDiffer();\n\n    CandidateProfile storage _profile = _id2Profile[profile.id];\n    if (_profile.id != address(0)) revert ErrExistentProfile();\n    if (\n      msg.sender != profile.admin ||\n      !IRoninValidatorSet(getContract(ContractType.VALIDATOR)).isCandidateAdmin(profile.consensus, profile.admin)\n    ) revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\n    _checkDuplicatedInRegistry(profile);\n\n    _addNewProfile(_profile, profile);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function changePubkey(address id, bytes memory pubkey) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    if (msg.sender != _profile.admin) revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\n    _checkNonDuplicatedPubkey(pubkey);\n    _setPubkey(_profile, pubkey);\n\n    emit PubkeyChanged(id, pubkey);\n  }\n}\n"
    },
    "contracts/ronin/profile/ProfileHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../utils/RoleAccess.sol\";\nimport { ProfileStorage } from \"./ProfileStorage.sol\";\n\nabstract contract ProfileHandler is ProfileStorage {\n  /**\n   * @dev Checks each element in the new profile and reverts if there is duplication with any existing profile.\n   */\n  function _checkDuplicatedInRegistry(CandidateProfile memory profile) internal view {\n    _checkNonZeroAndNonDuplicated(RoleAccess.CONSENSUS, profile.consensus);\n    _checkNonZeroAndNonDuplicated(RoleAccess.CANDIDATE_ADMIN, profile.admin);\n    _checkNonZeroAndNonDuplicated(RoleAccess.TREASURY, profile.treasury);\n    _checkNonDuplicated(RoleAccess.TREASURY, profile.governor);\n    _checkNonDuplicatedPubkey(profile.pubkey);\n  }\n\n  function _checkNonZeroAndNonDuplicated(RoleAccess addressType, address addr) internal view {\n    if (addr == address(0)) revert ErrZeroAddress(addressType);\n    _checkNonDuplicated(addressType, addr);\n  }\n\n  function _checkNonDuplicated(RoleAccess addressType, address addr) internal view {\n    if (_registry[uint256(uint160(addr))]) {\n      revert ErrDuplicatedInfo(addressType, uint256(uint160(addr)));\n    }\n  }\n\n  function _checkNonDuplicatedPubkey(bytes memory pubkey) internal view {\n    if (_registry[_hashPubkey(pubkey)]) {\n      revert ErrDuplicatedPubkey(pubkey);\n    }\n  }\n}\n"
    },
    "contracts/ronin/profile/ProfileStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { IProfile } from \"../../interfaces/IProfile.sol\";\n\nabstract contract ProfileStorage is IProfile, HasContracts {\n  /// @dev Mapping from id address => candidate profile.\n  mapping(address => CandidateProfile) internal _id2Profile;\n  /**\n   * @dev Mapping from any address or keccak256(pubkey) => whether it is already registered.\n   * This registry can only be toggled to `true` and NOT vice versa. All registered values\n   * cannot be reused.\n   */\n  mapping(uint256 => bool) internal _registry;\n  /// @dev Upgradeable gap.\n  bytes32[49] __gap;\n\n  /**\n   * @dev Add a profile from memory to storage.\n   */\n  function _addNewProfile(CandidateProfile storage _profile, CandidateProfile memory newProfile) internal {\n    _profile.id = newProfile.id;\n\n    _setConsensus(_profile, newProfile.consensus);\n    _setAdmin(_profile, newProfile.admin);\n    _setTreasury(_profile, newProfile.treasury);\n    _setGovernor(_profile, newProfile.governor);\n    _setPubkey(_profile, newProfile.pubkey);\n\n    emit ProfileAdded(newProfile.id);\n  }\n\n  function _setConsensus(CandidateProfile storage _profile, address consensus) internal {\n    _profile.consensus = consensus;\n    _registry[uint256(uint160(consensus))] = true;\n  }\n\n  function _setAdmin(CandidateProfile storage _profile, address admin) internal {\n    _profile.admin = admin;\n    _registry[uint256(uint160(admin))] = true;\n  }\n\n  function _setTreasury(CandidateProfile storage _profile, address payable treasury) internal {\n    _profile.treasury = treasury;\n    _registry[uint256(uint160(address(treasury)))] = true;\n  }\n\n  /**\n   * @dev Allow to registry a profile without governor address since not all validators are governing validators.\n   */\n  function _setGovernor(CandidateProfile storage _profile, address governor) internal {\n    _profile.governor = governor;\n    if (governor != address(0)) {\n      _registry[uint256(uint160(governor))] = true;\n    }\n  }\n\n  function _setPubkey(CandidateProfile storage _profile, bytes memory pubkey) internal {\n    _profile.pubkey = pubkey;\n    _registry[_hashPubkey(pubkey)] = true;\n  }\n\n  /**\n   * @dev Get an existed profile struct from `id`. Revert if the profile does not exists.\n   */\n  function _getId2ProfileHelper(address id) internal view returns (CandidateProfile storage _profile) {\n    _profile = _id2Profile[id];\n    if (_profile.id == address(0)) revert ErrNonExistentProfile();\n  }\n\n  /**\n   * @dev Returns hash of a public key.\n   */\n  function _hashPubkey(bytes memory pubkey) internal pure returns (uint256) {\n    return uint256(keccak256(pubkey));\n  }\n}\n"
    },
    "contracts/utils/CommonErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ContractType } from \"./ContractType.sol\";\nimport { RoleAccess } from \"./RoleAccess.sol\";\n\nerror ErrSyncTooFarPeriod(uint256 period, uint256 latestRewardedPeriod);\n/**\n * @dev Error thrown when an address is expected to be an already created externally owned account (EOA).\n * This error indicates that the provided address is invalid for certain contract operations that require already created EOA.\n */\nerror ErrAddressIsNotCreatedEOA(address addr, bytes32 codehash);\n/**\n * @dev Error raised when a bridge operator update operation fails.\n * @param bridgeOperator The address of the bridge operator that failed to update.\n */\nerror ErrBridgeOperatorUpdateFailed(address bridgeOperator);\n/**\n * @dev Error thrown when attempting to add a bridge operator that already exists in the contract.\n * This error indicates that the provided bridge operator address is already registered as a bridge operator in the contract.\n */\nerror ErrBridgeOperatorAlreadyExisted(address bridgeOperator);\n/**\n * @dev The error indicating an unsupported interface.\n * @param interfaceId The bytes4 interface identifier that is not supported.\n * @param addr The address where the unsupported interface was encountered.\n */\nerror ErrUnsupportedInterface(bytes4 interfaceId, address addr);\n/**\n * @dev Error thrown when the return data from a callback function is invalid.\n * @param callbackFnSig The signature of the callback function that returned invalid data.\n * @param register The address of the register where the callback function was invoked.\n * @param returnData The invalid return data received from the callback function.\n */\nerror ErrInvalidReturnData(bytes4 callbackFnSig, address register, bytes returnData);\n/**\n * @dev Error of set to non-contract.\n */\nerror ErrZeroCodeContract(address addr);\n/**\n * @dev Error indicating that arguments are invalid.\n */\nerror ErrInvalidArguments(bytes4 msgSig);\n/**\n * @dev Error indicating that given address is null when it should not.\n */\nerror ErrZeroAddress(bytes4 msgSig);\n/**\n * @dev Error indicating that the provided threshold is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that the invalid threshold applies to.\n */\nerror ErrInvalidThreshold(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a function can only be called by the contract itself.\n * @param msgSig The function signature (bytes4) that can only be called by the contract itself.\n */\nerror ErrOnlySelfCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n * @param expectedRole The role required to perform the function.\n */\nerror ErrUnauthorized(bytes4 msgSig, RoleAccess expectedRole);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n */\nerror ErrUnauthorizedCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4).\n * @param expectedContractType The contract type required to perform the function.\n * @param actual The actual address that called to the function.\n */\nerror ErrUnexpectedInternalCall(bytes4 msgSig, ContractType expectedContractType, address actual);\n\n/**\n * @dev Error indicating that an array is empty when it should contain elements.\n */\nerror ErrEmptyArray();\n\n/**\n * @dev Error indicating a mismatch in the length of input parameters or arrays for a specific function.\n * @param msgSig The function signature (bytes4) that has a length mismatch.\n */\nerror ErrLengthMismatch(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a proxy call to an external contract has failed.\n * @param msgSig The function signature (bytes4) of the proxy call that failed.\n * @param extCallSig The function signature (bytes4) of the external contract call that failed.\n */\nerror ErrProxyCallFailed(bytes4 msgSig, bytes4 extCallSig);\n\n/**\n * @dev Error indicating that a function tried to call a precompiled contract that is not allowed.\n * @param msgSig The function signature (bytes4) that attempted to call a precompiled contract.\n */\nerror ErrCallPrecompiled(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a native token transfer has failed.\n * @param msgSig The function signature (bytes4) of the token transfer that failed.\n */\nerror ErrNativeTransferFailed(bytes4 msgSig);\n\n/**\n * @dev Error indicating that an order is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid order.\n */\nerror ErrInvalidOrder(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the chain ID is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid chain ID.\n * @param actual Current chain ID that executing function.\n * @param expected Expected chain ID required for the tx to success.\n */\nerror ErrInvalidChainId(bytes4 msgSig, uint256 actual, uint256 expected);\n\n/**\n * @dev Error indicating that a vote type is not supported.\n * @param msgSig The function signature (bytes4) of the operation that encountered an unsupported vote type.\n */\nerror ErrUnsupportedVoteType(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the proposal nonce is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid proposal nonce.\n */\nerror ErrInvalidProposalNonce(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a voter has already voted.\n * @param voter The address of the voter who has already voted.\n */\nerror ErrAlreadyVoted(address voter);\n\n/**\n * @dev Error indicating that a signature is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid signature.\n */\nerror ErrInvalidSignatures(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a relay call has failed.\n * @param msgSig The function signature (bytes4) of the relay call that failed.\n */\nerror ErrRelayFailed(bytes4 msgSig);\n/**\n * @dev Error indicating that a vote weight is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid vote weight.\n */\nerror ErrInvalidVoteWeight(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a query was made for an outdated bridge operator set.\n */\nerror ErrQueryForOutdatedBridgeOperatorSet();\n\n/**\n * @dev Error indicating that a request is invalid.\n */\nerror ErrInvalidRequest();\n\n/**\n * @dev Error indicating that a token standard is invalid.\n */\nerror ErrInvalidTokenStandard();\n\n/**\n * @dev Error indicating that a token is not supported.\n */\nerror ErrUnsupportedToken();\n\n/**\n * @dev Error indicating that a receipt kind is invalid.\n */\nerror ErrInvalidReceiptKind();\n\n/**\n * @dev Error indicating that a receipt is invalid.\n */\nerror ErrInvalidReceipt();\n\n/**\n * @dev Error indicating that an address is not payable.\n */\nerror ErrNonpayableAddress(address);\n\n/**\n * @dev Error indicating that the period is already processed, i.e. scattered reward.\n */\nerror ErrPeriodAlreadyProcessed(uint256 requestingPeriod, uint256 latestPeriod);\n\n/**\n * @dev Error thrown when an invalid vote hash is provided.\n */\nerror ErrInvalidVoteHash();\n\n/**\n * @dev Error thrown when querying for an empty vote.\n */\nerror ErrQueryForEmptyVote();\n\n/**\n * @dev Error thrown when querying for an expired vote.\n */\nerror ErrQueryForExpiredVote();\n\n/**\n * @dev Error thrown when querying for a non-existent vote.\n */\nerror ErrQueryForNonExistentVote();\n\n/**\n * @dev Error indicating that the method is only called once per block.\n */\nerror ErrOncePerBlock();\n\n/**\n * @dev Error of method caller must be coinbase\n */\nerror ErrCallerMustBeCoinbase();\n"
    },
    "contracts/utils/ContractType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum ContractType {\n  /*  0 */ UNKNOWN,\n  /*  1 */ PAUSE_ENFORCER,\n  /*  2 */ BRIDGE,\n  /*  3 */ BRIDGE_TRACKING,\n  /*  4 */ GOVERNANCE_ADMIN,\n  /*  5 */ MAINTENANCE,\n  /*  6 */ SLASH_INDICATOR,\n  /*  7 */ STAKING_VESTING,\n  /*  8 */ VALIDATOR,\n  /*  9 */ STAKING,\n  /* 10 */ RONIN_TRUSTED_ORGANIZATION,\n  /* 11 */ BRIDGE_MANAGER,\n  /* 12 */ BRIDGE_SLASH,\n  /* 13 */ BRIDGE_REWARD,\n  /* 14 */ FAST_FINALITY_TRACKING,\n  /* 15 */ PROFILE\n}\n"
    },
    "contracts/utils/IdentityGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { AddressArrayUtils } from \"../libraries/AddressArrayUtils.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { TransparentUpgradeableProxyV2 } from \"../extensions/TransparentUpgradeableProxyV2.sol\";\nimport { ErrAddressIsNotCreatedEOA, ErrZeroAddress, ErrOnlySelfCall, ErrZeroCodeContract, ErrUnsupportedInterface } from \"./CommonErrors.sol\";\n\nabstract contract IdentityGuard {\n  using AddressArrayUtils for address[];\n\n  /// @dev value is equal to keccak256(abi.encode())\n  /// @dev see: https://eips.ethereum.org/EIPS/eip-1052\n  bytes32 internal constant CREATED_ACCOUNT_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n  /**\n   * @dev Modifier to restrict functions to only be called by this contract.\n   * @dev Reverts if the caller is not this contract.\n   */\n  modifier onlySelfCall() virtual {\n    _requireSelfCall();\n    _;\n  }\n\n  /**\n   * @dev Modifier to ensure that the elements in the `arr` array are non-duplicates.\n   * It calls the internal `_checkDuplicate` function to perform the duplicate check.\n   *\n   * Requirements:\n   * - The elements in the `arr` array must not contain any duplicates.\n   */\n  modifier nonDuplicate(address[] memory arr) virtual {\n    _requireNonDuplicate(arr);\n    _;\n  }\n\n  /**\n   * @dev Internal method to check the method caller.\n   * @dev Reverts if the method caller is not this contract.\n   */\n  function _requireSelfCall() internal view virtual {\n    if (msg.sender != address(this)) revert ErrOnlySelfCall(msg.sig);\n  }\n\n  /**\n   * @dev Internal function to check if a contract address has code.\n   * @param addr The address of the contract to check.\n   * @dev Throws an error if the contract address has no code.\n   */\n  function _requireHasCode(address addr) internal view {\n    if (addr.code.length == 0) revert ErrZeroCodeContract(addr);\n  }\n\n  /**\n   * @dev Checks if an address is zero and reverts if it is.\n   * @param addr The address to check.\n   */\n  function _requireNonZeroAddress(address addr) internal pure {\n    if (addr == address(0)) revert ErrZeroAddress(msg.sig);\n  }\n\n  /**\n   * @dev Check if arr is empty and revert if it is.\n   * Checks if an array contains any duplicate addresses and reverts if duplicates are found.\n   * @param arr The array of addresses to check.\n   */\n  function _requireNonDuplicate(address[] memory arr) internal pure {\n    if (arr.hasDuplicate()) revert AddressArrayUtils.ErrDuplicated(msg.sig);\n  }\n\n  /**\n   * @dev Internal function to require that the provided address is a created externally owned account (EOA).\n   * This internal function is used to ensure that the provided address is a valid externally owned account (EOA).\n   * It checks the codehash of the address against a predefined constant to confirm that the address is a created EOA.\n   * @notice This method only works with non-state EOA accounts\n   */\n  function _requireCreatedEOA(address addr) internal view {\n    _requireNonZeroAddress(addr);\n    bytes32 codehash = addr.codehash;\n    if (codehash != CREATED_ACCOUNT_HASH) revert ErrAddressIsNotCreatedEOA(addr, codehash);\n  }\n\n  /**\n   * @dev Internal function to require that the specified contract supports the given interface. This method handle in\n   * both case that the callee is either or not the proxy admin of the caller. If the contract does not support the\n   * interface `interfaceId` or EIP165, a revert with the corresponding error message is triggered.\n   *\n   * @param contractAddr The address of the contract to check for interface support.\n   * @param interfaceId The interface ID to check for support.\n   */\n  function _requireSupportsInterface(address contractAddr, bytes4 interfaceId) internal view {\n    bytes memory supportsInterfaceParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n    (bool success, bytes memory returnOrRevertData) = contractAddr.staticcall(supportsInterfaceParams);\n    if (!success) {\n      (success, returnOrRevertData) = contractAddr.staticcall(\n        abi.encodeCall(TransparentUpgradeableProxyV2.functionDelegateCall, (supportsInterfaceParams))\n      );\n      if (!success) revert ErrUnsupportedInterface(interfaceId, contractAddr);\n    }\n    if (!abi.decode(returnOrRevertData, (bool))) revert ErrUnsupportedInterface(interfaceId, contractAddr);\n  }\n}\n"
    },
    "contracts/utils/RoleAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum RoleAccess {\n  /* 0 */ UNKNOWN,\n  /* 1 */ ADMIN,\n  /* 2 */ COINBASE,\n  /* 3 */ GOVERNOR,\n  /* 4 */ CANDIDATE_ADMIN,\n  /* 5 */ WITHDRAWAL_MIGRATOR,\n  /* 6 */ __DEPRECATED_BRIDGE_OPERATOR,\n  /* 7 */ BLOCK_PRODUCER,\n  /* 8 */ VALIDATOR_CANDIDATE,\n  /* 9 */ CONSENSUS,\n  /* 10 */ TREASURY\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}