{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/extensions/bridge-operator-governance/BridgeTrackingHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract BridgeTrackingHelper {\n  /// @dev Event emited when the bridge tracking contract tracks the invalid data, cause malform in sharing bridge reward.\n  event BridgeTrackingIncorrectlyResponded();\n\n  /**\n   * @dev Internal function to validate the bridge tracking response for a given set of ballots.\n   * @param totalBallot The total number of ballots available for the tracking response.\n   * @param totalVote The total number of votes recorded in the tracking response.\n   * @param ballots An array containing the individual ballot counts in the tracking response.\n   * @return valid A boolean indicating whether the bridge tracking response is valid or not.\n   * @notice The function checks if each individual ballot count is not greater than the total votes recorded.\n   * @notice It also verifies that the sum of all individual ballot counts does not exceed the total available ballots.\n   */\n  function _isValidBridgeTrackingResponse(\n    uint256 totalBallot,\n    uint256 totalVote,\n    uint256[] memory ballots\n  ) internal pure returns (bool valid) {\n    valid = true;\n    uint256 sumBallot;\n    uint256 length = ballots.length;\n\n    unchecked {\n      for (uint256 i; i < length; ++i) {\n        if (ballots[i] > totalVote) {\n          valid = false;\n          break;\n        }\n\n        sumBallot += ballots[i];\n      }\n    }\n\n    valid = valid && (sumBallot <= totalBallot);\n  }\n}\n"
    },
    "contracts/extensions/collections/HasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { HasProxyAdmin } from \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasContracts.sol\";\nimport { IdentityGuard } from \"../../utils/IdentityGuard.sol\";\nimport { ErrUnexpectedInternalCall } from \"../../utils/CommonErrors.sol\";\n\n/**\n * @title HasContracts\n * @dev A contract that provides functionality to manage multiple contracts with different roles.\n */\nabstract contract HasContracts is HasProxyAdmin, IHasContracts, IdentityGuard {\n  /// @dev value is equal to keccak256(\"@ronin.dpos.collections.HasContracts.slot\") - 1\n  bytes32 private constant _STORAGE_SLOT = 0xdea3103d22025c269050bea94c0c84688877f12fa22b7e6d2d5d78a9a49aa1cb;\n\n  /**\n   * @dev Modifier to restrict access to functions only to contracts with a specific role.\n   * @param contractType The contract type that allowed to call\n   */\n  modifier onlyContract(ContractType contractType) virtual {\n    _requireContract(contractType);\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function setContract(ContractType contractType, address addr) external virtual onlyAdmin {\n    _requireHasCode(addr);\n    _setContract(contractType, addr);\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function getContract(ContractType contractType) public view returns (address contract_) {\n    contract_ = _getContractMap()[uint8(contractType)];\n    if (contract_ == address(0)) revert ErrContractTypeNotFound(contractType);\n  }\n\n  /**\n   * @dev Internal function to set the address of a contract with a specific role.\n   * @param contractType The contract type of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function _setContract(ContractType contractType, address addr) internal virtual {\n    _getContractMap()[uint8(contractType)] = addr;\n    emit ContractUpdated(contractType, addr);\n  }\n\n  /**\n   * @dev Internal function to access the mapping of contract addresses with roles.\n   * @return contracts_ The mapping of contract addresses with roles.\n   */\n  function _getContractMap() private pure returns (mapping(uint8 => address) storage contracts_) {\n    assembly {\n      contracts_.slot := _STORAGE_SLOT\n    }\n  }\n\n  /**\n   * @dev Internal function to check if the calling contract has a specific role.\n   * @param contractType The contract type that the calling contract must have.\n   * @dev Throws an error if the calling contract does not have the specified role.\n   */\n  function _requireContract(ContractType contractType) private view {\n    if (msg.sender != getContract(contractType)) {\n      revert ErrUnexpectedInternalCall(msg.sig, contractType, msg.sender);\n    }\n  }\n}\n"
    },
    "contracts/extensions/collections/HasProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../utils/CommonErrors.sol\";\n\nabstract contract HasProxyAdmin {\n  // bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n  bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  modifier onlyAdmin() {\n    _requireAdmin();\n    _;\n  }\n\n  /**\n   * @dev Returns proxy admin.\n   */\n  function _getAdmin() internal view virtual returns (address) {\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  function _requireAdmin() internal view {\n    if (msg.sender != _getAdmin()) revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\n  }\n}\n"
    },
    "contracts/extensions/consumers/GlobalConfigConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nabstract contract GlobalConfigConsumer {\n  /// @dev The addition amount of gas sending along in external calls. Total gas stipend is added with default 2300 gas.\n  uint256 public constant DEFAULT_ADDITION_GAS = 1200;\n  /// @dev The length of a period in second.\n  uint256 public constant PERIOD_DURATION = 1 days;\n}\n"
    },
    "contracts/extensions/consumers/PercentageConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract PercentageConsumer {\n  uint256 internal constant _MAX_PERCENTAGE = 100_00;\n}\n"
    },
    "contracts/extensions/GatewayV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"../interfaces/IQuorum.sol\";\nimport \"./collections/HasProxyAdmin.sol\";\n\nabstract contract GatewayV3 is HasProxyAdmin, Pausable, IQuorum {\n  uint256 internal _num;\n  uint256 internal _denom;\n\n  address private ______deprecated;\n  uint256 public nonce;\n\n  address public emergencyPauser;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[49] private ______gap;\n\n  /**\n   * @dev Grant emergency pauser role for `_addr`.\n   */\n  function setEmergencyPauser(address _addr) external onlyAdmin {\n    emergencyPauser = _addr;\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function getThreshold() external view virtual returns (uint256 num_, uint256 denom_) {\n    return (_num, _denom);\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function checkThreshold(uint256 _voteWeight) external view virtual returns (bool) {\n    return _voteWeight * _denom >= _num * _getTotalWeight();\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function setThreshold(\n    uint256 _numerator,\n    uint256 _denominator\n  ) external virtual onlyAdmin returns (uint256, uint256) {\n    return _setThreshold(_numerator, _denominator);\n  }\n\n  /**\n   * @dev Triggers paused state.\n   */\n  function pause() external {\n    _requireAuth();\n    _pause();\n  }\n\n  /**\n   * @dev Triggers unpaused state.\n   */\n  function unpause() external {\n    _requireAuth();\n    _unpause();\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function minimumVoteWeight() public view virtual returns (uint256) {\n    return _minimumVoteWeight(_getTotalWeight());\n  }\n\n  /**\n   * @dev Sets threshold and returns the old one.\n   *\n   * Emits the `ThresholdUpdated` event.\n   *\n   */\n  function _setThreshold(\n    uint256 _numerator,\n    uint256 _denominator\n  ) internal virtual returns (uint256 _previousNum, uint256 _previousDenom) {\n    if (_numerator > _denominator) revert ErrInvalidThreshold(msg.sig);\n    _previousNum = _num;\n    _previousDenom = _denom;\n    _num = _numerator;\n    _denom = _denominator;\n    unchecked {\n      emit ThresholdUpdated(nonce++, _numerator, _denominator, _previousNum, _previousDenom);\n    }\n  }\n\n  /**\n   * @dev Returns minimum vote weight.\n   */\n  function _minimumVoteWeight(uint256 _totalWeight) internal view virtual returns (uint256) {\n    return (_num * _totalWeight + _denom - 1) / _denom;\n  }\n\n  /**\n   * @dev Internal method to check method caller.\n   *\n   * Requirements:\n   *\n   * - The method caller must be admin or pauser.\n   *\n   */\n  function _requireAuth() private view {\n    if (!(msg.sender == _getAdmin() || msg.sender == emergencyPauser)) {\n      revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\n    }\n  }\n\n  /**\n   * @dev Returns the total weight.\n   */\n  function _getTotalWeight() internal view virtual returns (uint256);\n}\n"
    },
    "contracts/extensions/GovernanceAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../extensions/sequential-governance/CoreGovernance.sol\";\nimport \"../extensions/collections/HasContracts.sol\";\nimport \"../interfaces/IRoninTrustedOrganization.sol\";\nimport { ErrorHandler } from \"../libraries/ErrorHandler.sol\";\nimport { IdentityGuard } from \"../utils/IdentityGuard.sol\";\nimport { HasGovernanceAdminDeprecated, HasBridgeDeprecated } from \"../utils/DeprecatedSlots.sol\";\n\nabstract contract GovernanceAdmin is\n  CoreGovernance,\n  IdentityGuard,\n  HasContracts,\n  HasGovernanceAdminDeprecated,\n  HasBridgeDeprecated\n{\n  using ErrorHandler for bool;\n\n  uint256 public roninChainId;\n  /// @dev Domain separator\n  bytes32 public DOMAIN_SEPARATOR;\n\n  constructor(uint256 _roninChainId, address _roninTrustedOrganizationContract) {\n    roninChainId = _roninChainId;\n\n    /*\n     * DOMAIN_SEPARATOR = keccak256(\n     *  abi.encode(\n     *    keccak256(\"EIP712Domain(string name,string version,bytes32 salt)\"),\n     *    keccak256(\"GovernanceAdmin\"), // name hash\n     *    keccak256(\"2\"), // version hash\n     *    keccak256(abi.encode(\"RONIN_GOVERNANCE_ADMIN\", _roninChainId)) // salt\n     *  )\n     */\n    assembly {\n      let ptr := mload(0x40)\n\n      // See abi.encode implementation: https://github.com/axieinfinity/ronin/blob/569ebd5a782da5601c6aba22799dc9b4afd39da9/accounts/abi/argument.go#L227-L267\n      mstore(ptr, 0x40) // offset bytes\n      mstore(add(ptr, 0x20), _roninChainId)\n      mstore(add(ptr, 0x40), 0x16) // \"RONIN_GOVERNANCE_ADMIN\".length\n      mstore(add(ptr, 0x60), 0x524f4e494e5f474f5645524e414e43455f41444d494e00000000000000000000) // bytes(\"RONIN_GOVERNANCE_ADMIN\")\n      let salt := keccak256(ptr, 0x80) // keccak256(abi.encode(\"RONIN_GOVERNANCE_ADMIN\", _roninChainId))\n\n      mstore(ptr, 0x599a80fcaa47b95e2323ab4d34d34e0cc9feda4b843edafcc30c7bdf60ea15bf) // keccak256(\"EIP712Domain(string name,string version,bytes32 salt)\")\n      mstore(add(ptr, 0x20), 0x7e7935007966eb860f4a2ee3dcc9fd53fb3205ce2aa86b0126d4893d4d4c14b9) // keccak256(\"GovernanceAdmin\")\n      mstore(add(ptr, 0x40), 0x2a80e1ef1d7842f27f2e6be0972bb708b9a135c38860dbe73c27c3486c34f4de) // keccak256(\"3\")\n      mstore(add(ptr, 0x60), salt)\n      sstore(DOMAIN_SEPARATOR.slot, keccak256(ptr, 0x80))\n    }\n\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, _roninTrustedOrganizationContract);\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function setContract(ContractType contractType, address addr) external virtual override onlySelfCall {\n    _requireHasCode(addr);\n    _setContract(contractType, addr);\n  }\n\n  /**\n   * @dev Sets the expiry duration for a new proposal.\n   *\n   * Requirements:\n   * - Only allowing self-call to this method, since this contract does not have admin.\n   *\n   */\n  function setProposalExpiryDuration(uint256 _expiryDuration) external onlySelfCall {\n    _setProposalExpiryDuration(_expiryDuration);\n  }\n\n  /**\n   * @dev Returns the current implementation of `_proxy`.\n   *\n   * Requirements:\n   * - This contract must be the admin of `_proxy`.\n   *\n   */\n  function getProxyImplementation(address _proxy) external view returns (address) {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n    bytes4 _selector = 0x5c60da1b;\n    (bool _success, bytes memory _returndata) = _proxy.staticcall(abi.encodeWithSelector(_selector));\n    _success.handleRevert(_selector, _returndata);\n    return abi.decode(_returndata, (address));\n  }\n\n  /**\n   * @dev Returns the proposal expiry duration.\n   */\n  function getProposalExpiryDuration() external view returns (uint256) {\n    return super._getProposalExpiryDuration();\n  }\n\n  /**\n   * @dev Returns the current admin of `_proxy`.\n   *\n   * Requirements:\n   * - This contract must be the admin of `_proxy`.\n   *\n   */\n  function getProxyAdmin(address _proxy) external view returns (address) {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"admin()\")) == 0xf851a440\n    bytes4 _selector = 0xf851a440;\n    (bool _success, bytes memory _returndata) = _proxy.staticcall(abi.encodeWithSelector(_selector));\n    _success.handleRevert(_selector, _returndata);\n    return abi.decode(_returndata, (address));\n  }\n\n  /**\n   * @dev Changes the admin of `_proxy` to `newAdmin`.\n   *\n   * Requirements:\n   * - This contract must be the current admin of `_proxy`.\n   *\n   */\n  function changeProxyAdmin(address _proxy, address _newAdmin) external onlySelfCall {\n    // bytes4(keccak256(\"changeAdmin(address)\"))\n    bytes4 _selector = 0x8f283970;\n    (bool _success, bytes memory _returndata) = _proxy.call(abi.encodeWithSelector(_selector, _newAdmin));\n    _success.handleRevert(_selector, _returndata);\n  }\n\n  /**\n   * @dev Override `CoreGovernance-_getMinimumVoteWeight`.\n   */\n  function _getMinimumVoteWeight() internal view virtual override returns (uint256) {\n    bytes4 _selector = IQuorum.minimumVoteWeight.selector;\n    (bool _success, bytes memory _returndata) = getContract(ContractType.RONIN_TRUSTED_ORGANIZATION).staticcall(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector)\n      )\n    );\n    _success.handleRevert(_selector, _returndata);\n    return abi.decode(_returndata, (uint256));\n  }\n\n  /**\n   * @dev Override `CoreGovernance-_getTotalWeights`.\n   */\n  function _getTotalWeight() internal view virtual override returns (uint256) {\n    bytes4 _selector = IRoninTrustedOrganization.totalWeight.selector;\n    (bool _success, bytes memory _returndata) = getContract(ContractType.RONIN_TRUSTED_ORGANIZATION).staticcall(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector)\n      )\n    );\n    _success.handleRevert(_selector, _returndata);\n    return abi.decode(_returndata, (uint256));\n  }\n}\n"
    },
    "contracts/extensions/MinimumWithdrawal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./collections/HasProxyAdmin.sol\";\nimport \"../libraries/Transfer.sol\";\n\nabstract contract MinimumWithdrawal is HasProxyAdmin {\n  /// @dev Throwed when the ERC20 withdrawal quantity is less than the minimum threshold.\n  error ErrQueryForTooSmallQuantity();\n\n  /// @dev Emitted when the minimum thresholds are updated\n  event MinimumThresholdsUpdated(address[] tokens, uint256[] threshold);\n\n  /// @dev Mapping from token address => minimum thresholds\n  mapping(address => uint256) public minimumThreshold;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @dev Sets the minimum thresholds to withdraw.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The arrays have the same length and its length larger than 0.\n   *\n   * Emits the `MinimumThresholdsUpdated` event.\n   *\n   */\n  function setMinimumThresholds(address[] calldata _tokens, uint256[] calldata _thresholds) external virtual onlyAdmin {\n    if (_tokens.length == 0) revert ErrEmptyArray();\n    _setMinimumThresholds(_tokens, _thresholds);\n  }\n\n  /**\n   * @dev Sets minimum thresholds.\n   *\n   * Requirements:\n   * - The array lengths are equal.\n   *\n   * Emits the `MinimumThresholdsUpdated` event.\n   *\n   */\n  function _setMinimumThresholds(address[] calldata _tokens, uint256[] calldata _thresholds) internal virtual {\n    if (_tokens.length != _thresholds.length) revert ErrLengthMismatch(msg.sig);\n\n    for (uint256 _i; _i < _tokens.length; ) {\n      minimumThreshold[_tokens[_i]] = _thresholds[_i];\n\n      unchecked {\n        ++_i;\n      }\n    }\n    emit MinimumThresholdsUpdated(_tokens, _thresholds);\n  }\n\n  /**\n   * @dev Checks whether the request is larger than or equal to the minimum threshold.\n   */\n  function _checkWithdrawal(Transfer.Request calldata _request) internal view {\n    if (_request.info.erc == Token.Standard.ERC20 && _request.info.quantity < minimumThreshold[_request.tokenAddr]) {\n      revert ErrQueryForTooSmallQuantity();\n    }\n  }\n}\n"
    },
    "contracts/extensions/RONTransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nabstract contract RONTransferHelper {\n  /// @dev Error of sender has insufficient balance.\n  error ErrInsufficientBalance(bytes4 msgSig, uint256 currentBalance, uint256 sendAmount);\n  /// @dev Error of recipient not accepting RON when transfer RON.\n  error ErrRecipientRevert(bytes4 msgSig);\n\n  /**\n   * @dev See `_sendRON`.\n   * Reverts if the recipient does not receive RON.\n   */\n  function _transferRON(address payable recipient, uint256 amount) internal {\n    if (!_sendRON(recipient, amount)) revert ErrRecipientRevert(msg.sig);\n  }\n\n  /**\n   * @dev Send `amount` RON to the address `recipient`.\n   * Returns whether the recipient receives RON or not.\n   * Reverts once the contract balance is insufficient.\n   *\n   * Note: consider using `ReentrancyGuard` before calling this function.\n   *\n   */\n  function _sendRON(address payable recipient, uint256 amount) internal returns (bool success) {\n    if (address(this).balance < amount) revert ErrInsufficientBalance(msg.sig, address(this).balance, amount);\n    return _unsafeSendRON(recipient, amount);\n  }\n\n  /**\n   * @dev Unsafe send `amount` RON to the address `recipient`. If the sender's balance is insufficient,\n   * the call does not revert.\n   *\n   * Note:\n   * - Does not assert whether the balance of sender is sufficient.\n   * - Does not assert whether the recipient accepts RON.\n   * - Consider using `ReentrancyGuard` before calling this function.\n   *\n   */\n  function _unsafeSendRON(address payable recipient, uint256 amount) internal returns (bool success) {\n    (success, ) = recipient.call{ value: amount }(\"\");\n  }\n\n  /**\n   * @dev Same purpose with {_unsafeSendRONLimitGas(address,uin256)} but containing gas limit stipend forwarded in the call.\n   */\n  function _unsafeSendRONLimitGas(\n    address payable recipient,\n    uint256 amount,\n    uint256 gas\n  ) internal returns (bool success) {\n    (success, ) = recipient.call{ value: amount, gas: gas }(\"\");\n  }\n}\n"
    },
    "contracts/extensions/sequential-governance/CoreGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../libraries/Proposal.sol\";\nimport \"../../libraries/GlobalProposal.sol\";\nimport \"../../utils/CommonErrors.sol\";\nimport \"../../libraries/Ballot.sol\";\nimport \"../../interfaces/consumers/ChainTypeConsumer.sol\";\nimport \"../../interfaces/consumers/SignatureConsumer.sol\";\nimport \"../../interfaces/consumers/VoteStatusConsumer.sol\";\n\nabstract contract CoreGovernance is SignatureConsumer, VoteStatusConsumer, ChainTypeConsumer {\n  using Proposal for Proposal.ProposalDetail;\n\n  /**\n   * @dev Error thrown when attempting to interact with a finalized vote.\n   */\n  error ErrVoteIsFinalized();\n\n  /**\n   * @dev Error thrown when the current proposal is not completed.\n   */\n  error ErrCurrentProposalIsNotCompleted();\n\n  struct ProposalVote {\n    VoteStatus status;\n    bytes32 hash;\n    uint256 againstVoteWeight; // Total weight of against votes\n    uint256 forVoteWeight; // Total weight of for votes\n    address[] forVoteds; // Array of addresses voting for\n    address[] againstVoteds; // Array of addresses voting against\n    uint256 expiryTimestamp;\n    mapping(address => Signature) sig;\n    mapping(address => bool) voted;\n  }\n\n  /// @dev Emitted when a proposal is created\n  event ProposalCreated(\n    uint256 indexed chainId,\n    uint256 indexed round,\n    bytes32 indexed proposalHash,\n    Proposal.ProposalDetail proposal,\n    address creator\n  );\n  /// @dev Emitted when the proposal is voted\n  event ProposalVoted(bytes32 indexed proposalHash, address indexed voter, Ballot.VoteType support, uint256 weight);\n  /// @dev Emitted when the proposal is approved\n  event ProposalApproved(bytes32 indexed proposalHash);\n  /// @dev Emitted when the vote is reject\n  event ProposalRejected(bytes32 indexed proposalHash);\n  /// @dev Emitted when the vote is expired\n  event ProposalExpired(bytes32 indexed proposalHash);\n  /// @dev Emitted when the proposal is executed\n  event ProposalExecuted(bytes32 indexed proposalHash, bool[] successCalls, bytes[] returnDatas);\n  /// @dev Emitted when the proposal expiry duration is changed.\n  event ProposalExpiryDurationChanged(uint256 indexed duration);\n\n  /// @dev Mapping from chain id => vote round\n  /// @notice chain id = 0 for global proposal\n  mapping(uint256 => uint256) public round;\n  /// @dev Mapping from chain id => vote round => proposal vote\n  mapping(uint256 => mapping(uint256 => ProposalVote)) public vote;\n\n  uint256 internal _proposalExpiryDuration;\n\n  constructor(uint256 _expiryDuration) {\n    _setProposalExpiryDuration(_expiryDuration);\n  }\n\n  /**\n   * @dev Creates new voting round by calculating the `_round` number of chain `_chainId`.\n   * Increases the `_round` number if the previous one is not expired. Delete the previous proposal\n   * if it is expired and not increase the `_round`.\n   */\n  function _createVotingRound(uint256 _chainId) internal returns (uint256 _round) {\n    _round = round[_chainId];\n    // Skip checking for the first ever round\n    if (_round == 0) {\n      _round = round[_chainId] = 1;\n    } else {\n      ProposalVote storage _latestProposalVote = vote[_chainId][_round];\n      bool _isExpired = _tryDeleteExpiredVotingRound(_latestProposalVote);\n      // Skip increasing round number if the latest round is expired, allow the vote to be overridden\n      if (!_isExpired) {\n        if (_latestProposalVote.status == VoteStatus.Pending) revert ErrCurrentProposalIsNotCompleted();\n        unchecked {\n          _round = ++round[_chainId];\n        }\n      }\n    }\n  }\n\n  /**\n   * @dev Saves new round voting for the proposal `_proposalHash` of chain `_chainId`.\n   */\n  function _saveVotingRound(ProposalVote storage _vote, bytes32 _proposalHash, uint256 _expiryTimestamp) internal {\n    _vote.hash = _proposalHash;\n    _vote.expiryTimestamp = _expiryTimestamp;\n  }\n\n  /**\n   * @dev Proposes for a new proposal.\n   *\n   * Requirements:\n   * - The chain id is not equal to 0.\n   *\n   * Emits the `ProposalCreated` event.\n   *\n   */\n  function _proposeProposal(\n    uint256 chainId,\n    uint256 expiryTimestamp,\n    address[] memory targets,\n    uint256[] memory values,\n    bytes[] memory calldatas,\n    uint256[] memory gasAmounts,\n    address creator\n  ) internal virtual returns (Proposal.ProposalDetail memory proposal) {\n    if (chainId == 0) revert ErrInvalidChainId(msg.sig, 0, block.chainid);\n    uint256 round_ = _createVotingRound(chainId);\n\n    proposal = Proposal.ProposalDetail(round_, chainId, expiryTimestamp, targets, values, calldatas, gasAmounts);\n    proposal.validate(_proposalExpiryDuration);\n\n    bytes32 proposalHash = proposal.hash();\n    _saveVotingRound(vote[chainId][round_], proposalHash, expiryTimestamp);\n    emit ProposalCreated(chainId, round_, proposalHash, proposal, creator);\n  }\n\n  /**\n   * @dev Proposes proposal struct.\n   *\n   * Requirements:\n   * - The chain id is not equal to 0.\n   * - The proposal nonce is equal to the new round.\n   *\n   * Emits the `ProposalCreated` event.\n   *\n   */\n  function _proposeProposalStruct(\n    Proposal.ProposalDetail memory proposal,\n    address creator\n  ) internal virtual returns (uint256 round_) {\n    uint256 chainId = proposal.chainId;\n    if (chainId == 0) revert ErrInvalidChainId(msg.sig, 0, block.chainid);\n    proposal.validate(_proposalExpiryDuration);\n\n    bytes32 proposalHash = proposal.hash();\n    round_ = _createVotingRound(chainId);\n    _saveVotingRound(vote[chainId][round_], proposalHash, proposal.expiryTimestamp);\n    if (round_ != proposal.nonce) revert ErrInvalidProposalNonce(msg.sig);\n    emit ProposalCreated(chainId, round_, proposalHash, proposal, creator);\n  }\n\n  /**\n   * @dev Casts vote for the proposal with data and returns whether the voting is done.\n   *\n   * Requirements:\n   * - The proposal nonce is equal to the round.\n   * - The vote is not finalized.\n   * - The voter has not voted for the round.\n   *\n   * Emits the `ProposalVoted` event. Emits the `ProposalApproved`, `ProposalExecuted` or `ProposalRejected` once the\n   * proposal is approved, executed or rejected.\n   *\n   */\n  function _castVote(\n    Proposal.ProposalDetail memory proposal,\n    Ballot.VoteType support,\n    uint256 minimumForVoteWeight,\n    uint256 minimumAgainstVoteWeight,\n    address voter,\n    Signature memory signature,\n    uint256 voterWeight\n  ) internal virtual returns (bool done) {\n    uint256 chainId = proposal.chainId;\n    uint256 round_ = proposal.nonce;\n    ProposalVote storage _vote = vote[chainId][round_];\n\n    if (_tryDeleteExpiredVotingRound(_vote)) {\n      return true;\n    }\n\n    if (round[proposal.chainId] != round_) revert ErrInvalidProposalNonce(msg.sig);\n    if (_vote.status != VoteStatus.Pending) revert ErrVoteIsFinalized();\n    if (_voted(_vote, voter)) revert ErrAlreadyVoted(voter);\n\n    _vote.voted[voter] = true;\n    // Stores the signature if it is not empty\n    if (signature.r > 0 || signature.s > 0 || signature.v > 0) {\n      _vote.sig[voter] = signature;\n    }\n    emit ProposalVoted(_vote.hash, voter, support, voterWeight);\n\n    uint256 _forVoteWeight;\n    uint256 _againstVoteWeight;\n    if (support == Ballot.VoteType.For) {\n      _vote.forVoteds.push(voter);\n      _forVoteWeight = _vote.forVoteWeight += voterWeight;\n    } else if (support == Ballot.VoteType.Against) {\n      _vote.againstVoteds.push(voter);\n      _againstVoteWeight = _vote.againstVoteWeight += voterWeight;\n    } else revert ErrUnsupportedVoteType(msg.sig);\n\n    if (_forVoteWeight >= minimumForVoteWeight) {\n      done = true;\n      _vote.status = VoteStatus.Approved;\n      emit ProposalApproved(_vote.hash);\n      _tryExecute(_vote, proposal);\n    } else if (_againstVoteWeight >= minimumAgainstVoteWeight) {\n      done = true;\n      _vote.status = VoteStatus.Rejected;\n      emit ProposalRejected(_vote.hash);\n    }\n  }\n\n  /**\n   * @dev When the contract is on Ronin chain, checks whether the proposal is expired and delete it if is expired.\n   *\n   * Emits the event `ProposalExpired` if the vote is expired.\n   *\n   * Note: This function assumes the vote `_proposalVote` is already created, consider verifying the vote's existence\n   * before or it will emit an unexpected event of `ProposalExpired`.\n   */\n  function _tryDeleteExpiredVotingRound(ProposalVote storage proposalVote) internal returns (bool isExpired) {\n    isExpired =\n      _getChainType() == ChainType.RoninChain &&\n      proposalVote.status == VoteStatus.Pending &&\n      proposalVote.expiryTimestamp <= block.timestamp;\n\n    if (isExpired) {\n      emit ProposalExpired(proposalVote.hash);\n\n      for (uint256 _i; _i < proposalVote.forVoteds.length; ) {\n        delete proposalVote.voted[proposalVote.forVoteds[_i]];\n        delete proposalVote.sig[proposalVote.forVoteds[_i]];\n\n        unchecked {\n          ++_i;\n        }\n      }\n      for (uint256 _i; _i < proposalVote.againstVoteds.length; ) {\n        delete proposalVote.voted[proposalVote.againstVoteds[_i]];\n        delete proposalVote.sig[proposalVote.againstVoteds[_i]];\n\n        unchecked {\n          ++_i;\n        }\n      }\n      delete proposalVote.status;\n      delete proposalVote.hash;\n      delete proposalVote.againstVoteWeight;\n      delete proposalVote.forVoteWeight;\n      delete proposalVote.forVoteds;\n      delete proposalVote.againstVoteds;\n      delete proposalVote.expiryTimestamp;\n    }\n  }\n\n  /**\n   * @dev Executes the proposal and update the vote status once the proposal is executable.\n   */\n  function _tryExecute(ProposalVote storage vote_, Proposal.ProposalDetail memory proposal) internal {\n    if (proposal.executable()) {\n      vote_.status = VoteStatus.Executed;\n      (bool[] memory _successCalls, bytes[] memory _returnDatas) = proposal.execute();\n      emit ProposalExecuted(vote_.hash, _successCalls, _returnDatas);\n    }\n  }\n\n  /**\n   * @dev Sets the expiry duration for a new proposal.\n   */\n  function _setProposalExpiryDuration(uint256 expiryDuration) internal {\n    _proposalExpiryDuration = expiryDuration;\n    emit ProposalExpiryDurationChanged(expiryDuration);\n  }\n\n  /**\n   * @dev Returns the expiry duration for a new proposal.\n   */\n  function _getProposalExpiryDuration() internal view returns (uint256) {\n    return _proposalExpiryDuration;\n  }\n\n  /**\n   * @dev Returns whether the voter casted for the proposal.\n   */\n  function _voted(ProposalVote storage vote_, address voter) internal view returns (bool) {\n    return vote_.voted[voter];\n  }\n\n  /**\n   * @dev Returns total weight from validators.\n   */\n  function _getTotalWeight() internal view virtual returns (uint256);\n\n  /**\n   * @dev Returns minimum vote to pass a proposal.\n   */\n  function _getMinimumVoteWeight() internal view virtual returns (uint256);\n\n  /**\n   * @dev Returns current context is running on whether Ronin chain or on mainchain.\n   */\n  function _getChainType() internal view virtual returns (ChainType);\n}\n"
    },
    "contracts/extensions/sequential-governance/governance-proposal/CommonGovernanceProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../CoreGovernance.sol\";\n\nabstract contract CommonGovernanceProposal is CoreGovernance {\n  using Proposal for Proposal.ProposalDetail;\n\n  /**\n   * @dev Error thrown when an invalid proposal is encountered.\n   * @param actual The actual value of the proposal.\n   * @param expected The expected value of the proposal.\n   */\n  error ErrInvalidProposal(bytes32 actual, bytes32 expected);\n\n  /**\n   * @dev Casts votes by signatures.\n   *\n   * Note: This method does not verify the proposal hash with the vote hash. Please consider checking it before.\n   *\n   */\n  function _castVotesBySignatures(\n    Proposal.ProposalDetail memory _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures,\n    bytes32 _forDigest,\n    bytes32 _againstDigest\n  ) internal {\n    if (!(_supports.length != 0 && _supports.length == _signatures.length)) revert ErrLengthMismatch(msg.sig);\n\n    uint256 _minimumForVoteWeight = _getMinimumVoteWeight();\n    uint256 _minimumAgainstVoteWeight = _getTotalWeight() - _minimumForVoteWeight + 1;\n\n    address _lastSigner;\n    address _signer;\n    Signature calldata _sig;\n    bool _hasValidVotes;\n    for (uint256 _i; _i < _signatures.length; ) {\n      _sig = _signatures[_i];\n\n      if (_supports[_i] == Ballot.VoteType.For) {\n        _signer = ECDSA.recover(_forDigest, _sig.v, _sig.r, _sig.s);\n      } else if (_supports[_i] == Ballot.VoteType.Against) {\n        _signer = ECDSA.recover(_againstDigest, _sig.v, _sig.r, _sig.s);\n      } else revert ErrUnsupportedVoteType(msg.sig);\n\n      if (_lastSigner >= _signer) revert ErrInvalidOrder(msg.sig);\n      _lastSigner = _signer;\n\n      uint256 _weight = _getWeight(_signer);\n      if (_weight > 0) {\n        _hasValidVotes = true;\n        if (\n          _castVote(_proposal, _supports[_i], _minimumForVoteWeight, _minimumAgainstVoteWeight, _signer, _sig, _weight)\n        ) {\n          return;\n        }\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    if (!_hasValidVotes) revert ErrInvalidSignatures(msg.sig);\n  }\n\n  /**\n   * @dev Returns the voted signatures for the proposals.\n   *\n   * Note: The signatures can be empty in case the proposal is voted on the current network.\n   *\n   */\n  function _getProposalSignatures(\n    uint256 _chainId,\n    uint256 _round\n  )\n    internal\n    view\n    returns (address[] memory _voters, Ballot.VoteType[] memory _supports, Signature[] memory _signatures)\n  {\n    ProposalVote storage _vote = vote[_chainId][_round];\n\n    uint256 _forLength = _vote.forVoteds.length;\n    uint256 _againstLength = _vote.againstVoteds.length;\n    uint256 _voterLength = _forLength + _againstLength;\n\n    _supports = new Ballot.VoteType[](_voterLength);\n    _signatures = new Signature[](_voterLength);\n    _voters = new address[](_voterLength);\n    for (uint256 _i; _i < _forLength; ) {\n      _supports[_i] = Ballot.VoteType.For;\n      _signatures[_i] = vote[_chainId][_round].sig[_vote.forVoteds[_i]];\n      _voters[_i] = _vote.forVoteds[_i];\n\n      unchecked {\n        ++_i;\n      }\n    }\n    for (uint256 _i; _i < _againstLength; ) {\n      _supports[_i + _forLength] = Ballot.VoteType.Against;\n      _signatures[_i + _forLength] = vote[_chainId][_round].sig[_vote.againstVoteds[_i]];\n      _voters[_i + _forLength] = _vote.againstVoteds[_i];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @dev Returns whether the voter `_voter` casted vote for the proposal.\n   */\n  function _proposalVoted(uint256 _chainId, uint256 _round, address _voter) internal view returns (bool) {\n    return _voted(vote[_chainId][_round], _voter);\n  }\n\n  /**\n   * @dev Returns the weight of a governor.\n   */\n  function _getWeight(address _governor) internal view virtual returns (uint256);\n}\n"
    },
    "contracts/extensions/sequential-governance/governance-proposal/GovernanceProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../CoreGovernance.sol\";\nimport \"./CommonGovernanceProposal.sol\";\n\nabstract contract GovernanceProposal is CoreGovernance, CommonGovernanceProposal {\n  using Proposal for Proposal.ProposalDetail;\n\n  /**\n   * @dev Proposes a proposal struct and casts votes by signature.\n   */\n  function _proposeProposalStructAndCastVotes(\n    Proposal.ProposalDetail calldata _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures,\n    bytes32 _domainSeparator,\n    address _creator\n  ) internal {\n    _proposeProposalStruct(_proposal, _creator);\n    bytes32 _proposalHash = _proposal.hash();\n    _castVotesBySignatures(\n      _proposal,\n      _supports,\n      _signatures,\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_proposalHash, Ballot.VoteType.For)),\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_proposalHash, Ballot.VoteType.Against))\n    );\n  }\n\n  /**\n   * @dev Proposes a proposal struct and casts votes by signature.\n   */\n  function _castProposalBySignatures(\n    Proposal.ProposalDetail calldata _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures,\n    bytes32 _domainSeparator\n  ) internal {\n    bytes32 _proposalHash = _proposal.hash();\n\n    if (vote[_proposal.chainId][_proposal.nonce].hash != _proposalHash) {\n      revert ErrInvalidProposal(_proposalHash, vote[_proposal.chainId][_proposal.nonce].hash);\n    }\n\n    _castVotesBySignatures(\n      _proposal,\n      _supports,\n      _signatures,\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_proposalHash, Ballot.VoteType.For)),\n      ECDSA.toTypedDataHash(_domainSeparator, Ballot.hash(_proposalHash, Ballot.VoteType.Against))\n    );\n  }\n\n  /**\n   * @dev See `castProposalVoteForCurrentNetwork`.\n   */\n  function _castProposalVoteForCurrentNetwork(\n    address _voter,\n    Proposal.ProposalDetail memory _proposal,\n    Ballot.VoteType _support\n  ) internal {\n    if (_proposal.chainId != block.chainid) revert ErrInvalidChainId(msg.sig, _proposal.chainId, block.chainid);\n\n    bytes32 proposalHash = _proposal.hash();\n    if (vote[_proposal.chainId][_proposal.nonce].hash != proposalHash)\n      revert ErrInvalidProposal(proposalHash, vote[_proposal.chainId][_proposal.nonce].hash);\n\n    uint256 _minimumForVoteWeight = _getMinimumVoteWeight();\n    uint256 _minimumAgainstVoteWeight = _getTotalWeight() - _minimumForVoteWeight + 1;\n    Signature memory _emptySignature;\n    _castVote(\n      _proposal,\n      _support,\n      _minimumForVoteWeight,\n      _minimumAgainstVoteWeight,\n      _voter,\n      _emptySignature,\n      _getWeight(_voter)\n    );\n  }\n\n  /**\n   * @dev See {CommonGovernanceProposal-_getProposalSignatures}\n   */\n  function getProposalSignatures(\n    uint256 _chainId,\n    uint256 _round\n  )\n    external\n    view\n    returns (address[] memory _voters, Ballot.VoteType[] memory _supports, Signature[] memory _signatures)\n  {\n    return _getProposalSignatures(_chainId, _round);\n  }\n\n  /**\n   * @dev See {CommonGovernanceProposal-_proposalVoted}\n   */\n  function proposalVoted(uint256 _chainId, uint256 _round, address _voter) external view returns (bool) {\n    return _proposalVoted(_chainId, _round, _voter);\n  }\n}\n"
    },
    "contracts/extensions/TransparentUpgradeableProxyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract TransparentUpgradeableProxyV2 is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n\n  /**\n   * @dev Calls a function from the current implementation as specified by `_data`, which should be an encoded function call.\n   *\n   * Requirements:\n   * - Only the admin can call this function.\n   *\n   * Note: The proxy admin is not allowed to interact with the proxy logic through the fallback function to avoid\n   * triggering some unexpected logic. This is to allow the administrator to explicitly call the proxy, please consider\n   * reviewing the encoded data `_data` and the method which is called before using this.\n   *\n   */\n  function functionDelegateCall(bytes memory _data) public payable ifAdmin {\n    address _addr = _implementation();\n    assembly {\n      let _result := delegatecall(gas(), _addr, add(_data, 32), mload(_data), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch _result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/interfaces/bridge/events/IBridgeManagerEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBridgeManagerEvents {\n  /**\n   * @dev The structure representing information about a bridge operator.\n   * @param addr The address of the bridge operator.\n   * @param voteWeight The vote weight assigned to the bridge operator.\n   */\n  struct BridgeOperatorInfo {\n    address addr;\n    uint96 voteWeight;\n  }\n\n  /**\n   * @dev Emitted when new bridge operators are added.\n   * @param statuses The array of boolean values represents whether the corresponding bridge operator is added successfully.\n   * @param voteWeights The array of vote weights assigned to the added bridge operators.\n   * @param governors The array of addresses representing the governors associated with the added bridge operators.\n   * @param bridgeOperators The array of addresses representing the added bridge operators.\n   */\n  event BridgeOperatorsAdded(bool[] statuses, uint96[] voteWeights, address[] governors, address[] bridgeOperators);\n\n  /**\n   * @dev Emitted when bridge operators are removed.\n   * @param statuses The array of boolean values representing the statuses of the removed bridge operators.\n   * @param bridgeOperators The array of addresses representing the removed bridge operators.\n   */\n  event BridgeOperatorsRemoved(bool[] statuses, address[] bridgeOperators);\n\n  /**\n   * @dev Emitted when a bridge operator is updated.\n   * @param governor The address of the governor initiating the update.\n   * @param fromBridgeOperator The address of the bridge operator being updated.\n   * @param toBridgeOperator The updated address of the bridge operator.\n   */\n  event BridgeOperatorUpdated(\n    address indexed governor,\n    address indexed fromBridgeOperator,\n    address indexed toBridgeOperator\n  );\n}\n"
    },
    "contracts/interfaces/bridge/events/IBridgeRewardEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBridgeRewardEvents {\n  /**\n   * @dev Reward-related information for a bridge operator.\n   * @param claimed The amount of rewards claimed by the bridge operator.\n   * @param slashed The amount of rewards that have been slashed from the bridge operator.\n   */\n  struct BridgeRewardInfo {\n    uint256 claimed;\n    uint256 slashed;\n  }\n\n  /**\n   * @dev Emitted when RON are safely received as rewards in the contract.\n   * @param from The address of the sender who transferred RON tokens as rewards.\n   * @param balanceBefore The balance of the contract before receiving the RON tokens.\n   * @param amount The amount of RON received.\n   */\n  event SafeReceived(address indexed from, uint256 balanceBefore, uint256 amount);\n  /// @dev Event emitted when the reward per period config is updated.\n  event UpdatedRewardPerPeriod(uint256 newRewardPerPeriod);\n  /// @dev Event emitted when the reward of the `operator` is scattered with `amount`.\n  event BridgeRewardScattered(uint256 indexed period, address operator, uint256 amount);\n  /// @dev Event emitted when the reward of the `operator` is slashed with `amount`.\n  event BridgeRewardSlashed(uint256 indexed period, address operator, uint256 amount);\n  /// @dev Event emitted when the reward of the `operator` is scattered with `amount` but failed to transfer.\n  event BridgeRewardScatterFailed(uint256 indexed period, address operator, uint256 amount);\n  /// @dev Event emitted when the requesting period to sync  is too far.\n  event BridgeRewardSyncTooFarPeriod(uint256 requestingPeriod, uint256 latestPeriod);\n}\n"
    },
    "contracts/interfaces/bridge/events/IBridgeSlashEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBridgeSlashEvents {\n  /**\n   * @dev Enumeration representing the slashing tiers for bridge operators.\n   */\n  enum Tier {\n    Tier0,\n    Tier1,\n    Tier2\n  }\n\n  /**\n   * @dev Struct representing the status of a bridge operator.\n   */\n  struct BridgeSlashInfo {\n    uint128 slashUntilPeriod;\n    uint128 newlyAddedAtPeriod;\n  }\n\n  /**\n   * @dev Event emitted when a bridge operator is slashed.\n   * @param tier The slash tier of the operator.\n   * @param bridgeOperator The address of the slashed bridge operator.\n   * @param period The period in which the operator is slashed.\n   * @param slashUntilPeriod The period until which the operator is penalized.\n   */\n  event Slashed(Tier indexed tier, address indexed bridgeOperator, uint256 indexed period, uint256 slashUntilPeriod);\n\n  /**\n   * @dev Emitted when a removal request is made for a bridge operator.\n   * @param period The period for which the removal request is made.\n   * @param bridgeOperator The address of the bridge operator being requested for removal.\n   */\n  event RemovalRequested(uint256 indexed period, address indexed bridgeOperator);\n}\n"
    },
    "contracts/interfaces/bridge/IBridgeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IBridgeManagerEvents } from \"./events/IBridgeManagerEvents.sol\";\n\n/**\n * @title IBridgeManager\n * @dev The interface for managing bridge operators.\n */\ninterface IBridgeManager is IBridgeManagerEvents {\n  /**\n   * @dev The domain separator used for computing hash digests in the contract.\n   */\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @dev Returns the total number of bridge operators.\n   * @return The total number of bridge operators.\n   */\n  function totalBridgeOperator() external view returns (uint256);\n\n  /**\n   * @dev Checks if the given address is a bridge operator.\n   * @param addr The address to check.\n   * @return A boolean indicating whether the address is a bridge operator.\n   */\n  function isBridgeOperator(address addr) external view returns (bool);\n\n  /**\n   * @dev Retrieves the full information of all registered bridge operators.\n   *\n   * This external function allows external callers to obtain the full information of all the registered bridge operators.\n   * The returned arrays include the addresses of governors, bridge operators, and their corresponding vote weights.\n   *\n   * @return governors An array of addresses representing the governors of each bridge operator.\n   * @return bridgeOperators An array of addresses representing the registered bridge operators.\n   * @return weights An array of uint256 values representing the vote weights of each bridge operator.\n   *\n   * Note: The length of each array will be the same, and the order of elements corresponds to the same bridge operator.\n   *\n   * Example Usage:\n   * ```\n   * (address[] memory governors, address[] memory bridgeOperators, uint256[] memory weights) = getFullBridgeOperatorInfos();\n   * for (uint256 i = 0; i < bridgeOperators.length; i++) {\n   *     // Access individual information for each bridge operator.\n   *     address governor = governors[i];\n   *     address bridgeOperator = bridgeOperators[i];\n   *     uint256 weight = weights[i];\n   *     // ... (Process or use the information as required) ...\n   * }\n   * ```\n   *\n   */\n  function getFullBridgeOperatorInfos()\n    external\n    view\n    returns (address[] memory governors, address[] memory bridgeOperators, uint96[] memory weights);\n\n  /**\n   * @dev Returns total weights of the governor list.\n   */\n  function sumGovernorsWeight(address[] calldata governors) external view returns (uint256 sum);\n\n  /**\n   * @dev Returns total weights.\n   */\n  function getTotalWeight() external view returns (uint256);\n\n  /**\n   * @dev Returns an array of all bridge operators.\n   * @return An array containing the addresses of all bridge operators.\n   */\n  function getBridgeOperators() external view returns (address[] memory);\n\n  /**\n   * @dev Returns an array of bridge operators correspoding to governor addresses.\n   * @return bridgeOperators_ An array containing the addresses of all bridge operators.\n   */\n  function getBridgeOperatorOf(address[] calldata gorvernors) external view returns (address[] memory bridgeOperators_);\n\n  /**\n   * @dev Retrieves the governors corresponding to a given array of bridge operators.\n   * This external function allows external callers to obtain the governors associated with a given array of bridge operators.\n   * The function takes an input array `bridgeOperators` containing bridge operator addresses and returns an array of corresponding governors.\n   * @param bridgeOperators An array of bridge operator addresses for which governors are to be retrieved.\n   * @return governors An array of addresses representing the governors corresponding to the provided bridge operators.\n   */\n  function getGovernorsOf(address[] calldata bridgeOperators) external view returns (address[] memory governors);\n\n  /**\n   * @dev External function to retrieve the vote weight of a specific governor.\n   * @param governor The address of the governor to get the vote weight for.\n   * @return voteWeight The vote weight of the specified governor.\n   */\n  function getGovernorWeight(address governor) external view returns (uint96);\n\n  /**\n   * @dev External function to retrieve the vote weight of a specific bridge operator.\n   * @param bridgeOperator The address of the bridge operator to get the vote weight for.\n   * @return weight The vote weight of the specified bridge operator.\n   */\n  function getBridgeOperatorWeight(address bridgeOperator) external view returns (uint96 weight);\n\n  /**\n   * @dev Returns the weights of a list of governor addresses.\n   */\n  function getGovernorWeights(address[] calldata governors) external view returns (uint96[] memory weights);\n\n  /**\n   * @dev Returns an array of all governors.\n   * @return An array containing the addresses of all governors.\n   */\n  function getGovernors() external view returns (address[] memory);\n\n  /**\n   * @dev Adds multiple bridge operators.\n   * @param governors An array of addresses of hot/cold wallets for bridge operator to update their node address.\n   * @param bridgeOperators An array of addresses representing the bridge operators to add.\n   * @return addeds An array of booleans indicating whether each bridge operator was added successfully.\n   *\n   * Note: return boolean array `addeds` indicates whether a group (voteWeight, governor, operator) are recorded.\n   * It is expected that FE/BE staticcall to the function first to get the return values and handle it correctly.\n   * Governors are expected to see the outcome of this function and decide if they want to vote for the proposal or not.\n   *\n   * Example Usage:\n   * Making an `eth_call` in ethers.js\n   * ```\n   * const {addeds} = await bridgeManagerContract.callStatic.addBridgeOperators(\n   *  voteWeights,\n   *  governors,\n   *  bridgeOperators,\n   *  // overriding the caller to the contract itself since we use `onlySelfCall` guard\n   *  {from: bridgeManagerContract.address}\n   * )\n   * const filteredOperators = bridgeOperators.filter((_, index) => addeds[index]);\n   * const filteredWeights = weights.filter((_, index) => addeds[index]);\n   * const filteredGovernors = governors.filter((_, index) => addeds[index]);\n   * // ... (Process or use the information as required) ...\n   * ```\n   */\n  function addBridgeOperators(\n    uint96[] calldata voteWeights,\n    address[] calldata governors,\n    address[] calldata bridgeOperators\n  ) external returns (bool[] memory addeds);\n\n  /**\n   * @dev Removes multiple bridge operators.\n   * @param bridgeOperators An array of addresses representing the bridge operators to remove.\n   * @return removeds An array of booleans indicating whether each bridge operator was removed successfully.\n   *\n   * * Note: return boolean array `removeds` indicates whether a group (voteWeight, governor, operator) are recorded.\n   * It is expected that FE/BE staticcall to the function first to get the return values and handle it correctly.\n   * Governors are expected to see the outcome of this function and decide if they want to vote for the proposal or not.\n   *\n   * Example Usage:\n   * Making an `eth_call` in ethers.js\n   * ```\n   * const {removeds} = await bridgeManagerContract.callStatic.removeBridgeOperators(\n   *  bridgeOperators,\n   *  // overriding the caller to the contract itself since we use `onlySelfCall` guard\n   *  {from: bridgeManagerContract.address}\n   * )\n   * const filteredOperators = bridgeOperators.filter((_, index) => removeds[index]);\n   * // ... (Process or use the information as required) ...\n   * ```\n   */\n  function removeBridgeOperators(address[] calldata bridgeOperators) external returns (bool[] memory removeds);\n\n  /**\n   * @dev Governor updates their corresponding governor and/or operator address.\n   * Requirements:\n   * - The caller must the governor of the operator that is requested changes.\n   * @param bridgeOperator The address of the bridge operator to update.\n   */\n  function updateBridgeOperator(address bridgeOperator) external;\n}\n"
    },
    "contracts/interfaces/bridge/IBridgeManagerCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title IBridgeManagerCallback\n * @dev Interface for the callback functions to be implemented by the Bridge Manager contract.\n */\ninterface IBridgeManagerCallback is IERC165 {\n  /**\n   * @dev Handles the event when bridge operators are added.\n   * @param bridgeOperators The addresses of the bridge operators.\n   * @param addeds The corresponding boolean values indicating whether the operators were added or not.\n   * @return selector The selector of the function being called.\n   */\n  function onBridgeOperatorsAdded(\n    address[] memory bridgeOperators,\n    bool[] memory addeds\n  ) external returns (bytes4 selector);\n\n  /**\n   * @dev Handles the event when bridge operators are removed.\n   * @param bridgeOperators The addresses of the bridge operators.\n   * @param removeds The corresponding boolean values indicating whether the operators were removed or not.\n   * @return selector The selector of the function being called.\n   */\n  function onBridgeOperatorsRemoved(\n    address[] memory bridgeOperators,\n    bool[] memory removeds\n  ) external returns (bytes4 selector);\n\n  /**\n   * @dev Handles the event when a bridge operator is updated.\n   * @param currentBridgeOperator The address of the current bridge operator.\n   * @param newbridgeOperator The new address of the bridge operator.\n   * @return selector The selector of the function being called.\n   */\n  function onBridgeOperatorUpdated(\n    address currentBridgeOperator,\n    address newbridgeOperator\n  ) external returns (bytes4 selector);\n}\n"
    },
    "contracts/interfaces/bridge/IBridgeReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { IBridgeRewardEvents } from \"./events/IBridgeRewardEvents.sol\";\n\ninterface IBridgeReward is IBridgeRewardEvents {\n  /**\n   * @dev This function allows bridge operators to manually synchronize the reward for a given period length.\n   * @param periodLength The length of the reward period for which synchronization is requested.\n   */\n  function syncReward(uint256 periodLength) external;\n\n  /**\n   * @dev Receives RON from any address.\n   */\n  function receiveRON() external payable;\n\n  /**\n   * @dev Invoke calculate and transfer reward to operators based on their performance.\n   *\n   * Requirements:\n   * - This method is only called once each period.\n   * - The caller must be the bridge tracking contract or a bridge operator.\n   */\n  function execSyncReward(\n    address[] calldata operators,\n    uint256[] calldata ballots,\n    uint256 totalBallot,\n    uint256 totalVote,\n    uint256 period\n  ) external;\n\n  /**\n   * @dev Retrieve the total amount of rewards that have been topped up in the contract.\n   * @return totalRewardToppedUp The total rewards topped up value.\n   */\n  function getTotalRewardToppedUp() external view returns (uint256);\n\n  /**\n   * @dev Retrieve the total amount of rewards that have been scattered to bridge operators in the contract.\n   * @return totalRewardScattered The total rewards scattered value.\n   */\n  function getTotalRewardScattered() external view returns (uint256);\n\n  /**\n   * @dev Getter for all bridge operators per period.\n   */\n  function getRewardPerPeriod() external view returns (uint256);\n\n  /**\n   * @dev External function to retrieve the latest rewarded period in the contract.\n   * @return latestRewardedPeriod The latest rewarded period value.\n   */\n  function getLatestRewardedPeriod() external view returns (uint256);\n\n  /**\n   * @dev Setter for all bridge operators per period.\n   */\n  function setRewardPerPeriod(uint256 rewardPerPeriod) external;\n}\n"
    },
    "contracts/interfaces/bridge/IBridgeSlash.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IBridgeSlashEvents } from \"./events/IBridgeSlashEvents.sol\";\n\n/**\n * @title IBridgeSlash\n * @dev Interface for the BridgeSlash contract to manage slashing functionality for bridge operators.\n */\ninterface IBridgeSlash is IBridgeSlashEvents {\n  /**\n   * @dev Slashes the unavailability of bridge operators during a specific period.\n   * @param period The period to slash the bridge operators for.\n   */\n  function execSlashBridgeOperators(\n    address[] calldata operators,\n    uint256[] calldata ballots,\n    uint256 totalBallot,\n    uint256 totalVote,\n    uint256 period\n  ) external;\n\n  /**\n   * @dev Returns the penalize durations for the specified bridge operators.\n   * @param bridgeOperators The addresses of the bridge operators.\n   * @return untilPeriods The penalized periods for the bridge operators.\n   */\n  function getSlashUntilPeriodOf(address[] calldata bridgeOperators) external returns (uint256[] memory untilPeriods);\n\n  /**\n   * @dev Retrieves the added periods of the specified bridge operators.\n   * @param bridgeOperators An array of bridge operator addresses.\n   * @return addedPeriods An array of uint256 values representing the added periods for each bridge operator.\n   */\n  function getAddedPeriodOf(address[] calldata bridgeOperators) external view returns (uint256[] memory addedPeriods);\n\n  /**\n   * @dev Gets the slash tier based on the given ballot and total ballots.\n   * @param ballot The ballot count for a bridge operator.\n   * @param totalVote The total vote count for the period.\n   * @return tier The slash tier.\n   */\n  function getSlashTier(uint256 ballot, uint256 totalVote) external pure returns (Tier tier);\n\n  /**\n   * @dev Retrieve the penalty durations for different slash tiers.\n   * @return penaltyDurations The array of penalty durations for each slash tier.\n   */\n  function getPenaltyDurations() external pure returns (uint256[] memory penaltyDurations);\n\n  /**\n   * @dev Returns the penalty duration for Tier 1 slashing.\n   * @return The duration in period number for Tier 1 slashing.\n   */\n  function TIER_1_PENALTY_DURATION() external view returns (uint256);\n\n  /**\n   * @dev Returns the penalty duration for Tier 2 slashing.\n   * @return The duration in period number for Tier 2 slashing.\n   */\n  function TIER_2_PENALTY_DURATION() external view returns (uint256);\n\n  /**\n   * @dev Returns the threshold duration for removing bridge operators.\n   * @return The duration in period number that exceeds which a bridge operator will be removed.\n   */\n  function REMOVE_DURATION_THRESHOLD() external view returns (uint256);\n\n  /**\n   * @dev External function to retrieve the value of the minimum vote threshold to execute slashing rule.\n   * @return minimumVoteThreshold The minimum vote threshold value.\n   */\n  function MINIMUM_VOTE_THRESHOLD() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/bridge/IBridgeTracking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBridgeTracking {\n  struct Request {\n    VoteKind kind;\n    uint256 id;\n  }\n\n  enum VoteKind {\n    Deposit,\n    Withdrawal,\n    MainchainWithdrawal\n  }\n\n  event ExternalCallFailed(address indexed to, bytes4 indexed msgSig, bytes reason);\n\n  /**\n   * @dev Returns the block that allow incomming mutable call.\n   */\n  function startedAtBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the total number of votes at the specific period `_period`.\n   */\n  function totalVote(uint256 _period) external view returns (uint256);\n\n  /**\n   * @dev Returns the total number of ballots at the specific period `_period`.\n   */\n  function totalBallot(uint256 _period) external view returns (uint256);\n\n  /**\n   * @dev Returns the total number of ballots of bridge operators at the specific period `_period`.\n   */\n  function getManyTotalBallots(\n    uint256 _period,\n    address[] calldata _bridgeOperators\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the total number of ballots of a bridge operator at the specific period `_period`.\n   */\n  function totalBallotOf(uint256 _period, address _bridgeOperator) external view returns (uint256);\n\n  /**\n   * @dev Handles the request once it is approved.\n   *\n   * Requirements:\n   * - The method caller is the bridge contract.\n   *\n   */\n  function handleVoteApproved(VoteKind _kind, uint256 _requestId) external;\n\n  /**\n   * @dev Records vote for a receipt and a operator.\n   *\n   * Requirements:\n   * - The method caller is the bridge contract.\n   *\n   */\n  function recordVote(VoteKind _kind, uint256 _requestId, address _operator) external;\n}\n"
    },
    "contracts/interfaces/collections/IHasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { ContractType } from \"../../utils/ContractType.sol\";\n\ninterface IHasContracts {\n  /// @dev Error of invalid role.\n  error ErrContractTypeNotFound(ContractType contractType);\n\n  /// @dev Emitted when a contract is updated.\n  event ContractUpdated(ContractType indexed contractType, address indexed addr);\n\n  /**\n   * @dev Returns the address of a contract with a specific role.\n   * Throws an error if no contract is set for the specified role.\n   *\n   * @param contractType The role of the contract to retrieve.\n   * @return contract_ The address of the contract with the specified role.\n   */\n  function getContract(ContractType contractType) external view returns (address contract_);\n\n  /**\n   * @dev Sets the address of a contract with a specific role.\n   * Emits the event {ContractUpdated}.\n   * @param contractType The role of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function setContract(ContractType contractType, address addr) external;\n}\n"
    },
    "contracts/interfaces/consumers/ChainTypeConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainTypeConsumer {\n  enum ChainType {\n    RoninChain,\n    Mainchain\n  }\n}\n"
    },
    "contracts/interfaces/consumers/MappedTokenConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../libraries/Token.sol\";\n\ninterface MappedTokenConsumer {\n  struct MappedToken {\n    Token.Standard erc;\n    address tokenAddr;\n  }\n}\n"
    },
    "contracts/interfaces/consumers/PeriodWrapperConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PeriodWrapperConsumer {\n  struct PeriodWrapper {\n    // Inner value.\n    uint256 inner;\n    // Last period number that the info updated.\n    uint256 lastPeriod;\n  }\n}\n"
    },
    "contracts/interfaces/consumers/SignatureConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface SignatureConsumer {\n  struct Signature {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n}\n"
    },
    "contracts/interfaces/consumers/VoteStatusConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VoteStatusConsumer {\n  enum VoteStatus {\n    Pending,\n    Approved,\n    Executed,\n    Rejected,\n    Expired\n  }\n}\n"
    },
    "contracts/interfaces/IERC20Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\ninterface IERC20Mintable {\n  function mint(address _to, uint256 _value) external returns (bool _success);\n}\n"
    },
    "contracts/interfaces/IERC721Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC721Mintable {\n  function mint(address _to, uint256 _tokenId) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IFastFinalityTracking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IFastFinalityTracking {\n  /**\n   * @dev Submit list of `voters` who vote for fast finality in the current block.\n   *\n   * Requirements:\n   * - Only called once per block\n   * - Only coinbase can call this method\n   */\n  function recordFinality(address[] calldata voters) external;\n\n  /**\n   * @dev Returns vote count of `addrs` in the `period`.\n   */\n  function getManyFinalityVoteCounts(\n    uint256 period,\n    address[] calldata addrs\n  ) external view returns (uint256[] memory voteCounts);\n}\n"
    },
    "contracts/interfaces/IMaintenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TConsensus } from \"../udvts/Types.sol\";\n\ninterface IMaintenance {\n  /**\n   * @dev Error thrown when attempting to schedule an already scheduled event.\n   */\n  error ErrAlreadyScheduled();\n\n  /**\n   * @dev Error thrown when referring to a non-existent schedule.\n   */\n  error ErrUnexistedSchedule();\n\n  /**\n   * @dev Error thrown when the end block of a schedule is out of range.\n   */\n  error ErrEndBlockOutOfRange();\n\n  /**\n   * @dev Error thrown when the start block of a schedule is out of range.\n   */\n  error ErrStartBlockOutOfRange();\n\n  /**\n   * @dev Error thrown when attempting to initiate maintenance while already in maintenance mode.\n   */\n  error ErrAlreadyOnMaintenance();\n\n  /**\n   * @dev Error thrown when attempting an action before the cooldown period has ended.\n   */\n  error ErrCooldownTimeNotYetEnded();\n\n  /**\n   * @dev Error thrown when the total number of schedules exceeds the limit.\n   */\n  error ErrTotalOfSchedulesExceeded();\n\n  /**\n   * @dev Error thrown when an invalid maintenance duration is specified.\n   */\n  error ErrInvalidMaintenanceDuration();\n\n  /**\n   * @dev Error thrown when an invalid maintenance duration configuration is provided.\n   */\n  error ErrInvalidMaintenanceDurationConfig();\n\n  /**\n   * @dev Error thrown when an invalid offset is specified to start the schedule configurations.\n   */\n  error ErrInvalidOffsetToStartScheduleConfigs();\n\n  struct Schedule {\n    uint256 from;\n    uint256 to;\n    uint256 lastUpdatedBlock;\n    uint256 requestTimestamp;\n  }\n\n  /// @dev Emitted when a maintenance is scheduled.\n  event MaintenanceScheduled(TConsensus indexed consensusAddr, Schedule);\n  /// @dev Emitted when a schedule of maintenance is cancelled.\n  event MaintenanceScheduleCancelled(TConsensus indexed consensusAddr);\n  /// @dev Emitted when the maintenance config is updated.\n  event MaintenanceConfigUpdated(\n    uint256 minMaintenanceDurationInBlock,\n    uint256 maxMaintenanceDurationInBlock,\n    uint256 minOffsetToStartSchedule,\n    uint256 maxOffsetToStartSchedule,\n    uint256 maxSchedules,\n    uint256 cooldownSecsToMaintain\n  );\n\n  /**\n   * @dev Returns whether the validator `consensusAddr` maintained at the block number `_block`.\n   */\n  function checkMaintained(TConsensus consensusAddr, uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator whose id `validatorId` maintained at the block number `_block`.\n   */\n  function checkMaintainedById(address validatorId, uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `consensusAddr` maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks.\n   */\n  function checkMaintainedInBlockRange(\n    TConsensus consensusAddr,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool);\n\n  /**\n   * @dev Returns the bool array indicating the validators maintained at block number `k` or not.\n   */\n  function checkManyMaintained(\n    TConsensus[] calldata consensusAddrList,\n    uint256 atBlock\n  ) external view returns (bool[] memory);\n\n  function checkManyMaintainedById(\n    address[] calldata candidateIdList,\n    uint256 atBlock\n  ) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns a bool array indicating the validators maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks or not.\n   */\n  function checkManyMaintainedInBlockRange(\n    TConsensus[] calldata _consensusAddrList,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool[] memory);\n\n  function checkManyMaintainedInBlockRangeById(\n    address[] calldata idList,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the validator `consensusAddr` has finished cooldown.\n   */\n  function checkCooldownEnded(TConsensus consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `consensusAddr` has schedule.\n   */\n  function checkScheduled(TConsensus consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns the detailed schedule of the validator `consensusAddr`.\n   */\n  function getSchedule(TConsensus consensusAddr) external view returns (Schedule memory);\n\n  /**\n   * @dev Returns the total of current schedules.\n   */\n  function totalSchedule() external view returns (uint256 count);\n\n  /**\n   * @dev Returns the cooldown to maintain in seconds.\n   */\n  function cooldownSecsToMaintain() external view returns (uint256);\n\n  /**\n   * @dev Sets the duration restriction, start time restriction, and max allowed for maintenance.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The max duration is larger than the min duration.\n   * - The max offset is larger than the min offset.\n   *\n   * Emits the event `MaintenanceConfigUpdated`.\n   *\n   */\n  function setMaintenanceConfig(\n    uint256 minMaintenanceDurationInBlock_,\n    uint256 maxMaintenanceDurationInBlock_,\n    uint256 minOffsetToStartSchedule_,\n    uint256 maxOffsetToStartSchedule_,\n    uint256 maxSchedules_,\n    uint256 cooldownSecsToMaintain_\n  ) external;\n\n  /**\n   * @dev Returns the min duration for maintenance in block.\n   */\n  function minMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the max duration for maintenance in block.\n   */\n  function maxMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev The offset to the min block number that the schedule can start\n   */\n  function minOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev The offset to the max block number that the schedule can start\n   */\n  function maxOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev Returns the max number of scheduled maintenances.\n   */\n  function maxSchedule() external view returns (uint256);\n\n  /**\n   * @dev Schedules for maintenance from `startedAtBlock` to `endedAtBlock`.\n   *\n   * Requirements:\n   * - The candidate `consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `consensusAddr`.\n   * - The candidate `consensusAddr` has no schedule yet or the previous is done.\n   * - The total number of schedules is not larger than `maxSchedules()`.\n   * - The start block must be at least `minOffsetToStartSchedule()` and at most `maxOffsetToStartSchedule()` blocks from the current block.\n   * - The end block is larger than the start block.\n   * - The scheduled duration is larger than the `minMaintenanceDurationInBlock()` and less than the `maxMaintenanceDurationInBlock()`.\n   * - The start block is at the start of an epoch.\n   * - The end block is at the end of an epoch.\n   *\n   * Emits the event `MaintenanceScheduled`.\n   *\n   */\n  function schedule(TConsensus consensusAddr, uint256 startedAtBlock, uint256 endedAtBlock) external;\n\n  /**\n   * @dev Cancel the schedule of maintenance for the `consensusAddr`.\n   *\n   * Requirements:\n   * - The candidate `consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `consensusAddr`.\n   * - A schedule for the `consensusAddr` must be existent and not executed yet.\n   *\n   * Emits the event `MaintenanceScheduleCancelled`.\n   */\n  function cancelSchedule(TConsensus consensusAddr) external;\n}\n"
    },
    "contracts/interfaces/IProfile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TPoolId, TConsensus } from \"../udvts/Types.sol\";\nimport \"../utils/RoleAccess.sol\";\n\ninterface IProfile {\n  struct CandidateProfile {\n    /**\n     * @dev Primary key of the profile, use for backward querying.\n     *\n     * {Staking} Contract: index of pool\n     * {RoninValidatorSet} Contract: index of almost all data related to a validator\n     *\n     */\n    address id;\n    /// @dev Consensus address.\n    TConsensus consensus;\n    /// @dev Pool admin address.\n    address admin;\n    /// @dev Treasury address.\n    address payable treasury;\n    /// @dev Address to voting proposal.\n    address __reservedGovernor;\n    /// @dev Public key for fast finality.\n    bytes pubkey;\n  }\n\n  /// @dev Event emitted when a profile with `id` is added.\n  event ProfileAdded(address indexed id);\n  /// @dev Event emitted when a address in a profile is changed.\n  event ProfileAddressChanged(address indexed id, RoleAccess indexed addressType);\n  /// @dev Event emitted when the pubkey of the `id` is changed.\n  event PubkeyChanged(address indexed id, bytes pubkey);\n\n  /// @dev Error of already existed profile.\n  error ErrExistentProfile();\n  /// @dev Error of non existed profile.\n  error ErrNonExistentProfile();\n  /// @dev Error when create a new profile whose id and consensus are not identical.\n  error ErrIdAndConsensusDiffer();\n  /**\n   * @dev Error when there is a duplicated info of `value`, which is uin256-padding value of any address or hash of public key,\n   * and with value type of `infoType`.\n   */\n  error ErrDuplicatedInfo(RoleAccess infoType, uint256 value);\n  error ErrDuplicatedPubkey(bytes pubkey);\n  error ErrZeroAddress(RoleAccess infoType);\n  error ErrZeroPubkey();\n\n  /// @dev Getter to query full `profile` from `id` address.\n  function getId2Profile(address id) external view returns (CandidateProfile memory profile);\n\n  /// @dev Getter to batch query from `id` to `consensus`, return address(0) if the profile not exist.\n  function getManyId2Consensus(address[] calldata idList) external view returns (TConsensus[] memory consensusList);\n\n  /// @dev Getter to backward query from `consensus` address to `id` address.\n  function getConsensus2Id(TConsensus consensus) external view returns (address id);\n\n  /// @dev Getter to backward batch query from `consensus` address to `id` address.\n  function getManyConsensus2Id(TConsensus[] memory consensus) external view returns (address[] memory);\n\n  /**\n   * @notice Add a new profile.\n   *\n   * @dev Requirements:\n   * - The profile must not be existent before.\n   * - Only contract admin can call this method.\n   */\n  function addNewProfile(CandidateProfile memory profile) external;\n\n  /**\n   * @dev Cross-contract function to add/update new profile of a validator candidate when they\n   * applying for candidate role.\n   *\n   * Requirements:\n   * - Only `stakingContract` can call this method.\n   */\n  function execApplyValidatorCandidate(address admin, address id, address treasury, bytes calldata pubkey) external;\n\n  /**\n   * @dev Updated the treasury address of candidate id `id` immediately without waiting time.\n   *\n   * Emit an {ProfileAddressChanged}.\n   */\n  function requestChangeAdminAddress(address id, address newAdminAddr) external;\n\n  /**\n   * @dev Updated the treasury address of candidate id `id` immediately without waiting time.\n   *\n   * Emit an {ProfileAddressChanged}.\n   */\n  function requestChangeConsensusAddr(address id, TConsensus newConsensusAddr) external;\n\n  /**\n   * @dev Updated the treasury address of candidate id `id` immediately without waiting time.\n   *\n   * Emit an {ProfileAddressChanged}.\n   */\n  function requestChangeTreasuryAddr(address id, address payable newTreasury) external;\n\n  /**\n   * @notice The candidate admin changes the public key.\n   *\n   * @dev Requirements:\n   * - The profile must be existed.\n   * - Only user with candidate admin role can call this method.\n   * - New public key must not be duplicated.\n   */\n\n  function changePubkey(address id, bytes memory pubkey) external;\n}\n"
    },
    "contracts/interfaces/IQuorum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IQuorum {\n  /// @dev Emitted when the threshold is updated\n  event ThresholdUpdated(\n    uint256 indexed nonce,\n    uint256 indexed numerator,\n    uint256 indexed denominator,\n    uint256 previousNumerator,\n    uint256 previousDenominator\n  );\n\n  /**\n   * @dev Returns the threshold.\n   */\n  function getThreshold() external view returns (uint256 _num, uint256 _denom);\n\n  /**\n   * @dev Checks whether the `_voteWeight` passes the threshold.\n   */\n  function checkThreshold(uint256 _voteWeight) external view returns (bool);\n\n  /**\n   * @dev Returns the minimum vote weight to pass the threshold.\n   */\n  function minimumVoteWeight() external view returns (uint256);\n\n  /**\n   * @dev Sets the threshold.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `ThresholdUpdated` event.\n   *\n   */\n  function setThreshold(\n    uint256 _numerator,\n    uint256 _denominator\n  ) external returns (uint256 _previousNum, uint256 _previousDenom);\n}\n"
    },
    "contracts/interfaces/IRoninGatewayV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../libraries/Transfer.sol\";\nimport \"./consumers/MappedTokenConsumer.sol\";\n\ninterface IRoninGatewayV3 is MappedTokenConsumer {\n  /**\n   * @dev Error thrown when attempting to withdraw funds that have already been migrated.\n   */\n  error ErrWithdrawalsMigrated();\n\n  /**\n   * @dev Error thrown when an invalid trusted threshold is specified.\n   */\n  error ErrInvalidTrustedThreshold();\n\n  /**\n   * @dev Error thrown when attempting to withdraw funds that have already been withdrawn on the mainchain.\n   */\n  error ErrWithdrawnOnMainchainAlready();\n\n  /// @dev Emitted when the assets are depositted\n  event Deposited(bytes32 receiptHash, Transfer.Receipt receipt);\n  /// @dev Emitted when the withdrawal is requested\n  event WithdrawalRequested(bytes32 receiptHash, Transfer.Receipt);\n  /// @dev Emitted when the assets are withdrawn on mainchain\n  event MainchainWithdrew(bytes32 receiptHash, Transfer.Receipt receipt);\n  /// @dev Emitted when the withdrawal signatures is requested\n  event WithdrawalSignaturesRequested(bytes32 receiptHash, Transfer.Receipt);\n  /// @dev Emitted when the tokens are mapped\n  event TokenMapped(address[] roninTokens, address[] mainchainTokens, uint256[] chainIds, Token.Standard[] standards);\n  /// @dev Emitted when the threshold is updated\n  event TrustedThresholdUpdated(\n    uint256 indexed nonce,\n    uint256 indexed numerator,\n    uint256 indexed denominator,\n    uint256 previousNumerator,\n    uint256 previousDenominator\n  );\n  /// @dev Emitted when a deposit is voted\n  event DepositVoted(address indexed bridgeOperator, uint256 indexed id, uint256 indexed chainId, bytes32 receiptHash);\n\n  /**\n   * @dev Returns withdrawal count.\n   */\n  function withdrawalCount() external view returns (uint256);\n\n  /**\n   * @dev Returns withdrawal signatures.\n   */\n  function getWithdrawalSignatures(\n    uint256 _withdrawalId,\n    address[] calldata _validators\n  ) external view returns (bytes[] memory);\n\n  /**\n   * @dev Deposits based on the receipt.\n   *\n   * Requirements:\n   * - The method caller is a validator.\n   *\n   * Emits the `Deposited` once the assets are released.\n   *\n   * @notice The assets will be transferred whenever the valid call passes the quorum threshold.\n   *\n   */\n  function depositFor(Transfer.Receipt calldata _receipt) external;\n\n  /**\n   * @dev Marks the withdrawals are done on mainchain and returns the boolean array indicating whether the withdrawal\n   * vote is already done before.\n   *\n   * Requirements:\n   * - The method caller is a validator.\n   *\n   * Emits the `MainchainWithdrew` once the valid call passes the quorum threshold.\n   *\n   * @notice Not reverting to avoid unnecessary failed transactions because the validators can send transactions at the\n   * same time.\n   *\n   */\n  function tryBulkAcknowledgeMainchainWithdrew(uint256[] calldata _withdrawalIds) external returns (bool[] memory);\n\n  /**\n   * @dev Tries bulk deposits based on the receipts and returns the boolean array indicating whether the deposit vote\n   * is already done before. Reverts if the deposit is invalid or is voted by the validator again.\n   *\n   * Requirements:\n   * - The method caller is a validator.\n   *\n   * Emits the `Deposited` once the assets are released.\n   *\n   * @notice The assets will be transferred whenever the valid call for the receipt passes the quorum threshold. Not\n   * reverting to avoid unnecessary failed transactions because the validators can send transactions at the same time.\n   *\n   */\n  function tryBulkDepositFor(Transfer.Receipt[] calldata _receipts) external returns (bool[] memory);\n\n  /**\n   * @dev Locks the assets and request withdrawal.\n   *\n   * Emits the `WithdrawalRequested` event.\n   *\n   */\n  function requestWithdrawalFor(Transfer.Request calldata _request, uint256 _chainId) external;\n\n  /**\n   * @dev Bulk requests withdrawals.\n   *\n   * Emits the `WithdrawalRequested` events.\n   *\n   */\n  function bulkRequestWithdrawalFor(Transfer.Request[] calldata _requests, uint256 _chainId) external;\n\n  /**\n   * @dev Requests withdrawal signatures for a specific withdrawal.\n   *\n   * Emits the `WithdrawalSignaturesRequested` event.\n   *\n   */\n  function requestWithdrawalSignatures(uint256 _withdrawalId) external;\n\n  /**\n   * @dev Submits withdrawal signatures.\n   *\n   * Requirements:\n   * - The method caller is a validator.\n   *\n   */\n  function bulkSubmitWithdrawalSignatures(uint256[] calldata _withdrawals, bytes[] calldata _signatures) external;\n\n  /**\n   * @dev Maps Ronin tokens to mainchain networks.\n   *\n   * Requirement:\n   * - The method caller is admin.\n   * - The arrays have the same length and its length larger than 0.\n   *\n   * Emits the `TokenMapped` event.\n   *\n   */\n  function mapTokens(\n    address[] calldata _roninTokens,\n    address[] calldata _mainchainTokens,\n    uint256[] calldata chainIds,\n    Token.Standard[] calldata _standards\n  ) external;\n\n  /**\n   * @dev Returns whether the deposit is casted by the voter.\n   */\n  function depositVoted(uint256 _chainId, uint256 _depositId, address _voter) external view returns (bool);\n\n  /**\n   * @dev Returns whether the mainchain withdrew is casted by the voter.\n   */\n  function mainchainWithdrewVoted(uint256 _withdrawalId, address _voter) external view returns (bool);\n\n  /**\n   * @dev Returns whether the withdrawal is done on mainchain.\n   */\n  function mainchainWithdrew(uint256 _withdrawalId) external view returns (bool);\n\n  /**\n   * @dev Returns mainchain token address.\n   * Reverts for unsupported token.\n   */\n  function getMainchainToken(address _roninToken, uint256 _chainId) external view returns (MappedToken memory _token);\n}\n"
    },
    "contracts/interfaces/IRoninGovernanceAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/CommonErrors.sol\";\n\ninterface IRoninGovernanceAdmin {\n  /// @dev Emitted when an emergency exit poll is created.\n  event EmergencyExitPollCreated(\n    bytes32 voteHash,\n    address validatorId,\n    address recipientAfterUnlockedFund,\n    uint256 requestedAt,\n    uint256 expiredAt\n  );\n  /// @dev Emitted when an emergency exit poll is approved.\n  event EmergencyExitPollApproved(bytes32 voteHash);\n  /// @dev Emitted when an emergency exit poll is expired.\n  event EmergencyExitPollExpired(bytes32 voteHash);\n  /// @dev Emitted when an emergency exit poll is voted.\n  event EmergencyExitPollVoted(bytes32 indexed voteHash, address indexed voter);\n\n  /**\n   * @dev Create a vote to agree that an emergency exit is valid and should return the locked funds back.a\n   *\n   * Requirements:\n   * - The method caller is validator contract.\n   *\n   */\n  function createEmergencyExitPoll(\n    address validatorId,\n    address recipientAfterUnlockedFund,\n    uint256 requestedAt,\n    uint256 expiredAt\n  ) external;\n}\n"
    },
    "contracts/interfaces/IRoninTrustedOrganization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IQuorum.sol\";\nimport \"../udvts/Types.sol\";\n\ninterface IRoninTrustedOrganization is IQuorum {\n  /**\n   * @dev Error indicating that a query for a duplicate entry was made.\n   */\n  error ErrQueryForDupplicated();\n\n  /**\n   * @dev Error indicating that a query was made for a non-existent consensus address.\n   */\n  error ErrQueryForNonExistentConsensusAddress();\n\n  /**\n   * @dev Error indicating that a governor address has already been added.\n   * @param addr The address of the governor that is already added.\n   */\n  error ErrGovernorAddressIsAlreadyAdded(address addr);\n\n  /**\n   * @dev Error indicating that a consensus address is not added.\n   * @param addr The address of the consensus contract that is not added.\n   */\n  error ErrConsensusAddressIsNotAdded(TConsensus addr);\n\n  /**\n   * @dev Error indicating that a consensus address is already added.\n   * @param addr The address of the consensus contract that is already added.\n   */\n  error ErrConsensusAddressIsAlreadyAdded(TConsensus addr);\n\n  struct TrustedOrganization {\n    // Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n    TConsensus consensusAddr;\n    // Address to voting proposal\n    address governor;\n    // Address to voting bridge operators\n    address __deprecatedBridgeVoter;\n    // Its Weight\n    uint256 weight;\n    // The block that the organization was added\n    uint256 addedBlock;\n  }\n\n  /// @dev Emitted when the trusted organization is added.\n  event TrustedOrganizationsAdded(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is updated.\n  event TrustedOrganizationsUpdated(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is removed.\n  event TrustedOrganizationsRemoved(TConsensus[] orgs);\n  /// @dev Emitted when the consensus address of a trusted organization is changed.\n  event ConsensusAddressOfTrustedOrgChanged(TrustedOrganization orgAfterChanged, TConsensus oldConsensus);\n\n  /**\n   * @dev Adds a list of addresses into the trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   * - The field `addedBlock` should be blank.\n   *\n   * Emits the event `TrustedOrganizationAdded` once an organization is added.\n   *\n   */\n  function addTrustedOrganizations(TrustedOrganization[] calldata) external;\n\n  /**\n   * @dev Updates weights for a list of existent trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   *\n   * Emits the `TrustedOrganizationUpdated` event.\n   *\n   */\n  function updateTrustedOrganizations(TrustedOrganization[] calldata list) external;\n\n  /**\n   * @dev Removes a list of addresses from the trusted organization.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `TrustedOrganizationRemoved` once an organization is removed.\n   *\n   * @param consensusAddrs The list of consensus addresses linked to corresponding trusted organization that to be removed.\n   */\n  function removeTrustedOrganizations(TConsensus[] calldata consensusAddrs) external;\n\n  /**\n   * @dev Fallback function of `Profile-requestChangeConsensusAddress`.\n   *\n   * Requirements:\n   * - The caller must be the Profile contract.\n   *\n   * Emits the event `ConsensusAddressOfTrustedOrgChanged` once an organization is removed.\n   */\n  function execChangeConsensusAddressForTrustedOrg(TConsensus oldConsensusAddr, TConsensus newConsensusAddr) external;\n\n  /**\n   * @dev Returns total weights.\n   */\n  function totalWeight() external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a consensus.\n   */\n  function getConsensusWeight(TConsensus consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a consensus.\n   */\n  function getConsensusWeightById(address cid) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a governor.\n   */\n  function getGovernorWeight(address governor) external view returns (uint256);\n\n  /**\n   * @dev Returns the weights of a list of consensus addresses.\n   */\n  function getConsensusWeights(TConsensus[] calldata list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of consensus addresses.\n   */\n  function getConsensusWeightsById(address[] calldata cids) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of governor addresses.\n   */\n  function getGovernorWeights(address[] calldata list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns total weights of the consensus list.\n   */\n  function sumConsensusWeight(TConsensus[] calldata list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns total weights of the governor list.\n   */\n  function sumGovernorWeight(address[] calldata list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns the trusted organization at `_index`.\n   */\n  function getTrustedOrganizationAt(uint256 index) external view returns (TrustedOrganization memory);\n\n  /**\n   * @dev Returns the number of trusted organizations.\n   */\n  function countTrustedOrganization() external view returns (uint256);\n\n  /**\n   * @dev Returns all of the trusted organizations.\n   */\n  function getAllTrustedOrganizations() external view returns (TrustedOrganization[] memory);\n\n  /**\n   * @dev Returns the trusted organization by consensus address.\n   *\n   * Reverts once the consensus address is non-existent.\n   */\n  function getTrustedOrganization(TConsensus consensusAddr) external view returns (TrustedOrganization memory);\n}\n"
    },
    "contracts/interfaces/IStakingVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IStakingVesting {\n  /**\n   * @dev Error thrown when attempting to send a bonus that has already been sent.\n   */\n  error ErrBonusAlreadySent();\n\n  /// @dev Emitted when the block bonus for block producer is transferred.\n  event BonusTransferred(\n    uint256 indexed blockNumber,\n    address indexed recipient,\n    uint256 blockProducerAmount,\n    uint256 bridgeOperatorAmount\n  );\n  /// @dev Emitted when the transfer of block bonus for block producer is failed.\n  event BonusTransferFailed(\n    uint256 indexed blockNumber,\n    address indexed recipient,\n    uint256 blockProducerAmount,\n    uint256 bridgeOperatorAmount,\n    uint256 contractBalance\n  );\n  /// @dev Emitted when the block bonus for block producer is updated\n  event BlockProducerBonusPerBlockUpdated(uint256);\n  /// @dev Emitted when the block bonus for bridge operator is updated\n  event BridgeOperatorBonusPerBlockUpdated(uint256);\n  /// @dev Emitted when the percent of fast finality reward is updated\n  event FastFinalityRewardPercentageUpdated(uint256);\n\n  /**\n   * @dev Returns the bonus amount for the block producer at `blockNum`.\n   */\n  function blockProducerBlockBonus(uint256 blockNum) external view returns (uint256);\n\n  /**\n   * @dev Returns the bonus amount for the bridge validator at `blockNum`.\n   */\n  function bridgeOperatorBlockBonus(uint256 blockNum) external view returns (uint256);\n\n  /**\n   * @dev Returns the percentage of fast finality reward.\n   */\n  function fastFinalityRewardPercentage() external view returns (uint256);\n\n  /**\n   * @dev Receives RON from any address.\n   */\n  function receiveRON() external payable;\n\n  /**\n   * @dev Returns the last block number that the staking vesting is sent.\n   */\n  function lastBlockSendingBonus() external view returns (uint256);\n\n  /**\n   * @dev Transfers the staking vesting for the block producer and the bridge operator whenever a new block is mined.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   * - The method must be called only once per block.\n   *\n   * Emits the event `BonusTransferred` or `BonusTransferFailed`.\n   *\n   * Notes:\n   * - The method does not revert when the contract balance is insufficient to send bonus. This assure the submit reward method\n   * will not be reverted, and the underlying nodes does not hang.\n   *\n   * @param forBlockProducer Indicates whether requesting the bonus for the block procucer, in case of being in jail or relevance.\n   * @param forBridgeOperator Indicates whether requesting the bonus for the bridge operator.\n   *\n   * @return success Whether the transfer is successfully. This returns false mostly because this contract is out of balance.\n   * @return blockProducerBonus The amount of bonus actually sent for the block producer, returns 0 when the transfer is failed.\n   * @return bridgeOperatorBonus The amount of bonus actually sent for the bridge operator, returns 0 when the transfer is failed.\n   * @return fastFinalityRewardPercentage The percent of fast finality reward, returns 0 when the transfer is failed.\n   *\n   */\n  function requestBonus(\n    bool forBlockProducer,\n    bool forBridgeOperator\n  )\n    external\n    returns (\n      bool success,\n      uint256 blockProducerBonus,\n      uint256 bridgeOperatorBonus,\n      uint256 fastFinalityRewardPercentage\n    );\n\n  /**\n   * @dev Sets the bonus amount per block for block producer.\n   *\n   * Emits the event `BlockProducerBonusPerBlockUpdated`.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   */\n  function setBlockProducerBonusPerBlock(uint256 amount) external;\n\n  /**\n   * @dev Sets the bonus amount per block for bridge operator.\n   *\n   * Emits the event `BridgeOperatorBonusPerBlockUpdated`.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   */\n  function setBridgeOperatorBonusPerBlock(uint256 _amount) external;\n\n  /**\n   * @dev Sets the percent of fast finality reward.\n   *\n   * Emits the event `FastFinalityRewardPercentageUpdated`.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   */\n  function setFastFinalityRewardPercentage(uint256 _percent) external;\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWETH {\n  function deposit() external payable;\n\n  function withdraw(uint256 _wad) external;\n\n  function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/slash-indicator/IBaseSlash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IBaseSlash {\n  enum SlashType {\n    UNKNOWN,\n    UNAVAILABILITY_TIER_1,\n    UNAVAILABILITY_TIER_2,\n    DOUBLE_SIGNING,\n    BRIDGE_VOTING,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_1,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_2,\n    UNAVAILABILITY_TIER_3,\n    FAST_FINALITY\n  }\n\n  /// @dev Error thrown when evidence has already been submitted.\n  error ErrEvidenceAlreadySubmitted();\n\n  /// @dev Emitted when the validator is slashed.\n  event Slashed(address indexed validator, SlashType slashType, uint256 period);\n}\n"
    },
    "contracts/interfaces/slash-indicator/ICreditScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ICreditScore {\n  /**\n   * @dev Error thrown when an invalid credit score configuration is provided.\n   */\n  error ErrInvalidCreditScoreConfig();\n\n  /**\n   * @dev Error thrown when an invalid cut-off percentage configuration is provided.\n   */\n  error ErrInvalidCutOffPercentageConfig();\n\n  /**\n   * @dev Error thrown when the caller's credit score is insufficient to bail out a situation.\n   */\n  error ErrInsufficientCreditScoreToBailOut();\n\n  /**\n   * @dev Error thrown when a validator has previously bailed out.\n   */\n  error ErrValidatorHasBailedOutPreviously();\n\n  /**\n   * @dev Error thrown when the caller must be jailed in the current period.\n   */\n  error ErrCallerMustBeJailedInTheCurrentPeriod();\n\n  /// @dev Emitted when the configs to credit score is updated. See the method `setCreditScoreConfigs` for param details.\n  event CreditScoreConfigsUpdated(\n    uint256 gainCreditScore,\n    uint256 maxCreditScore,\n    uint256 bailOutCostMultiplier,\n    uint256 cutOffPercentageAfterBailout\n  );\n  /// @dev Emitted the credit score of validators is updated.\n  event CreditScoresUpdated(address[] validators, uint256[] creditScores);\n  /// @dev Emitted when a validator bailed out of jail.\n  event BailedOut(TConsensus indexed consensus, uint256 period, uint256 usedCreditScore);\n\n  /**\n   * @dev Updates the credit score for the validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function execUpdateCreditScores(address[] calldata validatorIds, uint256 period) external;\n\n  /**\n   * @dev Resets the credit score for the revoked validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function execResetCreditScores(address[] calldata validatorIds) external;\n\n  /**\n   * @dev A slashed validator use this method to get out of jail.\n   *\n   * Requirements:\n   * - The `_consensusAddr` must be a validator.\n   * - Only validator's admin can call this method.\n   *\n   * Emits the event `BailedOut`.\n   *\n   */\n  function bailOut(TConsensus consensusAddr) external;\n\n  /**\n   * @dev Sets the configs to credit score.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CreditScoreConfigsUpdated`.\n   *\n   * @param _gainScore The score to gain per period.\n   * @param _maxScore The max number of credit score that a validator can hold.\n   * @param _bailOutMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @param _cutOffPercentage The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) external;\n\n  /**\n   * @dev Returns the configs related to credit score.\n   *\n   * @return _gainCreditScore The score to gain per period.\n   * @return _maxCreditScore The max number of credit score that a validator can hold.\n   * @return _bailOutCostMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @return _cutOffPercentageAfterBailout The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function getCreditScoreConfigs()\n    external\n    view\n    returns (\n      uint256 _gainCreditScore,\n      uint256 _maxCreditScore,\n      uint256 _bailOutCostMultiplier,\n      uint256 _cutOffPercentageAfterBailout\n    );\n\n  /**\n   * @dev Returns the current credit score of the validator.\n   */\n  function getCreditScore(TConsensus consensus) external view returns (uint256);\n\n  /**\n   * @dev Returns the current credit score of a list of validators.\n   */\n  function getManyCreditScores(\n    TConsensus[] calldata consensusAddrs\n  ) external view returns (uint256[] memory _resultList);\n\n  /**\n   * @dev Returns the whether the `consensus` has been bailed out at the `period`.\n   */\n  function checkBailedOutAtPeriod(TConsensus consensus, uint256 period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ISlashDoubleSign is IBaseSlash {\n  /**\n   * @dev Emitted when the configs to slash double sign is updated. See the method `getDoubleSignSlashingConfigs`\n   * for param details.\n   */\n  event DoubleSignSlashingConfigsUpdated(\n    uint256 slashDoubleSignAmount,\n    uint256 doubleSigningJailUntilBlock,\n    uint256 doubleSigningOffsetLimitBlock\n  );\n\n  /**\n   * @dev Slashes for double signing.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` if the double signing evidence of the two headers valid.\n   */\n  function slashDoubleSign(TConsensus _validatorAddr, bytes calldata _header1, bytes calldata _header2) external;\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return _slashDoubleSignAmount The amount of RON to slash double sign.\n   * @return _doubleSigningJailUntilBlock The block number that the punished validator will be jailed until, due to\n   * double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function getDoubleSignSlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _slashDoubleSignAmount,\n      uint256 _doubleSigningJailUntilBlock,\n      uint256 _doubleSigningOffsetLimitBlock\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `DoubleSignSlashingConfigsUpdated`.\n   *\n   * @param _slashAmount The amount of RON to slash double sign.\n   * @param _jailUntilBlock The block number that the punished validator will be jailed until, due to double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _doubleSigningOffsetLimitBlock\n  ) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ISlashFastFinality is IBaseSlash {\n  /**\n   * @dev Emitted when the configs to slash fast finality is updated. See the method `getFastFinalitySlashingConfigs`\n   * for param details.\n   */\n  event FastFinalitySlashingConfigsUpdated(uint256 slashFastFinalityAmount, uint256 fastFinalityJailUntilBlock);\n\n  /**\n   * @dev Slashes for fast finality.\n   *\n   * Requirements:\n   * - Only whitelisted addresses are allowed to call.\n   *\n   * Emits the event `Slashed` if the fast finality evidence of the two headers valid.\n   */\n  function slashFastFinality(\n    TConsensus consensusAddr,\n    bytes calldata voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] calldata targetBlockHash,\n    bytes[][2] calldata listOfPublicKey,\n    bytes[2] calldata aggregatedSignature\n  ) external;\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return slashFastFinalityAmount The amount of RON to slash fast finality.\n   * @return fastFinalityJailUntilBlock The block number that the punished validator will be jailed until, due to\n   * malicious fast finality.\n   */\n  function getFastFinalitySlashingConfigs()\n    external\n    view\n    returns (uint256 slashFastFinalityAmount, uint256 fastFinalityJailUntilBlock);\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `FastFinalitySlashingConfigsUpdated`.\n   *\n   * @param slashAmount The amount of RON to slash fast finality.\n   * @param jailUntilBlock The block number that the punished validator will be jailed until, due to fast finality.\n   *\n   */\n  function setFastFinalitySlashingConfigs(uint256 slashAmount, uint256 jailUntilBlock) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashIndicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashDoubleSign.sol\";\nimport \"./ISlashUnavailability.sol\";\nimport \"./ICreditScore.sol\";\n\ninterface ISlashIndicator is\n  ISlashDoubleSign,\n  ISlashUnavailability,\n  ICreditScore\n{}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashUnavailability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ISlashUnavailability is IBaseSlash {\n  /**\n   * @dev Error thrown when attempting to slash a validator twice or slash more than one validator in one block.\n   */\n  error ErrCannotSlashAValidatorTwiceOrSlashMoreThanOneValidatorInOneBlock();\n\n  /**\n   * @dev Emitted when the configs to slash bridge operator is updated. See the method `getUnavailabilitySlashingConfigs`\n   * for param details.\n   */\n  event UnavailabilitySlashingConfigsUpdated(\n    uint256 unavailabilityTier1Threshold,\n    uint256 unavailabilityTier2Threshold,\n    uint256 slashAmountForUnavailabilityTier2Threshold,\n    uint256 jailDurationForUnavailabilityTier2Threshold\n  );\n\n  /**\n   * @dev Returns the last block that a block producer is slashed for unavailability.\n   */\n  function lastUnavailabilitySlashedBlock() external view returns (uint256);\n\n  /**\n   * @dev Slashes for unavailability by increasing the counter of block producer `consensusAddr`.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` when the threshold is reached.\n   *\n   */\n  function slashUnavailability(TConsensus consensusAddr) external;\n\n  /**\n   * @dev Returns the current unavailability indicator of a block producer.\n   */\n  function currentUnavailabilityIndicator(TConsensus consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the unavailability indicator in the period `period` of a block producer.\n   */\n  function getUnavailabilityIndicator(TConsensus consensusAddr, uint256 period) external view returns (uint256);\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return unavailabilityTier1Threshold The mining reward will be deprecated, if (s)he missed more than this\n   * threshold. This threshold is applied for tier-1 and tier-3 slash.\n   * @return unavailabilityTier2Threshold  The mining reward will be deprecated, (s)he will be put in jailed, and will\n   * be deducted self-staking if (s)he misses more than this threshold. This threshold is applied for tier-2 slash.\n   * @return slashAmountForUnavailabilityTier2Threshold The amount of RON to deduct from self-staking of a block\n   * producer when (s)he is slashed with tier-2 or tier-3.\n   * @return jailDurationForUnavailabilityTier2Threshold The number of blocks to jail a block producer when (s)he is\n   * slashed with tier-2 or tier-3.\n   *\n   */\n  function getUnavailabilitySlashingConfigs()\n    external\n    view\n    returns (\n      uint256 unavailabilityTier1Threshold,\n      uint256 unavailabilityTier2Threshold,\n      uint256 slashAmountForUnavailabilityTier2Threshold,\n      uint256 jailDurationForUnavailabilityTier2Threshold\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeOperatorSlashingConfigsUpdated`.\n   *\n   * @param tier1Threshold The mining reward will be deprecated, if (s)he missed more than this threshold.\n   * @param tier2Threshold The mining reward will be deprecated, (s)he will be put in jailed, and will be deducted\n   * self-staking if (s)he misses more than this threshold.\n   * @param slashAmountForTier2Threshold The amount of RON to deduct from self-staking of a block producer when (s)he\n   * is slashed tier-2.\n   * @param jailDurationForTier2Threshold The number of blocks to jail a block producer when (s)he is slashed tier-2.\n   *\n   */\n  function setUnavailabilitySlashingConfigs(\n    uint256 tier1Threshold,\n    uint256 tier2Threshold,\n    uint256 slashAmountForTier2Threshold,\n    uint256 jailDurationForTier2Threshold\n  ) external;\n}\n"
    },
    "contracts/interfaces/staking/IBaseStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TPoolId, TConsensus } from \"../../udvts/Types.sol\";\n\ninterface IBaseStaking {\n  struct PoolDetail {\n    /**\n     * @dev Address of the pool.\n     * @custom non-volatile-storage Permanently set to the first consensus address of the candidate.\n     */\n    address pid;\n\n    /**\n     * @dev The address of the pool admin.\n     * @custom shadowed-storage This storage slot is always kept in sync with the admin in `Profile-CandidateProfile`.\n     */\n    address __shadowedPoolAdmin;\n\n    /// @dev Self-staking amount\n    uint256 stakingAmount;\n\n    /// @dev Total number of RON staking for the pool\n    uint256 stakingTotal;\n\n    /// @dev Mapping from delegator => delegating amount\n    mapping(address => uint256) delegatingAmount;\n\n    /// @dev Mapping from delegator => the last timestamp that delegator staked\n    mapping(address => uint256) lastDelegatingTimestamp;\n  }\n\n  /// @dev Emitted when the minium number of seconds to undelegate is updated.\n  event CooldownSecsToUndelegateUpdated(uint256 minSecs);\n  /// @dev Emitted when the number of seconds that a candidate must wait to be revoked.\n  event WaitingSecsToRevokeUpdated(uint256 secs);\n\n  /// @dev Error of cannot transfer RON.\n  error ErrCannotTransferRON();\n  /// @dev Error of receiving zero message value.\n  error ErrZeroValue();\n  /// @dev Error of pool admin is not allowed to call.\n  error ErrPoolAdminForbidden();\n  /// @dev Error of no one is allowed to call but the pool's admin.\n  error ErrOnlyPoolAdminAllowed();\n  /// @dev Error of admin of any active pool cannot delegate.\n  error ErrAdminOfAnyActivePoolForbidden(address admin);\n  /// @dev Error of querying inactive pool.\n  error ErrInactivePool(TConsensus consensusAddr, address poolAddr);\n  /// @dev Error of length of input arrays are not of the same.\n  error ErrInvalidArrays();\n\n  /**\n   * @dev Returns whether the `admin` is currently active.\n   */\n  function isAdminOfActivePool(address admin) external view returns (bool);\n\n  /**\n   * @dev Returns the consensus address corresponding to the pool admin.\n   */\n  function getPoolAddressOf(address admin) external view returns (address);\n\n  /**\n   * @dev Returns the staking pool details.\n   */\n  function getPoolDetail(\n    TConsensus consensusAddr\n  ) external view returns (address admin, uint256 stakingAmount, uint256 stakingTotal);\n\n  function getPoolDetailById(\n    address poolId\n  ) external view returns (address admin, uint256 stakingAmount, uint256 stakingTotal);\n\n  /**\n   * @dev Returns the self-staking amounts of the pools.\n   */\n  function getManySelfStakings(TConsensus[] calldata consensusAddrs) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the self-staking amounts of the pools.\n   */\n  function getManySelfStakingsById(address[] calldata poolIds) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns The cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n   */\n  function cooldownSecsToUndelegate() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of seconds that a candidate must wait for the renounce request gets affected.\n   */\n  function waitingSecsToRevoke() external view returns (uint256);\n\n  /**\n   * @dev Sets the cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CooldownSecsToUndelegateUpdated`.\n   *\n   */\n  function setCooldownSecsToUndelegate(uint256 cooldownSecs) external;\n\n  /**\n   * @dev Sets the number of seconds that a candidate must wait to be revoked.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `WaitingSecsToRevokeUpdated`.\n   *\n   */\n  function setWaitingSecsToRevoke(uint256 secs) external;\n}\n"
    },
    "contracts/interfaces/staking/ICandidateStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IRewardPool.sol\";\n\ninterface ICandidateStaking is IRewardPool {\n  /// @dev Emitted when the minimum staking amount for being a validator is updated.\n  event MinValidatorStakingAmountUpdated(uint256 threshold);\n  /// @dev Emitted when the commission rate range is updated.\n  event CommissionRateRangeUpdated(uint256 minRate, uint256 maxRate);\n\n  /// @dev Emitted when the pool admin staked for themself.\n  event Staked(address indexed poolId, uint256 amount);\n  /// @dev Emitted when the pool admin unstaked the amount of RON from themself.\n  event Unstaked(address indexed poolId, uint256 amount);\n\n  /// @dev Emitted when the validator pool is approved.\n  event PoolApproved(address indexed validator, address indexed admin);\n  /// @dev Emitted when the validator pool is deprecated.\n  event PoolsDeprecated(address[] validator);\n  /// @dev Emitted when the staking amount transfer failed.\n  event StakingAmountTransferFailed(\n    address indexed poolId,\n    address indexed admin,\n    uint256 amount,\n    uint256 contractBalance\n  );\n  /// @dev Emitted when the staking amount deducted failed, e.g. when the validator gets slashed.\n  event StakingAmountDeductFailed(\n    address indexed poolId,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Error of cannot transfer RON to specified target.\n  error ErrCannotInitTransferRON(address addr, string extraInfo);\n  /// @dev Error of three interaction addresses must be of the same in applying for validator candidate.\n  error ErrThreeInteractionAddrsNotEqual();\n  /// @dev Error of unstaking zero amount.\n  error ErrUnstakeZeroAmount();\n  /// @dev Error of invalid staking amount left after deducted.\n  error ErrStakingAmountLeft();\n  /// @dev Error of insufficient staking amount for unstaking.\n  error ErrInsufficientStakingAmount();\n  /// @dev Error of unstaking too early.\n  error ErrUnstakeTooEarly();\n  /// @dev Error of setting commission rate exceeds max allowed.\n  error ErrInvalidCommissionRate();\n\n  /**\n   * @dev Returns the minimum threshold for being a validator candidate.\n   */\n  function minValidatorStakingAmount() external view returns (uint256);\n\n  /**\n   * @dev Returns the commission rate range that the candidate can set.\n   */\n  function getCommissionRateRange() external view returns (uint256 minRange, uint256 maxRange);\n\n  /**\n   * @dev Sets the minimum threshold for being a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinValidatorStakingAmountUpdated` event.\n   *\n   */\n  function setMinValidatorStakingAmount(uint256) external;\n\n  /**\n   * @dev Sets the commission rate range that a candidate can set.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `CommissionRateRangeUpdated` event.\n   *\n   */\n  function setCommissionRateRange(uint256 minRate, uint256 maxRate) external;\n\n  /**\n   * @dev Proposes a candidate to become a validator.\n   *\n   * Requirements:\n   * - The method caller is able to receive RON.\n   * - The treasury is able to receive RON.\n   * - The amount is larger than or equal to the minimum validator staking amount `minValidatorStakingAmount()`.\n   *\n   * Emits the event `PoolApproved`.\n   *\n   * @param candidateAdmin the candidate admin will be stored in the validator contract, used for calling function that affects\n   * to its candidate, e.g. scheduling maintenance.\n   *\n   */\n  function applyValidatorCandidate(\n    address candidateAdmin,\n    TConsensus consensusAddr,\n    address payable treasuryAddr,\n    uint256 commissionRate,\n    bytes calldata pubkey\n  ) external payable;\n\n  /**\n   * @dev Deprecates the pool.\n   * - Deduct self-staking amount of the pool admin to zero.\n   * - Transfer the deducted amount to the pool admin.\n   * - Deactivate the pool admin address in the mapping of active pool admins\n   *\n   * Requirements:\n   * - The method caller is validator contract.\n   *\n   * Emits the event `PoolsDeprecated` and `Unstaked` events.\n   * Emits the event `StakingAmountTransferFailed` if the contract cannot transfer RON back to the pool admin.\n   *\n   */\n  function execDeprecatePools(address[] calldata pools, uint256 period) external;\n\n  /**\n   * @dev Self-delegates to the validator candidate `consensusAddr`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   * - The `msg.value` is larger than 0.\n   *\n   * Emits the event `Staked`.\n   *\n   */\n  function stake(TConsensus consensusAddr) external payable;\n\n  /**\n   * @dev Unstakes from the validator candidate `consensusAddr` for `amount`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   * Emits the event `Unstaked`.\n   *\n   */\n  function unstake(TConsensus consensusAddr, uint256 amount) external;\n\n  /**\n   * @dev Pool admin requests update validator commission rate. The request will be forwarded to the candidate manager\n   * contract, and the value is getting updated in {ICandidateManager-execRequestUpdateCommissionRate}.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   * - The `_effectiveDaysOnwards` must be equal to or larger than the {CandidateManager-_minEffectiveDaysOnwards}.\n   * - The `_rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdated`.\n   *\n   */\n  function requestUpdateCommissionRate(\n    TConsensus consensusAddr,\n    uint256 effectiveDaysOnwards,\n    uint256 commissionRate\n  ) external;\n\n  /**\n   * @dev Renounces being a validator candidate and takes back the delegating/staking amount.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   */\n  function requestRenounce(TConsensus consensusAddr) external;\n\n  /**\n   * @dev Renounces being a validator candidate and takes back the delegating/staking amount.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   */\n  function requestEmergencyExit(TConsensus consensusAddr) external;\n}\n"
    },
    "contracts/interfaces/staking/IDelegatorStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IRewardPool.sol\";\n\ninterface IDelegatorStaking is IRewardPool {\n  /// @dev Emitted when the delegator staked for a validator candidate.\n  event Delegated(address indexed delegator, address indexed poolId, uint256 amount);\n  /// @dev Emitted when the delegator unstaked from a validator candidate.\n  event Undelegated(address indexed delegator, address indexed poolId, uint256 amount);\n\n  /// @dev Error of undelegating zero amount.\n  error ErrUndelegateZeroAmount();\n  /// @dev Error of undelegating insufficient amount.\n  error ErrInsufficientDelegatingAmount();\n  /// @dev Error of undelegating too early.\n  error ErrUndelegateTooEarly();\n\n  /**\n   * @dev Stakes for a validator candidate `_consensusAddr`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is not the pool admin.\n   *\n   * Emits the `Delegated` event.\n   *\n   */\n  function delegate(TConsensus consensusAddr) external payable;\n\n  /**\n   * @dev Unstakes from a validator candidate `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   *\n   * Emits the `Undelegated` event.\n   *\n   */\n  function undelegate(TConsensus consensusAddr, uint256 amount) external;\n\n  /**\n   * @dev Bulk unstakes from a list of candidates.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   *\n   * Emits the events `Undelegated`.\n   *\n   */\n  function bulkUndelegate(TConsensus[] calldata consensusAddrs, uint256[] calldata amounts) external;\n\n  /**\n   * @dev Unstakes an amount of RON from the `_consensusAddrSrc` and stake for `_consensusAddrDst`.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   * - The consensus address `_consensusAddrDst` is a validator candidate.\n   *\n   * Emits the `Undelegated` event and the `Delegated` event.\n   *\n   */\n  function redelegate(TConsensus consensusAddrSrc, TConsensus consensusAddrDst, uint256 amount) external;\n\n  /**\n   * @dev Returns the claimable reward of the user `_user`.\n   */\n  function getRewards(\n    address user,\n    TConsensus[] calldata consensusAddrList\n  ) external view returns (uint256[] memory _rewards);\n\n  /**\n   * @dev Claims the reward of method caller.\n   *\n   * Emits the `RewardClaimed` event.\n   *\n   */\n  function claimRewards(TConsensus[] calldata consensusAddrList) external returns (uint256 amount);\n\n  /**\n   * @dev Claims the rewards and delegates them to the consensus address.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   * - The consensus address `_consensusAddrDst` is a validator candidate.\n   *\n   * Emits the `RewardClaimed` event and the `Delegated` event.\n   *\n   */\n  function delegateRewards(\n    TConsensus[] calldata consensusAddrList,\n    TConsensus consensusAddrDst\n  ) external returns (uint256 amount);\n}\n"
    },
    "contracts/interfaces/staking/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/consumers/PeriodWrapperConsumer.sol\";\n\nimport { TPoolId, TConsensus } from \"../../udvts/Types.sol\";\n\ninterface IRewardPool is PeriodWrapperConsumer {\n  struct UserRewardFields {\n    // Recorded reward amount.\n    uint256 debited;\n    // The last accumulated of the amount rewards per share (one unit staking) that the info updated.\n    uint256 aRps;\n    // Lowest staking amount in the period.\n    uint256 lowestAmount;\n    // Last period number that the info updated.\n    uint256 lastPeriod;\n  }\n\n  struct PoolFields {\n    // Accumulated of the amount rewards per share (one unit staking).\n    uint256 aRps;\n    // The staking total to share reward of the current period.\n    PeriodWrapper shares;\n  }\n\n  /// @dev Emitted when the fields to calculate pending reward for the user is updated.\n  event UserRewardUpdated(address indexed poolAddr, address indexed user, uint256 debited);\n  /// @dev Emitted when the user claimed their reward\n  event RewardClaimed(address indexed poolAddr, address indexed user, uint256 amount);\n\n  /// @dev Emitted when the pool shares are updated\n  event PoolSharesUpdated(uint256 indexed period, address indexed poolAddr, uint256 shares);\n  /// @dev Emitted when the pools are updated\n  event PoolsUpdated(uint256 indexed period, address[] poolAddrs, uint256[] aRps, uint256[] shares);\n  /// @dev Emitted when the contract fails when updating the pools\n  event PoolsUpdateFailed(uint256 indexed period, address[] poolAddrs, uint256[] rewards);\n  /// @dev Emitted when the contract fails when updating the pools that already set\n  event PoolsUpdateConflicted(uint256 indexed period, address[] poolAddrs);\n\n  /// @dev Error of invalid pool share.\n  error ErrInvalidPoolShare();\n\n  /**\n   * @dev Returns the reward amount that user claimable.\n   */\n  function getReward(TConsensus consensusAddr, address user) external view returns (uint256);\n\n  /**\n   * @dev Returns the staking amount of an user.\n   */\n  function getStakingAmount(TConsensus consensusAddr, address user) external view returns (uint256);\n\n  /**\n   * @dev Returns the staking amounts of the users.\n   */\n  function getManyStakingAmounts(\n    TConsensus[] calldata consensusAddrs,\n    address[] calldata userList\n  ) external view returns (uint256[] memory);\n\n  function getManyStakingAmountsById(\n    address[] calldata poolIds,\n    address[] calldata userList\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the total staking amount of all users for a pool.\n   */\n  function getStakingTotal(TConsensus consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the total staking amounts of all users for the pools `_poolAddrs`.\n   */\n  function getManyStakingTotals(TConsensus[] calldata consensusAddrs) external view returns (uint256[] memory);\n\n  function getManyStakingTotalsById(\n    address[] calldata poolIds\n  ) external view returns (uint256[] memory stakingAmounts_);\n}\n"
    },
    "contracts/interfaces/staking/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseStaking.sol\";\nimport \"./IStakingCallback.sol\";\nimport \"./ICandidateStaking.sol\";\nimport \"./IDelegatorStaking.sol\";\n\ninterface IStaking is IRewardPool, IBaseStaking, ICandidateStaking, IDelegatorStaking, IStakingCallback {\n  /**\n   * @dev Records the amount of rewards `_rewards` for the pools `_consensusAddrs`.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   *\n   * Emits the event `PoolsUpdated` once the contract recorded the rewards successfully.\n   * Emits the event `PoolsUpdateFailed` once the input array lengths are not equal.\n   * Emits the event `PoolsUpdateConflicted` when there are some pools which already updated in the period.\n   *\n   * Note: This method should be called once at the period ending.\n   *\n   */\n  function execRecordRewards(address[] calldata poolIds, uint256[] calldata rewards, uint256 period) external payable;\n\n  /**\n   * @dev Deducts from staking amount of the validator `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   *\n   * Emits the event `Unstaked`.\n   *\n   */\n  function execDeductStakingAmount(address poolId, uint256 amount) external returns (uint256 actualDeductingAmount);\n}\n"
    },
    "contracts/interfaces/staking/IStakingCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TPoolId } from \"../../udvts/Types.sol\";\n\ninterface IStakingCallback {\n  /**\n   * @dev Requirements:\n   * - Only Profile contract can call this method.\n   */\n  function execChangeAdminAddress(address poolAddr, address newAdminAddr) external;\n}\n"
    },
    "contracts/interfaces/validator/ICandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ICandidateManager {\n  struct ValidatorCandidate {\n    /**\n     * @dev The address of the candidate admin.\n     * @custom shadowed-storage This storage slot is always kept in sync with {Profile-CandidateProfile}.admin.\n     */\n    address __shadowedAdmin;\n    /**\n     * @dev Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n     * @custom shadowed-storage This storage slot is always kept in sync with {Profile-CandidateProfile}.consensus.\n     */\n    TConsensus __shadowedConsensus;\n    /**\n     * @dev Address that receives mining reward of the validator\n     * @custom shadowed-storage This storage slot is always kept in sync with {Profile-CandidateProfile}.treasury.\n     */\n    address payable __shadowedTreasury;\n    /// @dev Address of the bridge operator corresponding to the candidate\n    address ____deprecatedBridgeOperatorAddr;\n    /**\n     * @dev The percentage of reward that validators can be received, the rest goes to the delegators.\n     * Values in range [0; 100_00] stands for 0-100%\n     */\n    uint256 commissionRate;\n    /// @dev The timestamp that scheduled to revoke the candidate (no schedule=0)\n    uint256 revokingTimestamp;\n    /// @dev The deadline that the candidate must top up staking amount to keep it larger than or equal to the threshold (no deadline=0)\n    uint256 topupDeadline;\n  }\n\n  struct CommissionSchedule {\n    /// @dev The timestamp that the commission schedule gets affected (no schedule=0).\n    uint256 effectiveTimestamp;\n    /// @dev The new commission rate. Value is in range [0; 100_00], stands for 0-100%\n    uint256 commissionRate;\n  }\n\n  /// @dev Emitted when the maximum number of validator candidates is updated.\n  event MaxValidatorCandidateUpdated(uint256 threshold);\n  /// @dev Emitted when the min offset to the effective date of commission rate change is updated.\n  event MinEffectiveDaysOnwardsUpdated(uint256 numOfDays);\n  /// @dev Emitted when the validator candidate is granted.\n  event CandidateGranted(address indexed consensusAddr, address indexed treasuryAddr, address indexed admin);\n  /// @dev Emitted when the revoking timestamp of a candidate is updated.\n  event CandidateRevokingTimestampUpdated(address indexed cid, uint256 revokingTimestamp);\n  /// @dev Emitted when the topup deadline of a candidate is updated.\n  event CandidateTopupDeadlineUpdated(address indexed cid, uint256 topupDeadline);\n  /// @dev Emitted when the validator candidate is revoked.\n  event CandidatesRevoked(address[] consensusAddrs);\n\n  /// @dev Emitted when the commission rate of a validator is updated.\n  event CommissionRateUpdated(address indexed consensusAddr, uint256 rate);\n  /// @dev Error of exceeding maximum number of candidates.\n  error ErrExceedsMaxNumberOfCandidate();\n  /// @dev Error of querying for already existent candidate.\n  error ErrExistentCandidate();\n  /// @dev Error of querying for non-existent candidate.\n  error ErrNonExistentCandidate();\n  /// @dev Error of candidate admin already exists.\n  error ErrExistentCandidateAdmin(address candidateAdminAddr);\n  /// @dev Error of treasury already exists.\n  error ErrExistentTreasury(address _treasuryAddr);\n  /// @dev Error of invalid commission rate.\n  error ErrInvalidCommissionRate();\n    /// @dev Error of invalid min effective days onwards.\n  error ErrInvalidMinEffectiveDaysOnwards();\n\n  /**\n   * @dev Returns the maximum number of validator candidate.\n   */\n  function maxValidatorCandidate() external view returns (uint256);\n\n  /**\n   * @dev Returns the minimum number of days to the effective date of commission rate change.\n   */\n  function minEffectiveDaysOnward() external view returns (uint256);\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function setMaxValidatorCandidate(uint256) external;\n\n  /**\n   * @dev Sets the minimum number of days to the effective date of commision rate change.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external;\n\n  /**\n   * @dev Returns whether the address is a validator (candidate).\n   */\n  function isValidatorCandidate(TConsensus consensus) external view returns (bool);\n\n  /**\n   * @dev Returns the validator candidate.\n   */\n  function getValidatorCandidates() external view returns (address[] memory);\n\n  /**\n   * @dev Returns all candidate info.\n   */\n  function getCandidateInfos() external view returns (ValidatorCandidate[] memory);\n\n  /**\n   * @dev Returns the info of a candidate.\n   */\n  function getCandidateInfo(TConsensus consensus) external view returns (ValidatorCandidate memory);\n\n  /**\n   * @dev Returns whether the address is the candidate admin.\n   */\n  function isCandidateAdmin(TConsensus consensus, address admin) external view returns (bool);\n\n  /**\n   * @dev Returns the schedule of changing commission rate of a candidate address.\n   */\n  function getCommissionChangeSchedule(TConsensus consensus) external view returns (CommissionSchedule memory);\n}\n"
    },
    "contracts/interfaces/validator/ICandidateManagerCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ICandidateManagerCallback {\n  /// @dev Emitted when a schedule for updating commission rate is set.\n  event CommissionRateUpdateScheduled(address indexed consensusAddr, uint256 effectiveTimestamp, uint256 rate);\n  /// @dev Error of already requested revoking candidate before.\n  error ErrAlreadyRequestedRevokingCandidate();\n  /// @dev Error of commission change schedule exists.\n  error ErrAlreadyRequestedUpdatingCommissionRate();\n  /// @dev Error of trusted org cannot renounce.\n  error ErrTrustedOrgCannotRenounce();\n  /// @dev Error of invalid effective days onwards.\n  error ErrInvalidEffectiveDaysOnwards();\n\n  /**\n   * @dev Grants a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateGranted`.\n   *\n   */\n  function execApplyValidatorCandidate(\n    address candidateAdmin,\n    address cid,\n    address payable treasuryAddr,\n    uint256 commissionRate\n  ) external;\n\n  /**\n   * @dev Requests to revoke a validator candidate in next `secsLeft` seconds.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateRevokingTimestampUpdated`.\n   *\n   */\n  function execRequestRenounceCandidate(address, uint256 secsLeft) external;\n\n  /**\n   * @dev Fallback function of `CandidateStaking-requestUpdateCommissionRate`.\n   *\n   * Requirements:\n   * - The method caller is the staking contract.\n   * - The `effectiveTimestamp` must be the beginning of a UTC day, and at least from 7 days onwards\n   * - The `rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdateScheduled`.\n   *\n   */\n  function execRequestUpdateCommissionRate(address cid, uint256 effectiveTimestamp, uint256 rate) external;\n\n  /**\n   * @dev Fallback function of `Profile-requestChangeAdminAddress`.\n   * This updates the shadow storage slot of \"shadowedAdmin\" for candidate id `id` to `newAdmin`.\n   *\n   * Requirements:\n   * - The caller must be the Profile contract.\n   */\n  function execChangeAdminAddress(address cid, address newAdmin) external;\n\n  /**\n   * @dev Fallback function of `Profile-requestChangeConsensusAddress`.\n   * This updates the shadow storage slot of \"shadowedConsensus\" for candidate id `id` to `newAdmin`.\n   *\n   * Requirements:\n   * - The caller must be the Profile contract.\n   */\n  function execChangeConsensusAddress(address cid, TConsensus newConsensus) external;\n\n  /**\n   * @dev Fallback function of `Profile-requestChangeTreasuryAddress`.\n   * This updates the shadow storage slot of \"shadowedTreasury\" for candidate id `id` to `newAdmin`.\n   *\n   * Requirements:\n   * - The caller must be the Profile contract.\n   */\n  function execChangeTreasuryAddress(address cid, address payable newTreasury) external;\n}\n"
    },
    "contracts/interfaces/validator/ICoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashingExecution.sol\";\n\ninterface ICoinbaseExecution is ISlashingExecution {\n  enum BlockRewardDeprecatedType {\n    UNKNOWN,\n    UNAVAILABILITY,\n    AFTER_BAILOUT\n  }\n\n  /// @dev Emitted when the validator set is updated\n  event ValidatorSetUpdated(uint256 indexed period, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated, to mirror the in-jail and maintaining status of the validator.\n  event BlockProducerSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated.\n  event BridgeOperatorSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] bridgeOperators);\n\n  /// @dev Emitted when the reward of the block producer is deprecated.\n  event BlockRewardDeprecated(\n    address indexed coinbaseAddr,\n    uint256 rewardAmount,\n    BlockRewardDeprecatedType deprecatedType\n  );\n  /// @dev Emitted when the block reward is submitted.\n  event BlockRewardSubmitted(address indexed coinbaseAddr, uint256 submittedAmount, uint256 bonusAmount);\n\n  /// @dev Emitted when the block producer reward is distributed.\n  event MiningRewardDistributed(address indexed consensusAddr, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the block producer reward.\n  event MiningRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the bridge operator reward is distributed.\n  event BridgeOperatorRewardDistributed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipientAddr,\n    uint256 amount\n  );\n  /// @dev Emitted when the contract fails when distributing the bridge operator reward.\n  event BridgeOperatorRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the fast finality reward is distributed.\n  event FastFinalityRewardDistributed(address indexed consensusAddr, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the fast finality reward.\n  event FastFinalityRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the amount of RON reward is distributed to staking contract.\n  event StakingRewardDistributed(uint256 totalAmount, address[] consensusAddrs, uint256[] amounts);\n  /// @dev Emitted when the contracts fails when distributing the amount of RON to the staking contract.\n  event StakingRewardDistributionFailed(\n    uint256 totalAmount,\n    address[] consensusAddrs,\n    uint256[] amounts,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the epoch is wrapped up.\n  event WrappedUpEpoch(uint256 indexed periodNumber, uint256 indexed epochNumber, bool periodEnding);\n\n  /// @dev Error of only allowed at the end of epoch\n  error ErrAtEndOfEpochOnly();\n  /// @dev Error of query for already wrapped up epoch\n  error ErrAlreadyWrappedEpoch();\n\n  /**\n   * @dev Submits reward of the current block.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDeprecated` if the coinbase is slashed or no longer be a block producer.\n   * Emits the event `BlockRewardSubmitted` for the valid call.\n   *\n   */\n  function submitBlockReward() external payable;\n\n  /**\n   * @dev Wraps up the current epoch.\n   *\n   * Requirements:\n   * - The method must be called when the current epoch is ending.\n   * - The epoch is not wrapped yet.\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDistributed` when some validator has reward distributed.\n   * Emits the event `StakingRewardDistributed` when some staking pool has reward distributed.\n   * Emits the event `BlockProducerSetUpdated` when the epoch is wrapped up.\n   * Emits the event `BridgeOperatorSetUpdated` when the epoch is wrapped up at period ending.\n   * Emits the event `ValidatorSetUpdated` when the epoch is wrapped up at period ending, and the validator set gets updated.\n   * Emits the event `WrappedUpEpoch`.\n   *\n   */\n  function wrapUpEpoch() external payable;\n}\n"
    },
    "contracts/interfaces/validator/IEmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IEmergencyExit {\n  /// @dev Emitted when the fund is locked from an emergency exit request\n  event EmergencyExitRequested(address indexed consensusAddr, uint256 lockedAmount);\n  /// @dev Emitted when the fund that locked from an emergency exit request is transferred to the recipient.\n  event EmergencyExitLockedFundReleased(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount\n  );\n  /// @dev Emitted when the fund that locked from an emergency exit request is failed to transferred back.\n  event EmergencyExitLockedFundReleasingFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the emergency exit locked amount is updated.\n  event EmergencyExitLockedAmountUpdated(uint256 amount);\n  /// @dev Emitted when the emergency expiry duration is updated.\n  event EmergencyExpiryDurationUpdated(uint256 amount);\n\n  /// @dev Error of already requested emergency exit before.\n  error ErrAlreadyRequestedEmergencyExit();\n  /// @dev Error thrown when the info of releasing locked fund not exist.\n  error ErrLockedFundReleaseInfoNotFound(address cid);\n  /// @dev Error thrown when the the locked fund of emergency exit might be recycled.\n  error ErrLockedFundMightBeRecycled(address cid);\n\n  /**\n   * @dev Returns the amount of RON to lock from a consensus address.\n   */\n  function emergencyExitLockedAmount() external returns (uint256);\n\n  /**\n   * @dev Returns the duration that an emergency request is expired and the fund will be recycled.\n   */\n  function emergencyExpiryDuration() external returns (uint256);\n\n  /**\n   * @dev Sets the amount of RON to lock from a consensus address.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedAmountUpdated`.\n   *\n   */\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external;\n\n  /**\n   * @dev Sets the duration that an emergency request is expired and the fund will be recycled.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExpiryDurationUpdated`.\n   *\n   */\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external;\n\n  /**\n   * @dev Unlocks fund for emergency exit request.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedFundReleased` if the fund is successfully unlocked.\n   * Emits the event `EmergencyExitLockedFundReleasingFailed` if the fund is failed to unlock.\n   *\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(address validatorId, address payable recipient) external;\n\n  /**\n   * @dev Fallback function of `IStaking-requestEmergencyExit`.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   */\n  function execRequestEmergencyExit(address validatorId, uint256 secLeftToRevoke) external;\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ICommonInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IJailingInfo.sol\";\nimport \"./ITimingInfo.sol\";\nimport \"./IValidatorInfoV2.sol\";\n\ninterface ICommonInfo is ITimingInfo, IJailingInfo, IValidatorInfoV2 {\n  struct EmergencyExitInfo {\n    uint256 lockedAmount;\n    // The timestamp that this locked amount will be recycled to staking vesting contract\n    uint256 recyclingAt;\n  }\n\n  /// @dev Emitted when the deprecated reward is withdrawn.\n  event DeprecatedRewardRecycled(address indexed recipientAddr, uint256 amount);\n  /// @dev Emitted when the deprecated reward withdrawal is failed\n  event DeprecatedRewardRecycleFailed(address indexed recipientAddr, uint256 amount, uint256 balance);\n\n  /// @dev Error thrown when receives RON from neither staking vesting contract nor staking contract\n  error ErrUnauthorizedReceiveRON();\n  /// @dev Error thrown when queries for a non existent info.\n  error NonExistentRecyclingInfo();\n\n  /**\n   * @dev Returns the total deprecated reward, which includes reward that is not sent for slashed validators and unsastified bridge operators\n   */\n  function totalDeprecatedReward() external view returns (uint256);\n\n  /**\n   * @dev Returns the emergency exit request.\n   */\n  function getEmergencyExitInfo(TConsensus consensus) external view returns (EmergencyExitInfo memory);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IJailingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../udvts/Types.sol\";\n\ninterface IJailingInfo {\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkJailed(TConsensus) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeft(\n    TConsensus addr\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) at a specific block.\n   */\n  function checkJailedAtBlock(TConsensus addr, uint256 blockNum) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail at a specific block and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeftAtBlock(\n    TConsensus addr,\n    uint256 blockNum\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validators are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkManyJailed(TConsensus[] calldata) external view returns (bool[] memory);\n\n  function checkManyJailedById(address[] calldata candidateIds) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during the current period.\n   */\n  function checkMiningRewardDeprecated(TConsensus addr) external view returns (bool);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during a specific period.\n   */\n  function checkMiningRewardDeprecatedAtPeriod(TConsensus addr, uint256 period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ITimingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ITimingInfo {\n  /**\n   * @dev Returns the block that validator set was updated.\n   */\n  function getLastUpdatedBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of blocks in a epoch.\n   */\n  function numberOfBlocksInEpoch() external view returns (uint256 _numberOfBlocks);\n\n  /**\n   * @dev Returns the epoch index from the block number.\n   */\n  function epochOf(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Returns whether the epoch ending is at the block number `_block`.\n   */\n  function epochEndingAt(uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Tries to get the period index from the epoch number.\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber);\n\n  /**\n   * @dev Returns whether the period ending at the current block number.\n   */\n  function isPeriodEnding() external view returns (bool);\n\n  /**\n   * @dev Returns the period index from the current block.\n   */\n  function currentPeriod() external view returns (uint256);\n\n  /**\n   * @dev Returns the block number that the current period starts at.\n   */\n  function currentPeriodStartAtBlock() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IValidatorInfoV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\nimport { TConsensus } from \"../../../udvts/Types.sol\";\n\ninterface IValidatorInfoV2 {\n  /// @dev Error thrown when an invalid maximum prioritized validator number is provided.\n  error ErrInvalidMaxPrioritizedValidatorNumber();\n  /// @dev Emitted when the number of max validator is updated.\n  event MaxValidatorNumberUpdated(uint256);\n  /// @dev Emitted when the number of reserved slots for prioritized validators is updated.\n  event MaxPrioritizedValidatorNumberUpdated(uint256);\n\n  /**\n   * @dev Returns the maximum number of validators in the epoch.\n   */\n  function maxValidatorNumber() external view returns (uint256 _maximumValidatorNumber);\n\n  /**\n   * @dev Returns the number of reserved slots for prioritized validators.\n   */\n  function maxPrioritizedValidatorNumber() external view returns (uint256 _maximumPrioritizedValidatorNumber);\n\n  /**\n   * @dev Returns the current validator list.\n   */\n  function getValidators() external view returns (address[] memory _validatorList);\n\n  /**\n   * @dev Returns the current block producer list.\n   */\n  function getBlockProducers() external view returns (address[] memory);\n\n  /**\n   * @dev Returns whether the address is block producer or not.\n   */\n  function isBlockProducer(TConsensus consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns total numbers of the block producers.\n   */\n  function totalBlockProducer() external view returns (uint256);\n\n  /**\n   * @dev Updates the max validator number\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxValidatorNumberUpdated`\n   *\n   */\n  function setMaxValidatorNumber(uint256 _maxValidatorNumber) external;\n\n  /**\n   * @dev Updates the number of reserved slots for prioritized validators\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxPrioritizedValidatorNumberUpdated`\n   *\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _maxPrioritizedValidatorNumber) external;\n}\n"
    },
    "contracts/interfaces/validator/IRoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ICandidateManager.sol\";\nimport \"./ICandidateManagerCallback.sol\";\nimport \"./info-fragments/ICommonInfo.sol\";\nimport \"./ICoinbaseExecution.sol\";\nimport \"./ISlashingExecution.sol\";\nimport \"./IEmergencyExit.sol\";\n\ninterface IRoninValidatorSet is\n  ICandidateManagerCallback,\n  ICandidateManager,\n  ICommonInfo,\n  ISlashingExecution,\n  ICoinbaseExecution,\n  IEmergencyExit\n{}\n"
    },
    "contracts/interfaces/validator/ISlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISlashingExecution {\n  /// @dev Emitted when the validator is punished.\n  event ValidatorPunished(\n    address indexed cid,\n    uint256 indexed period,\n    uint256 jailedUntil,\n    uint256 deductedStakingAmount,\n    bool blockProducerRewardDeprecated,\n    bool bridgeOperatorRewardDeprecated\n  );\n  /// @dev Emitted when the validator get out of jail by bailout.\n  event ValidatorUnjailed(address indexed cid, uint256 period);\n\n  /// @dev Error of cannot bailout due to high tier slash.\n  error ErrCannotBailout(address validator);\n\n  /**\n   * @dev Finalize the slash request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorPunished`.\n   *\n   */\n  function execSlash(address cid, uint256 newJailedUntil, uint256 slashAmount, bool cannotBailout) external;\n\n  /**\n   * @dev Finalize the bailout request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorUnjailed`.\n   *\n   */\n  function execBailOut(address cid, uint256 period) external;\n}\n"
    },
    "contracts/libraries/AddressArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary AddressArrayUtils {\n  /**\n   * @dev Error thrown when a duplicated element is detected in an array.\n   * @param msgSig The function signature that invoke the error.\n   */\n  error ErrDuplicated(bytes4 msgSig);\n\n  /**\n   * @dev Returns whether or not there's a duplicate. Runs in O(n^2).\n   * @param A Array to search\n   * @return Returns true if duplicate, false otherwise\n   */\n  function hasDuplicate(address[] memory A) internal pure returns (bool) {\n    if (A.length == 0) {\n      return false;\n    }\n    unchecked {\n      for (uint256 i = 0; i < A.length - 1; i++) {\n        for (uint256 j = i + 1; j < A.length; j++) {\n          if (A[i] == A[j]) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @dev Returns whether two arrays of addresses are equal or not.\n   */\n  function isEqual(address[] memory _this, address[] memory _other) internal pure returns (bool yes_) {\n    // Hashing two arrays and compare their hash\n    assembly {\n      let _thisHash := keccak256(add(_this, 32), mul(mload(_this), 32))\n      let _otherHash := keccak256(add(_other, 32), mul(mload(_other), 32))\n      yes_ := eq(_thisHash, _otherHash)\n    }\n  }\n\n  /**\n   * @dev Return the concatenated array from a and b.\n   */\n  function extend(address[] memory a, address[] memory b) internal pure returns (address[] memory c) {\n    uint256 lengthA = a.length;\n    uint256 lengthB = b.length;\n    unchecked {\n      c = new address[](lengthA + lengthB);\n    }\n    uint256 i;\n    for (; i < lengthA; ) {\n      c[i] = a[i];\n      unchecked {\n        ++i;\n      }\n    }\n    for (uint256 j; j < lengthB; ) {\n      c[i] = b[j];\n      unchecked {\n        ++i;\n        ++j;\n      }\n    }\n  }\n}\n"
    },
    "contracts/libraries/Ballot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nlibrary Ballot {\n  using ECDSA for bytes32;\n\n  enum VoteType {\n    For,\n    Against\n  }\n\n  // keccak256(\"Ballot(bytes32 proposalHash,uint8 support)\");\n  bytes32 private constant BALLOT_TYPEHASH = 0xd900570327c4c0df8dd6bdd522b7da7e39145dd049d2fd4602276adcd511e3c2;\n\n  function hash(bytes32 _proposalHash, VoteType _support) internal pure returns (bytes32 digest) {\n    // return keccak256(abi.encode(BALLOT_TYPEHASH, _proposalHash, _support));\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, BALLOT_TYPEHASH)\n      mstore(add(ptr, 0x20), _proposalHash)\n      mstore(add(ptr, 0x40), _support)\n      digest := keccak256(ptr, 0x60)\n    }\n  }\n}\n"
    },
    "contracts/libraries/EmergencyExitBallot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nlibrary EmergencyExitBallot {\n  // keccak256(\"EmergencyExitBallot(address validatorId,address recipientAfterUnlockedFund,uint256 requestedAt,uint256 expiredAt)\");\n  bytes32 private constant EMERGENCY_EXIT_BALLOT_TYPEHASH =\n    0x64e34629e995f7ed2919b1f05a7ad1f274a24512f6d0d8b5b057427f7adf6518;\n\n  /**\n   * @dev Returns hash of the ballot.\n   */\n  function hash(\n    address validatorId,\n    address recipientAfterUnlockedFund,\n    uint256 requestedAt,\n    uint256 expiredAt\n  ) internal pure returns (bytes32 digest) {\n    /*\n     * return\n     *   keccak256(\n     *     abi.encode(\n     *       EMERGENCY_EXIT_BALLOT_TYPEHASH,\n     *       validatorId,\n     *       recipientAfterUnlockedFund,\n     *       requestedAt,\n     *       expiredAt\n     *     )\n     *   );\n     */\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, EMERGENCY_EXIT_BALLOT_TYPEHASH)\n      mstore(add(ptr, 0x20), validatorId)\n      mstore(add(ptr, 0x40), recipientAfterUnlockedFund)\n      mstore(add(ptr, 0x60), requestedAt)\n      mstore(add(ptr, 0x80), expiredAt)\n      digest := keccak256(ptr, 0xa0)\n    }\n  }\n}\n"
    },
    "contracts/libraries/EnumFlags.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This library implements checking flag of an enumerated value.\n * The originated idea is inherited from [Enum.HashFlag(Enum)](https://learn.microsoft.com/en-us/dotnet/api/system.enum.hasflag?view=net-6.0) method of C#.\n */\nlibrary EnumFlags {\n  enum ValidatorFlag {\n    None, // bit(00)\n    BlockProducer, // bit(01)\n    DeprecatedBridgeOperator, // bit(10)\n    Both // bit(11)\n  }\n\n  function isNone(ValidatorFlag _value) internal pure returns (bool) {\n    return uint8(_value) == 0;\n  }\n\n  /**\n   * @dev Checks if `_value` has `_flag`.\n   */\n  function hasFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (bool) {\n    return (uint8(_value) & uint8(_flag)) != 0;\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after adding `_flag`.\n   */\n  function addFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) | uint8(_flag));\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after remove `_flag`.\n   */\n  function removeFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) & ~uint8(_flag));\n  }\n}\n"
    },
    "contracts/libraries/ErrorHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ErrProxyCallFailed } from \"../utils/CommonErrors.sol\";\n\nlibrary ErrorHandler {\n  /// @notice handle low level call revert if call failed,\n  /// If extcall return empty bytes, reverts with custom error.\n  /// @param status Status of external call\n  /// @param callSig function signature of the calldata\n  /// @param returnOrRevertData bytes result from external call\n  function handleRevert(bool status, bytes4 callSig, bytes memory returnOrRevertData) internal pure {\n    // Get the function signature of current context\n    bytes4 msgSig = msg.sig;\n    assembly {\n      if iszero(status) {\n        // Load the length of bytes array\n        let revertLength := mload(returnOrRevertData)\n        // Check if length != 0 => revert following reason from external call\n        if iszero(iszero(revertLength)) {\n          // Start of revert data bytes. The 0x20 offset is always the same.\n          revert(add(returnOrRevertData, 0x20), revertLength)\n        }\n\n        // Load free memory pointer\n        let ptr := mload(0x40)\n        // Store 4 bytes the function selector of ErrProxyCallFailed(msg.sig, callSig)\n        // Equivalent to revert ErrProxyCallFailed(bytes4,bytes4)\n        mstore(ptr, 0x8e3eda2b)\n        // Store 4 bytes of msgSig parameter in the next slot\n        mstore(add(ptr, 0x20), msgSig)\n        // Store 4 bytes of callSig parameter in the next slot\n        mstore(add(ptr, 0x40), callSig)\n        // Revert 68 bytes of error starting from 0x1c\n        revert(add(ptr, 0x1c), 0x44)\n      }\n    }\n  }\n}\n"
    },
    "contracts/libraries/GlobalProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Proposal.sol\";\n\nlibrary GlobalProposal {\n  /**\n   * @dev Error thrown when attempting to interact with an unsupported target.\n   */\n  error ErrUnsupportedTarget(bytes32 proposalHash, uint256 targetNumber);\n\n  enum TargetOption {\n    /* 0 */ BridgeManager,\n    /* 1 */ GatewayContract,\n    /* 2 */ BridgeReward,\n    /* 3 */ BridgeSlash,\n    /* 4 */ BridgeTracking\n  }\n\n  struct GlobalProposalDetail {\n    // Nonce to make sure proposals are executed in order\n    uint256 nonce;\n    uint256 expiryTimestamp;\n    TargetOption[] targetOptions;\n    uint256[] values;\n    bytes[] calldatas;\n    uint256[] gasAmounts;\n  }\n\n  // keccak256(\"GlobalProposalDetail(uint256 nonce,uint256 expiryTimestamp,uint8[] targetOptions,uint256[] values,bytes[] calldatas,uint256[] gasAmounts)\");\n  bytes32 public constant TYPE_HASH = 0x1463f426c05aff2c1a7a0957a71c9898bc8b47142540538e79ee25ee91141350;\n\n  /**\n   * @dev Returns struct hash of the proposal.\n   */\n  function hash(GlobalProposalDetail memory self) internal pure returns (bytes32 digest_) {\n    uint256[] memory values = self.values;\n    TargetOption[] memory targets = self.targetOptions;\n    bytes32[] memory calldataHashList = new bytes32[](self.calldatas.length);\n    uint256[] memory gasAmounts = self.gasAmounts;\n\n    for (uint256 i; i < calldataHashList.length; ) {\n      calldataHashList[i] = keccak256(self.calldatas[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    /*\n     * return\n     *   keccak256(\n     *     abi.encode(\n     *       TYPE_HASH,\n     *       _proposal.nonce,\n     *       _proposal.expiryTimestamp,\n     *       _targetsHash,\n     *       _valuesHash,\n     *       _calldatasHash,\n     *       _gasAmountsHash\n     *     )\n     *   );\n     */\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, TYPE_HASH)\n      mstore(add(ptr, 0x20), mload(self)) // _proposal.nonce\n      mstore(add(ptr, 0x40), mload(add(self, 0x20))) // _proposal.expiryTimestamp\n\n      let arrayHashed\n      arrayHashed := keccak256(add(targets, 32), mul(mload(targets), 32)) // targetsHash\n      mstore(add(ptr, 0x60), arrayHashed)\n      arrayHashed := keccak256(add(values, 32), mul(mload(values), 32)) // _valuesHash\n      mstore(add(ptr, 0x80), arrayHashed)\n      arrayHashed := keccak256(add(calldataHashList, 32), mul(mload(calldataHashList), 32)) // _calldatasHash\n      mstore(add(ptr, 0xa0), arrayHashed)\n      arrayHashed := keccak256(add(gasAmounts, 32), mul(mload(gasAmounts), 32)) // _gasAmountsHash\n      mstore(add(ptr, 0xc0), arrayHashed)\n      digest_ := keccak256(ptr, 0xe0)\n    }\n  }\n\n  /**\n   * @dev Converts into the normal proposal.\n   */\n  function intoProposalDetail(\n    GlobalProposalDetail memory self,\n    address[] memory targets\n  ) internal pure returns (Proposal.ProposalDetail memory detail_) {\n    detail_.nonce = self.nonce;\n    detail_.expiryTimestamp = self.expiryTimestamp;\n    detail_.chainId = 0;\n    detail_.targets = new address[](self.targetOptions.length);\n    detail_.values = self.values;\n    detail_.calldatas = self.calldatas;\n    detail_.gasAmounts = self.gasAmounts;\n\n    for (uint256 i; i < self.targetOptions.length; ) {\n      detail_.targets[i] = targets[i];\n      unchecked {\n        ++i;\n      }\n    }\n  }\n}\n"
    },
    "contracts/libraries/IsolatedGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/consumers/VoteStatusConsumer.sol\";\nimport \"../utils/CommonErrors.sol\";\n\nlibrary IsolatedGovernance {\n  struct Vote {\n    VoteStatusConsumer.VoteStatus status;\n    bytes32 finalHash;\n    /// @dev Mapping from voter => receipt hash\n    mapping(address => bytes32) voteHashOf;\n    /// @dev The timestamp that voting is expired (no expiration=0)\n    uint256 expiredAt;\n    /// @dev The timestamp that voting is created\n    uint256 createdAt;\n    /// @dev The list of voters\n    address[] voters;\n  }\n\n  /**\n   * @dev Casts vote for the receipt with the receipt hash `_hash`.\n   *\n   * Requirements:\n   * - The voter has not voted for the round.\n   *\n   */\n  function castVote(Vote storage _v, address _voter, bytes32 _hash) internal {\n    if (_v.expiredAt > 0 && _v.expiredAt <= block.timestamp) {\n      _v.status = VoteStatusConsumer.VoteStatus.Expired;\n    }\n\n    if (voted(_v, _voter)) revert ErrAlreadyVoted(_voter);\n\n    _v.voteHashOf[_voter] = _hash;\n    _v.voters.push(_voter);\n  }\n\n  /**\n   * @dev Updates vote with the requirement of minimum vote weight.\n   */\n  function syncVoteStatus(\n    Vote storage _v,\n    uint256 _minimumVoteWeight,\n    uint256 _votedWeightForHash,\n    bytes32 _hash\n  ) internal returns (VoteStatusConsumer.VoteStatus _status) {\n    if (_votedWeightForHash >= _minimumVoteWeight && _v.status == VoteStatusConsumer.VoteStatus.Pending) {\n      _v.status = VoteStatusConsumer.VoteStatus.Approved;\n      _v.finalHash = _hash;\n    }\n\n    return _v.status;\n  }\n\n  /**\n   * @dev Returns the list of vote's addresses that voted for the hash `_hash`.\n   */\n  function filterByHash(Vote storage _v, bytes32 _hash) internal view returns (address[] memory _voters) {\n    uint256 _count;\n    _voters = new address[](_v.voters.length);\n\n    unchecked {\n      for (uint _i; _i < _voters.length; ++_i) {\n        address _voter = _v.voters[_i];\n        if (_v.voteHashOf[_voter] == _hash) {\n          _voters[_count++] = _voter;\n        }\n      }\n    }\n\n    assembly {\n      mstore(_voters, _count)\n    }\n  }\n\n  /**\n   * @dev Returns whether the voter casted for the proposal.\n   */\n  function voted(Vote storage _v, address _voter) internal view returns (bool) {\n    return _v.voteHashOf[_voter] != bytes32(0);\n  }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary Math {\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns whether the number `c` is in range of [a; b].\n   */\n  function inRange(uint256 c, uint256 a, uint256 b) internal pure returns (bool) {\n    return a <= c && c <= b;\n  }\n\n  /**\n   * @dev Returns whether two inclusive ranges [x1;x2] and [y1;y2] overlap.\n   */\n  function twoRangeOverlap(uint256 x1, uint256 x2, uint256 y1, uint256 y2) internal pure returns (bool) {\n    return x1 <= y2 && y1 <= x2;\n  }\n\n  /**\n   * @dev Returns value of a + b; in case result is larger than upperbound, upperbound is returned.\n   */\n  function addWithUpperbound(uint256 a, uint256 b, uint256 upperbound) internal pure returns (uint256) {\n    return min(a + b, upperbound);\n  }\n\n  /**\n   * @dev Returns value of a - b; in case of negative result, 0 is returned.\n   */\n  function subNonNegative(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a - b : 0;\n  }\n\n  /**\n   * @dev Returns value of `a + zeroable` if zerobale is not 0; otherwise, return 0.\n   */\n  function addIfNonZero(uint256 a, uint256 zeroable) internal pure returns (uint256) {\n    return zeroable != 0 ? a + zeroable : 0;\n  }\n}\n"
    },
    "contracts/libraries/Proposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ErrInvalidChainId, ErrLengthMismatch } from \"../utils/CommonErrors.sol\";\n\nlibrary Proposal {\n  /**\n   * @dev Error thrown when there is insufficient gas to execute a function.\n   */\n  error ErrInsufficientGas(bytes32 proposalHash);\n\n  /**\n   * @dev Error thrown when an invalid expiry timestamp is provided.\n   */\n  error ErrInvalidExpiryTimestamp();\n\n  struct ProposalDetail {\n    // Nonce to make sure proposals are executed in order\n    uint256 nonce;\n    // Value 0: all chain should run this proposal\n    // Other values: only specifc chain has to execute\n    uint256 chainId;\n    uint256 expiryTimestamp;\n    address[] targets;\n    uint256[] values;\n    bytes[] calldatas;\n    uint256[] gasAmounts;\n  }\n\n  // keccak256(\"ProposalDetail(uint256 nonce,uint256 chainId,uint256 expiryTimestamp,address[] targets,uint256[] values,bytes[] calldatas,uint256[] gasAmounts)\");\n  bytes32 public constant TYPE_HASH = 0xd051578048e6ff0bbc9fca3b65a42088dbde10f36ca841de566711087ad9b08a;\n\n  /**\n   * @dev Validates the proposal.\n   */\n  function validate(ProposalDetail memory _proposal, uint256 _maxExpiryDuration) internal view {\n    if (\n      !(_proposal.targets.length > 0 &&\n        _proposal.targets.length == _proposal.values.length &&\n        _proposal.targets.length == _proposal.calldatas.length &&\n        _proposal.targets.length == _proposal.gasAmounts.length)\n    ) {\n      revert ErrLengthMismatch(msg.sig);\n    }\n\n    if (_proposal.expiryTimestamp > block.timestamp + _maxExpiryDuration) {\n      revert ErrInvalidExpiryTimestamp();\n    }\n  }\n\n  /**\n   * @dev Returns struct hash of the proposal.\n   */\n  function hash(ProposalDetail memory _proposal) internal pure returns (bytes32 digest_) {\n    uint256[] memory _values = _proposal.values;\n    address[] memory _targets = _proposal.targets;\n    bytes32[] memory _calldataHashList = new bytes32[](_proposal.calldatas.length);\n    uint256[] memory _gasAmounts = _proposal.gasAmounts;\n\n    for (uint256 _i; _i < _calldataHashList.length; ) {\n      _calldataHashList[_i] = keccak256(_proposal.calldatas[_i]);\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // return\n    //   keccak256(\n    //     abi.encode(\n    //       TYPE_HASH,\n    //       _proposal.nonce,\n    //       _proposal.chainId,\n    //       _targetsHash,\n    //       _valuesHash,\n    //       _calldatasHash,\n    //       _gasAmountsHash\n    //     )\n    //   );\n    // /\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, TYPE_HASH)\n      mstore(add(ptr, 0x20), mload(_proposal)) // _proposal.nonce\n      mstore(add(ptr, 0x40), mload(add(_proposal, 0x20))) // _proposal.chainId\n      mstore(add(ptr, 0x60), mload(add(_proposal, 0x40))) // expiry timestamp\n\n      let arrayHashed\n      arrayHashed := keccak256(add(_targets, 32), mul(mload(_targets), 32)) // targetsHash\n      mstore(add(ptr, 0x80), arrayHashed)\n      arrayHashed := keccak256(add(_values, 32), mul(mload(_values), 32)) // _valuesHash\n      mstore(add(ptr, 0xa0), arrayHashed)\n      arrayHashed := keccak256(add(_calldataHashList, 32), mul(mload(_calldataHashList), 32)) // _calldatasHash\n      mstore(add(ptr, 0xc0), arrayHashed)\n      arrayHashed := keccak256(add(_gasAmounts, 32), mul(mload(_gasAmounts), 32)) // _gasAmountsHash\n      mstore(add(ptr, 0xe0), arrayHashed)\n      digest_ := keccak256(ptr, 0x100)\n    }\n  }\n\n  /**\n   * @dev Returns whether the proposal is executable for the current chain.\n   *\n   * @notice Does not check whether the call result is successful or not. Please use `execute` instead.\n   *\n   */\n  function executable(ProposalDetail memory _proposal) internal view returns (bool _result) {\n    return _proposal.chainId == 0 || _proposal.chainId == block.chainid;\n  }\n\n  /**\n   * @dev Executes the proposal.\n   */\n  function execute(\n    ProposalDetail memory _proposal\n  ) internal returns (bool[] memory _successCalls, bytes[] memory _returnDatas) {\n    if (!executable(_proposal)) revert ErrInvalidChainId(msg.sig, _proposal.chainId, block.chainid);\n\n    _successCalls = new bool[](_proposal.targets.length);\n    _returnDatas = new bytes[](_proposal.targets.length);\n    for (uint256 _i = 0; _i < _proposal.targets.length; ) {\n      if (gasleft() <= _proposal.gasAmounts[_i]) revert ErrInsufficientGas(hash(_proposal));\n\n      (_successCalls[_i], _returnDatas[_i]) = _proposal.targets[_i].call{\n        value: _proposal.values[_i],\n        gas: _proposal.gasAmounts[_i]\n      }(_proposal.calldatas[_i]);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n}\n"
    },
    "contracts/libraries/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"../interfaces/IWETH.sol\";\n\nlibrary Token {\n  /// @dev Error indicating that the provided information is invalid.\n  error ErrInvalidInfo();\n\n  /// @dev Error indicating that the minting of ERC20 tokens has failed.\n  error ErrERC20MintingFailed();\n\n  /// @dev Error indicating that the minting of ERC721 tokens has failed.\n  error ErrERC721MintingFailed();\n\n  /// @dev Error indicating that an unsupported standard is encountered.\n  error ErrUnsupportedStandard();\n\n  /**\n   * @dev Error indicating that the `transfer` has failed.\n   * @param tokenInfo Info of the token including ERC standard, id or quantity.\n   * @param to Receiver of the token value.\n   * @param token Address of the token.\n   */\n  error ErrTokenCouldNotTransfer(Info tokenInfo, address to, address token);\n\n  /**\n   * @dev Error indicating that the `transferFrom` has failed.\n   * @param tokenInfo Info of the token including ERC standard, id or quantity.\n   * @param from Owner of the token value.\n   * @param to Receiver of the token value.\n   * @param token Address of the token.\n   */\n  error ErrTokenCouldNotTransferFrom(Info tokenInfo, address from, address to, address token);\n\n  enum Standard {\n    ERC20,\n    ERC721\n  }\n\n  struct Info {\n    Standard erc;\n    // For ERC20:  the id must be 0 and the quantity is larger than 0.\n    // For ERC721: the quantity must be 0.\n    uint256 id;\n    uint256 quantity;\n  }\n\n  // keccak256(\"TokenInfo(uint8 erc,uint256 id,uint256 quantity)\");\n  bytes32 public constant INFO_TYPE_HASH = 0x1e2b74b2a792d5c0f0b6e59b037fa9d43d84fbb759337f0112fcc15ca414fc8d;\n\n  /**\n   * @dev Returns token info struct hash.\n   */\n  function hash(Info memory _info) internal pure returns (bytes32 digest) {\n    // keccak256(abi.encode(INFO_TYPE_HASH, _info.erc, _info.id, _info.quantity))\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, INFO_TYPE_HASH)\n      mstore(add(ptr, 0x20), mload(_info)) // _info.erc\n      mstore(add(ptr, 0x40), mload(add(_info, 0x20))) // _info.id\n      mstore(add(ptr, 0x60), mload(add(_info, 0x40))) // _info.quantity\n      digest := keccak256(ptr, 0x80)\n    }\n  }\n\n  /**\n   * @dev Validates the token info.\n   */\n  function validate(Info memory _info) internal pure {\n    if (\n      !((_info.erc == Standard.ERC20 && _info.quantity > 0 && _info.id == 0) ||\n        (_info.erc == Standard.ERC721 && _info.quantity == 0))\n    ) revert ErrInvalidInfo();\n  }\n\n  /**\n   * @dev Transfer asset from.\n   *\n   * Requirements:\n   * - The `_from` address must approve for the contract using this library.\n   *\n   */\n  function transferFrom(Info memory _info, address _from, address _to, address _token) internal {\n    bool _success;\n    bytes memory _data;\n    if (_info.erc == Standard.ERC20) {\n      (_success, _data) = _token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, _from, _to, _info.quantity));\n      _success = _success && (_data.length == 0 || abi.decode(_data, (bool)));\n    } else if (_info.erc == Standard.ERC721) {\n      // bytes4(keccak256(\"transferFrom(address,address,uint256)\"))\n      (_success, ) = _token.call(abi.encodeWithSelector(0x23b872dd, _from, _to, _info.id));\n    } else revert ErrUnsupportedStandard();\n\n    if (!_success) revert ErrTokenCouldNotTransferFrom(_info, _from, _to, _token);\n  }\n\n  /**\n   * @dev Transfers ERC721 token and returns the result.\n   */\n  function tryTransferERC721(address _token, address _to, uint256 _id) internal returns (bool _success) {\n    (_success, ) = _token.call(abi.encodeWithSelector(IERC721.transferFrom.selector, address(this), _to, _id));\n  }\n\n  /**\n   * @dev Transfers ERC20 token and returns the result.\n   */\n  function tryTransferERC20(address _token, address _to, uint256 _quantity) internal returns (bool _success) {\n    bytes memory _data;\n    (_success, _data) = _token.call(abi.encodeWithSelector(IERC20.transfer.selector, _to, _quantity));\n    _success = _success && (_data.length == 0 || abi.decode(_data, (bool)));\n  }\n\n  /**\n   * @dev Transfer assets from current address to `_to` address.\n   */\n  function transfer(Info memory _info, address _to, address _token) internal {\n    bool _success;\n    if (_info.erc == Standard.ERC20) {\n      _success = tryTransferERC20(_token, _to, _info.quantity);\n    } else if (_info.erc == Standard.ERC721) {\n      _success = tryTransferERC721(_token, _to, _info.id);\n    } else revert ErrUnsupportedStandard();\n\n    if (!_success) revert ErrTokenCouldNotTransfer(_info, _to, _token);\n  }\n\n  /**\n   * @dev Tries minting and transfering assets.\n   *\n   * @notice Prioritizes transfer native token if the token is wrapped.\n   *\n   */\n  function handleAssetTransfer(\n    Info memory _info,\n    address payable _to,\n    address _token,\n    IWETH _wrappedNativeToken\n  ) internal {\n    bool _success;\n    if (_token == address(_wrappedNativeToken)) {\n      // Try sending the native token before transferring the wrapped token\n      if (!_to.send(_info.quantity)) {\n        _wrappedNativeToken.deposit{ value: _info.quantity }();\n        transfer(_info, _to, _token);\n      }\n    } else if (_info.erc == Token.Standard.ERC20) {\n      uint256 _balance = IERC20(_token).balanceOf(address(this));\n\n      if (_balance < _info.quantity) {\n        // bytes4(keccak256(\"mint(address,uint256)\"))\n        (_success, ) = _token.call(abi.encodeWithSelector(0x40c10f19, address(this), _info.quantity - _balance));\n        if (!_success) revert ErrERC20MintingFailed();\n      }\n\n      transfer(_info, _to, _token);\n    } else if (_info.erc == Token.Standard.ERC721) {\n      if (!tryTransferERC721(_token, _to, _info.id)) {\n        // bytes4(keccak256(\"mint(address,uint256)\"))\n        (_success, ) = _token.call(abi.encodeWithSelector(0x40c10f19, _to, _info.id));\n        if (!_success) revert ErrERC721MintingFailed();\n      }\n    } else revert ErrUnsupportedStandard();\n  }\n\n  struct Owner {\n    address addr;\n    address tokenAddr;\n    uint256 chainId;\n  }\n\n  // keccak256(\"TokenOwner(address addr,address tokenAddr,uint256 chainId)\");\n  bytes32 public constant OWNER_TYPE_HASH = 0x353bdd8d69b9e3185b3972e08b03845c0c14a21a390215302776a7a34b0e8764;\n\n  /**\n   * @dev Returns ownership struct hash.\n   */\n  function hash(Owner memory _owner) internal pure returns (bytes32 digest) {\n    // keccak256(abi.encode(OWNER_TYPE_HASH, _owner.addr, _owner.tokenAddr, _owner.chainId))\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, OWNER_TYPE_HASH)\n      mstore(add(ptr, 0x20), mload(_owner)) // _owner.addr\n      mstore(add(ptr, 0x40), mload(add(_owner, 0x20))) // _owner.tokenAddr\n      mstore(add(ptr, 0x60), mload(add(_owner, 0x40))) // _owner.chainId\n      digest := keccak256(ptr, 0x80)\n    }\n  }\n}\n"
    },
    "contracts/libraries/Transfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./Token.sol\";\n\nlibrary Transfer {\n  using ECDSA for bytes32;\n\n  enum Kind {\n    Deposit,\n    Withdrawal\n  }\n\n  struct Request {\n    // For deposit request: Recipient address on Ronin network\n    // For withdrawal request: Recipient address on mainchain network\n    address recipientAddr;\n    // Token address to deposit/withdraw\n    // Value 0: native token\n    address tokenAddr;\n    Token.Info info;\n  }\n\n  /**\n   * @dev Converts the transfer request into the deposit receipt.\n   */\n  function into_deposit_receipt(\n    Request memory _request,\n    address _requester,\n    uint256 _id,\n    address _roninTokenAddr,\n    uint256 _roninChainId\n  ) internal view returns (Receipt memory _receipt) {\n    _receipt.id = _id;\n    _receipt.kind = Kind.Deposit;\n    _receipt.mainchain.addr = _requester;\n    _receipt.mainchain.tokenAddr = _request.tokenAddr;\n    _receipt.mainchain.chainId = block.chainid;\n    _receipt.ronin.addr = _request.recipientAddr;\n    _receipt.ronin.tokenAddr = _roninTokenAddr;\n    _receipt.ronin.chainId = _roninChainId;\n    _receipt.info = _request.info;\n  }\n\n  /**\n   * @dev Converts the transfer request into the withdrawal receipt.\n   */\n  function into_withdrawal_receipt(\n    Request memory _request,\n    address _requester,\n    uint256 _id,\n    address _mainchainTokenAddr,\n    uint256 _mainchainId\n  ) internal view returns (Receipt memory _receipt) {\n    _receipt.id = _id;\n    _receipt.kind = Kind.Withdrawal;\n    _receipt.ronin.addr = _requester;\n    _receipt.ronin.tokenAddr = _request.tokenAddr;\n    _receipt.ronin.chainId = block.chainid;\n    _receipt.mainchain.addr = _request.recipientAddr;\n    _receipt.mainchain.tokenAddr = _mainchainTokenAddr;\n    _receipt.mainchain.chainId = _mainchainId;\n    _receipt.info = _request.info;\n  }\n\n  struct Receipt {\n    uint256 id;\n    Kind kind;\n    Token.Owner mainchain;\n    Token.Owner ronin;\n    Token.Info info;\n  }\n\n  // keccak256(\"Receipt(uint256 id,uint8 kind,TokenOwner mainchain,TokenOwner ronin,TokenInfo info)TokenInfo(uint8 erc,uint256 id,uint256 quantity)TokenOwner(address addr,address tokenAddr,uint256 chainId)\");\n  bytes32 public constant TYPE_HASH = 0xb9d1fe7c9deeec5dc90a2f47ff1684239519f2545b2228d3d91fb27df3189eea;\n\n  /**\n   * @dev Returns token info struct hash.\n   */\n  function hash(Receipt memory _receipt) internal pure returns (bytes32 digest) {\n    bytes32 hashedReceiptMainchain = Token.hash(_receipt.mainchain);\n    bytes32 hashedReceiptRonin = Token.hash(_receipt.ronin);\n    bytes32 hashedReceiptInfo = Token.hash(_receipt.info);\n\n    /*\n     * return\n     *   keccak256(\n     *     abi.encode(\n     *       TYPE_HASH,\n     *       _receipt.id,\n     *       _receipt.kind,\n     *       Token.hash(_receipt.mainchain),\n     *       Token.hash(_receipt.ronin),\n     *       Token.hash(_receipt.info)\n     *     )\n     *   );\n     */\n    assembly {\n      let ptr := mload(0x40)\n      mstore(ptr, TYPE_HASH)\n      mstore(add(ptr, 0x20), mload(_receipt)) // _receipt.id\n      mstore(add(ptr, 0x40), mload(add(_receipt, 0x20))) // _receipt.kind\n      mstore(add(ptr, 0x60), hashedReceiptMainchain)\n      mstore(add(ptr, 0x80), hashedReceiptRonin)\n      mstore(add(ptr, 0xa0), hashedReceiptInfo)\n      digest := keccak256(ptr, 0xc0)\n    }\n  }\n\n  /**\n   * @dev Returns the receipt digest.\n   */\n  function receiptDigest(bytes32 _domainSeparator, bytes32 _receiptHash) internal pure returns (bytes32) {\n    return _domainSeparator.toTypedDataHash(_receiptHash);\n  }\n}\n"
    },
    "contracts/mocks/libraries/Sorting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary Sorting {\n  struct Node {\n    uint key;\n    uint value;\n  }\n\n  struct Node3 {\n    uint key;\n    uint value;\n    uint otherKey;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                   VALUE SORTING                                   //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sort(uint[] memory data) internal pure returns (uint[] memory) {\n    return _quickSort(data, int(0), int(data.length - 1));\n  }\n\n  function _quickSort(uint[] memory arr, int left, int right) private pure returns (uint[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return arr;\n    uint pivot = arr[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (arr[uint(i)] > pivot) i++;\n      while (pivot > arr[uint(j)]) j--;\n      if (i <= j) {\n        (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) arr = _quickSort(arr, left, j);\n    if (i < right) arr = _quickSort(arr, i, right);\n\n    return arr;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                   NODE SORTING                                    //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sort(address[] memory _keys, uint256[] memory _values) internal pure returns (address[] memory) {\n    require(_values.length == _keys.length, \"Sorting: invalid array length\");\n    if (_keys.length == 0) {\n      return _keys;\n    }\n\n    Node[] memory _nodes = new Node[](_keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node(uint256(uint160(_keys[_i])), _values[_i]);\n    }\n    _quickSortNodes(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _keys[_i] = address(uint160(_nodes[_i].key)); // Casting?\n    }\n\n    return _keys;\n  }\n\n  function sort(uint256[] memory keys, uint256[] memory values) internal pure returns (uint256[] memory) {\n    require(values.length == keys.length, \"Sorting: invalid array length\");\n    if (keys.length == 0) {\n      return keys;\n    }\n\n    Node[] memory _nodes = new Node[](keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node(keys[_i], values[_i]);\n    }\n    _quickSortNodes(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      keys[_i] = _nodes[_i].key; // Casting?\n    }\n\n    return keys;\n  }\n\n  function sortNodes(Node[] memory nodes) internal pure returns (Node[] memory) {\n    return _quickSortNodes(nodes, int(0), int(nodes.length - 1));\n  }\n\n  function _quickSortNodes(Node[] memory nodes, int left, int right) private pure returns (Node[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return nodes;\n    Node memory pivot = nodes[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (nodes[uint(i)].value > pivot.value) i++;\n      while (pivot.value > nodes[uint(j)].value) j--;\n      if (i <= j) {\n        (nodes[uint(i)], nodes[uint(j)]) = __swapNodes(nodes[uint(i)], nodes[uint(j)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) nodes = _quickSortNodes(nodes, left, j);\n    if (i < right) nodes = _quickSortNodes(nodes, i, right);\n\n    return nodes;\n  }\n\n  function _bubbleSortNodes(Node[] memory nodes) private pure returns (Node[] memory) {\n    uint length = nodes.length;\n    for (uint i = 0; i < length - 1; i++) {\n      for (uint j = i + 1; j < length; j++) {\n        if (nodes[j].value > nodes[i].value) {\n          (nodes[i], nodes[j]) = __swapNodes(nodes[i], nodes[j]);\n        }\n      }\n    }\n    return nodes;\n  }\n\n  function __swapNodes(Node memory x, Node memory y) private pure returns (Node memory, Node memory) {\n    Node memory tmp = x;\n    (x, y) = (y, tmp);\n    return (x, y);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                  NODE3 SORTING                                    //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sortWithExternalKeys(\n    address[] memory _keys,\n    uint256[] memory _values,\n    uint256[] memory _otherKeys\n  ) internal pure returns (address[] memory keys_, uint256[] memory otherKeys_) {\n    require((_values.length == _keys.length) && (_otherKeys.length == _keys.length), \"Sorting: invalid array length\");\n    if (_keys.length == 0) {\n      return (_keys, _otherKeys);\n    }\n\n    Node3[] memory _nodes = new Node3[](_keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node3(uint256(uint160(_keys[_i])), _values[_i], _otherKeys[_i]);\n    }\n    _quickSortNode3s(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _keys[_i] = address(uint160(_nodes[_i].key)); // Casting?\n    }\n\n    return (_keys, _otherKeys);\n  }\n\n  function sortNode3s(Node3[] memory nodes) internal pure returns (Node3[] memory) {\n    return _quickSortNode3s(nodes, int(0), int(nodes.length - 1));\n  }\n\n  function _quickSortNode3s(Node3[] memory nodes, int left, int right) private pure returns (Node3[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return nodes;\n    Node3 memory pivot = nodes[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (nodes[uint(i)].value > pivot.value) i++;\n      while (pivot.value > nodes[uint(j)].value) j--;\n      if (i <= j) {\n        (nodes[uint(i)], nodes[uint(j)]) = __swapNode3s(nodes[uint(i)], nodes[uint(j)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) nodes = _quickSortNode3s(nodes, left, j);\n    if (i < right) nodes = _quickSortNode3s(nodes, i, right);\n\n    return nodes;\n  }\n\n  function _bubbleSortNode3s(Node3[] memory nodes) private pure returns (Node3[] memory) {\n    uint length = nodes.length;\n    for (uint i = 0; i < length - 1; i++) {\n      for (uint j = i + 1; j < length; j++) {\n        if (nodes[j].value > nodes[i].value) {\n          (nodes[i], nodes[j]) = __swapNode3s(nodes[i], nodes[j]);\n        }\n      }\n    }\n    return nodes;\n  }\n\n  function __swapNode3s(Node3 memory x, Node3 memory y) private pure returns (Node3 memory, Node3 memory) {\n    Node3 memory tmp = x;\n    (x, y) = (y, tmp);\n    return (x, y);\n  }\n}\n"
    },
    "contracts/mocks/MockPrecompile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./libraries/Sorting.sol\";\nimport \"../libraries/Math.sol\";\n\ncontract MockPrecompile {\n  function sortValidators(\n    address[] memory _validators,\n    uint256[] memory _weights\n  ) public pure returns (address[] memory) {\n    return Sorting.sort(_validators, _weights);\n  }\n\n  function validatingDoubleSignProof(\n    address /*consensusAddr*/,\n    bytes calldata /*_header1*/,\n    bytes calldata /*_header2*/\n  ) public pure returns (bool _validEvidence) {\n    return true;\n  }\n\n  function validateFinalityVoteProof(\n    bytes calldata,\n    uint256,\n    bytes32[2] calldata,\n    bytes[][2] calldata,\n    bytes[2] calldata\n  ) public pure returns (bool) {\n    return true;\n  }\n\n  function pickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) public pure returns (address[] memory _result) {\n    (_result, _trustedWeights) = Sorting.sortWithExternalKeys(_candidates, _weights, _trustedWeights);\n    uint256 _newValidatorCount = Math.min(_maxValidatorNumber, _result.length);\n    _arrangeValidatorCandidates(_result, _trustedWeights, _newValidatorCount, _maxPrioritizedValidatorNumber);\n  }\n\n  /**\n   * @dev Arranges the sorted candidates to list of validators, by asserting prioritized and non-prioritized candidates\n   *\n   * @param _candidates A sorted list of candidates\n   */\n  function _arrangeValidatorCandidates(\n    address[] memory _candidates,\n    uint256[] memory _trustedWeights,\n    uint _newValidatorCount,\n    uint _maxPrioritizedValidatorNumber\n  ) internal pure {\n    address[] memory _waitingCandidates = new address[](_candidates.length);\n    uint _waitingCounter;\n    uint _prioritySlotCounter;\n\n    for (uint _i = 0; _i < _candidates.length; _i++) {\n      if (_trustedWeights[_i] > 0 && _prioritySlotCounter < _maxPrioritizedValidatorNumber) {\n        _candidates[_prioritySlotCounter++] = _candidates[_i];\n        continue;\n      }\n      _waitingCandidates[_waitingCounter++] = _candidates[_i];\n    }\n\n    _waitingCounter = 0;\n    for (uint _i = _prioritySlotCounter; _i < _newValidatorCount; _i++) {\n      _candidates[_i] = _waitingCandidates[_waitingCounter++];\n    }\n\n    assembly {\n      mstore(_candidates, _newValidatorCount)\n    }\n  }\n}\n"
    },
    "contracts/mocks/MockSlashIndicatorExtended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./MockPrecompile.sol\";\nimport \"../ronin/slash-indicator/SlashIndicator.sol\";\nimport \"../interfaces/validator/IRoninValidatorSet.sol\";\n\ncontract MockSlashIndicatorExtended is SlashIndicator, MockPrecompile {\n  function slashFelony(address _validatorAddr) external {\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execSlash(_validatorAddr, 0, 0, false);\n  }\n\n  function slashMisdemeanor(address _validatorAddr) external {\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execSlash(_validatorAddr, 0, 0, false);\n  }\n\n  function _pcValidateEvidence(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) internal pure override returns (bool _validEvidence) {\n    return validatingDoubleSignProof(_consensusAddr, _header1, _header2);\n  }\n}\n"
    },
    "contracts/mocks/ronin/MockBridgeReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IBridgeReward, BridgeReward } from \"../../ronin/gateway/BridgeReward.sol\";\n\ncontract MockBridgeReward is BridgeReward {\n  function calcRewardAndCheckSlashedStatus(\n    bool isValidTrackingResponse,\n    uint256 numBridgeOperators,\n    uint256 rewardPerPeriod,\n    uint256 ballot,\n    uint256 totalBallot,\n    uint256 period,\n    uint256 slashUntilPeriod\n  ) external pure returns (uint256 reward, bool isSlashed) {\n    return\n      _calcRewardAndCheckSlashedStatus(\n        isValidTrackingResponse,\n        numBridgeOperators,\n        rewardPerPeriod,\n        ballot,\n        totalBallot,\n        period,\n        slashUntilPeriod\n      );\n  }\n\n  function calcReward(\n    bool isValidTrackingResponse,\n    uint256 numBridgeOperators,\n    uint256 rewardPerPeriod,\n    uint256 ballot,\n    uint256 totalBallot\n  ) external pure returns (uint256 reward) {\n    reward = _calcReward(isValidTrackingResponse, numBridgeOperators, rewardPerPeriod, ballot, totalBallot);\n  }\n\n  function isValidBridgeTrackingResponse(\n    uint256 totalBallot,\n    uint256 totalVote,\n    uint256[] memory ballots\n  ) external pure returns (bool valid) {\n    return _isValidBridgeTrackingResponse(totalBallot, totalVote, ballots);\n  }\n\n  function shouldShareEqually(\n    uint256 totalBallot,\n    uint256 totalVote,\n    uint256[] memory ballots\n  ) external returns (bool shareEqually) {\n    return _shouldShareEqually(totalBallot, totalVote, ballots);\n  }\n\n  function shouldSlashedThisPeriod(uint256 period, uint256 slashUntilDuration) external pure returns (bool) {\n    return _shouldSlashedThisPeriod(period, slashUntilDuration);\n  }\n}\n"
    },
    "contracts/mocks/ronin/MockBridgeSlash.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IBridgeSlash, BridgeSlash } from \"../../ronin/gateway/BridgeSlash.sol\";\n\ncontract MockBridgeSlash is BridgeSlash {\n  function calcSlashUntilPeriod(\n    Tier tier,\n    uint256 period,\n    uint256 slashUntilPeriod\n  ) external pure returns (uint256 newSlashUntilPeriod) {\n    newSlashUntilPeriod = _calcSlashUntilPeriod(tier, period, slashUntilPeriod, _getPenaltyDurations());\n  }\n\n  function isSlashDurationMetRemovalThreshold(uint256 slashUntilPeriod, uint256 period) external pure returns (bool) {\n    return _isSlashDurationMetRemovalThreshold(slashUntilPeriod, period);\n  }\n}\n"
    },
    "contracts/mocks/ronin/MockRoninGatewayV3Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../ronin/gateway/RoninGatewayV3.sol\";\n\ncontract MockRoninGatewayV3Extended is RoninGatewayV3 {\n  /*\n   * @dev Returns the vote weight for a deposit based on its corressponding hash.\n   */\n  function getDepositVoteWeight(\n    uint256 _chainId,\n    uint256 _depositId,\n    bytes32 _hash\n  ) external view returns (uint256 totalWeight) {\n    totalWeight = _getVoteWeight(depositVote[_chainId][_depositId], _hash);\n  }\n\n  /**\n   * @dev Returns the vote weight for a mainchain withdrew acknowledgement based on its corressponding hash.\n   */\n  function getMainchainWithdrewVoteWeight(\n    uint256 _withdrawalId,\n    bytes32 _hash\n  ) external view returns (uint256 totalWeight) {\n    totalWeight = _getVoteWeight(mainchainWithdrewVote[_withdrawalId], _hash);\n  }\n\n  /**\n   * @dev Returns the vote weight for a withdraw stats based on its corressponding hash.\n   */\n  function getWithdrawalStatVoteWeight(\n    uint256 _withdrawalId,\n    bytes32 _hash\n  ) external view returns (uint256 totalWeight) {\n    totalWeight = _getVoteWeight(withdrawalStatVote[_withdrawalId], _hash);\n  }\n}\n"
    },
    "contracts/mocks/validator/MockRoninValidatorSetExtended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./MockRoninValidatorSetOverridePrecompile.sol\";\nimport \"../../libraries/EnumFlags.sol\";\n\ncontract MockRoninValidatorSetExtended is MockRoninValidatorSetOverridePrecompile {\n  bool private _initialized;\n  uint256[] internal _epochs;\n\n  constructor() {}\n\n  function initEpoch() public {\n    if (!_initialized) {\n      _epochs.push(0);\n      _initialized = true;\n    }\n  }\n\n  function endEpoch() external {\n    _epochs.push(block.number);\n  }\n\n  function epochOf(uint256 _block) public view override returns (uint256 _epoch) {\n    for (uint256 _i = _epochs.length; _i > 0; _i--) {\n      if (_block > _epochs[_i - 1]) {\n        return _i;\n      }\n    }\n  }\n\n  function epochEndingAt(uint256 _block) public view override(ITimingInfo, TimingStorage) returns (bool) {\n    for (uint _i = 0; _i < _epochs.length; _i++) {\n      if (_block == _epochs[_i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function getJailUntils(address[] calldata _addrs) public view returns (uint256[] memory jailUntils_) {\n    jailUntils_ = new uint256[](_addrs.length);\n    for (uint _i = 0; _i < _addrs.length; _i++) {\n      jailUntils_[_i] = _blockProducerJailedBlock[_addrs[_i]];\n    }\n  }\n\n  function addValidators(address[] calldata _addrs) public {\n    for (uint _i = 0; _i < _addrs.length; _i++) {\n      address _cAddr = _addrs[_i];\n      _validatorIds[_i] = _cAddr;\n      _validatorMap[_cAddr] = EnumFlags.ValidatorFlag.Both;\n    }\n  }\n}\n"
    },
    "contracts/mocks/validator/MockRoninValidatorSetOverridePrecompile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../MockPrecompile.sol\";\nimport \"../../ronin/validator/RoninValidatorSet.sol\";\n\ncontract MockRoninValidatorSetOverridePrecompile is RoninValidatorSet, MockPrecompile {\n  constructor() {}\n\n  function arrangeValidatorCandidates(\n    address[] memory _candidates,\n    uint256[] memory _trustedWeights,\n    uint _newValidatorCount,\n    uint _maxPrioritizedValidatorNumber\n  ) external pure returns (address[] memory) {\n    _arrangeValidatorCandidates(_candidates, _trustedWeights, _newValidatorCount, _maxPrioritizedValidatorNumber);\n    return _candidates;\n  }\n\n  function _pcSortCandidates(\n    address[] memory _candidates,\n    uint256[] memory _weights\n  ) internal pure override returns (address[] memory _result) {\n    return sortValidators(_candidates, _weights);\n  }\n\n  function _pcPickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) internal pure override returns (address[] memory _result, uint256 _newValidatorCount) {\n    _result = pickValidatorSet(\n      _candidates,\n      _weights,\n      _trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n\n    _newValidatorCount = _result.length;\n  }\n}\n"
    },
    "contracts/mocks/validator/MockValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../ronin/validator/CandidateManagerCallback.sol\";\nimport { HasStakingVestingDeprecated, HasSlashIndicatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\ncontract MockValidatorSet is\n  IRoninValidatorSet,\n  CandidateManagerCallback,\n  HasStakingVestingDeprecated,\n  HasSlashIndicatorDeprecated\n{\n  uint256 internal _lastUpdatedPeriod;\n  uint256 internal _numberOfBlocksInEpoch;\n  /// @dev Mapping from period number => slashed\n  mapping(uint256 => bool) internal _periodSlashed;\n\n  constructor(\n    address _stakingContract,\n    address _slashIndicatorContract,\n    address _stakingVestingContract,\n    address _profileContract,\n    uint256 __maxValidatorCandidate,\n    uint256 __numberOfBlocksInEpoch,\n    uint256 __minEffectiveDaysOnwards\n  ) {\n    _setContract(ContractType.STAKING, _stakingContract);\n    _setContract(ContractType.SLASH_INDICATOR, _slashIndicatorContract);\n    _setContract(ContractType.STAKING_VESTING, _stakingVestingContract);\n    _setContract(ContractType.PROFILE, _profileContract);\n    _setMaxValidatorCandidate(__maxValidatorCandidate);\n    _numberOfBlocksInEpoch = __numberOfBlocksInEpoch;\n    _minEffectiveDaysOnwards = __minEffectiveDaysOnwards;\n  }\n\n  function submitBlockReward() external payable override {}\n\n  function wrapUpEpoch() external payable override {\n    _syncCandidateSet(_lastUpdatedPeriod + 1);\n    _lastUpdatedPeriod = currentPeriod();\n  }\n\n  function getLastUpdatedBlock() external view override returns (uint256) {}\n\n  function checkManyJailed(TConsensus[] calldata) external view override returns (bool[] memory) {}\n\n  function checkManyJailedById(address[] calldata candidateIds) external view returns (bool[] memory) {}\n\n  function checkMiningRewardDeprecated(TConsensus) external view override returns (bool) {}\n\n  function checkMiningRewardDeprecatedAtPeriod(TConsensus, uint256 period) external view override returns (bool) {}\n\n  function checkBridgeRewardDeprecatedAtPeriod(\n    TConsensus _consensusAddr,\n    uint256 _period\n  ) external view returns (bool _result) {}\n\n  function epochOf(uint256 _block) external view override returns (uint256) {}\n\n  function getValidators() external view override returns (address[] memory) {}\n\n  function epochEndingAt(uint256 _block) external view override returns (bool) {}\n\n  function execSlash(address cid, uint256 newJailedUntil, uint256 slashAmount, bool cannotBailout) external override {}\n\n  function execBailOut(address, uint256) external override {}\n\n  function setMaxValidatorNumber(uint256 _maxValidatorNumber) external override {}\n\n  function setMaxPrioritizedValidatorNumber(uint256 _maxPrioritizedValidatorNumber) external override {}\n\n  function maxValidatorNumber() external view override returns (uint256 _maximumValidatorNumber) {}\n\n  function maxPrioritizedValidatorNumber()\n    external\n    view\n    override\n    returns (uint256 _maximumPrioritizedValidatorNumber)\n  {}\n\n  function numberOfBlocksInEpoch() public view override returns (uint256) {\n    return _numberOfBlocksInEpoch;\n  }\n\n  function getBlockProducers() external view override returns (address[] memory) {}\n\n  function isBlockProducer(TConsensus) external pure override returns (bool) {\n    return true;\n  }\n\n  function totalBlockProducer() external view override returns (uint256) {}\n\n  function tryGetPeriodOfEpoch(uint256) external view returns (bool, uint256) {}\n\n  function isPeriodEnding() public view virtual returns (bool) {\n    return currentPeriod() > _lastUpdatedPeriod;\n  }\n\n  function currentPeriod() public view override returns (uint256) {\n    return block.timestamp / 86400;\n  }\n\n  function checkJailed(TConsensus) external view override returns (bool) {}\n\n  function getJailedTimeLeft(TConsensus) external view override returns (bool, uint256, uint256) {}\n\n  function currentPeriodStartAtBlock() external view override returns (uint256) {}\n\n  function checkJailedAtBlock(TConsensus _addr, uint256 _blockNum) external view override returns (bool) {}\n\n  function getJailedTimeLeftAtBlock(\n    TConsensus _addr,\n    uint256 _blockNum\n  ) external view override returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_) {}\n\n  function totalDeprecatedReward() external view override returns (uint256) {}\n\n  function __css2cid(TConsensus consensusAddr) internal view override returns (address) {\n    return IProfile(getContract(ContractType.PROFILE)).getConsensus2Id(consensusAddr);\n  }\n\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view override returns (address[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyConsensus2Id(consensusAddrs);\n  }\n\n  function execReleaseLockedFundForEmergencyExitRequest(\n    address _candidateId,\n    address payable _recipient\n  ) external override {}\n\n  function emergencyExitLockedAmount() external override returns (uint256) {}\n\n  function emergencyExpiryDuration() external override returns (uint256) {}\n\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external override {}\n\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external override {}\n\n  function getEmergencyExitInfo(TConsensus consensus) external view override returns (EmergencyExitInfo memory) {}\n\n  function execRequestEmergencyExit(address, uint256) external {}\n\n  function isOperatingBridge(TConsensus) external view returns (bool) {}\n\n  function _emergencyExitLockedFundReleased(address _consensusAddr) internal virtual override returns (bool) {}\n\n  function _isTrustedOrg(address validatorId) internal virtual override returns (bool) {}\n}\n"
    },
    "contracts/precompile-usages/PCUPickValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUPickValidatorSet is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of picking validator set\n  function precompilePickValidatorSetAddress() public view virtual returns (address) {\n    return address(0x68);\n  }\n\n  /**\n   * @dev Sorts and arranges to return a new validator set.\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcPickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) internal view virtual returns (address[] memory _result, uint256 _newValidatorCount) {\n    address _smc = precompilePickValidatorSetAddress();\n    bytes memory _payload = abi.encodeWithSignature(\n      \"pickValidatorSet(address[],uint256[],uint256[],uint256,uint256)\",\n      _candidates,\n      _weights,\n      _trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n    bool _success = true;\n\n    uint256 _payloadLength = _payload.length;\n    uint256 _resultLength = 0x20 * _candidates.length + 0x40;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _result, _resultLength)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n\n      _result := add(_result, 0x20)\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n\n    _newValidatorCount = _result.length;\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUSortValidators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUSortValidators is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of sorting validators\n  function precompileSortValidatorsAddress() public view virtual returns (address) {\n    return address(0x66);\n  }\n\n  /**\n   * @dev Sorts candidates descending by their weights by calling precompile contract.\n   *\n   * Note: This function is marked as virtual for being wrapping in mock contract for testing purpose.\n   */\n  function _pcSortCandidates(\n    address[] memory _candidates,\n    uint256[] memory _weights\n  ) internal view virtual returns (address[] memory _result) {\n    address _smc = precompileSortValidatorsAddress();\n    bool _success = true;\n\n    bytes memory _payload = abi.encodeWithSignature(\"sortValidators(address[],uint256[])\", _candidates, _weights);\n    uint256 _payloadLength = _payload.length;\n    uint256 _resultLength = 0x20 * _candidates.length + 0x40;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _result, _resultLength)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n\n      _result := add(_result, 0x20)\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUValidateDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUValidateDoubleSign is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of validating double sign evidence\n  function precompileValidateDoubleSignAddress() public view virtual returns (address) {\n    return address(0x67);\n  }\n\n  /**\n   * @dev Validates the two submitted block header if they are produced by the same address\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcValidateEvidence(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) internal view virtual returns (bool _validEvidence) {\n    address _smc = precompileValidateDoubleSignAddress();\n    bool _success = true;\n\n    bytes memory _payload = abi.encodeWithSignature(\n      \"validatingDoubleSignProof(address,bytes,bytes)\",\n      _consensusAddr,\n      _header1,\n      _header2\n    );\n    uint _payloadLength = _payload.length;\n    uint[1] memory _output;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _output, 0x20)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n    return (_output[0] != 0);\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUValidateFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUValidateFastFinality is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of validating double sign evidence\n  function precompileValidateFastFinalityAddress() public view virtual returns (address) {\n    return address(0x69);\n  }\n\n  /**\n   * @dev Validates the proof of malicious voting on fast finality\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcValidateFastFinalityEvidence(\n    bytes memory voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] memory targetBlockHash,\n    bytes[][2] memory listOfPublicKey,\n    bytes[2] memory aggregatedSignature\n  ) internal view virtual returns (bool validEvidence) {\n    address smc = precompileValidateFastFinalityAddress();\n    bool success = true;\n\n    bytes memory payload = abi.encodeWithSignature(\n      \"validateFinalityVoteProof(bytes,uint256,bytes32[2],bytes[][2],bytes[2])\",\n      voterPublicKey,\n      targetBlockNumber,\n      targetBlockHash,\n      listOfPublicKey,\n      aggregatedSignature\n    );\n    uint payloadLength = payload.length;\n    uint[1] memory output;\n\n    assembly {\n      let payloadStart := add(payload, 0x20)\n      if iszero(staticcall(gas(), smc, payloadStart, payloadLength, output, 0x20)) {\n        success := 0\n      }\n\n      if iszero(returndatasize()) {\n        success := 0\n      }\n    }\n\n    if (!success) revert ErrCallPrecompiled();\n    return (output[0] != 0);\n  }\n}\n"
    },
    "contracts/precompile-usages/PrecompiledUsage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PrecompiledUsage {\n  /// @dev Error of call to precompile fails.\n  error ErrCallPrecompiled();\n}\n"
    },
    "contracts/ronin/fast-finality/FastFinalityTracking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { IRoninValidatorSet } from \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport { IFastFinalityTracking } from \"../..//interfaces/IFastFinalityTracking.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../utils/CommonErrors.sol\";\n\ncontract FastFinalityTracking is IFastFinalityTracking, Initializable, HasContracts {\n  /// @dev Mapping from epoch number => consensus address => number of QC vote\n  mapping(uint256 => mapping(address => uint256)) internal _tracker;\n  /// @dev The latest block that tracked the QC vote\n  uint256 internal _latestTrackingBlock;\n\n  modifier oncePerBlock() {\n    if (block.number <= _latestTrackingBlock) {\n      revert ErrOncePerBlock();\n    }\n\n    _latestTrackingBlock = block.number;\n    _;\n  }\n\n  modifier onlyCoinbase() {\n    if (msg.sender != block.coinbase) revert ErrCallerMustBeCoinbase();\n    _;\n  }\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address validatorContract) external initializer {\n    _setContract(ContractType.VALIDATOR, validatorContract);\n  }\n\n  /**\n   * @inheritdoc IFastFinalityTracking\n   */\n  function recordFinality(address[] calldata voters) external override oncePerBlock onlyCoinbase {\n    uint256 currentEpoch = IRoninValidatorSet(getContract(ContractType.VALIDATOR)).epochOf(block.number);\n\n    for (uint i; i < voters.length; ) {\n      unchecked {\n        ++_tracker[currentEpoch][voters[i]];\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IFastFinalityTracking\n   */\n  function getManyFinalityVoteCounts(\n    uint256 epoch,\n    address[] calldata addrs\n  ) external view override returns (uint256[] memory voteCounts) {\n    uint256 length = addrs.length;\n    voteCounts = new uint256[](length);\n    for (uint i; i < length; ) {\n      voteCounts[i] = _tracker[epoch][addrs[i]];\n      unchecked {\n        ++i;\n      }\n    }\n  }\n}\n"
    },
    "contracts/ronin/gateway/BridgeReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { BridgeTrackingHelper } from \"../../extensions/bridge-operator-governance/BridgeTrackingHelper.sol\";\nimport { ContractType, HasContracts } from \"../../extensions/collections/HasContracts.sol\";\nimport { RONTransferHelper } from \"../../extensions/RONTransferHelper.sol\";\nimport { IRoninValidatorSet } from \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport { IBridgeManager } from \"../../interfaces/bridge/IBridgeManager.sol\";\nimport { IBridgeTracking } from \"../../interfaces/bridge/IBridgeTracking.sol\";\nimport { IBridgeReward } from \"../../interfaces/bridge/IBridgeReward.sol\";\nimport { IBridgeSlash } from \"../../interfaces/bridge/IBridgeSlash.sol\";\nimport { Math } from \"../../libraries/Math.sol\";\nimport { TUint256Slot } from \"../../types/Types.sol\";\nimport { ErrSyncTooFarPeriod, ErrInvalidArguments, ErrLengthMismatch, ErrUnauthorizedCall } from \"../../utils/CommonErrors.sol\";\n\ncontract BridgeReward is IBridgeReward, BridgeTrackingHelper, HasContracts, RONTransferHelper, Initializable {\n  /// @dev value is equal to keccak256(\"@ronin.dpos.gateway.BridgeReward.rewardInfo.slot\") - 1\n  bytes32 private constant REWARD_INFO_SLOT = 0x518cfd198acbffe95e740cfce1af28a3f7de51f0d784893d3d72c5cc59d7062a;\n  /// @dev value is equal to keccak256(\"@ronin.dpos.gateway.BridgeReward.rewardPerPeriod.slot\") - 1\n  TUint256Slot private constant REWARD_PER_PERIOD_SLOT =\n    TUint256Slot.wrap(0x90f7d557245e5dd9485f463e58974fa7cdc93c0abbd0a1afebb8f9640ec73910);\n  /// @dev value is equal to keccak256(\"@ronin.dpos.gateway.BridgeReward.latestRewardedPeriod.slot\") - 1\n  TUint256Slot private constant LATEST_REWARDED_PERIOD_SLOT =\n    TUint256Slot.wrap(0x2417f25874c1cdc139a787dd21df976d40d767090442b3a2496917ecfc93b619);\n  /// @dev value is equal to keccak256(\"@ronin.dpos.gateway.BridgeReward.totalRewardToppedUp.slot\") - 1\n  TUint256Slot private constant TOTAL_REWARDS_TOPPED_UP_SLOT =\n    TUint256Slot.wrap(0x9a8c9f129792436c37b7bd2d79c56132fc05bf26cc8070794648517c2a0c6c64);\n  /// @dev value is equal to keccak256(\"@ronin.dpos.gateway.BridgeReward.totalRewardScattered.slot\") - 1\n  TUint256Slot private constant TOTAL_REWARDS_SCATTERED_SLOT =\n    TUint256Slot.wrap(0x3663384f6436b31a97d9c9a02f64ab8b73ead575c5b6224fa0800a6bd57f62f4);\n\n  address private immutable _self;\n\n  constructor() payable {\n    _self = address(this);\n    _disableInitializers();\n  }\n\n  function initialize(\n    address bridgeManagerContract,\n    address bridgeTrackingContract,\n    address bridgeSlashContract,\n    address validatorSetContract,\n    address dposGA,\n    uint256 rewardPerPeriod\n  ) external payable initializer {\n    _setContract(ContractType.BRIDGE_MANAGER, bridgeManagerContract);\n    _setContract(ContractType.BRIDGE_TRACKING, bridgeTrackingContract);\n    _setContract(ContractType.BRIDGE_SLASH, bridgeSlashContract);\n    _setContract(ContractType.VALIDATOR, validatorSetContract);\n    _setContract(ContractType.GOVERNANCE_ADMIN, dposGA);\n    LATEST_REWARDED_PERIOD_SLOT.store(type(uint256).max);\n    _setRewardPerPeriod(rewardPerPeriod);\n    _receiveRON();\n  }\n\n  /**\n   * @dev Helper for running upgrade script, required to only revoked once by the DPoS's governance admin.\n   * The following must be assured after initializing REP2: `_lastSyncPeriod` == `{BridgeReward}.latestRewardedPeriod` == `currentPeriod()`\n   */\n  function initializeREP2() external onlyContract(ContractType.GOVERNANCE_ADMIN) {\n    require(getLatestRewardedPeriod() == type(uint256).max, \"already init rep 2\");\n    LATEST_REWARDED_PERIOD_SLOT.store(IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod() - 1);\n    _setContract(ContractType.GOVERNANCE_ADMIN, address(0));\n  }\n\n  /**\n   * @inheritdoc IBridgeReward\n   */\n  function receiveRON() external payable {\n    _receiveRON();\n  }\n\n  /**\n   * @inheritdoc IBridgeReward\n   */\n  function syncReward(uint256 periodLength) external {\n    if (!_isBridgeOperator(msg.sender)) revert ErrUnauthorizedCall(msg.sig);\n\n    uint256 latestRewardedPeriod = getLatestRewardedPeriod();\n    uint256 currentPeriod = IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod();\n\n    if (currentPeriod <= latestRewardedPeriod) revert ErrInvalidArguments(msg.sig);\n    if (latestRewardedPeriod + periodLength > currentPeriod) revert ErrInvalidArguments(msg.sig);\n\n    LATEST_REWARDED_PERIOD_SLOT.addAssign(periodLength);\n\n    address[] memory operators = IBridgeManager(getContract(ContractType.BRIDGE_MANAGER)).getBridgeOperators();\n    IBridgeTracking bridgeTrackingContract = IBridgeTracking(getContract(ContractType.BRIDGE_TRACKING));\n\n    for (uint256 i = 1; i <= periodLength; ) {\n      unchecked {\n        _syncReward({\n          operators: operators,\n          ballots: bridgeTrackingContract.getManyTotalBallots(latestRewardedPeriod, operators),\n          totalBallot: bridgeTrackingContract.totalBallot(latestRewardedPeriod),\n          totalVote: bridgeTrackingContract.totalVote(latestRewardedPeriod),\n          period: latestRewardedPeriod += i\n        });\n\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeReward\n   *\n   * @dev The `period` a.k.a. `latestSyncedPeriod` must equal to `latestRewardedPeriod` + 1.\n   */\n  function execSyncReward(\n    address[] calldata operators,\n    uint256[] calldata ballots,\n    uint256 totalBallot,\n    uint256 totalVote,\n    uint256 period\n  ) external onlyContract(ContractType.BRIDGE_TRACKING) {\n    if (operators.length != ballots.length) revert ErrLengthMismatch(msg.sig);\n    if (operators.length == 0) return;\n\n    // Only sync the period that is after the latest rewarded period, i.e. `latestSyncedPeriod == latestRewardedPeriod + 1`.\n    unchecked {\n      uint256 latestRewardedPeriod = getLatestRewardedPeriod();\n      if (period < latestRewardedPeriod + 1) revert ErrInvalidArguments(msg.sig);\n      else if (period > latestRewardedPeriod + 1) revert ErrSyncTooFarPeriod(period, latestRewardedPeriod);\n    }\n    LATEST_REWARDED_PERIOD_SLOT.store(period);\n\n    _syncReward({\n      operators: operators,\n      ballots: ballots,\n      totalBallot: totalBallot,\n      totalVote: totalVote,\n      period: period\n    });\n  }\n\n  /**\n   * @inheritdoc IBridgeReward\n   */\n  function getTotalRewardToppedUp() external view returns (uint256) {\n    return TOTAL_REWARDS_TOPPED_UP_SLOT.load();\n  }\n\n  /**\n   * @inheritdoc IBridgeReward\n   */\n  function getTotalRewardScattered() external view returns (uint256) {\n    return TOTAL_REWARDS_SCATTERED_SLOT.load();\n  }\n\n  /**\n   * @dev Internal function to receive RON tokens as rewards and update the total topped-up rewards amount.\n   */\n  function _receiveRON() internal {\n    // prevent transfer RON directly to logic contract\n    if (address(this) == _self) revert ErrUnauthorizedCall(msg.sig);\n\n    emit SafeReceived(msg.sender, TOTAL_REWARDS_TOPPED_UP_SLOT.load(), msg.value);\n    TOTAL_REWARDS_TOPPED_UP_SLOT.addAssign(msg.value);\n  }\n\n  /**\n   * @dev Internal function to synchronize and distribute rewards to bridge operators for a given period.\n   * @param operators An array containing the addresses of bridge operators to receive rewards.\n   * @param ballots An array containing the individual ballot counts for each bridge operator.\n   * @param totalBallot The total number of available ballots for the period.\n   * @param totalVote The total number of votes recorded for the period.\n   * @param period The period for which the rewards are being synchronized.\n   */\n  function _syncReward(\n    address[] memory operators,\n    uint256[] memory ballots,\n    uint256 totalBallot,\n    uint256 totalVote,\n    uint256 period\n  ) internal {\n    uint256 numBridgeOperators = operators.length;\n    uint256 rewardPerPeriod = getRewardPerPeriod();\n    uint256[] memory slashedDurationList = _getSlashInfo(operators);\n    // Validate should share the reward equally\n    bool shouldShareEqually = _shouldShareEqually(totalBallot, totalVote, ballots);\n\n    uint256 reward;\n    bool shouldSlash;\n    uint256 sumRewards;\n\n    for (uint256 i; i < numBridgeOperators; ) {\n      (reward, shouldSlash) = _calcRewardAndCheckSlashedStatus({\n        shouldShareEqually: shouldShareEqually,\n        numBridgeOperators: numBridgeOperators,\n        rewardPerPeriod: rewardPerPeriod,\n        ballot: ballots[i],\n        totalBallot: totalBallot,\n        period: period,\n        slashUntilPeriod: slashedDurationList[i]\n      });\n\n      sumRewards += shouldSlash ? 0 : reward;\n      _updateRewardAndTransfer({ period: period, operator: operators[i], reward: reward, shouldSlash: shouldSlash });\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    TOTAL_REWARDS_SCATTERED_SLOT.addAssign(sumRewards);\n  }\n\n  /**\n   * @dev Returns whether should share the reward equally, in case of bridge tracking returns\n   * informed data or there is no ballot in a day.\n   *\n   * Emit a {BridgeTrackingIncorrectlyResponded} event when in case of incorrect data.\n   */\n  function _shouldShareEqually(\n    uint256 totalBallot,\n    uint256 totalVote,\n    uint256[] memory ballots\n  ) internal returns (bool shareEqually) {\n    bool valid = _isValidBridgeTrackingResponse(totalBallot, totalVote, ballots);\n    if (!valid) {\n      emit BridgeTrackingIncorrectlyResponded();\n    }\n\n    return !valid || totalBallot == 0;\n  }\n\n  /**\n   * @dev Internal function to calculate the reward for a bridge operator and check its slashing status.\n   * @param shouldShareEqually A boolean indicating whether the reward should be shared equally among bridge operators.\n   * @param numBridgeOperators The total number of bridge operators for proportional reward calculation.\n   * @param rewardPerPeriod The total reward available for the period.\n   * @param ballot The individual ballot count of the bridge operator for the period.\n   * @param totalBallot The total number of available ballots for the period.\n   * @param period The period for which the reward is being calculated.\n   * @param slashUntilPeriod The period until which slashing is effective for the bridge operator.\n   * @return reward The calculated reward for the bridge operator.\n   * @return shouldSlash A boolean indicating whether the bridge operator should be slashed for the current period.\n   */\n  function _calcRewardAndCheckSlashedStatus(\n    bool shouldShareEqually,\n    uint256 numBridgeOperators,\n    uint256 rewardPerPeriod,\n    uint256 ballot,\n    uint256 totalBallot,\n    uint256 period,\n    uint256 slashUntilPeriod\n  ) internal pure returns (uint256 reward, bool shouldSlash) {\n    shouldSlash = _shouldSlashedThisPeriod(period, slashUntilPeriod);\n    reward = _calcReward(shouldShareEqually, numBridgeOperators, rewardPerPeriod, ballot, totalBallot);\n  }\n\n  /**\n   * @dev Internal function to check if a specific period should be considered as slashed based on the slash duration.\n   * @param period The period to check if it should be slashed.\n   * @param slashDuration The duration until which periods should be considered as slashed.\n   * @return shouldSlashed A boolean indicating whether the specified period should be slashed.\n   * @notice This function is used internally to determine if a particular period should be marked as slashed based on the slash duration.\n   */\n  function _shouldSlashedThisPeriod(uint256 period, uint256 slashDuration) internal pure returns (bool) {\n    return period <= slashDuration;\n  }\n\n  /**\n   * @dev Internal function to calculate the reward for a bridge operator based on the provided parameters.\n   * @param shouldShareEqually A boolean indicating whether the reward should be shared equally among bridge operators.\n   * @param numBridgeOperators The total number of bridge operators for proportional reward calculation.\n   * @param rewardPerPeriod The total reward available for the period.\n   * @param ballot The individual ballot count of the bridge operator for the period.\n   * @param totalBallot The total number of available ballots for the period.\n   * @return reward The calculated reward for the bridge operator.\n   */\n  function _calcReward(\n    bool shouldShareEqually,\n    uint256 numBridgeOperators,\n    uint256 rewardPerPeriod,\n    uint256 ballot,\n    uint256 totalBallot\n  ) internal pure returns (uint256 reward) {\n    // Shares equally in case the bridge has nothing to vote or bridge tracking response is incorrect\n    // Else shares the bridge operators reward proportionally\n    reward = shouldShareEqually ? rewardPerPeriod / numBridgeOperators : (rewardPerPeriod * ballot) / totalBallot;\n  }\n\n  /**\n   * @dev Transfer `reward` to a `operator` or only emit event based on the operator `slashed` status.\n   */\n  function _updateRewardAndTransfer(uint256 period, address operator, uint256 reward, bool shouldSlash) private {\n    BridgeRewardInfo storage _iRewardInfo = _getRewardInfo()[operator];\n\n    if (shouldSlash) {\n      _iRewardInfo.slashed += reward;\n      emit BridgeRewardSlashed(period, operator, reward);\n    } else {\n      _iRewardInfo.claimed += reward;\n      if (_unsafeSendRONLimitGas({ recipient: payable(operator), amount: reward, gas: 0 })) {\n        emit BridgeRewardScattered(period, operator, reward);\n      } else {\n        emit BridgeRewardScatterFailed(period, operator, reward);\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeReward\n   */\n  function getRewardPerPeriod() public view returns (uint256) {\n    return REWARD_PER_PERIOD_SLOT.load();\n  }\n\n  /**\n   * @inheritdoc IBridgeReward\n   */\n  function getLatestRewardedPeriod() public view returns (uint256) {\n    return LATEST_REWARDED_PERIOD_SLOT.load();\n  }\n\n  /**\n   * @inheritdoc IBridgeReward\n   */\n  function setRewardPerPeriod(uint256 rewardPerPeriod) external onlyContract(ContractType.BRIDGE_MANAGER) {\n    _setRewardPerPeriod(rewardPerPeriod);\n  }\n\n  /**\n   * @dev Internal function for setting the total reward per period.\n   * Emit an {UpdatedRewardPerPeriod} event after set.\n   */\n  function _setRewardPerPeriod(uint256 rewardPerPeriod) internal {\n    REWARD_PER_PERIOD_SLOT.store(rewardPerPeriod);\n    emit UpdatedRewardPerPeriod(rewardPerPeriod);\n  }\n\n  /**\n   * @dev Internal helper for querying slash info of a list of operators.\n   */\n  function _getSlashInfo(address[] memory operatorList) internal returns (uint256[] memory _slashedDuration) {\n    return IBridgeSlash(getContract(ContractType.BRIDGE_SLASH)).getSlashUntilPeriodOf(operatorList);\n  }\n\n  /**\n   * @dev Internal helper for querying whether an address is an operator.\n   */\n  function _isBridgeOperator(address operator) internal view returns (bool) {\n    return IBridgeManager(getContract(ContractType.BRIDGE_MANAGER)).isBridgeOperator(operator);\n  }\n\n  /**\n   * @dev Internal function to access the mapping from bridge operator => BridgeRewardInfo.\n   * @return rewardInfo the mapping from bridge operator => BridgeRewardInfo.\n   */\n  function _getRewardInfo() internal pure returns (mapping(address => BridgeRewardInfo) storage rewardInfo) {\n    assembly (\"memory-safe\") {\n      rewardInfo.slot := REWARD_INFO_SLOT\n    }\n  }\n}\n"
    },
    "contracts/ronin/gateway/BridgeSlash.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { BridgeTrackingHelper } from \"../../extensions/bridge-operator-governance/BridgeTrackingHelper.sol\";\nimport { IHasContracts, HasContracts } from \"../../extensions/collections/HasContracts.sol\";\nimport { IBridgeSlash } from \"../../interfaces/bridge/IBridgeSlash.sol\";\nimport { IERC165, IBridgeManagerCallback } from \"../../interfaces/bridge/IBridgeManagerCallback.sol\";\nimport { IBridgeTracking } from \"../../interfaces/bridge/IBridgeTracking.sol\";\nimport { IRoninValidatorSet } from \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport { Math } from \"../../libraries/Math.sol\";\nimport { ContractType } from \"../../utils/ContractType.sol\";\nimport { IdentityGuard } from \"../../utils/IdentityGuard.sol\";\nimport { ErrLengthMismatch } from \"../../utils/CommonErrors.sol\";\n\n/**\n * @title BridgeSlash\n * @dev A contract that implements slashing functionality for bridge operators based on their availability.\n */\ncontract BridgeSlash is\n  IBridgeSlash,\n  IBridgeManagerCallback,\n  BridgeTrackingHelper,\n  IdentityGuard,\n  Initializable,\n  HasContracts\n{\n  /// @inheritdoc IBridgeSlash\n  uint256 public constant TIER_1_PENALTY_DURATION = 1;\n  /// @inheritdoc IBridgeSlash\n  uint256 public constant TIER_2_PENALTY_DURATION = 5;\n  /// @inheritdoc IBridgeSlash\n  uint256 public constant MINIMUM_VOTE_THRESHOLD = 50;\n  /// @inheritdoc IBridgeSlash\n  uint256 public constant REMOVE_DURATION_THRESHOLD = 30;\n\n  /// @dev Tier 1 slashing threshold ratio is 10%\n  uint256 private constant TIER_1_THRESHOLD = 10_00;\n  /// @dev Tier 2 slashing threshold ratio is 30%\n  uint256 private constant TIER_2_THRESHOLD = 30_00;\n  /// @dev Max percentage 100%. Values [0; 100_00] reflexes [0; 100%]\n  uint256 private constant PERCENTAGE_FRACTION = 100_00;\n  /// @dev This value is set to the maximum value of uint128 to indicate a permanent slash duration.\n  uint256 private constant SLASH_PERMANENT_DURATION = type(uint128).max;\n  /// @dev value is equal to keccak256(\"@ronin.dpos.gateway.BridgeSlash.bridgeSlashInfos.slot\") - 1\n  bytes32 private constant BRIDGE_SLASH_INFOS_SLOT = 0xd08d185790a07c7b9b721e2713c8580010a57f31c72c16f6e80b831d0ee45bfe;\n\n  /// @dev The period that the contract allows slashing.\n  uint256 internal _startedAtPeriod;\n\n  /**\n   * @dev The modifier verifies if the `totalVote` is non-zero, indicating the presence of ballots for the period.\n   * @param totalVote The total number of ballots for the period.\n   */\n  modifier onlyPeriodHasEnoughVotes(uint256 totalVote) {\n    if (totalVote <= MINIMUM_VOTE_THRESHOLD) return;\n    _;\n  }\n\n  modifier skipOnNotStarted(uint256 period) {\n    if (period < _startedAtPeriod) return;\n    _;\n  }\n\n  constructor() payable {\n    _disableInitializers();\n  }\n\n  function initialize(\n    address validatorContract,\n    address bridgeManagerContract,\n    address bridgeTrackingContract,\n    address dposGA\n  ) external initializer {\n    _setContract(ContractType.VALIDATOR, validatorContract);\n    _setContract(ContractType.BRIDGE_MANAGER, bridgeManagerContract);\n    _setContract(ContractType.BRIDGE_TRACKING, bridgeTrackingContract);\n    _setContract(ContractType.GOVERNANCE_ADMIN, dposGA);\n    _startedAtPeriod = type(uint256).max;\n  }\n\n  /**\n   * @dev Helper for running upgrade script, required to only revoked once by the DPoS's governance admin.\n   */\n  function initializeREP2() external onlyContract(ContractType.GOVERNANCE_ADMIN) {\n    require(_startedAtPeriod == type(uint256).max, \"already init rep 2\");\n    _startedAtPeriod = IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod() + 1;\n    _setContract(ContractType.GOVERNANCE_ADMIN, address(0));\n  }\n\n  /**\n   * @inheritdoc IBridgeManagerCallback\n   */\n  function onBridgeOperatorsAdded(\n    address[] calldata bridgeOperators,\n    bool[] memory addeds\n  ) external onlyContract(ContractType.BRIDGE_MANAGER) returns (bytes4) {\n    uint256 length = bridgeOperators.length;\n    if (length != addeds.length) revert ErrLengthMismatch(msg.sig);\n    if (length == 0) {\n      return IBridgeManagerCallback.onBridgeOperatorsAdded.selector;\n    }\n\n    mapping(address => BridgeSlashInfo) storage _bridgeSlashInfos = _getBridgeSlashInfos();\n    uint256 currentPeriod = IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod();\n\n    for (uint256 i; i < length; ) {\n      unchecked {\n        if (addeds[i]) {\n          _bridgeSlashInfos[bridgeOperators[i]].newlyAddedAtPeriod = uint128(currentPeriod);\n        }\n\n        ++i;\n      }\n    }\n\n    return IBridgeManagerCallback.onBridgeOperatorsAdded.selector;\n  }\n\n  /**\n   * @inheritdoc IBridgeManagerCallback\n   */\n  function onBridgeOperatorUpdated(\n    address currentBridgeOperator,\n    address newBridgeOperator\n  ) external onlyContract(ContractType.BRIDGE_MANAGER) returns (bytes4) {\n    mapping(address => BridgeSlashInfo) storage _bridgeSlashInfos = _getBridgeSlashInfos();\n\n    _bridgeSlashInfos[newBridgeOperator] = _bridgeSlashInfos[currentBridgeOperator];\n    delete _bridgeSlashInfos[currentBridgeOperator];\n\n    return IBridgeManagerCallback.onBridgeOperatorUpdated.selector;\n  }\n\n  /**\n   * @inheritdoc IBridgeSlash\n   */\n  function execSlashBridgeOperators(\n    address[] memory operators,\n    uint256[] memory ballots,\n    uint256 totalBallot,\n    uint256 totalVote,\n    uint256 period\n  ) external onlyContract(ContractType.BRIDGE_TRACKING) skipOnNotStarted(period) onlyPeriodHasEnoughVotes(totalVote) {\n    if (operators.length != ballots.length) revert ErrLengthMismatch(msg.sig);\n    if (operators.length == 0) return;\n    if (!_isValidBridgeTrackingResponse(totalBallot, totalVote, ballots)) {\n      emit BridgeTrackingIncorrectlyResponded();\n      return;\n    }\n\n    // Get penalty durations for each slash tier.\n    uint256[] memory penaltyDurations = _getPenaltyDurations();\n    // Get the storage mapping for bridge slash information.\n    mapping(address => BridgeSlashInfo) storage _bridgeSlashInfos = _getBridgeSlashInfos();\n\n    // Declare variables for iteration.\n    BridgeSlashInfo memory status;\n    uint256 slashUntilPeriod;\n    address bridgeOperator;\n    Tier tier;\n\n    for (uint256 i; i < operators.length; ) {\n      bridgeOperator = operators[i];\n      status = _bridgeSlashInfos[bridgeOperator];\n\n      // Check if the bridge operator was added before the current period.\n      // Bridge operators added in current period will not be slashed.\n      if (status.newlyAddedAtPeriod < period) {\n        // Determine the slash tier for the bridge operator based on their ballots.\n        tier = _getSlashTier(ballots[i], totalVote);\n\n        slashUntilPeriod = _calcSlashUntilPeriod(tier, period, status.slashUntilPeriod, penaltyDurations);\n\n        // Check if the slash duration exceeds the threshold for removal.\n        if (_isSlashDurationMetRemovalThreshold(slashUntilPeriod, period)) {\n          slashUntilPeriod = SLASH_PERMANENT_DURATION;\n          emit RemovalRequested(period, bridgeOperator);\n        }\n\n        // Emit the Slashed event if the tier is not Tier 0 and bridge operator will not be removed.\n        // Update the slash until period number for the bridge operator if the tier is not Tier 0.\n        if (tier != Tier.Tier0) {\n          if (slashUntilPeriod != SLASH_PERMANENT_DURATION) {\n            emit Slashed(tier, bridgeOperator, period, slashUntilPeriod);\n          }\n\n          // Store updated slash until period\n          _bridgeSlashInfos[bridgeOperator].slashUntilPeriod = uint128(slashUntilPeriod);\n        }\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeManagerCallback\n   */\n  function onBridgeOperatorsRemoved(\n    address[] calldata,\n    bool[] calldata\n  ) external view onlyContract(ContractType.BRIDGE_MANAGER) returns (bytes4) {\n    return IBridgeManagerCallback.onBridgeOperatorsAdded.selector;\n  }\n\n  /**\n   * @inheritdoc IERC165\n   */\n  function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n    return interfaceId == type(IBridgeManagerCallback).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /**\n   * @inheritdoc IBridgeSlash\n   */\n  function getSlashUntilPeriodOf(\n    address[] calldata bridgeOperators\n  ) external view returns (uint256[] memory untilPeriods) {\n    uint256 length = bridgeOperators.length;\n    untilPeriods = new uint256[](length);\n    mapping(address => BridgeSlashInfo) storage _bridgeSlashInfos = _getBridgeSlashInfos();\n\n    for (uint256 i; i < length; ) {\n      untilPeriods[i] = _bridgeSlashInfos[bridgeOperators[i]].slashUntilPeriod;\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeSlash\n   */\n  function getAddedPeriodOf(address[] calldata bridgeOperators) external view returns (uint256[] memory addedPeriods) {\n    uint256 length = bridgeOperators.length;\n    addedPeriods = new uint256[](length);\n    mapping(address => BridgeSlashInfo) storage _bridgeSlashInfos = _getBridgeSlashInfos();\n\n    for (uint256 i; i < length; ) {\n      addedPeriods[i] = _bridgeSlashInfos[bridgeOperators[i]].newlyAddedAtPeriod;\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeSlash\n   */\n  function getPenaltyDurations() external pure returns (uint256[] memory penaltyDurations) {\n    penaltyDurations = _getPenaltyDurations();\n  }\n\n  /**\n   * @inheritdoc IBridgeSlash\n   */\n  function getSlashTier(uint256 ballot, uint256 totalVote) external pure returns (Tier tier) {\n    tier = _getSlashTier(ballot, totalVote);\n  }\n\n  /**\n   * @dev Checks if the slash duration exceeds the threshold for removal and handles it accordingly.\n   * @param slashUntilPeriod The slash until period number.\n   * @param period The current period.\n   * @return met A boolean indicates that the threshold for removal is met.\n   */\n  function _isSlashDurationMetRemovalThreshold(\n    uint256 slashUntilPeriod,\n    uint256 period\n  ) internal pure returns (bool met) {\n    met = slashUntilPeriod - (period - 1) >= REMOVE_DURATION_THRESHOLD;\n  }\n\n  /**\n   * @dev Calculates the slash until period based on the specified tier, current period, and slash until period.\n   * @param tier The slash tier representing the severity of the slash.\n   * @param period The current period in which the calculation is performed.\n   * @param slashUntilPeriod The existing slash until period.\n   * @param penaltyDurations An array of penalty durations for each slash tier.\n   * @return newSlashUntilPeriod The newly calculated slash until period.\n   */\n  function _calcSlashUntilPeriod(\n    Tier tier,\n    uint256 period,\n    uint256 slashUntilPeriod,\n    uint256[] memory penaltyDurations\n  ) internal pure returns (uint256 newSlashUntilPeriod) {\n    // Calculate the slash until period number.\n    newSlashUntilPeriod = penaltyDurations[uint8(tier)] + Math.max(period - 1, slashUntilPeriod);\n  }\n\n  /**\n   * @dev Internal function to determine the slashing tier based on the given ballot count and total votes.\n   * @param ballot The individual ballot count of a bridge operator.\n   * @param totalVote The total number of votes recorded for the bridge operator.\n   * @return tier The calculated slashing tier for the bridge operator.\n   * @notice The `ratio` is calculated as the percentage of uncast votes (totalVote - ballot) relative to the total votes.\n   */\n  function _getSlashTier(uint256 ballot, uint256 totalVote) internal pure virtual returns (Tier tier) {\n    uint256 ratio = ((totalVote - ballot) * PERCENTAGE_FRACTION) / totalVote;\n    tier = ratio > TIER_2_THRESHOLD ? Tier.Tier2 : ratio > TIER_1_THRESHOLD ? Tier.Tier1 : Tier.Tier0;\n  }\n\n  /**\n   * @dev Internal function to access the mapping from bridge operator => BridgeSlashInfo.\n   * @return bridgeSlashInfos the mapping from bridge operator => BridgeSlashInfo.\n   */\n  function _getBridgeSlashInfos() internal pure returns (mapping(address => BridgeSlashInfo) storage bridgeSlashInfos) {\n    assembly (\"memory-safe\") {\n      bridgeSlashInfos.slot := BRIDGE_SLASH_INFOS_SLOT\n    }\n  }\n\n  /**\n   * @dev Internal function to retrieve the penalty durations for each slashing tier.\n   * @return penaltyDurations An array containing the penalty durations for Tier0, Tier1, and Tier2 in that order.\n   */\n  function _getPenaltyDurations() internal pure virtual returns (uint256[] memory penaltyDurations) {\n    // reserve index 0\n    penaltyDurations = new uint256[](3);\n    penaltyDurations[uint8(Tier.Tier1)] = TIER_1_PENALTY_DURATION;\n    penaltyDurations[uint8(Tier.Tier2)] = TIER_2_PENALTY_DURATION;\n  }\n}\n"
    },
    "contracts/ronin/gateway/BridgeTracking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../interfaces/bridge/IBridgeTracking.sol\";\nimport { IBridgeManager } from \"../../interfaces/bridge/IBridgeManager.sol\";\nimport { IBridgeSlash } from \"../../interfaces/bridge/IBridgeSlash.sol\";\nimport { IBridgeReward } from \"../../interfaces/bridge/IBridgeReward.sol\";\nimport { IRoninValidatorSet } from \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport { HasBridgeDeprecated, HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\ncontract BridgeTracking is HasBridgeDeprecated, HasValidatorDeprecated, HasContracts, Initializable, IBridgeTracking {\n  struct PeriodVotingMetric {\n    /// @dev Total requests that are tracked in the period. This value is 0 until the {_bufferMetric.requests[]} gets added into a period metric.\n    uint256 totalRequest;\n    uint256 totalBallot;\n    mapping(address => uint256) totalBallotOf;\n    address[] voters;\n  }\n\n  struct PeriodVotingMetricTimeWrapper {\n    uint256 lastEpoch;\n    Request[] requests;\n    PeriodVotingMetric data;\n  }\n\n  struct ReceiptTrackingInfo {\n    /// @dev The period that the receipt is approved. Value 0 means the receipt is not approved yet.\n    uint256 approvedPeriod;\n    /// @dev The address list of voters\n    address[] voters;\n    /// @dev Mapping from voter => flag indicating the voter casts vote for this receipt\n    mapping(address => bool) voted;\n    /// @dev The period that the receipt is tracked, i.e. the metric is transferred from buffer to the period. Value 0 means the receipt is currently in buffer or not tracked yet.\n    uint256 trackedPeriod;\n  }\n\n  /// @dev The block that the contract allows incoming mutable calls.\n  uint256 internal _startedAtBlock;\n\n  /// @dev The temporary info of votes and ballots\n  PeriodVotingMetricTimeWrapper internal _bufferMetric;\n  /// @dev Mapping from period number => vote stats based on period\n  mapping(uint256 => PeriodVotingMetric) internal _periodMetric;\n  /// @dev Mapping from vote kind => receipt id => receipt stats\n  mapping(VoteKind => mapping(uint256 => ReceiptTrackingInfo)) internal _receiptTrackingInfo;\n  /// @dev The latest period that get synced with bridge's slashing and rewarding contract\n  uint256 internal _lastSyncPeriod;\n\n  modifier skipOnNotStarted() {\n    _skipOnNotStarted();\n    _;\n  }\n\n  /**\n   * @dev Returns the whole transaction in case the current block is less than start block.\n   */\n  function _skipOnNotStarted() private view {\n    if (block.number < _startedAtBlock) {\n      assembly {\n        return(0, 0)\n      }\n    }\n  }\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(address bridgeContract, address validatorContract, uint256 startedAtBlock_) external initializer {\n    _setContract(ContractType.BRIDGE, bridgeContract);\n    _setContract(ContractType.VALIDATOR, validatorContract);\n    _startedAtBlock = startedAtBlock_;\n  }\n\n  function initializeV2() external reinitializer(2) {\n    _setContract(ContractType.BRIDGE, ______deprecatedBridge);\n    _setContract(ContractType.VALIDATOR, ______deprecatedValidator);\n\n    delete ______deprecatedBridge;\n    delete ______deprecatedValidator;\n  }\n\n  function initializeV3(\n    address bridgeManager,\n    address bridgeSlash,\n    address bridgeReward,\n    address dposGA\n  ) external reinitializer(3) {\n    _setContract(ContractType.BRIDGE_MANAGER, bridgeManager);\n    _setContract(ContractType.BRIDGE_SLASH, bridgeSlash);\n    _setContract(ContractType.BRIDGE_REWARD, bridgeReward);\n    _setContract(ContractType.GOVERNANCE_ADMIN, dposGA);\n    _lastSyncPeriod = type(uint256).max;\n  }\n\n  /**\n   * @dev Helper for running upgrade script, required to only revoked once by the DPoS's governance admin.\n   * The following must be assured after initializing REP2:\n   * `_lastSyncPeriod`\n   *    == `{BridgeReward}.latestRewardedPeriod + 1`\n   *    == `{BridgeSlash}._startedAtPeriod - 1`\n   *    == `currentPeriod()`\n   */\n  function initializeREP2() external onlyContract(ContractType.GOVERNANCE_ADMIN) {\n    require(_lastSyncPeriod == type(uint256).max, \"already init rep 2\");\n    _lastSyncPeriod = IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod();\n    _setContract(ContractType.GOVERNANCE_ADMIN, address(0));\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function startedAtBlock() external view override returns (uint256) {\n    return _startedAtBlock;\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function totalVote(uint256 period) public view override returns (uint256 totalVote_) {\n    totalVote_ = _periodMetric[period].totalRequest;\n    if (_isBufferCountedForPeriod(period)) {\n      totalVote_ += _bufferMetric.requests.length;\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function totalBallot(uint256 period) public view override returns (uint256 totalBallot_) {\n    totalBallot_ = _periodMetric[period].totalBallot;\n    if (_isBufferCountedForPeriod(period)) {\n      totalBallot_ += _bufferMetric.data.totalBallot;\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function getManyTotalBallots(\n    uint256 period,\n    address[] calldata operators\n  ) external view override returns (uint256[] memory _res) {\n    _res = _getManyTotalBallots(period, operators);\n  }\n\n  function _getManyTotalBallots(\n    uint256 period,\n    address[] memory operators\n  ) internal view returns (uint256[] memory res) {\n    uint256 length = operators.length;\n    res = new uint256[](length);\n    bool isBufferCounted = _isBufferCountedForPeriod(period);\n    for (uint i = 0; i < length; ) {\n      res[i] = _totalBallotOf(period, operators[i], isBufferCounted);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function totalBallotOf(uint256 period, address bridgeOperator) public view override returns (uint256) {\n    return _totalBallotOf(period, bridgeOperator, _isBufferCountedForPeriod(period));\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function handleVoteApproved(\n    VoteKind kind,\n    uint256 requestId\n  ) external override onlyContract(ContractType.BRIDGE) skipOnNotStarted {\n    ReceiptTrackingInfo storage _receiptInfo = _receiptTrackingInfo[kind][requestId];\n\n    // Only records for the receipt which not approved\n    if (_receiptInfo.approvedPeriod == 0) {\n      _trySyncBuffer();\n      uint256 currentPeriod = IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod();\n      _receiptInfo.approvedPeriod = currentPeriod;\n\n      Request storage _bufferRequest = _bufferMetric.requests.push();\n      _bufferRequest.kind = kind;\n      _bufferRequest.id = requestId;\n\n      address[] storage _voters = _receiptInfo.voters;\n      for (uint i = 0; i < _voters.length; ) {\n        _increaseBallot(kind, requestId, _voters[i], currentPeriod);\n\n        unchecked {\n          ++i;\n        }\n      }\n\n      delete _receiptInfo.voters;\n    }\n  }\n\n  /**\n   * @inheritdoc IBridgeTracking\n   */\n  function recordVote(\n    VoteKind kind,\n    uint256 requestId,\n    address operator\n  ) external override onlyContract(ContractType.BRIDGE) skipOnNotStarted {\n    uint256 period = IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod();\n    _trySyncBuffer();\n    ReceiptTrackingInfo storage _receiptInfo = _receiptTrackingInfo[kind][requestId];\n\n    // When the vote is not approved yet, the voters are saved in the receipt info, and not increase ballot metric.\n    // The ballot metric will be increased later in the {handleVoteApproved} method.\n    if (_receiptInfo.approvedPeriod == 0) {\n      _receiptInfo.voters.push(operator);\n      return;\n    }\n\n    _increaseBallot(kind, requestId, operator, period);\n\n    uint256 lastSyncPeriod = _lastSyncPeriod;\n    // When switching to new period, wrap up vote info, then slash and distribute reward accordingly.\n    if (lastSyncPeriod < period) {\n      _lastSyncPeriod = period;\n\n      address[] memory allOperators = IBridgeManager(getContract(ContractType.BRIDGE_MANAGER)).getBridgeOperators();\n      uint256[] memory ballots = _getManyTotalBallots(lastSyncPeriod, allOperators);\n\n      uint256 totalVote_ = totalVote(lastSyncPeriod);\n      uint256 totalBallot_ = totalBallot(lastSyncPeriod);\n\n      address bridgeSlashContract = getContract(ContractType.BRIDGE_SLASH);\n      (bool success, bytes memory returnOrRevertData) = bridgeSlashContract.call(\n        abi.encodeCall(\n          IBridgeSlash.execSlashBridgeOperators,\n          (allOperators, ballots, totalBallot_, totalVote_, lastSyncPeriod)\n        )\n      );\n      if (!success) {\n        emit ExternalCallFailed(\n          bridgeSlashContract,\n          IBridgeSlash.execSlashBridgeOperators.selector,\n          returnOrRevertData\n        );\n      }\n\n      address bridgeRewardContract = getContract(ContractType.BRIDGE_REWARD);\n      (success, returnOrRevertData) = bridgeRewardContract.call(\n        abi.encodeCall(IBridgeReward.execSyncReward, (allOperators, ballots, totalBallot_, totalVote_, lastSyncPeriod))\n      );\n      if (!success) {\n        emit ExternalCallFailed(bridgeRewardContract, IBridgeReward.execSyncReward.selector, returnOrRevertData);\n      }\n    }\n  }\n\n  /**\n   * @dev Increases the ballot for the operator at a period.\n   */\n  function _increaseBallot(VoteKind kind, uint256 requestId, address operator, uint256 currentPeriod) internal {\n    ReceiptTrackingInfo storage _receiptInfo = _receiptTrackingInfo[kind][requestId];\n    if (_receiptInfo.voted[operator]) {\n      return;\n    }\n\n    _receiptInfo.voted[operator] = true;\n\n    uint256 trackedPeriod = _receiptInfo.trackedPeriod;\n\n    // Do not increase ballot for receipt that is neither in the buffer, nor in the most current tracked period.\n    // If the receipt is not tracked in a period, increase metric in buffer.\n    unchecked {\n      if (trackedPeriod == 0) {\n        if (_bufferMetric.data.totalBallotOf[operator] == 0) {\n          _bufferMetric.data.voters.push(operator);\n        }\n        _bufferMetric.data.totalBallot++;\n        _bufferMetric.data.totalBallotOf[operator]++;\n      }\n      // If the receipt is tracked in the most current tracked period, increase metric in the period.\n      else if (trackedPeriod == currentPeriod) {\n        PeriodVotingMetric storage _metric = _periodMetric[trackedPeriod];\n        _metric.totalBallot++;\n        _metric.totalBallotOf[operator]++;\n      }\n    }\n  }\n\n  /**\n   * @dev See `totalBallotOf`.\n   */\n  function _totalBallotOf(\n    uint256 period,\n    address operator,\n    bool mustCountLastStats\n  ) internal view returns (uint256 _totalBallot) {\n    _totalBallot = _periodMetric[period].totalBallotOf[operator];\n    if (mustCountLastStats) {\n      _totalBallot += _bufferMetric.data.totalBallotOf[operator];\n    }\n  }\n\n  /**\n   * @dev Syncs period stats. Move all data from the buffer metric to the period metric.\n   *\n   * Requirements:\n   * - The epoch after the buffer epoch is wrapped up.\n   */\n  function _trySyncBuffer() internal {\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    uint256 currentEpoch = validatorContract.epochOf(block.number);\n    if (_bufferMetric.lastEpoch < currentEpoch) {\n      (, uint256 trackedPeriod) = validatorContract.tryGetPeriodOfEpoch(_bufferMetric.lastEpoch + 1);\n      _bufferMetric.lastEpoch = currentEpoch;\n\n      // Copy numbers of totals\n      PeriodVotingMetric storage _metric = _periodMetric[trackedPeriod];\n      _metric.totalRequest += _bufferMetric.requests.length;\n      _metric.totalBallot += _bufferMetric.data.totalBallot;\n\n      // Copy voters info and voters' ballot\n      for (uint i = 0; i < _bufferMetric.data.voters.length; ) {\n        address voter = _bufferMetric.data.voters[i];\n        _metric.totalBallotOf[voter] += _bufferMetric.data.totalBallotOf[voter];\n        delete _bufferMetric.data.totalBallotOf[voter]; // need to manually delete each element, due to mapping\n\n        unchecked {\n          ++i;\n        }\n      }\n\n      // Mark all receipts in the buffer as tracked. Keep total number of receipts and delete receipt details.\n      for (uint i = 0; i < _bufferMetric.requests.length; ) {\n        Request storage _bufferRequest = _bufferMetric.requests[i];\n        ReceiptTrackingInfo storage _receiptInfo = _receiptTrackingInfo[_bufferRequest.kind][_bufferRequest.id];\n        _receiptInfo.trackedPeriod = trackedPeriod;\n\n        unchecked {\n          ++i;\n        }\n      }\n\n      delete _bufferMetric.requests;\n      delete _bufferMetric.data;\n    }\n  }\n\n  /**\n   * @dev Returns whether the buffer stats must be counted or not.\n   */\n  function _isBufferCountedForPeriod(uint256 queriedPeriod) internal view returns (bool) {\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    uint256 currentEpoch = validatorContract.epochOf(block.number);\n    (bool filled, uint256 periodOfNextTemporaryEpoch) = validatorContract.tryGetPeriodOfEpoch(\n      _bufferMetric.lastEpoch + 1\n    );\n    return filled && queriedPeriod == periodOfNextTemporaryEpoch && _bufferMetric.lastEpoch < currentEpoch;\n  }\n}\n"
    },
    "contracts/ronin/gateway/RoninGatewayV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../extensions/GatewayV3.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/MinimumWithdrawal.sol\";\nimport \"../../interfaces/IERC20Mintable.sol\";\nimport \"../../interfaces/IERC721Mintable.sol\";\nimport \"../../interfaces/bridge/IBridgeTracking.sol\";\nimport \"../../interfaces/IRoninGatewayV3.sol\";\nimport \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../interfaces/consumers/VoteStatusConsumer.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../libraries/IsolatedGovernance.sol\";\nimport \"../../interfaces/bridge/IBridgeManager.sol\";\n\ncontract RoninGatewayV3 is\n  GatewayV3,\n  Initializable,\n  MinimumWithdrawal,\n  AccessControlEnumerable,\n  VoteStatusConsumer,\n  IRoninGatewayV3,\n  HasContracts\n{\n  using Token for Token.Info;\n  using Transfer for Transfer.Request;\n  using Transfer for Transfer.Receipt;\n  using IsolatedGovernance for IsolatedGovernance.Vote;\n\n  /// @custom:deprecated Previously `withdrawalMigrated` (non-zero value)\n  bool private ___deprecated4;\n  /// @dev Total withdrawal\n  uint256 public withdrawalCount;\n  /// @dev Mapping from chain id => deposit id => deposit vote\n  mapping(uint256 => mapping(uint256 => IsolatedGovernance.Vote)) public depositVote;\n  /// @dev Mapping from withdrawal id => mainchain withdrew vote\n  mapping(uint256 => IsolatedGovernance.Vote) public mainchainWithdrewVote;\n  /// @dev Mapping from withdrawal id => withdrawal receipt\n  mapping(uint256 => Transfer.Receipt) public withdrawal;\n  /// @dev Mapping from withdrawal id => validator address => signatures\n  mapping(uint256 => mapping(address => bytes)) internal _withdrawalSig;\n  /// @dev Mapping from token address => chain id => mainchain token address\n  mapping(address => mapping(uint256 => MappedToken)) internal _mainchainToken;\n\n  /// @custom:deprecated Previously `_validatorContract` (non-zero value)\n  address private ____deprecated0;\n  /// @custom:deprecated Previously `_bridgeTrackingContract` (non-zero value)\n  address private ____deprecated1;\n\n  /// @dev Mapping from withdrawal id => vote for recording withdrawal stats\n  mapping(uint256 => IsolatedGovernance.Vote) public withdrawalStatVote;\n\n  /// @custom:deprecated Previously `_trustedOrgContract` (non-zero value)\n  address private ____deprecated2;\n\n  uint256 internal _trustedNum;\n  uint256 internal _trustedDenom;\n\n  fallback() external payable {\n    _fallback();\n  }\n\n  receive() external payable {\n    _fallback();\n  }\n\n  modifier onlyBridgeOperator() {\n    _requireBridgeOperator();\n    _;\n  }\n\n  /**\n   * @dev Reverts if the method caller is not bridge operator.\n   */\n  function _requireBridgeOperator() internal view {\n    if (!IBridgeManager(getContract(ContractType.BRIDGE_MANAGER)).isBridgeOperator(msg.sender))\n      revert ErrUnauthorized(msg.sig, RoleAccess.__DEPRECATED_BRIDGE_OPERATOR);\n  }\n\n  /**\n   * @dev Initializes contract storage.\n   */\n  function initialize(\n    address _roleSetter,\n    uint256 _numerator,\n    uint256 _denominator,\n    uint256 _trustedNumerator,\n    uint256 _trustedDenominator,\n    address[] calldata /* _withdrawalMigrators */,\n    // _packedAddresses[0]: roninTokens\n    // _packedAddresses[1]: mainchainTokens\n    address[][2] calldata _packedAddresses,\n    // _packedNumbers[0]: chainIds\n    // _packedNumbers[1]: minimumThresholds\n    uint256[][2] calldata _packedNumbers,\n    Token.Standard[] calldata _standards\n  ) external virtual initializer {\n    _setupRole(DEFAULT_ADMIN_ROLE, _roleSetter);\n    _setThreshold(_numerator, _denominator);\n    _setTrustedThreshold(_trustedNumerator, _trustedDenominator);\n    if (_packedAddresses[0].length > 0) {\n      _mapTokens(_packedAddresses[0], _packedAddresses[1], _packedNumbers[0], _standards);\n      _setMinimumThresholds(_packedAddresses[0], _packedNumbers[1]);\n    }\n  }\n\n  function initializeV2() external reinitializer(2) {\n    _setContract(ContractType.VALIDATOR, ____deprecated0);\n    _setContract(ContractType.BRIDGE_TRACKING, ____deprecated1);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, ____deprecated2);\n    delete ____deprecated0;\n    delete ____deprecated1;\n    delete ____deprecated2;\n  }\n\n  function initializeV3(address bridgeAdmin) external reinitializer(3) {\n    _setContract(ContractType.BRIDGE_MANAGER, bridgeAdmin);\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function getWithdrawalSignatures(\n    uint256 withdrawalId,\n    address[] calldata operators\n  ) external view returns (bytes[] memory _signatures) {\n    _signatures = new bytes[](operators.length);\n    for (uint256 _i = 0; _i < operators.length; ) {\n      _signatures[_i] = _withdrawalSig[withdrawalId][operators[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function depositFor(Transfer.Receipt calldata _receipt) external whenNotPaused onlyBridgeOperator {\n    address _sender = msg.sender;\n    _depositFor(_receipt, _sender, minimumVoteWeight());\n    IBridgeTracking(getContract(ContractType.BRIDGE_TRACKING)).recordVote(\n      IBridgeTracking.VoteKind.Deposit,\n      _receipt.id,\n      _sender\n    );\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function tryBulkAcknowledgeMainchainWithdrew(\n    uint256[] calldata _withdrawalIds\n  ) external onlyBridgeOperator returns (bool[] memory _executedReceipts) {\n    address _governor = msg.sender;\n    uint256 _minVoteWeight = minimumVoteWeight();\n\n    uint256 _withdrawalId;\n    _executedReceipts = new bool[](_withdrawalIds.length);\n    IBridgeTracking _bridgeTrackingContract = IBridgeTracking(getContract(ContractType.BRIDGE_TRACKING));\n    for (uint256 _i; _i < _withdrawalIds.length; ) {\n      _withdrawalId = _withdrawalIds[_i];\n      _bridgeTrackingContract.recordVote(IBridgeTracking.VoteKind.MainchainWithdrawal, _withdrawalId, _governor);\n      if (mainchainWithdrew(_withdrawalId)) {\n        _executedReceipts[_i] = true;\n      } else {\n        IsolatedGovernance.Vote storage _vote = mainchainWithdrewVote[_withdrawalId];\n        Transfer.Receipt memory _withdrawal = withdrawal[_withdrawalId];\n        bytes32 _hash = _withdrawal.hash();\n        VoteStatus _status = _castIsolatedVote(_vote, _governor, _minVoteWeight, _hash);\n        if (_status == VoteStatus.Approved) {\n          _vote.status = VoteStatus.Executed;\n          _bridgeTrackingContract.handleVoteApproved(IBridgeTracking.VoteKind.MainchainWithdrawal, _withdrawalId);\n          emit MainchainWithdrew(_hash, _withdrawal);\n        }\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function tryBulkDepositFor(\n    Transfer.Receipt[] calldata _receipts\n  ) external whenNotPaused onlyBridgeOperator returns (bool[] memory _executedReceipts) {\n    address _sender = msg.sender;\n\n    Transfer.Receipt memory _receipt;\n    _executedReceipts = new bool[](_receipts.length);\n    uint256 _minVoteWeight = minimumVoteWeight();\n    IBridgeTracking _bridgeTrackingContract = IBridgeTracking(getContract(ContractType.BRIDGE_TRACKING));\n    for (uint256 _i; _i < _receipts.length; ) {\n      _receipt = _receipts[_i];\n      _bridgeTrackingContract.recordVote(IBridgeTracking.VoteKind.Deposit, _receipt.id, _sender);\n      if (depositVote[_receipt.mainchain.chainId][_receipt.id].status == VoteStatus.Executed) {\n        _executedReceipts[_i] = true;\n      } else {\n        _depositFor(_receipt, _sender, _minVoteWeight);\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function requestWithdrawalFor(Transfer.Request calldata _request, uint256 _chainId) external whenNotPaused {\n    _requestWithdrawalFor(_request, msg.sender, _chainId);\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function bulkRequestWithdrawalFor(Transfer.Request[] calldata _requests, uint256 _chainId) external whenNotPaused {\n    if (_requests.length == 0) revert ErrEmptyArray();\n\n    for (uint256 _i; _i < _requests.length; ) {\n      _requestWithdrawalFor(_requests[_i], msg.sender, _chainId);\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function requestWithdrawalSignatures(uint256 _withdrawalId) external whenNotPaused {\n    if (mainchainWithdrew(_withdrawalId)) revert ErrWithdrawnOnMainchainAlready();\n\n    Transfer.Receipt memory _receipt = withdrawal[_withdrawalId];\n    if (_receipt.ronin.chainId != block.chainid) {\n      revert ErrInvalidChainId(msg.sig, _receipt.ronin.chainId, block.chainid);\n    }\n\n    emit WithdrawalSignaturesRequested(_receipt.hash(), _receipt);\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function bulkSubmitWithdrawalSignatures(\n    uint256[] calldata withdrawals,\n    bytes[] calldata signatures\n  ) external whenNotPaused onlyBridgeOperator {\n    address operator = msg.sender;\n\n    if (!(withdrawals.length > 0 && withdrawals.length == signatures.length)) {\n      revert ErrLengthMismatch(msg.sig);\n    }\n\n    uint256 _minVoteWeight = minimumVoteWeight();\n\n    uint256 id;\n    IBridgeTracking _bridgeTrackingContract = IBridgeTracking(getContract(ContractType.BRIDGE_TRACKING));\n    for (uint256 _i; _i < withdrawals.length; ) {\n      id = withdrawals[_i];\n      _withdrawalSig[id][operator] = signatures[_i];\n      _bridgeTrackingContract.recordVote(IBridgeTracking.VoteKind.Withdrawal, id, operator);\n\n      IsolatedGovernance.Vote storage _proposal = withdrawalStatVote[id];\n      VoteStatus _status = _castIsolatedVote(_proposal, operator, _minVoteWeight, bytes32(id));\n      if (_status == VoteStatus.Approved) {\n        _proposal.status = VoteStatus.Executed;\n        _bridgeTrackingContract.handleVoteApproved(IBridgeTracking.VoteKind.Withdrawal, id);\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function mapTokens(\n    address[] calldata _roninTokens,\n    address[] calldata _mainchainTokens,\n    uint256[] calldata _chainIds,\n    Token.Standard[] calldata _standards\n  ) external onlyAdmin {\n    if (_roninTokens.length == 0) revert ErrLengthMismatch(msg.sig);\n    _mapTokens(_roninTokens, _mainchainTokens, _chainIds, _standards);\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function depositVoted(uint256 _chainId, uint256 _depositId, address _voter) external view returns (bool) {\n    return depositVote[_chainId][_depositId].voted(_voter);\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function mainchainWithdrewVoted(uint256 _withdrawalId, address _voter) external view returns (bool) {\n    return mainchainWithdrewVote[_withdrawalId].voted(_voter);\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function mainchainWithdrew(uint256 _withdrawalId) public view returns (bool) {\n    return mainchainWithdrewVote[_withdrawalId].status == VoteStatus.Executed;\n  }\n\n  /**\n   * @inheritdoc IRoninGatewayV3\n   */\n  function getMainchainToken(address _roninToken, uint256 _chainId) public view returns (MappedToken memory _token) {\n    _token = _mainchainToken[_roninToken][_chainId];\n    if (_token.tokenAddr == address(0)) revert ErrUnsupportedToken();\n  }\n\n  /**\n   * @dev Maps Ronin tokens to mainchain networks.\n   *\n   * Requirement:\n   * - The arrays have the same length.\n   *\n   * Emits the `TokenMapped` event.\n   *\n   */\n  function _mapTokens(\n    address[] calldata _roninTokens,\n    address[] calldata _mainchainTokens,\n    uint256[] calldata _chainIds,\n    Token.Standard[] calldata _standards\n  ) internal {\n    if (!(_roninTokens.length == _mainchainTokens.length && _roninTokens.length == _chainIds.length))\n      revert ErrLengthMismatch(msg.sig);\n\n    for (uint256 _i; _i < _roninTokens.length; ) {\n      _mainchainToken[_roninTokens[_i]][_chainIds[_i]].tokenAddr = _mainchainTokens[_i];\n      _mainchainToken[_roninTokens[_i]][_chainIds[_i]].erc = _standards[_i];\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    emit TokenMapped(_roninTokens, _mainchainTokens, _chainIds, _standards);\n  }\n\n  /**\n   * @dev Deposits based on the receipt.\n   *\n   * Emits the `Deposited` once the assets are released.\n   *\n   */\n  function _depositFor(Transfer.Receipt memory receipt, address operator, uint256 minVoteWeight) internal {\n    uint256 id = receipt.id;\n    receipt.info.validate();\n    if (receipt.kind != Transfer.Kind.Deposit) revert ErrInvalidReceiptKind();\n\n    if (receipt.ronin.chainId != block.chainid) revert ErrInvalidChainId(msg.sig, receipt.ronin.chainId, block.chainid);\n\n    MappedToken memory _token = getMainchainToken(receipt.ronin.tokenAddr, receipt.mainchain.chainId);\n\n    if (!(_token.erc == receipt.info.erc && _token.tokenAddr == receipt.mainchain.tokenAddr))\n      revert ErrInvalidReceipt();\n\n    IsolatedGovernance.Vote storage _proposal = depositVote[receipt.mainchain.chainId][id];\n    bytes32 _receiptHash = receipt.hash();\n    VoteStatus _status = _castIsolatedVote(_proposal, operator, minVoteWeight, _receiptHash);\n    emit DepositVoted(operator, id, receipt.mainchain.chainId, _receiptHash);\n    if (_status == VoteStatus.Approved) {\n      _proposal.status = VoteStatus.Executed;\n      receipt.info.handleAssetTransfer(payable(receipt.ronin.addr), receipt.ronin.tokenAddr, IWETH(address(0)));\n      IBridgeTracking(getContract(ContractType.BRIDGE_TRACKING)).handleVoteApproved(\n        IBridgeTracking.VoteKind.Deposit,\n        receipt.id\n      );\n      emit Deposited(_receiptHash, receipt);\n    }\n  }\n\n  /**\n   * @dev Locks the assets and request withdrawal.\n   *\n   * Requirements:\n   * - The token info is valid.\n   *\n   * Emits the `WithdrawalRequested` event.\n   *\n   */\n  function _requestWithdrawalFor(Transfer.Request calldata _request, address _requester, uint256 _chainId) internal {\n    _request.info.validate();\n    _checkWithdrawal(_request);\n    MappedToken memory _token = getMainchainToken(_request.tokenAddr, _chainId);\n    if (_request.info.erc != _token.erc) revert ErrInvalidTokenStandard();\n\n    _request.info.transferFrom(_requester, address(this), _request.tokenAddr);\n    _storeAsReceipt(_request, _chainId, _requester, _token.tokenAddr);\n  }\n\n  /**\n   * @dev Stores the withdrawal request as a receipt.\n   *\n   * Emits the `WithdrawalRequested` event.\n   *\n   */\n  function _storeAsReceipt(\n    Transfer.Request calldata _request,\n    uint256 _chainId,\n    address _requester,\n    address _mainchainTokenAddr\n  ) internal returns (uint256 _withdrawalId) {\n    _withdrawalId = withdrawalCount++;\n    Transfer.Receipt memory _receipt = _request.into_withdrawal_receipt(\n      _requester,\n      _withdrawalId,\n      _mainchainTokenAddr,\n      _chainId\n    );\n    withdrawal[_withdrawalId] = _receipt;\n    emit WithdrawalRequested(_receipt.hash(), _receipt);\n  }\n\n  /**\n   * @dev Don't send me RON.\n   */\n  function _fallback() internal virtual {\n    revert ErrInvalidRequest();\n  }\n\n  /**\n   * @inheritdoc GatewayV3\n   */\n  function _getTotalWeight() internal view virtual override returns (uint256) {\n    return IBridgeManager(getContract(ContractType.BRIDGE_MANAGER)).getTotalWeight();\n  }\n\n  /**\n   * @dev Casts and updates the vote result.\n   *\n   * Requirements:\n   * - The vote is not finalized.\n   * - The voter has not voted for the round.\n   *\n   */\n  function _castIsolatedVote(\n    IsolatedGovernance.Vote storage _v,\n    address _voter,\n    uint256 _minVoteWeight,\n    bytes32 _hash\n  ) internal virtual returns (VoteStatus _status) {\n    _v.castVote(_voter, _hash);\n    uint256 _totalWeight = _getVoteWeight(_v, _hash);\n    return _v.syncVoteStatus(_minVoteWeight, _totalWeight, _hash);\n  }\n\n  /**\n   * @dev Returns the vote weight for a specified hash.\n   */\n  function _getVoteWeight(\n    IsolatedGovernance.Vote storage _v,\n    bytes32 _hash\n  ) internal view returns (uint256 _totalWeight) {\n    (, address[] memory bridgeOperators, uint96[] memory weights) = IBridgeManager(\n      getContract(ContractType.BRIDGE_MANAGER)\n    ).getFullBridgeOperatorInfos();\n    uint256 length = bridgeOperators.length;\n    unchecked {\n      for (uint _i; _i < length; ++_i) {\n        if (_v.voteHashOf[bridgeOperators[_i]] == _hash) {\n          _totalWeight += weights[_i];\n        }\n      }\n    }\n  }\n\n  function setTrustedThreshold(\n    uint256 _trustedNumerator,\n    uint256 _trustedDenominator\n  ) external virtual onlyAdmin returns (uint256, uint256) {\n    return _setTrustedThreshold(_trustedNumerator, _trustedDenominator);\n  }\n\n  /**\n   * @dev Returns the threshold about trusted org.\n   */\n  function getTrustedThreshold() external view virtual returns (uint256 trustedNum_, uint256 trustedDenom_) {\n    return (_trustedNum, _trustedDenom);\n  }\n\n  /**\n   * @dev Sets trusted threshold and returns the old one.\n   *\n   * Emits the `TrustedThresholdUpdated` event.\n   *\n   */\n  function _setTrustedThreshold(\n    uint256 _trustedNumerator,\n    uint256 _trustedDenominator\n  ) internal virtual returns (uint256 _previousTrustedNum, uint256 _previousTrustedDenom) {\n    if (_trustedNumerator > _trustedDenominator) revert ErrInvalidTrustedThreshold();\n\n    _previousTrustedNum = _num;\n    _previousTrustedDenom = _denom;\n    _trustedNum = _trustedNumerator;\n    _trustedDenom = _trustedDenominator;\n    unchecked {\n      emit TrustedThresholdUpdated(\n        nonce++,\n        _trustedNumerator,\n        _trustedDenominator,\n        _previousTrustedNum,\n        _previousTrustedDenom\n      );\n    }\n  }\n\n  /**\n   * @dev Returns minimum trusted vote weight.\n   */\n  function _minimumTrustedVoteWeight(uint256 _totalTrustedWeight) internal view virtual returns (uint256) {\n    return (_trustedNum * _totalTrustedWeight + _trustedDenom - 1) / _trustedDenom;\n  }\n}\n"
    },
    "contracts/ronin/Maintenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IMaintenance.sol\";\nimport \"../interfaces/IProfile.sol\";\nimport \"../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../extensions/collections/HasContracts.sol\";\nimport \"../libraries/Math.sol\";\nimport { HasValidatorDeprecated } from \"../utils/DeprecatedSlots.sol\";\nimport { ErrUnauthorized, RoleAccess } from \"../utils/CommonErrors.sol\";\n\ncontract Maintenance is IMaintenance, HasContracts, HasValidatorDeprecated, Initializable {\n  using Math for uint256;\n\n  /// @dev Mapping from candidate id => maintenance schedule.\n  mapping(address => Schedule) internal _schedule;\n\n  /// @dev The min duration to maintenance in blocks.\n  uint256 internal _minMaintenanceDurationInBlock;\n  /// @dev The max duration to maintenance in blocks.\n  uint256 internal _maxMaintenanceDurationInBlock;\n  /// @dev The offset to the min block number that the schedule can start.\n  uint256 internal _minOffsetToStartSchedule;\n  /// @dev The offset to the max block number that the schedule can start.\n  uint256 internal _maxOffsetToStartSchedule;\n  /// @dev The max number of scheduled maintenances.\n  uint256 internal _maxSchedule;\n  /// @dev The cooldown time to request new schedule.\n  uint256 internal _cooldownSecsToMaintain;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address validatorContract,\n    uint256 minMaintenanceDurationInBlock_,\n    uint256 maxMaintenanceDurationInBlock_,\n    uint256 minOffsetToStartSchedule_,\n    uint256 maxOffsetToStartSchedule_,\n    uint256 maxSchedule_,\n    uint256 cooldownSecsToMaintain_\n  ) external initializer {\n    _setContract(ContractType.VALIDATOR, validatorContract);\n    _setMaintenanceConfig(\n      minMaintenanceDurationInBlock_,\n      maxMaintenanceDurationInBlock_,\n      minOffsetToStartSchedule_,\n      maxOffsetToStartSchedule_,\n      maxSchedule_,\n      cooldownSecsToMaintain_\n    );\n  }\n\n  function initializeV2() external reinitializer(2) {\n    _setContract(ContractType.VALIDATOR, ______deprecatedValidator);\n    delete ______deprecatedValidator;\n  }\n\n  function initializeV3(address profileContract_) external reinitializer(3) {\n    _setContract(ContractType.PROFILE, profileContract_);\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function minMaintenanceDurationInBlock() external view returns (uint256) {\n    return _minMaintenanceDurationInBlock;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function maxMaintenanceDurationInBlock() external view returns (uint256) {\n    return _maxMaintenanceDurationInBlock;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function minOffsetToStartSchedule() external view returns (uint256) {\n    return _minOffsetToStartSchedule;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function maxOffsetToStartSchedule() external view returns (uint256) {\n    return _maxOffsetToStartSchedule;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function maxSchedule() external view returns (uint256) {\n    return _maxSchedule;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function cooldownSecsToMaintain() external view returns (uint256) {\n    return _cooldownSecsToMaintain;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function setMaintenanceConfig(\n    uint256 minMaintenanceDurationInBlock_,\n    uint256 maxMaintenanceDurationInBlock_,\n    uint256 minOffsetToStartSchedule_,\n    uint256 maxOffsetToStartSchedule_,\n    uint256 maxSchedule_,\n    uint256 cooldownSecsToMaintain_\n  ) external onlyAdmin {\n    _setMaintenanceConfig(\n      minMaintenanceDurationInBlock_,\n      maxMaintenanceDurationInBlock_,\n      minOffsetToStartSchedule_,\n      maxOffsetToStartSchedule_,\n      maxSchedule_,\n      cooldownSecsToMaintain_\n    );\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function schedule(TConsensus consensusAddr, uint256 startedAtBlock, uint256 endedAtBlock) external override {\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    address candidateId = __css2cid(consensusAddr);\n\n    if (!validatorContract.isBlockProducer(consensusAddr)) revert ErrUnauthorized(msg.sig, RoleAccess.BLOCK_PRODUCER);\n    if (!validatorContract.isCandidateAdmin(consensusAddr, msg.sender))\n      revert ErrUnauthorized(msg.sig, RoleAccess.CANDIDATE_ADMIN);\n    if (_checkScheduledById(candidateId)) revert ErrAlreadyScheduled();\n    if (!_checkCooldownEndedById(candidateId)) revert ErrCooldownTimeNotYetEnded();\n    if (totalSchedule() >= _maxSchedule) revert ErrTotalOfSchedulesExceeded();\n    if (!startedAtBlock.inRange(block.number + _minOffsetToStartSchedule, block.number + _maxOffsetToStartSchedule)) {\n      revert ErrStartBlockOutOfRange();\n    }\n    if (startedAtBlock >= endedAtBlock) revert ErrStartBlockOutOfRange();\n\n    uint256 maintenanceElapsed = endedAtBlock - startedAtBlock + 1;\n\n    if (!maintenanceElapsed.inRange(_minMaintenanceDurationInBlock, _maxMaintenanceDurationInBlock)) {\n      revert ErrInvalidMaintenanceDuration();\n    }\n    if (!validatorContract.epochEndingAt(startedAtBlock - 1)) revert ErrStartBlockOutOfRange();\n    if (!validatorContract.epochEndingAt(endedAtBlock)) revert ErrEndBlockOutOfRange();\n\n    Schedule storage _sSchedule = _schedule[candidateId];\n    _sSchedule.from = startedAtBlock;\n    _sSchedule.to = endedAtBlock;\n    _sSchedule.lastUpdatedBlock = block.number;\n    _sSchedule.requestTimestamp = block.timestamp;\n    emit MaintenanceScheduled(consensusAddr, _sSchedule);\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function cancelSchedule(TConsensus consensusAddr) external override {\n    if (!IRoninValidatorSet(getContract(ContractType.VALIDATOR)).isCandidateAdmin(consensusAddr, msg.sender)) {\n      revert ErrUnauthorized(msg.sig, RoleAccess.CANDIDATE_ADMIN);\n    }\n\n    address candidateId = __css2cid(consensusAddr);\n\n    if (!_checkScheduledById(candidateId)) revert ErrUnexistedSchedule();\n    if (_checkMaintainedById(candidateId, block.number)) revert ErrAlreadyOnMaintenance();\n\n    Schedule storage _sSchedule = _schedule[candidateId];\n    delete _sSchedule.from;\n    delete _sSchedule.to;\n    _sSchedule.lastUpdatedBlock = block.number;\n    emit MaintenanceScheduleCancelled(consensusAddr);\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function getSchedule(TConsensus consensusAddr) external view override returns (Schedule memory) {\n    return _schedule[__css2cid(consensusAddr)];\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkManyMaintained(\n    TConsensus[] calldata addrList,\n    uint256 atBlock\n  ) external view override returns (bool[] memory) {\n    address[] memory idList = __css2cidBatch(addrList);\n    return _checkManyMaintainedById(idList, atBlock);\n  }\n\n  function checkManyMaintainedById(\n    address[] calldata idList,\n    uint256 atBlock\n  ) external view override returns (bool[] memory) {\n    return _checkManyMaintainedById(idList, atBlock);\n  }\n\n  function _checkManyMaintainedById(\n    address[] memory idList,\n    uint256 atBlock\n  ) internal view returns (bool[] memory resList) {\n    resList = new bool[](idList.length);\n    for (uint i = 0; i < idList.length; ) {\n      resList[i] = _checkMaintainedById(idList[i], atBlock);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkManyMaintainedInBlockRange(\n    TConsensus[] calldata addrList,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) external view override returns (bool[] memory) {\n    address[] memory idList = __css2cidBatch(addrList);\n    return _checkManyMaintainedInBlockRangeById(idList, fromBlock, toBlock);\n  }\n\n  function checkManyMaintainedInBlockRangeById(\n    address[] calldata idList,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) external view override returns (bool[] memory) {\n    return _checkManyMaintainedInBlockRangeById(idList, fromBlock, toBlock);\n  }\n\n  function _checkManyMaintainedInBlockRangeById(\n    address[] memory idList,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) internal view returns (bool[] memory resList) {\n    resList = new bool[](idList.length);\n    for (uint i = 0; i < idList.length; ) {\n      resList[i] = _maintainingInBlockRange(idList[i], fromBlock, toBlock);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function totalSchedule() public view override returns (uint256 count) {\n    address[] memory validatorIds = IRoninValidatorSet(getContract(ContractType.VALIDATOR)).getValidators();\n    unchecked {\n      for (uint i = 0; i < validatorIds.length; i++) {\n        if (_checkScheduledById(validatorIds[i])) {\n          count++;\n        }\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkMaintained(TConsensus consensusAddr, uint256 atBlock) external view override returns (bool) {\n    return _checkMaintainedById(__css2cid(consensusAddr), atBlock);\n  }\n\n  function checkMaintainedById(address candidateId, uint256 atBlock) external view override returns (bool) {\n    return _checkMaintainedById(candidateId, atBlock);\n  }\n\n  function _checkMaintainedById(address candidateId, uint256 atBlock) internal view returns (bool) {\n    Schedule storage _s = _schedule[candidateId];\n    return _s.from <= atBlock && atBlock <= _s.to;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkMaintainedInBlockRange(\n    TConsensus consensusAddr,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) public view override returns (bool) {\n    return _maintainingInBlockRange(__css2cid(consensusAddr), fromBlock, toBlock);\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkScheduled(TConsensus consensusAddr) external view override returns (bool) {\n    return _checkScheduledById(__css2cid(consensusAddr));\n  }\n\n  function _checkScheduledById(address candidateId) internal view returns (bool) {\n    return block.number <= _schedule[candidateId].to;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkCooldownEnded(TConsensus consensusAddr) external view override returns (bool) {\n    return _checkCooldownEndedById(__css2cid(consensusAddr));\n  }\n\n  function _checkCooldownEndedById(address candidateId) internal view returns (bool) {\n    return block.timestamp > _schedule[candidateId].requestTimestamp + _cooldownSecsToMaintain;\n  }\n\n  /**\n   * @dev Sets the min block period and max block period to maintenance.\n   *\n   * Requirements:\n   * - The max period is larger than the min period.\n   *\n   * Emits the event `MaintenanceConfigUpdated`.\n   *\n   */\n  function _setMaintenanceConfig(\n    uint256 minMaintenanceDurationInBlock_,\n    uint256 maxMaintenanceDurationInBlock_,\n    uint256 minOffsetToStartSchedule_,\n    uint256 maxOffsetToStartSchedule_,\n    uint256 maxSchedule_,\n    uint256 cooldownSecsToMaintain_\n  ) internal {\n    if (minMaintenanceDurationInBlock_ >= maxMaintenanceDurationInBlock_) revert ErrInvalidMaintenanceDurationConfig();\n    if (minOffsetToStartSchedule_ >= maxOffsetToStartSchedule_) revert ErrInvalidOffsetToStartScheduleConfigs();\n\n    _minMaintenanceDurationInBlock = minMaintenanceDurationInBlock_;\n    _maxMaintenanceDurationInBlock = maxMaintenanceDurationInBlock_;\n    _minOffsetToStartSchedule = minOffsetToStartSchedule_;\n    _maxOffsetToStartSchedule = maxOffsetToStartSchedule_;\n    _maxSchedule = maxSchedule_;\n    _cooldownSecsToMaintain = cooldownSecsToMaintain_;\n    emit MaintenanceConfigUpdated(\n      minMaintenanceDurationInBlock_,\n      maxMaintenanceDurationInBlock_,\n      minOffsetToStartSchedule_,\n      maxOffsetToStartSchedule_,\n      maxSchedule_,\n      cooldownSecsToMaintain_\n    );\n  }\n\n  /**\n   * @dev Check if the validator was maintaining in the current period.\n   *\n   * Note: This method should be called at the end of the period.\n   */\n  function _maintainingInBlockRange(\n    address candidateId,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) private view returns (bool) {\n    Schedule storage s = _schedule[candidateId];\n    return Math.twoRangeOverlap(fromBlock, toBlock, s.from, s.to);\n  }\n\n  function __css2cid(TConsensus consensusAddr) internal view returns (address) {\n    return IProfile(getContract(ContractType.PROFILE)).getConsensus2Id(consensusAddr);\n  }\n\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view returns (address[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyConsensus2Id(consensusAddrs);\n  }\n}\n"
    },
    "contracts/ronin/profile/Profile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/validator/ICandidateManager.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport \"./ProfileXComponents.sol\";\nimport { ErrUnauthorized, RoleAccess } from \"../../utils/CommonErrors.sol\";\nimport { ContractType } from \"../../utils/ContractType.sol\";\n\npragma solidity ^0.8.9;\n\ncontract Profile is IProfile, ProfileXComponents, Initializable {\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address validatorContract) external initializer {\n    _setContract(ContractType.VALIDATOR, validatorContract);\n  }\n\n  function initializeV2(address stakingContract) external reinitializer(2) {\n    _setContract(ContractType.STAKING, stakingContract);\n  }\n\n  function initializeV3(address trustedOrgContract) external reinitializer(3) {\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, trustedOrgContract);\n\n    // TODO(bao): handle renounced validators\n    address[] memory validatorCandidates = IRoninValidatorSet(getContract(ContractType.VALIDATOR))\n      .getValidatorCandidates();\n    TConsensus[] memory consensuses;\n    assembly (\"memory-safe\") {\n      consensuses := validatorCandidates\n    }\n    for (uint256 i; i < validatorCandidates.length; ++i) {\n      _consensus2Id[consensuses[i]] = validatorCandidates[i];\n    }\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getId2Profile(address id) external view returns (CandidateProfile memory) {\n    return _id2Profile[id];\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getManyId2Consensus(address[] calldata idList) external view returns (TConsensus[] memory consensusList) {\n    consensusList = new TConsensus[](idList.length);\n    unchecked {\n      for (uint i; i < idList.length; ++i) {\n        consensusList[i] = _id2Profile[idList[i]].consensus;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getConsensus2Id(TConsensus consensus) external view returns (address id) {\n    id = _consensus2Id[consensus];\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getManyConsensus2Id(TConsensus[] calldata consensusList) external view returns (address[] memory idList) {\n    idList = new address[](consensusList.length);\n    unchecked {\n      for (uint i; i < consensusList.length; ++i) {\n        idList[i] = _consensus2Id[consensusList[i]];\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function addNewProfile(CandidateProfile memory profile) external onlyAdmin {\n    CandidateProfile storage _profile = _id2Profile[profile.id];\n    if (_profile.id != address(0)) revert ErrExistentProfile();\n    _addNewProfile(_profile, profile);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   *\n   * @dev Side-effects on other contracts:\n   * - Update Staking contract:\n   *    + [x] Update (id => PoolDetail) mapping in {BaseStaking.sol}.\n   *    + [x] Update `_adminOfActivePoolMapping` in {BaseStaking.sol}.\n   * - Update Validator contract:\n   *    + [x] Update (id => ValidatorCandidate) mapping\n   */\n  function requestChangeAdminAddress(address id, address newAdminAddr) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    _requireCandidateAdmin(_profile);\n    _checkNonZeroAndNonDuplicated(RoleAccess.ADMIN, newAdminAddr);\n    _setAdmin(_profile, newAdminAddr);\n\n    IStaking stakingContract = IStaking(getContract(ContractType.STAKING));\n    stakingContract.execChangeAdminAddress(id, newAdminAddr);\n\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    validatorContract.execChangeAdminAddress(id, newAdminAddr);\n\n    emit ProfileAddressChanged(id, RoleAccess.ADMIN);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   *\n   * @dev Side-effects on other contracts:\n   * - Update in Staking contract for Consensus address mapping:\n   *   + [x] Keep the same previous pool address.\n   * - Update in Validator contract for:\n   *   + [x] Consensus Address mapping\n   *   + [x] Bridge Address mapping\n   *   + [x] Jail mapping\n   *   + [x] Pending reward mapping\n   *   + [x] Schedule mapping\n   * - Update in Slashing contract for:\n   *   + [x] Handling slash indicator\n   *   + [x] Handling slash fast finality\n   *   + [x] Handling slash double sign\n   * - Update in Proposal contract for:\n   *   + [ ] Refund of emergency exit mapping\n   *   + [ ] ...\n   * - Update Trusted Org contracts:\n   *   + [x] Remove and delete weight of the old consensus\n   *   + [x] Replace and add weight for the new consensus\n   */\n  function requestChangeConsensusAddr(address id, TConsensus newConsensusAddr) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    _requireCandidateAdmin(_profile);\n    _checkNonZeroAndNonDuplicated(RoleAccess.CONSENSUS, TConsensus.unwrap(newConsensusAddr));\n\n    TConsensus oldConsensusAddr = _profile.consensus;\n    _setConsensus(_profile, newConsensusAddr);\n\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    validatorContract.execChangeConsensusAddress(id, newConsensusAddr);\n\n    IRoninTrustedOrganization trustedOrgContract = IRoninTrustedOrganization(\n      getContract(ContractType.RONIN_TRUSTED_ORGANIZATION)\n    );\n    trustedOrgContract.execChangeConsensusAddressForTrustedOrg({\n      oldConsensusAddr: oldConsensusAddr,\n      newConsensusAddr: newConsensusAddr\n    });\n\n    emit ProfileAddressChanged(id, RoleAccess.CONSENSUS);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   *\n   * @dev Side-effects on other contracts:\n   * - Update Validator contract:\n   *    + [x] Update (id => ValidatorCandidate) mapping\n   * - Update governance admin:\n   *    + [-] Update recipient in the EmergencyExitBallot to the newTreasury.\n   *          Cannot impl since we cannot cancel the previous the ballot and\n   *          create a new ballot on behalf of the validator contract.\n   */\n  function requestChangeTreasuryAddr(address id, address payable newTreasury) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    _requireCandidateAdmin(_profile);\n    _checkNonZeroAndNonDuplicated(RoleAccess.TREASURY, newTreasury);\n    _setTreasury(_profile, newTreasury);\n\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    validatorContract.execChangeTreasuryAddress(id, newTreasury);\n\n    emit ProfileAddressChanged(id, RoleAccess.TREASURY);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function changePubkey(address id, bytes memory pubkey) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    _requireCandidateAdmin(_profile);\n    _checkNonDuplicatedPubkey(pubkey);\n    _setPubkey(_profile, pubkey);\n\n    emit PubkeyChanged(id, pubkey);\n  }\n\n  function _requireCandidateAdmin(CandidateProfile storage sProfile) internal view {\n    if (\n      msg.sender != sProfile.admin ||\n      !IRoninValidatorSet(getContract(ContractType.VALIDATOR)).isCandidateAdmin(sProfile.consensus, msg.sender)\n    ) revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\n  }\n}\n"
    },
    "contracts/ronin/profile/ProfileHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../udvts/Types.sol\";\nimport \"../../utils/RoleAccess.sol\";\nimport { ProfileStorage } from \"./ProfileStorage.sol\";\n\nabstract contract ProfileHandler is ProfileStorage {\n  /**\n   * @dev Checks each element in the new profile and reverts if there is duplication with any existing profile.\n   */\n  function _checkDuplicatedInRegistry(CandidateProfile memory profile) internal view {\n    _checkNonZeroAndNonDuplicated(RoleAccess.CONSENSUS, TConsensus.unwrap(profile.consensus));\n    _checkNonZeroAndNonDuplicated(RoleAccess.CANDIDATE_ADMIN, profile.admin);\n    _checkNonZeroAndNonDuplicated(RoleAccess.TREASURY, profile.treasury);\n    _checkNonDuplicated(RoleAccess.TREASURY, profile.__reservedGovernor);\n    _checkNonDuplicatedPubkey(profile.pubkey);\n  }\n\n  function _checkNonZeroAndNonDuplicated(RoleAccess addressType, address addr) internal view {\n    if (addr == address(0)) revert ErrZeroAddress(addressType);\n    _checkNonDuplicated(addressType, addr);\n  }\n\n  function _checkNonDuplicated(RoleAccess addressType, address addr) internal view {\n    if (_registry[uint256(uint160(addr))]) {\n      revert ErrDuplicatedInfo(addressType, uint256(uint160(addr)));\n    }\n  }\n\n  function _checkNonDuplicatedPubkey(bytes memory pubkey) internal view {\n    if (_registry[_hashPubkey(pubkey)]) {\n      revert ErrDuplicatedPubkey(pubkey);\n    }\n  }\n}"
    },
    "contracts/ronin/profile/ProfileStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../udvts/Types.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { IProfile } from \"../../interfaces/IProfile.sol\";\n\nabstract contract ProfileStorage is IProfile, HasContracts {\n  /// @dev Mapping from id address => candidate profile.\n  mapping(address => CandidateProfile) internal _id2Profile;\n\n  /**\n   * @dev Mapping from any address or keccak256(pubkey) => whether it is already registered.\n   * This registry can only be toggled to `true` and NOT vice versa. All registered values\n   * cannot be reused.\n   */\n  mapping(uint256 => bool) internal _registry;\n\n  /// @dev Mapping from consensus address => id address.\n  mapping(TConsensus => address) internal _consensus2Id;\n\n  /// @dev Upgradeable gap.\n  bytes32[48] __gap;\n\n  /**\n   * @dev Add a profile from memory to storage.\n   */\n  function _addNewProfile(CandidateProfile storage _profile, CandidateProfile memory newProfile) internal {\n    _profile.id = newProfile.id;\n\n    _setConsensus(_profile, newProfile.consensus);\n    _setAdmin(_profile, newProfile.admin);\n    _setTreasury(_profile, newProfile.treasury);\n    _setGovernor(_profile, newProfile.__reservedGovernor);\n    _setPubkey(_profile, newProfile.pubkey);\n\n    emit ProfileAdded(newProfile.id);\n  }\n\n  function _setConsensus(CandidateProfile storage _profile, TConsensus consensus) internal {\n    delete _consensus2Id[_profile.consensus];\n    _consensus2Id[consensus] = _profile.id;\n\n    _profile.consensus = consensus;\n    _registry[uint256(uint160(TConsensus.unwrap(consensus)))] = true;\n  }\n\n  function _setAdmin(CandidateProfile storage _profile, address admin) internal {\n    _profile.admin = admin;\n    _registry[uint256(uint160(admin))] = true;\n  }\n\n  function _setTreasury(CandidateProfile storage _profile, address payable treasury) internal {\n    _profile.treasury = treasury;\n    _registry[uint256(uint160(address(treasury)))] = true;\n  }\n\n  /**\n   * @dev Allow to registry a profile without governor address since not all validators are governing validators.\n   */\n  function _setGovernor(CandidateProfile storage _profile, address governor) internal {\n    _profile.__reservedGovernor = governor;\n    if (governor != address(0)) {\n      _registry[uint256(uint160(governor))] = true;\n    }\n  }\n\n  function _setPubkey(CandidateProfile storage _profile, bytes memory pubkey) internal {\n    _profile.pubkey = pubkey;\n    _registry[_hashPubkey(pubkey)] = true;\n  }\n\n  /**\n   * @dev Get an existed profile struct from `id`. Revert if the profile does not exists.\n   */\n  function _getId2ProfileHelper(address id) internal view returns (CandidateProfile storage _profile) {\n    _profile = _id2Profile[id];\n    if (_profile.id == address(0)) revert ErrNonExistentProfile();\n  }\n\n  /**\n   * @dev Returns hash of a public key.\n   */\n  function _hashPubkey(bytes memory pubkey) internal pure returns (uint256) {\n    return uint256(keccak256(pubkey));\n  }\n}\n"
    },
    "contracts/ronin/profile/ProfileXComponents.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../../interfaces/IProfile.sol\";\nimport { ContractType } from \"../../utils/ContractType.sol\";\nimport \"./ProfileHandler.sol\";\n\npragma solidity ^0.8.9;\n\nabstract contract ProfileXComponents is IProfile, ProfileHandler {\n  /**\n   * @inheritdoc IProfile\n   */\n  function execApplyValidatorCandidate(\n    address admin,\n    address id,\n    address treasury,\n    bytes calldata pubkey\n  ) external override onlyContract(ContractType.STAKING) {\n    // Check existent profile\n    CandidateProfile storage _profile = _id2Profile[id];\n    if (_profile.id != address(0)) revert ErrExistentProfile();\n\n    // Validate the info and add the profile\n    CandidateProfile memory profile = CandidateProfile({\n      id: id,\n      consensus: TConsensus.wrap(id),\n      admin: admin,\n      treasury: payable(treasury),\n      __reservedGovernor: address(0),\n      pubkey: pubkey\n    });\n    _checkDuplicatedInRegistry(profile);\n    _addNewProfile(_profile, profile);\n  }\n}\n"
    },
    "contracts/ronin/RoninGovernanceAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../extensions/sequential-governance/governance-proposal/GovernanceProposal.sol\";\nimport \"../extensions/collections/HasContracts.sol\";\nimport \"../extensions/GovernanceAdmin.sol\";\nimport \"../libraries/EmergencyExitBallot.sol\";\nimport { ErrorHandler } from \"../libraries/ErrorHandler.sol\";\nimport { IsolatedGovernance } from \"../libraries/IsolatedGovernance.sol\";\nimport { HasValidatorDeprecated } from \"../utils/DeprecatedSlots.sol\";\nimport \"../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../interfaces/IRoninGovernanceAdmin.sol\";\n\ncontract RoninGovernanceAdmin is\n  HasContracts,\n  IRoninGovernanceAdmin,\n  GovernanceAdmin,\n  GovernanceProposal,\n  HasValidatorDeprecated\n{\n  using ErrorHandler for bool;\n  using Proposal for Proposal.ProposalDetail;\n  using IsolatedGovernance for IsolatedGovernance.Vote;\n\n  /// @dev Mapping from request hash => emergency poll\n  mapping(bytes32 => IsolatedGovernance.Vote) internal _emergencyExitPoll;\n\n  modifier onlyGovernor() {\n    _requireGorvernor();\n    _;\n  }\n\n  constructor(\n    uint256 _roninChainId,\n    address _roninTrustedOrganizationContract,\n    address _validatorContract,\n    uint256 _expiryDuration\n  ) CoreGovernance(_expiryDuration) GovernanceAdmin(_roninChainId, _roninTrustedOrganizationContract) {\n    _setContract(ContractType.VALIDATOR, _validatorContract);\n  }\n\n  function _requireGorvernor() private view {\n    if (_getWeight(msg.sender) == 0) revert ErrUnauthorized(msg.sig, RoleAccess.GOVERNOR);\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function setContract(\n    ContractType contractType,\n    address addr\n  ) external override(HasContracts, GovernanceAdmin) onlySelfCall {\n    _requireHasCode(addr);\n    _setContract(contractType, addr);\n  }\n\n  /**\n   * @dev Returns whether the voter casted vote for emergency exit poll.\n   */\n  function emergencyPollVoted(bytes32 _voteHash, address _voter) external view returns (bool) {\n    return _emergencyExitPoll[_voteHash].voted(_voter);\n  }\n\n  /**\n   * @dev See `CoreGovernance-_proposeProposal`.\n   *\n   * Requirements:\n   * - The method caller is governor.\n   *\n   */\n  function propose(\n    uint256 _chainId,\n    uint256 _expiryTimestamp,\n    address[] calldata _targets,\n    uint256[] calldata _values,\n    bytes[] calldata _calldatas,\n    uint256[] calldata _gasAmounts\n  ) external onlyGovernor {\n    _proposeProposal(_chainId, _expiryTimestamp, _targets, _values, _calldatas, _gasAmounts, msg.sender);\n  }\n\n  /**\n   * @dev See `GovernanceProposal-_proposeProposalStructAndCastVotes`.\n   *\n   * Requirements:\n   * - The method caller is governor.\n   * - The proposal is for the current network.\n   *\n   */\n  function proposeProposalStructAndCastVotes(\n    Proposal.ProposalDetail calldata _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures\n  ) external onlyGovernor {\n    _proposeProposalStructAndCastVotes(_proposal, _supports, _signatures, DOMAIN_SEPARATOR, msg.sender);\n  }\n\n  /**\n   * @dev Proposes and casts vote for a proposal on the current network.\n   *\n   * Requirements:\n   * - The method caller is governor.\n   * - The proposal is for the current network.\n   *\n   */\n  function proposeProposalForCurrentNetwork(\n    uint256 _expiryTimestamp,\n    address[] calldata _targets,\n    uint256[] calldata _values,\n    bytes[] calldata _calldatas,\n    uint256[] calldata _gasAmounts,\n    Ballot.VoteType _support\n  ) external onlyGovernor {\n    address _voter = msg.sender;\n    Proposal.ProposalDetail memory _proposal = _proposeProposal(\n      block.chainid,\n      _expiryTimestamp,\n      _targets,\n      _values,\n      _calldatas,\n      _gasAmounts,\n      _voter\n    );\n    _castProposalVoteForCurrentNetwork(_voter, _proposal, _support);\n  }\n\n  /**\n   * @dev Casts vote for a proposal on the current network.\n   *\n   * Requirements:\n   * - The method caller is governor.\n   *\n   */\n  function castProposalVoteForCurrentNetwork(\n    Proposal.ProposalDetail calldata _proposal,\n    Ballot.VoteType _support\n  ) external onlyGovernor {\n    _castProposalVoteForCurrentNetwork(msg.sender, _proposal, _support);\n  }\n\n  /**\n   * @dev See `GovernanceProposal-_castProposalBySignatures`.\n   */\n  function castProposalBySignatures(\n    Proposal.ProposalDetail calldata _proposal,\n    Ballot.VoteType[] calldata _supports,\n    Signature[] calldata _signatures\n  ) external {\n    _castProposalBySignatures(_proposal, _supports, _signatures, DOMAIN_SEPARATOR);\n  }\n\n  /**\n   * @dev Deletes the expired proposal by its chainId and nonce, without creating a new proposal.\n   *\n   * Requirements:\n   * - The proposal is already created.\n   *\n   */\n  function deleteExpired(uint256 _chainId, uint256 _round) external {\n    ProposalVote storage _vote = vote[_chainId][_round];\n    if (_vote.hash == 0) revert ErrQueryForEmptyVote();\n\n    _tryDeleteExpiredVotingRound(_vote);\n  }\n\n  /**\n   * @inheritdoc IRoninGovernanceAdmin\n   */\n  function createEmergencyExitPoll(\n    address validatorId,\n    address recipientAfterUnlockedFund,\n    uint256 requestedAt,\n    uint256 expiredAt\n  ) external onlyContract(ContractType.VALIDATOR) {\n    bytes32 ballotHash = EmergencyExitBallot.hash(validatorId, recipientAfterUnlockedFund, requestedAt, expiredAt);\n    IsolatedGovernance.Vote storage _v = _emergencyExitPoll[ballotHash];\n    _v.createdAt = block.timestamp;\n    _v.expiredAt = expiredAt;\n    emit EmergencyExitPollCreated(ballotHash, validatorId, recipientAfterUnlockedFund, requestedAt, expiredAt);\n  }\n\n  /**\n   * @dev Votes for an emergency exit. Executes to unlock fund for the emergency exit's requester.\n   *\n   * Requirements:\n   * - The voter is governor.\n   * - The voting is existent.\n   * - The voting is not expired yet.\n   *\n   */\n  function voteEmergencyExit(\n    bytes32 voteHash,\n    address validatorId,\n    address recipientAfterUnlockedFund,\n    uint256 requestedAt,\n    uint256 expiredAt\n  ) external onlyGovernor {\n    address _voter = msg.sender;\n    bytes32 _hash = EmergencyExitBallot.hash(validatorId, recipientAfterUnlockedFund, requestedAt, expiredAt);\n    if (voteHash != _hash) revert ErrInvalidVoteHash();\n\n    IsolatedGovernance.Vote storage _v = _emergencyExitPoll[_hash];\n    if (_v.createdAt == 0) revert ErrQueryForNonExistentVote();\n    if (_v.status == VoteStatus.Expired) revert ErrQueryForExpiredVote();\n\n    _v.castVote(_voter, _hash);\n    emit EmergencyExitPollVoted(_hash, _voter);\n\n    address[] memory _voters = _v.filterByHash(_hash);\n    VoteStatus _stt = _v.syncVoteStatus(_getMinimumVoteWeight(), _sumGovernorWeight(_voters), _hash);\n    if (_stt == VoteStatus.Approved) {\n      _execReleaseLockedFundForEmergencyExitRequest(validatorId, recipientAfterUnlockedFund);\n      emit EmergencyExitPollApproved(_hash);\n      _v.status = VoteStatus.Executed;\n    } else if (_stt == VoteStatus.Expired) {\n      emit EmergencyExitPollExpired(_hash);\n    }\n  }\n\n  /**\n   * @dev Returns weight of a govenor.\n   */\n  function _getWeight(address _governor) internal view virtual override returns (uint256) {\n    bytes4 _selector = IRoninTrustedOrganization.getGovernorWeight.selector;\n    (bool _success, bytes memory _returndata) = getContract(ContractType.RONIN_TRUSTED_ORGANIZATION).staticcall(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector, _governor)\n      )\n    );\n    _success.handleRevert(_selector, _returndata);\n    return abi.decode(_returndata, (uint256));\n  }\n\n  /**\n   * @dev Returns the total weight of a list address of governors.\n   */\n  function _sumGovernorWeight(address[] memory governors) internal view virtual returns (uint256) {\n    bytes4 _selector = IRoninTrustedOrganization.sumGovernorWeight.selector;\n    (bool _success, bytes memory _returndata) = getContract(ContractType.RONIN_TRUSTED_ORGANIZATION).staticcall(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector, governors)\n      )\n    );\n\n    _success.handleRevert(_selector, _returndata);\n    return abi.decode(_returndata, (uint256));\n  }\n\n  /**\n   * @dev Trigger function from validator contract to unlock fund for emergency exit request.\n   */\n  function _execReleaseLockedFundForEmergencyExitRequest(\n    address validatorId,\n    address recipientAfterUnlockedFund\n  ) internal virtual {\n    bytes4 _selector = IEmergencyExit.execReleaseLockedFundForEmergencyExitRequest.selector;\n    (bool _success, bytes memory _returndata) = getContract(ContractType.VALIDATOR).call(\n      abi.encodeWithSelector(\n        // TransparentUpgradeableProxyV2.functionDelegateCall.selector,\n        0x4bb5274a,\n        abi.encodeWithSelector(_selector, validatorId, recipientAfterUnlockedFund)\n      )\n    );\n    _success.handleRevert(_selector, _returndata);\n  }\n\n  /**\n   * @dev See `CoreGovernance-_getChainType`.\n   */\n  function _getChainType() internal pure override returns (ChainType) {\n    return ChainType.RoninChain;\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/CreditScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/IMaintenance.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/slash-indicator/ICreditScore.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasValidatorDeprecated, HasMaintenanceDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport { ErrUnauthorized, RoleAccess } from \"../../utils/CommonErrors.sol\";\n\nabstract contract CreditScore is\n  ICreditScore,\n  HasContracts,\n  HasValidatorDeprecated,\n  HasMaintenanceDeprecated,\n  PercentageConsumer\n{\n  /// @dev Mapping from validator id => period index => whether bailed out before\n  mapping(address => mapping(uint256 => bool)) internal _checkBailedOutAtPeriod;\n  /// @dev Mapping from validator address => credit score\n  mapping(address => uint256) internal _creditScore;\n\n  /// @dev The max gained number of credit score per period.\n  uint256 internal _gainCreditScore;\n  /// @dev The max number of credit score that a validator can hold.\n  uint256 internal _maxCreditScore;\n  /// @dev The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n  uint256 internal _bailOutCostMultiplier;\n  /// @dev The percentage of reward to be cut off from the validator in the rest of the period after bailed out.\n  uint256 internal _cutOffPercentageAfterBailout;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function execUpdateCreditScores(\n    address[] calldata validatorIds,\n    uint256 period\n  ) external override onlyContract(ContractType.VALIDATOR) {\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(msg.sender);\n    uint256 periodStartAtBlock = validatorContract.currentPeriodStartAtBlock();\n\n    bool[] memory jaileds = validatorContract.checkManyJailedById(validatorIds);\n    bool[] memory maintaineds = IMaintenance(getContract(ContractType.MAINTENANCE)).checkManyMaintainedInBlockRangeById(\n      validatorIds,\n      periodStartAtBlock,\n      block.number\n    );\n    uint256[] memory updatedCreditScores = new uint256[](validatorIds.length);\n\n    for (uint i = 0; i < validatorIds.length; ) {\n      address vId = validatorIds[i];\n\n      uint256 indicator = _getUnavailabilityIndicatorById(vId, period);\n      bool isJailedInPeriod = jaileds[i];\n      bool isMaintainingInPeriod = maintaineds[i];\n\n      uint256 _actualGain = (isJailedInPeriod || isMaintainingInPeriod)\n        ? 0\n        : Math.subNonNegative(_gainCreditScore, indicator);\n\n      _creditScore[vId] = Math.addWithUpperbound(_creditScore[vId], _actualGain, _maxCreditScore);\n      updatedCreditScores[i] = _creditScore[vId];\n      unchecked {\n        ++i;\n      }\n    }\n\n    emit CreditScoresUpdated(validatorIds, updatedCreditScores);\n  }\n\n  function execResetCreditScores(\n    address[] calldata validatorIds\n  ) external override onlyContract(ContractType.VALIDATOR) {\n    uint256[] memory updatedCreditScores = new uint256[](validatorIds.length);\n    for (uint i = 0; i < validatorIds.length; ) {\n      address _validator = validatorIds[i];\n      delete _creditScore[_validator];\n      delete updatedCreditScores[i];\n\n      unchecked {\n        ++i;\n      }\n    }\n    emit CreditScoresUpdated(validatorIds, updatedCreditScores);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function bailOut(TConsensus consensusAddr) external override {\n    address validatorId = __css2cid(consensusAddr);\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    if (!validatorContract.isValidatorCandidate(consensusAddr))\n      revert ErrUnauthorized(msg.sig, RoleAccess.VALIDATOR_CANDIDATE);\n\n    if (!validatorContract.isCandidateAdmin(consensusAddr, msg.sender))\n      revert ErrUnauthorized(msg.sig, RoleAccess.CANDIDATE_ADMIN);\n\n    (bool isJailed, , uint256 jailedEpochLeft) = validatorContract.getJailedTimeLeft(consensusAddr);\n    if (!isJailed) revert ErrCallerMustBeJailedInTheCurrentPeriod();\n\n    uint256 period = validatorContract.currentPeriod();\n    if (_checkBailedOutAtPeriod[validatorId][period]) revert ErrValidatorHasBailedOutPreviously();\n\n    uint256 score = _creditScore[validatorId];\n    uint256 cost = jailedEpochLeft * _bailOutCostMultiplier;\n    if (score < cost) revert ErrInsufficientCreditScoreToBailOut();\n\n    validatorContract.execBailOut(validatorId, period);\n\n    _creditScore[validatorId] -= cost;\n    _setUnavailabilityIndicator(validatorId, period, 0);\n    _checkBailedOutAtPeriod[validatorId][period] = true;\n    emit BailedOut(consensusAddr, period, cost);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) external override onlyAdmin {\n    _setCreditScoreConfigs(_gainScore, _maxScore, _bailOutMultiplier, _cutOffPercentage);\n  }\n\n  /**\n   * @dev See `ISlashUnavailability`\n   */\n  function _getUnavailabilityIndicatorById(address validator, uint256 period) internal view virtual returns (uint256);\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getCreditScoreConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 gainCreditScore_,\n      uint256 maxCreditScore_,\n      uint256 bailOutCostMultiplier_,\n      uint256 cutOffPercentageAfterBailout_\n    )\n  {\n    return (_gainCreditScore, _maxCreditScore, _bailOutCostMultiplier, _cutOffPercentageAfterBailout);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getCreditScore(TConsensus consensusAddr) external view override returns (uint256) {\n    return _creditScore[__css2cid(consensusAddr)];\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getManyCreditScores(\n    TConsensus[] calldata consensusAddrs\n  ) public view override returns (uint256[] memory resultList) {\n    address[] memory validatorIds = __css2cidBatch(consensusAddrs);\n    resultList = new uint256[](validatorIds.length);\n\n    for (uint i = 0; i < resultList.length; ) {\n      resultList[i] = _creditScore[validatorIds[i]];\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function checkBailedOutAtPeriod(TConsensus consensus, uint256 period) external view override returns (bool) {\n    return _checkBailedOutAtPeriodById(__css2cid(consensus), period);\n  }\n\n  function _checkBailedOutAtPeriodById(address validatorId, uint256 period) internal view virtual returns (bool) {\n    return _checkBailedOutAtPeriod[validatorId][period];\n  }\n\n  /**\n   * @dev See `SlashUnavailability`.\n   */\n  function _setUnavailabilityIndicator(address _validator, uint256 period, uint256 _indicator) internal virtual;\n\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view virtual returns (address[] memory);\n\n  /**\n   * @dev See `ICreditScore-setCreditScoreConfigs`.\n   */\n  function _setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) internal {\n    if (_gainScore > _maxScore) revert ErrInvalidCreditScoreConfig();\n    if (_cutOffPercentage > _MAX_PERCENTAGE) revert ErrInvalidCutOffPercentageConfig();\n\n    _gainCreditScore = _gainScore;\n    _maxCreditScore = _maxScore;\n    _bailOutCostMultiplier = _bailOutMultiplier;\n    _cutOffPercentageAfterBailout = _cutOffPercentage;\n    emit CreditScoreConfigsUpdated(_gainScore, _maxScore, _bailOutMultiplier, _cutOffPercentage);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/DeprecatedSlashBridgeOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasProxyAdmin.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\nabstract contract DeprecatedSlashBridgeOperator is HasProxyAdmin, HasContracts, HasValidatorDeprecated {\n  /**\n   * @dev The bridge operators will be deprecated reward if (s)he missed more than the ratio.\n   * Values 0-10,000 map to 0%-100%.\n   */\n  uint256 private ____deprecatedMissingVotesRatioTier1;\n  /**\n   * @dev The bridge operators will be deprecated all rewards including bridge reward and mining reward if (s)he missed\n   * more than the ratio. Values 0-10,000 map to 0%-100%.\n   */\n  uint256 private ____deprecatedMissingVotesRatioTier2;\n  /// @dev The number of blocks to jail the corresponding block producer when its bridge operator is slashed tier-2.\n  uint256 private ____deprecatedJailDurationForMissingVotesRatioTier2;\n  /// @dev The threshold to skip slashing the bridge operator in case the total number of votes in the bridge is too small.\n  uint256 private ____deprecatedSkipBridgeOperatorSlashingThreshold;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/ronin/slash-indicator/DeprecatedSlashBridgeVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { HasValidatorDeprecated, HasTrustedOrgDeprecated, HasGovernanceAdminDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\n\n// TODO: remove this from slashing logic of consensus contract\nabstract contract DeprecatedSlashBridgeVoting is\n  HasContracts,\n  HasValidatorDeprecated,\n  HasTrustedOrgDeprecated,\n  HasGovernanceAdminDeprecated\n{\n  /// @dev Mapping from validator address => period index => bridge voting slashed\n  mapping(address => mapping(uint256 => bool)) private __deprecatedBridgeVotingSlashed;\n  /// @dev The threshold to slash when a trusted organization does not vote for bridge operators.\n  uint256 private __deprecatedBridgeVotingThreshold;\n  /// @dev The amount of RON to slash bridge voting.\n  uint256 private __deprecatedBridgeVotingSlashAmount;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/slash-indicator/ISlashDoubleSign.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../precompile-usages/PCUValidateDoubleSign.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\nabstract contract SlashDoubleSign is ISlashDoubleSign, HasContracts, HasValidatorDeprecated, PCUValidateDoubleSign {\n  /// @dev The amount of RON to slash double sign.\n  uint256 internal _slashDoubleSignAmount;\n  /// @dev The block number that the punished validator will be jailed until, due to double signing.\n  uint256 internal _doubleSigningJailUntilBlock;\n  /** @dev The offset from the submitted block to the current block, from which double signing will be invalidated.\n   * This parameter is exposed for system transaction.\n   **/\n  uint256 internal _doubleSigningOffsetLimitBlock;\n  /// @dev Recording of submitted proof to prevent relay attack.\n  mapping(bytes32 => bool) _submittedEvidence;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[24] private ______gap;\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function slashDoubleSign(\n    TConsensus consensusAddr,\n    bytes calldata header1,\n    bytes calldata header2\n  ) external override onlyAdmin {\n    bytes32 header1Checksum = keccak256(header1);\n    bytes32 header2Checksum = keccak256(header2);\n\n    if (_submittedEvidence[header1Checksum] || _submittedEvidence[header2Checksum]) {\n      revert ErrEvidenceAlreadySubmitted();\n    }\n\n    address validatorId = __css2cid(consensusAddr);\n\n    // NOTE: Edge case: non-validator who never apply for the candidate role, nor have a profile.\n    // Must be slashed by the consensus address, since the validatorId will be address(0).\n    if (validatorId == address(0)) {\n      validatorId = TConsensus.unwrap(consensusAddr);\n    }\n\n    if (_pcValidateEvidence(validatorId, header1, header2)) {\n      IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n      uint256 period = validatorContract.currentPeriod();\n      _submittedEvidence[header1Checksum] = true;\n      _submittedEvidence[header2Checksum] = true;\n      emit Slashed(validatorId, SlashType.DOUBLE_SIGNING, period);\n      validatorContract.execSlash(validatorId, _doubleSigningJailUntilBlock, _slashDoubleSignAmount, true);\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function getDoubleSignSlashingConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 slashDoubleSignAmount_,\n      uint256 doubleSigningJailUntilBlock_,\n      uint256 doubleSigningOffsetLimitBlock_\n    )\n  {\n    return (_slashDoubleSignAmount, _doubleSigningJailUntilBlock, _doubleSigningOffsetLimitBlock);\n  }\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _offsetLimitBlock\n  ) external override onlyAdmin {\n    _setDoubleSignSlashingConfigs(_slashAmount, _jailUntilBlock, _offsetLimitBlock);\n  }\n\n  /**\n   * @dev See `ISlashDoubleSign-setDoubleSignSlashingConfigs`.\n   */\n  function _setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _offsetLimitBlock\n  ) internal {\n    _slashDoubleSignAmount = _slashAmount;\n    _doubleSigningJailUntilBlock = _jailUntilBlock;\n    _doubleSigningOffsetLimitBlock = _offsetLimitBlock;\n    emit DoubleSignSlashingConfigsUpdated(_slashAmount, _jailUntilBlock, _doubleSigningOffsetLimitBlock);\n  }\n\n  /**\n   * @dev Returns whether the account `_addr` should be slashed or not.\n   */\n  function _shouldSlash(TConsensus consensus, address validatorId) internal view virtual returns (bool);\n\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/slash-indicator/ISlashFastFinality.sol\";\nimport { IRoninValidatorSet } from \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport { IProfile } from \"../../interfaces/IProfile.sol\";\nimport { IRoninTrustedOrganization } from \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../precompile-usages/PCUValidateFastFinality.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../utils/CommonErrors.sol\";\n\nabstract contract SlashFastFinality is ISlashFastFinality, HasContracts, PCUValidateFastFinality {\n  /// @dev The amount of RON to slash fast finality.\n  uint256 internal _slashFastFinalityAmount;\n  /// @dev The block number that the punished validator will be jailed until, due to malicious fast finality.\n  uint256 internal _fastFinalityJailUntilBlock;\n  /// @dev Recording of submitted proof to prevent relay attack.\n  mapping(bytes32 => bool) internal _processedEvidence;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[21] private ______gap;\n\n  modifier onlyGoverningValidator() {\n    if (_getGovernorWeight(msg.sender) == 0) revert ErrUnauthorized(msg.sig, RoleAccess.GOVERNOR);\n    _;\n  }\n\n  /**\n   * @inheritdoc ISlashFastFinality\n   */\n  function slashFastFinality(\n    TConsensus consensusAddr,\n    bytes calldata voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] calldata targetBlockHash,\n    bytes[][2] calldata listOfPublicKey,\n    bytes[2] calldata aggregatedSignature\n  ) external override onlyGoverningValidator {\n    address validatorId = __css2cid(consensusAddr);\n    IProfile profileContract = IProfile(getContract(ContractType.PROFILE));\n    bytes memory expectingPubKey = (profileContract.getId2Profile(validatorId)).pubkey;\n    if (keccak256(voterPublicKey) != keccak256(expectingPubKey)) revert ErrInvalidArguments(msg.sig);\n\n    bytes32 evidenceHash = keccak256(abi.encodePacked(consensusAddr, targetBlockNumber));\n    if (_processedEvidence[evidenceHash]) revert ErrEvidenceAlreadySubmitted();\n\n    if (\n      _pcValidateFastFinalityEvidence(\n        voterPublicKey,\n        targetBlockNumber,\n        targetBlockHash,\n        listOfPublicKey,\n        aggregatedSignature\n      )\n    ) {\n      _processedEvidence[evidenceHash] = true;\n\n      IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n      uint256 period = validatorContract.currentPeriod();\n      emit Slashed(validatorId, SlashType.FAST_FINALITY, period);\n      validatorContract.execSlash({\n        cid: validatorId,\n        newJailedUntil: _fastFinalityJailUntilBlock,\n        slashAmount: _slashFastFinalityAmount,\n        cannotBailout: true\n      });\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashFastFinality\n   */\n  function getFastFinalitySlashingConfigs()\n    external\n    view\n    override\n    returns (uint256 slashFastFinalityAmount_, uint256 fastFinalityJailUntilBlock_)\n  {\n    return (_slashFastFinalityAmount, _fastFinalityJailUntilBlock);\n  }\n\n  /**\n   * @inheritdoc ISlashFastFinality\n   */\n  function setFastFinalitySlashingConfigs(uint256 slashAmount, uint256 jailUntilBlock) external override onlyAdmin {\n    _setFastFinalitySlashingConfigs(slashAmount, jailUntilBlock);\n  }\n\n  /**\n   * @dev See `ISlashFastFinality-setFastFinalitySlashingConfigs`.\n   */\n  function _setFastFinalitySlashingConfigs(uint256 slashAmount, uint256 jailUntilBlock) internal {\n    _slashFastFinalityAmount = slashAmount;\n    _fastFinalityJailUntilBlock = jailUntilBlock;\n    emit FastFinalitySlashingConfigsUpdated(slashAmount, jailUntilBlock);\n  }\n\n  /**\n   * @dev Get governor, i.e. governing validator's weight, of the `addr`.\n   */\n  function _getGovernorWeight(address addr) internal view returns (uint256) {\n    return IRoninTrustedOrganization(getContract(ContractType.RONIN_TRUSTED_ORGANIZATION)).getGovernorWeight(addr);\n  }\n\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashIndicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/slash-indicator/ISlashIndicator.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/IMaintenance.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport \"./DeprecatedSlashBridgeOperator.sol\";\nimport \"./DeprecatedSlashBridgeVoting.sol\";\nimport \"./SlashDoubleSign.sol\";\nimport \"./SlashFastFinality.sol\";\nimport \"./SlashUnavailability.sol\";\nimport \"./CreditScore.sol\";\n\ncontract SlashIndicator is\n  ISlashIndicator,\n  SlashDoubleSign,\n  SlashFastFinality,\n  DeprecatedSlashBridgeVoting,\n  DeprecatedSlashBridgeOperator,\n  SlashUnavailability,\n  CreditScore,\n  Initializable\n{\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __validatorContract,\n    address __maintenanceContract,\n    address __roninTrustedOrganizationContract,\n    address __roninGovernanceAdminContract,\n    uint256[4] calldata /* _bridgeOperatorSlashingConfigs */,\n    uint256[2] calldata /* _bridgeVotingSlashingConfigs */,\n    // _doubleSignSlashingConfigs[0]: _slashDoubleSignAmount\n    // _doubleSignSlashingConfigs[1]: _doubleSigningJailUntilBlock\n    // _doubleSignSlashingConfigs[2]: _doubleSigningOffsetLimitBlock\n    uint256[3] calldata _doubleSignSlashingConfigs,\n    // _unavailabilitySlashingConfigs[0]: _unavailabilityTier1Threshold\n    // _unavailabilitySlashingConfigs[1]: _unavailabilityTier2Threshold\n    // _unavailabilitySlashingConfigs[2]: _slashAmountForUnavailabilityTier2Threshold\n    // _unavailabilitySlashingConfigs[3]: _jailDurationForUnavailabilityTier2Threshold\n    uint256[4] calldata _unavailabilitySlashingConfigs,\n    // _creditScoreConfigs[0]: _gainCreditScore\n    // _creditScoreConfigs[1]: _maxCreditScore\n    // _creditScoreConfigs[2]: _bailOutCostMultiplier\n    // _creditScoreConfigs[3]: _cutOffPercentageAfterBailout\n    uint256[4] calldata _creditScoreConfigs\n  ) external initializer {\n    _setContract(ContractType.VALIDATOR, __validatorContract);\n    _setContract(ContractType.MAINTENANCE, __maintenanceContract);\n    _setContract(ContractType.GOVERNANCE_ADMIN, __roninGovernanceAdminContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, __roninTrustedOrganizationContract);\n\n    _setDoubleSignSlashingConfigs(\n      _doubleSignSlashingConfigs[0],\n      _doubleSignSlashingConfigs[1],\n      _doubleSignSlashingConfigs[2]\n    );\n    _setUnavailabilitySlashingConfigs(\n      _unavailabilitySlashingConfigs[0],\n      _unavailabilitySlashingConfigs[1],\n      _unavailabilitySlashingConfigs[2],\n      _unavailabilitySlashingConfigs[3]\n    );\n    _setCreditScoreConfigs(\n      _creditScoreConfigs[0],\n      _creditScoreConfigs[1],\n      _creditScoreConfigs[2],\n      _creditScoreConfigs[3]\n    );\n  }\n\n  function initializeV2(address roninGovernanceAdminContract) external reinitializer(2) {\n    _setContract(ContractType.VALIDATOR, ______deprecatedValidator);\n    _setContract(ContractType.MAINTENANCE, ______deprecatedMaintenance);\n    _setContract(ContractType.GOVERNANCE_ADMIN, roninGovernanceAdminContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, ______deprecatedTrustedOrg);\n\n    delete ______deprecatedValidator;\n    delete ______deprecatedMaintenance;\n    delete ______deprecatedTrustedOrg;\n    delete ______deprecatedGovernanceAdmin;\n  }\n\n  function initializeV3(address profileContract) external reinitializer(3) {\n    _setContract(ContractType.PROFILE, profileContract);\n    _setFastFinalitySlashingConfigs(_slashDoubleSignAmount, _doubleSigningJailUntilBlock);\n  }\n\n  /**\n   * @dev Helper for CreditScore contract to reset the indicator of the validator after bailing out.\n   */\n  function _setUnavailabilityIndicator(\n    address validator,\n    uint256 period,\n    uint256 indicator\n  ) internal override(CreditScore, SlashUnavailability) {\n    SlashUnavailability._setUnavailabilityIndicator(validator, period, indicator);\n  }\n\n  /**\n   * @dev Helper for CreditScore contract to query indicator of the validator.\n   */\n  function _getUnavailabilityIndicatorById(\n    address validatorId,\n    uint256 period\n  ) internal view override(CreditScore, SlashUnavailability) returns (uint256) {\n    return SlashUnavailability._getUnavailabilityIndicatorById(validatorId, period);\n  }\n\n  function _checkBailedOutAtPeriodById(\n    address cid,\n    uint256 period\n  ) internal view override(CreditScore, SlashUnavailability) returns (bool) {\n    return CreditScore._checkBailedOutAtPeriodById(cid, period);\n  }\n\n  /**\n   * @dev Sanity check the address to be slashed\n   */\n  function _shouldSlash(\n    TConsensus consensus,\n    address validatorId\n  ) internal view override(SlashDoubleSign, SlashUnavailability) returns (bool) {\n    return\n      (msg.sender != TConsensus.unwrap(consensus)) &&\n      (msg.sender != validatorId) &&\n      IRoninValidatorSet(getContract(ContractType.VALIDATOR)).isBlockProducer(consensus) &&\n      !IMaintenance(getContract(ContractType.MAINTENANCE)).checkMaintainedById(validatorId, block.number);\n  }\n\n  function __css2cid(\n    TConsensus consensusAddr\n  ) internal view override(CreditScore, SlashDoubleSign, SlashUnavailability, SlashFastFinality) returns (address) {\n    return IProfile(getContract(ContractType.PROFILE)).getConsensus2Id(consensusAddr);\n  }\n\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view override returns (address[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyConsensus2Id(consensusAddrs);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashUnavailability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./CreditScore.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/slash-indicator/ISlashUnavailability.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport { ErrInvalidThreshold } from \"../../utils/CommonErrors.sol\";\n\nabstract contract SlashUnavailability is ISlashUnavailability, HasContracts, HasValidatorDeprecated {\n  /// @dev The last block that a validator is slashed for unavailability.\n  uint256 internal _lastUnavailabilitySlashedBlock;\n  /// @dev Mapping from validator address => period index => unavailability indicator.\n  mapping(address => mapping(uint256 => uint256)) internal _unavailabilityIndicator;\n\n  /**\n   * @dev The mining reward will be deprecated, if (s)he missed more than this threshold.\n   * This threshold is applied for tier-1 and tier-3 of unavailability slash.\n   */\n  uint256 internal _unavailabilityTier1Threshold;\n  /**\n   * @dev The mining reward will be deprecated, (s)he will be put in jailed, and will be deducted\n   * self-staking if (s)he misses more than this threshold. This threshold is applied for tier-2 slash.\n   */\n  uint256 internal _unavailabilityTier2Threshold;\n  /**\n   * @dev The amount of RON to deduct from self-staking of a block producer when (s)he is slashed with\n   * tier-2 or tier-3.\n   **/\n  uint256 internal _slashAmountForUnavailabilityTier2Threshold;\n  /// @dev The number of blocks to jail a block producer when (s)he is slashed with tier-2 or tier-3.\n  uint256 internal _jailDurationForUnavailabilityTier2Threshold;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  modifier oncePerBlock() {\n    if (block.number <= _lastUnavailabilitySlashedBlock) {\n      revert ErrCannotSlashAValidatorTwiceOrSlashMoreThanOneValidatorInOneBlock();\n    }\n\n    _lastUnavailabilitySlashedBlock = block.number;\n    _;\n  }\n\n  function lastUnavailabilitySlashedBlock() external view returns (uint256) {\n    return _lastUnavailabilitySlashedBlock;\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function slashUnavailability(TConsensus consensusAddr) external override oncePerBlock {\n    if (msg.sender != block.coinbase) revert ErrUnauthorized(msg.sig, RoleAccess.COINBASE);\n\n    address validatorId = __css2cid(consensusAddr);\n    if (!_shouldSlash(consensusAddr, validatorId)) {\n      // Should return instead of throwing error since this is a part of system transaction.\n      return;\n    }\n\n    IRoninValidatorSet _validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    uint256 period = _validatorContract.currentPeriod();\n    uint256 count;\n    unchecked {\n      count = ++_unavailabilityIndicator[validatorId][period];\n    }\n    uint256 newJailedUntilBlock = Math.addIfNonZero(block.number, _jailDurationForUnavailabilityTier2Threshold);\n\n    if (count == _unavailabilityTier2Threshold) {\n      emit Slashed(validatorId, SlashType.UNAVAILABILITY_TIER_2, period);\n      _validatorContract.execSlash(\n        validatorId,\n        newJailedUntilBlock,\n        _slashAmountForUnavailabilityTier2Threshold,\n        false\n      );\n    } else if (count == _unavailabilityTier1Threshold) {\n      bool tier1SecondTime = _checkBailedOutAtPeriodById(validatorId, period);\n      if (!tier1SecondTime) {\n        emit Slashed(validatorId, SlashType.UNAVAILABILITY_TIER_1, period);\n        _validatorContract.execSlash(validatorId, 0, 0, false);\n      } else {\n        /// Handles tier-3\n        emit Slashed(validatorId, SlashType.UNAVAILABILITY_TIER_3, period);\n        _validatorContract.execSlash(\n          validatorId,\n          newJailedUntilBlock,\n          _slashAmountForUnavailabilityTier2Threshold,\n          true\n        );\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) external override onlyAdmin {\n    _setUnavailabilitySlashingConfigs(\n      _tier1Threshold,\n      _tier2Threshold,\n      _slashAmountForTier2Threshold,\n      _jailDurationForTier2Threshold\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function getUnavailabilitySlashingConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 unavailabilityTier1Threshold_,\n      uint256 unavailabilityTier2Threshold_,\n      uint256 slashAmountForUnavailabilityTier2Threshold_,\n      uint256 jailDurationForUnavailabilityTier2Threshold_\n    )\n  {\n    return (\n      _unavailabilityTier1Threshold,\n      _unavailabilityTier2Threshold,\n      _slashAmountForUnavailabilityTier2Threshold,\n      _jailDurationForUnavailabilityTier2Threshold\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function currentUnavailabilityIndicator(TConsensus consensus) external view override returns (uint256) {\n    return\n      _getUnavailabilityIndicatorById(\n        __css2cid(consensus),\n        IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod()\n      );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function getUnavailabilityIndicator(\n    TConsensus consensus,\n    uint256 period\n  ) external view virtual override returns (uint256) {\n    return _getUnavailabilityIndicatorById(__css2cid(consensus), period);\n  }\n\n  function _getUnavailabilityIndicatorById(\n    address validatorId,\n    uint256 period\n  ) internal view virtual returns (uint256) {\n    return _unavailabilityIndicator[validatorId][period];\n  }\n\n  /**\n   * @dev Sets the unavailability indicator of the `_validator` at `_period`.\n   */\n  function _setUnavailabilityIndicator(address _validator, uint256 _period, uint256 _indicator) internal virtual {\n    _unavailabilityIndicator[_validator][_period] = _indicator;\n  }\n\n  /**\n   * @dev See `ISlashUnavailability-setUnavailabilitySlashingConfigs`.\n   */\n  function _setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) internal {\n    if (_unavailabilityTier1Threshold > _unavailabilityTier2Threshold) revert ErrInvalidThreshold(msg.sig);\n\n    _unavailabilityTier1Threshold = _tier1Threshold;\n    _unavailabilityTier2Threshold = _tier2Threshold;\n    _slashAmountForUnavailabilityTier2Threshold = _slashAmountForTier2Threshold;\n    _jailDurationForUnavailabilityTier2Threshold = _jailDurationForTier2Threshold;\n    emit UnavailabilitySlashingConfigsUpdated(\n      _tier1Threshold,\n      _tier2Threshold,\n      _slashAmountForTier2Threshold,\n      _jailDurationForTier2Threshold\n    );\n  }\n\n  /**\n   * @dev Returns whether the account `_addr` should be slashed or not.\n   */\n  function _shouldSlash(TConsensus consensus, address validatorId) internal view virtual returns (bool);\n\n  /**\n   * @dev See `ICreditScore-checkBailedOutAtPeriodById`\n   */\n  function _checkBailedOutAtPeriodById(address validatorId, uint256 period) internal view virtual returns (bool);\n\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n}\n"
    },
    "contracts/ronin/staking/BaseStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../interfaces/staking/IBaseStaking.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"./RewardCalculation.sol\";\nimport { TPoolId, TConsensus } from \"../../udvts/Types.sol\";\n\nabstract contract BaseStaking is\n  RONTransferHelper,\n  ReentrancyGuard,\n  RewardCalculation,\n  HasContracts,\n  IBaseStaking,\n  HasValidatorDeprecated\n{\n  /// @dev Mapping from pool address (i.e. validator id) => staking pool detail\n  mapping(address => PoolDetail) internal _poolDetail;\n\n  /// @dev The cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n  uint256 internal _cooldownSecsToUndelegate;\n  /// @dev The number of seconds that a candidate must wait to be revoked and take the self-staking amount back.\n  uint256 internal _waitingSecsToRevoke;\n\n  /// @dev Mapping from \"admin address of an active pool\" => \"pool id\".\n  mapping(address => address) internal _adminOfActivePoolMapping;\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[49] private ______gap;\n\n  modifier noEmptyValue() {\n    _requireValue();\n    _;\n  }\n\n  modifier anyExceptPoolAdmin(PoolDetail storage _pool, address delegator) {\n    _anyExceptPoolAdmin(_pool, delegator);\n    _;\n  }\n\n  modifier onlyPoolAdmin(PoolDetail storage _pool, address requester) {\n    _requirePoolAdmin(_pool, requester);\n    _;\n  }\n\n  modifier poolOfConsensusIsActive(TConsensus consensusAddr) {\n    _poolOfConsensusIsActive(consensusAddr);\n    _;\n  }\n\n  function _requireValue() private view {\n    if (msg.value == 0) revert ErrZeroValue();\n  }\n\n  function _requirePoolAdmin(PoolDetail storage _pool, address requester) private view {\n    if (_pool.__shadowedPoolAdmin != requester) revert ErrOnlyPoolAdminAllowed();\n  }\n\n  function _anyExceptPoolAdmin(PoolDetail storage _pool, address delegator) private view {\n    if (_pool.__shadowedPoolAdmin == delegator) revert ErrPoolAdminForbidden();\n  }\n\n  function _poolOfConsensusIsActive(TConsensus consensusAddr) private view {\n    if (!IRoninValidatorSet(getContract(ContractType.VALIDATOR)).isValidatorCandidate(consensusAddr))\n      revert ErrInactivePool(consensusAddr, __css2cid(consensusAddr));\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function isAdminOfActivePool(address admin) public view override returns (bool) {\n    return _adminOfActivePoolMapping[admin] != address(0);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function getPoolAddressOf(address admin) external view override returns (address) {\n    return _adminOfActivePoolMapping[admin];\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function getPoolDetail(\n    TConsensus consensusAddr\n  ) external view returns (address admin, uint256 stakingAmount, uint256 stakingTotal) {\n    address poolId = __css2cid(consensusAddr);\n    return _getPoolDetailById(poolId);\n  }\n\n  function getPoolDetailById(\n    address poolId\n  ) external view returns (address admin, uint256 stakingAmount, uint256 stakingTotal) {\n    return _getPoolDetailById(poolId);\n  }\n\n  function _getPoolDetailById(\n    address poolId\n  ) internal view returns (address admin, uint256 stakingAmount, uint256 stakingTotal) {\n    PoolDetail storage _pool = _poolDetail[poolId];\n    return (_pool.__shadowedPoolAdmin, _pool.stakingAmount, _pool.stakingTotal);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function getManySelfStakings(\n    TConsensus[] calldata consensusAddrs\n  ) external view returns (uint256[] memory selfStakings_) {\n    address[] memory poolIds = __css2cidBatch(consensusAddrs);\n    return _getManySelfStakingsById(poolIds);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function getManySelfStakingsById(address[] calldata poolIds) external view returns (uint256[] memory selfStakings_) {\n    return _getManySelfStakingsById(poolIds);\n  }\n\n  /**\n   * @dev Query many self staking amount by list `poolIds`.\n   */\n  function _getManySelfStakingsById(address[] memory poolIds) internal view returns (uint256[] memory selfStakings_) {\n    selfStakings_ = new uint256[](poolIds.length);\n    for (uint i = 0; i < poolIds.length; ) {\n      selfStakings_[i] = _poolDetail[poolIds[i]].stakingAmount;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getStakingTotal(TConsensus consensusAddr) external view override returns (uint256) {\n    address poolId = __css2cid(consensusAddr);\n    return _getStakingTotal(poolId);\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getManyStakingTotals(\n    TConsensus[] calldata consensusAddrs\n  ) external view override returns (uint256[] memory stakingAmounts_) {\n    address[] memory poolIds = __css2cidBatch(consensusAddrs);\n    return _getManyStakingTotalsById(poolIds);\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getManyStakingTotalsById(\n    address[] calldata poolIds\n  ) external view override returns (uint256[] memory stakingAmounts_) {\n    return _getManyStakingTotalsById(poolIds);\n  }\n\n  function _getManyStakingTotalsById(\n    address[] memory poolIds\n  ) internal view returns (uint256[] memory stakingAmounts_) {\n    stakingAmounts_ = new uint256[](poolIds.length);\n    for (uint i = 0; i < poolIds.length; ) {\n      stakingAmounts_[i] = _getStakingTotal(poolIds[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function _getStakingTotal(address poolId) internal view override returns (uint256) {\n    return _poolDetail[poolId].stakingTotal;\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getStakingAmount(TConsensus consensusAddr, address user) external view override returns (uint256) {\n    address poolId = __css2cid(consensusAddr);\n    return _getStakingAmount(poolId, user);\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getManyStakingAmounts(\n    TConsensus[] calldata consensusAddrs,\n    address[] calldata userList\n  ) external view override returns (uint256[] memory stakingAmounts) {\n    address[] memory poolIds = __css2cidBatch(consensusAddrs);\n    return _getManyStakingAmountsById(poolIds, userList);\n  }\n\n  function getManyStakingAmountsById(\n    address[] calldata poolIds,\n    address[] calldata userList\n  ) external view returns (uint256[] memory stakingAmounts) {\n    return _getManyStakingAmountsById(poolIds, userList);\n  }\n\n  function _getManyStakingAmountsById(\n    address[] memory poolIds,\n    address[] memory userList\n  ) internal view returns (uint256[] memory stakingAmounts) {\n    if (poolIds.length != userList.length) revert ErrInvalidArrays();\n    stakingAmounts = new uint256[](poolIds.length);\n    for (uint i = 0; i < stakingAmounts.length; ) {\n      stakingAmounts[i] = _getStakingAmount(poolIds[i], userList[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function _getStakingAmount(address poolId, address user) internal view override returns (uint256) {\n    return _poolDetail[poolId].delegatingAmount[user];\n  }\n\n  function __css2cid(TConsensus consensusAddr) internal view returns (address) {\n    return IProfile(getContract(ContractType.PROFILE)).getConsensus2Id(consensusAddr);\n  }\n\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view returns (address[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyConsensus2Id(consensusAddrs);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function cooldownSecsToUndelegate() external view returns (uint256) {\n    return _cooldownSecsToUndelegate;\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function waitingSecsToRevoke() external view returns (uint256) {\n    return _waitingSecsToRevoke;\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function setCooldownSecsToUndelegate(uint256 cooldownSecs) external override onlyAdmin {\n    _setCooldownSecsToUndelegate(cooldownSecs);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function setWaitingSecsToRevoke(uint256 secs) external override onlyAdmin {\n    _setWaitingSecsToRevoke(secs);\n  }\n\n  /**\n   * @dev Sets the minium number of seconds to undelegate.\n   *\n   * Emits the event `CooldownSecsToUndelegateUpdated`.\n   *\n   */\n  function _setCooldownSecsToUndelegate(uint256 cooldownSecs) internal {\n    _cooldownSecsToUndelegate = cooldownSecs;\n    emit CooldownSecsToUndelegateUpdated(cooldownSecs);\n  }\n\n  /**\n   * @dev Sets the number of seconds that a candidate must wait to be revoked.\n   *\n   * Emits the event `WaitingSecsToRevokeUpdated`.\n   *\n   */\n  function _setWaitingSecsToRevoke(uint256 secs) internal {\n    _waitingSecsToRevoke = secs;\n    emit WaitingSecsToRevokeUpdated(secs);\n  }\n\n  /**\n   * @dev Changes the delegate amount.\n   */\n  function _changeDelegatingAmount(\n    PoolDetail storage _pool,\n    address delegator,\n    uint256 newDelegatingAmount,\n    uint256 newStakingTotal\n  ) internal {\n    _syncUserReward(_pool.pid, delegator, newDelegatingAmount);\n    _pool.stakingTotal = newStakingTotal;\n    _pool.delegatingAmount[delegator] = newDelegatingAmount;\n  }\n}\n"
    },
    "contracts/ronin/staking/CandidateStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../libraries/AddressArrayUtils.sol\";\nimport \"../../interfaces/staking/ICandidateStaking.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport \"./BaseStaking.sol\";\n\nabstract contract CandidateStaking is BaseStaking, ICandidateStaking, GlobalConfigConsumer, PercentageConsumer {\n  /// @dev The minimum threshold for being a validator candidate.\n  uint256 internal _minValidatorStakingAmount;\n\n  /// @dev The max commission rate that the validator can set (in range of [0;100_00] means [0-100%])\n  uint256 internal _maxCommissionRate;\n  /// @dev The min commission rate that the validator can set (in range of [0;100_00] means [0-100%])\n  uint256 internal _minCommissionRate;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] ______gap;\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function minValidatorStakingAmount() public view override returns (uint256) {\n    return _minValidatorStakingAmount;\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function getCommissionRateRange() external view override returns (uint256, uint256) {\n    return (_minCommissionRate, _maxCommissionRate);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function setMinValidatorStakingAmount(uint256 threshold) external override onlyAdmin {\n    _setMinValidatorStakingAmount(threshold);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function setCommissionRateRange(uint256 minRate, uint256 maxRate) external override onlyAdmin {\n    _setCommissionRateRange(minRate, maxRate);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function applyValidatorCandidate(\n    address candidateAdmin,\n    TConsensus consensusAddr,\n    address payable treasuryAddr,\n    uint256 commissionRate,\n    bytes calldata pubkey\n  ) external payable override nonReentrant {\n    if (isAdminOfActivePool(msg.sender)) revert ErrAdminOfAnyActivePoolForbidden(msg.sender);\n    if (commissionRate > _maxCommissionRate || commissionRate < _minCommissionRate) revert ErrInvalidCommissionRate();\n\n    uint256 amount = msg.value;\n    address payable poolAdmin = payable(msg.sender);\n    address poolId = TConsensus.unwrap(consensusAddr);\n\n    _applyValidatorCandidate({\n      poolAdmin: poolAdmin,\n      candidateAdmin: candidateAdmin,\n      poolId: poolId,\n      treasuryAddr: treasuryAddr,\n      pubkey: pubkey,\n      commissionRate: commissionRate,\n      amount: amount\n    });\n\n    PoolDetail storage _pool = _poolDetail[poolId];\n    _pool.__shadowedPoolAdmin = poolAdmin;\n    _pool.pid = poolId;\n    _adminOfActivePoolMapping[poolAdmin] = poolId;\n\n    _stake(_poolDetail[poolId], poolAdmin, amount);\n    emit PoolApproved(poolId, poolAdmin);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function requestUpdateCommissionRate(\n    TConsensus consensusAddr,\n    uint256 effectiveDaysOnwards,\n    uint256 commissionRate\n  )\n    external\n    override\n    poolOfConsensusIsActive(consensusAddr)\n    onlyPoolAdmin(_poolDetail[__css2cid(consensusAddr)], msg.sender)\n  {\n    if (commissionRate > _maxCommissionRate || commissionRate < _minCommissionRate) revert ErrInvalidCommissionRate();\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execRequestUpdateCommissionRate(\n      __css2cid(consensusAddr),\n      effectiveDaysOnwards,\n      commissionRate\n    );\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function execDeprecatePools(\n    address[] calldata poolIds,\n    uint256 newPeriod\n  ) external override onlyContract(ContractType.VALIDATOR) {\n    if (poolIds.length == 0) {\n      return;\n    }\n\n    for (uint i = 0; i < poolIds.length; ) {\n      address poolId = poolIds[i];\n      PoolDetail storage _pool = _poolDetail[poolId];\n      // Deactivate the pool admin in the active mapping.\n      delete _adminOfActivePoolMapping[_pool.__shadowedPoolAdmin];\n\n      // Deduct and transfer the self staking amount to the pool admin.\n      uint256 deductingAmount = _pool.stakingAmount;\n      if (deductingAmount > 0) {\n        _deductStakingAmount(_pool, deductingAmount);\n        if (!_unsafeSendRONLimitGas(payable(_pool.__shadowedPoolAdmin), deductingAmount, DEFAULT_ADDITION_GAS)) {\n          emit StakingAmountTransferFailed(\n            _pool.pid,\n            _pool.__shadowedPoolAdmin,\n            deductingAmount,\n            address(this).balance\n          );\n        }\n      }\n\n      // Settle the unclaimed reward and transfer to the pool admin.\n      uint256 lastRewardAmount = _claimReward(poolId, _pool.__shadowedPoolAdmin, newPeriod);\n      if (lastRewardAmount > 0) {\n        _unsafeSendRONLimitGas(payable(_pool.__shadowedPoolAdmin), lastRewardAmount, DEFAULT_ADDITION_GAS);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    emit PoolsDeprecated(poolIds);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function stake(\n    TConsensus consensusAddr\n  ) external payable override noEmptyValue poolOfConsensusIsActive(consensusAddr) {\n    address poolId = __css2cid(consensusAddr);\n    _stake(_poolDetail[poolId], msg.sender, msg.value);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function unstake(\n    TConsensus consensusAddr,\n    uint256 amount\n  ) external override nonReentrant poolOfConsensusIsActive(consensusAddr) {\n    if (amount == 0) revert ErrUnstakeZeroAmount();\n    address requester = msg.sender;\n    address poolId = __css2cid(consensusAddr);\n    PoolDetail storage _pool = _poolDetail[poolId];\n    uint256 remainAmount = _pool.stakingAmount - amount;\n    if (remainAmount < _minValidatorStakingAmount) revert ErrStakingAmountLeft();\n\n    _unstake(_pool, requester, amount);\n    if (!_unsafeSendRONLimitGas(payable(requester), amount, DEFAULT_ADDITION_GAS)) revert ErrCannotTransferRON();\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function requestRenounce(\n    TConsensus consensusAddr\n  )\n    external\n    override\n    poolOfConsensusIsActive(consensusAddr)\n    onlyPoolAdmin(_poolDetail[__css2cid(consensusAddr)], msg.sender)\n  {\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execRequestRenounceCandidate(\n      __css2cid(consensusAddr),\n      _waitingSecsToRevoke\n    );\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function requestEmergencyExit(\n    TConsensus consensusAddr\n  )\n    external\n    override\n    poolOfConsensusIsActive(consensusAddr)\n    onlyPoolAdmin(_poolDetail[__css2cid(consensusAddr)], msg.sender)\n  {\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execRequestEmergencyExit(\n      __css2cid(consensusAddr),\n      _waitingSecsToRevoke\n    );\n  }\n\n  /**\n   * @dev See `ICandidateStaking-applyValidatorCandidate`\n   */\n  function _applyValidatorCandidate(\n    address payable poolAdmin,\n    address candidateAdmin,\n    address poolId,\n    address payable treasuryAddr,\n    bytes memory pubkey,\n    uint256 commissionRate,\n    uint256 amount\n  ) internal {\n    if (!_unsafeSendRONLimitGas(poolAdmin, 0, DEFAULT_ADDITION_GAS)) {\n      revert ErrCannotInitTransferRON(poolAdmin, \"pool admin\");\n    }\n    if (!_unsafeSendRONLimitGas(treasuryAddr, 0, DEFAULT_ADDITION_GAS)) {\n      revert ErrCannotInitTransferRON(treasuryAddr, \"treasury\");\n    }\n    if (amount < _minValidatorStakingAmount) revert ErrInsufficientStakingAmount();\n    if (poolAdmin != candidateAdmin || candidateAdmin != treasuryAddr) revert ErrThreeInteractionAddrsNotEqual();\n\n    {\n      address[] memory diffAddrs = new address[](3);\n      diffAddrs[0] = poolAdmin;\n      diffAddrs[1] = poolId;\n      if (AddressArrayUtils.hasDuplicate(diffAddrs)) revert AddressArrayUtils.ErrDuplicated(msg.sig);\n    }\n\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execApplyValidatorCandidate({\n      candidateAdmin: candidateAdmin,\n      cid: poolId,\n      treasuryAddr: treasuryAddr,\n      commissionRate: commissionRate\n    });\n\n    IProfile profileContract = IProfile(getContract(ContractType.PROFILE));\n    profileContract.execApplyValidatorCandidate(candidateAdmin, poolId, treasuryAddr, pubkey);\n  }\n\n  /**\n   * @dev See `ICandidateStaking-stake`\n   */\n  function _stake(\n    PoolDetail storage _pool,\n    address requester,\n    uint256 amount\n  ) internal onlyPoolAdmin(_pool, requester) {\n    _pool.stakingAmount += amount;\n    _changeDelegatingAmount(_pool, requester, _pool.stakingAmount, _pool.stakingTotal + amount);\n    _pool.lastDelegatingTimestamp[requester] = block.timestamp;\n    emit Staked(_pool.pid, amount);\n  }\n\n  /**\n   * @dev See `ICandidateStaking-unstake`\n   */\n  function _unstake(\n    PoolDetail storage _pool,\n    address requester,\n    uint256 amount\n  ) internal onlyPoolAdmin(_pool, requester) {\n    if (amount > _pool.stakingAmount) revert ErrInsufficientStakingAmount();\n    if (_pool.lastDelegatingTimestamp[requester] + _cooldownSecsToUndelegate > block.timestamp) {\n      revert ErrUnstakeTooEarly();\n    }\n\n    _pool.stakingAmount -= amount;\n    _changeDelegatingAmount(_pool, requester, _pool.stakingAmount, _pool.stakingTotal - amount);\n    emit Unstaked(_pool.pid, amount);\n  }\n\n  /**\n   * @dev Deducts from staking amount of the validator `_consensusAddr` for `_amount`.\n   *\n   * Emits the event `Unstaked`.\n   *\n   * @return The actual deducted amount\n   */\n  function _deductStakingAmount(PoolDetail storage _pool, uint256 amount) internal virtual returns (uint256);\n\n  /**\n   * @dev Sets the minimum threshold for being a validator candidate.\n   *\n   * Emits the `MinValidatorStakingAmountUpdated` event.\n   *\n   */\n  function _setMinValidatorStakingAmount(uint256 threshold) internal {\n    _minValidatorStakingAmount = threshold;\n    emit MinValidatorStakingAmountUpdated(threshold);\n  }\n\n  /**\n   * @dev Sets the max commission rate that a candidate can set.\n   *\n   * Emits the `MaxCommissionRateUpdated` event.\n   *\n   */\n  function _setCommissionRateRange(uint256 minRate, uint256 maxRate) internal {\n    if (maxRate > _MAX_PERCENTAGE || minRate > maxRate) revert ErrInvalidCommissionRate();\n    _maxCommissionRate = maxRate;\n    _minCommissionRate = minRate;\n    emit CommissionRateRangeUpdated(minRate, maxRate);\n  }\n}\n"
    },
    "contracts/ronin/staking/DelegatorStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/staking/IDelegatorStaking.sol\";\nimport \"./BaseStaking.sol\";\n\nabstract contract DelegatorStaking is BaseStaking, IDelegatorStaking {\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function delegate(TConsensus consensusAddr) external payable noEmptyValue poolOfConsensusIsActive(consensusAddr) {\n    if (isAdminOfActivePool(msg.sender)) revert ErrAdminOfAnyActivePoolForbidden(msg.sender);\n    _delegate(_poolDetail[__css2cid(consensusAddr)], msg.sender, msg.value);\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function undelegate(TConsensus consensusAddr, uint256 amount) external nonReentrant {\n    address payable delegator = payable(msg.sender);\n    _undelegate(consensusAddr, _poolDetail[__css2cid(consensusAddr)], delegator, amount);\n    if (!_sendRON(delegator, amount)) revert ErrCannotTransferRON();\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function bulkUndelegate(TConsensus[] calldata consensusAddrs, uint256[] calldata amounts) external nonReentrant {\n    if (consensusAddrs.length == 0 || consensusAddrs.length != amounts.length) revert ErrInvalidArrays();\n\n    address payable delegator = payable(msg.sender);\n    uint256 total;\n\n    address[] memory poolIds = __css2cidBatch(consensusAddrs);\n    for (uint i = 0; i < poolIds.length; ) {\n      total += amounts[i];\n      _undelegate(consensusAddrs[i], _poolDetail[poolIds[i]], delegator, amounts[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    if (!_sendRON(delegator, total)) revert ErrCannotTransferRON();\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function redelegate(\n    TConsensus consensusAddrSrc,\n    TConsensus consensusAddrDst,\n    uint256 amount\n  ) external nonReentrant poolOfConsensusIsActive(consensusAddrDst) {\n    address delegator = msg.sender;\n    _undelegate(consensusAddrSrc, _poolDetail[__css2cid(consensusAddrSrc)], delegator, amount);\n    _delegate(_poolDetail[__css2cid(consensusAddrDst)], delegator, amount);\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function claimRewards(\n    TConsensus[] calldata consensusAddrList\n  ) external override nonReentrant returns (uint256 amount) {\n    amount = _claimRewards(msg.sender, __css2cidBatch(consensusAddrList));\n    _transferRON(payable(msg.sender), amount);\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function delegateRewards(\n    TConsensus[] calldata consensusAddrList,\n    TConsensus consensusAddrDst\n  ) external override nonReentrant poolOfConsensusIsActive(consensusAddrDst) returns (uint256 amount) {\n    if (isAdminOfActivePool(msg.sender)) revert ErrAdminOfAnyActivePoolForbidden(msg.sender);\n    address[] memory poolIds = __css2cidBatch(consensusAddrList);\n    address poolIdDst = __css2cid(consensusAddrDst);\n    return _delegateRewards(msg.sender, poolIds, poolIdDst);\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function getRewards(\n    address user,\n    TConsensus[] calldata consensusAddrs\n  ) external view returns (uint256[] memory rewards_) {\n    uint256 period = IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod();\n    rewards_ = new uint256[](consensusAddrs.length);\n\n    address[] memory poolIds = __css2cidBatch(consensusAddrs);\n    for (uint256 i = 0; i < consensusAddrs.length; ) {\n      address poolId = poolIds[i];\n      rewards_[i] = _getReward(poolId, user, period, _getStakingAmount(poolId, user));\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Delegates from a validator address.\n   *\n   * Requirements:\n   * - The delegator is not the pool admin.\n   *\n   * Emits the `Delegated` event.\n   *\n   * Note: This function does not verify the `msg.value` with the amount.\n   *\n   */\n  function _delegate(\n    PoolDetail storage _pool,\n    address delegator,\n    uint256 amount\n  ) internal anyExceptPoolAdmin(_pool, delegator) {\n    _changeDelegatingAmount(_pool, delegator, _pool.delegatingAmount[delegator] + amount, _pool.stakingTotal + amount);\n    _pool.lastDelegatingTimestamp[delegator] = block.timestamp;\n    emit Delegated(delegator, _pool.pid, amount);\n  }\n\n  /**\n   * @dev Undelegates from a validator address.\n   *\n   * Requirements:\n   * - The delegator is not the pool admin.\n   * - The amount is larger than 0.\n   * - The delegating amount is larger than or equal to the undelegating amount.\n   *\n   * Emits the `Undelegated` event.\n   *\n   * Note: Consider transferring back the amount of RON after calling this function.\n   *\n   */\n  function _undelegate(\n    TConsensus consensusAddr,\n    PoolDetail storage _pool,\n    address delegator,\n    uint256 amount\n  ) private anyExceptPoolAdmin(_pool, delegator) {\n    if (amount == 0) revert ErrUndelegateZeroAmount();\n    if (_pool.delegatingAmount[delegator] < amount) revert ErrInsufficientDelegatingAmount();\n\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    if (\n      validatorContract.isValidatorCandidate(consensusAddr) &&\n      validatorContract.getCandidateInfo(consensusAddr).revokingTimestamp == 0 && // if candidate is not on renunciation\n      _pool.lastDelegatingTimestamp[delegator] + _cooldownSecsToUndelegate >= block.timestamp // delegator is still in cooldown\n    ) revert ErrUndelegateTooEarly();\n\n    _changeDelegatingAmount(_pool, delegator, _pool.delegatingAmount[delegator] - amount, _pool.stakingTotal - amount);\n    emit Undelegated(delegator, _pool.pid, amount);\n  }\n\n  /**\n   * @dev Claims rewards from the pools `_poolAddrList`.\n   * Note: This function does not transfer reward to user.\n   */\n  function _claimRewards(address user, address[] memory poolIds) internal returns (uint256 amount) {\n    uint256 period = _currentPeriod();\n    for (uint256 i = 0; i < poolIds.length; ) {\n      amount += _claimReward(poolIds[i], user, period);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Claims the rewards and delegates them to the consensus address.\n   */\n  function _delegateRewards(\n    address user,\n    address[] memory poolIds,\n    address poolIdDst\n  ) internal returns (uint256 amount) {\n    amount = _claimRewards(user, poolIds);\n    _delegate(_poolDetail[poolIdDst], user, amount);\n  }\n}\n"
    },
    "contracts/ronin/staking/RewardCalculation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/staking/IRewardPool.sol\";\nimport \"../../libraries/Math.sol\";\nimport { TPoolId } from \"../../udvts/Types.sol\";\n\n/**\n * @title RewardCalculation contract\n * @dev This contract mainly contains the methods to calculate reward for staking contract.\n */\nabstract contract RewardCalculation is IRewardPool {\n  /// @dev Mapping from pool address => period number => accumulated rewards per share (one unit staking)\n  mapping(address => mapping(uint256 => PeriodWrapper)) private _accumulatedRps;\n  /// @dev Mapping from the pool address => user address => the reward info of the user\n  mapping(address => mapping(address => UserRewardFields)) private _userReward;\n  /// @dev Mapping from the pool address => reward pool fields\n  mapping(address => PoolFields) private _stakingPool;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getReward(TConsensus consensusAddr, address user) external view returns (uint256) {\n    address poolId = TConsensus.unwrap(consensusAddr);\n    return _getReward(poolId, user, _currentPeriod(), _getStakingAmount(poolId, user));\n  }\n\n  /**\n   * @dev See {IRewardPool-getStakingAmount}\n   */\n  function _getStakingAmount(address poolId, address user) internal view virtual returns (uint256);\n\n  /**\n   * @dev See {IRewardPool-getStakingTotal}\n   */\n  function _getStakingTotal(address poolId) internal view virtual returns (uint256);\n\n  /**\n   * @dev Returns the reward amount that user claimable.\n   */\n  function _getReward(\n    address poolId,\n    address user,\n    uint256 latestPeriod,\n    uint256 latestStakingAmount\n  ) internal view returns (uint256) {\n    UserRewardFields storage _reward = _userReward[poolId][user];\n\n    if (_reward.lastPeriod == latestPeriod) {\n      return _reward.debited;\n    }\n\n    uint256 aRps;\n    uint256 lastPeriodReward;\n    PoolFields storage _pool = _stakingPool[poolId];\n    PeriodWrapper storage _wrappedArps = _accumulatedRps[poolId][_reward.lastPeriod];\n\n    if (_wrappedArps.lastPeriod > 0) {\n      // Calculates the last period reward if the aRps at the period is set\n      aRps = _wrappedArps.inner;\n      lastPeriodReward = _reward.lowestAmount * (aRps - _reward.aRps);\n    } else {\n      // Fallbacks to the previous aRps in case the aRps is not set\n      aRps = _reward.aRps;\n    }\n\n    uint256 newPeriodsReward = latestStakingAmount * (_pool.aRps - aRps);\n    return _reward.debited + (lastPeriodReward + newPeriodsReward) / 1e18;\n  }\n\n  /**\n   * @dev Syncs the user reward.\n   *\n   * Emits the event `UserRewardUpdated` once the debit amount is updated.\n   * Emits the event `PoolSharesUpdated` once the pool share is updated.\n   *\n   * Note: The method should be called whenever the user's staking amount changes.\n   *\n   */\n  function _syncUserReward(address poolId, address user, uint256 newStakingAmount) internal {\n    uint256 period = _currentPeriod();\n    PoolFields storage _pool = _stakingPool[poolId];\n    uint256 lastShares = _pool.shares.inner;\n\n    // Updates the pool shares if it is outdated\n    if (_pool.shares.lastPeriod < period) {\n      _pool.shares = PeriodWrapper(_getStakingTotal(poolId), period);\n    }\n\n    UserRewardFields storage _reward = _userReward[poolId][user];\n    uint256 currentStakingAmount = _getStakingAmount(poolId, user);\n    uint256 debited = _getReward(poolId, user, period, currentStakingAmount);\n\n    if (_reward.debited != debited) {\n      _reward.debited = debited;\n      emit UserRewardUpdated(poolId, user, debited);\n    }\n\n    _syncMinStakingAmount(_pool, _reward, period, newStakingAmount, currentStakingAmount);\n    _reward.aRps = _pool.aRps;\n    _reward.lastPeriod = period;\n\n    if (_pool.shares.inner != lastShares) {\n      emit PoolSharesUpdated(period, poolId, _pool.shares.inner);\n    }\n  }\n\n  /**\n   * @dev Syncs the minimum staking amount of an user in the current period.\n   */\n  function _syncMinStakingAmount(\n    PoolFields storage _pool,\n    UserRewardFields storage _reward,\n    uint256 latestPeriod,\n    uint256 newStakingAmount,\n    uint256 currentStakingAmount\n  ) internal {\n    if (_reward.lastPeriod < latestPeriod) {\n      _reward.lowestAmount = currentStakingAmount;\n    }\n\n    uint256 lowestAmount = Math.min(_reward.lowestAmount, newStakingAmount);\n    uint256 diffAmount = _reward.lowestAmount - lowestAmount;\n    if (diffAmount > 0) {\n      _reward.lowestAmount = lowestAmount;\n      if (_pool.shares.inner < diffAmount) revert ErrInvalidPoolShare();\n      _pool.shares.inner -= diffAmount;\n    }\n  }\n\n  /**\n   * @dev Claims the settled reward for a specific user.\n   *\n   * @param lastPeriod Must be in two possible value: `_currentPeriod` in normal calculation, or\n   * `_currentPeriod + 1` in case of calculating the reward for revoked validators.\n   *\n   * Emits the `RewardClaimed` event and the `UserRewardUpdated` event.\n   *\n   * Note: This method should be called before transferring rewards for the user.\n   *\n   */\n  function _claimReward(address poolId, address user, uint256 lastPeriod) internal returns (uint256 amount) {\n    uint256 currentStakingAmount = _getStakingAmount(poolId, user);\n    amount = _getReward(poolId, user, lastPeriod, currentStakingAmount);\n    emit RewardClaimed(poolId, user, amount);\n\n    UserRewardFields storage _reward = _userReward[poolId][user];\n    _reward.debited = 0;\n    _syncMinStakingAmount(_stakingPool[poolId], _reward, lastPeriod, currentStakingAmount, currentStakingAmount);\n    _reward.lastPeriod = lastPeriod;\n    _reward.aRps = _stakingPool[poolId].aRps;\n    emit UserRewardUpdated(poolId, user, 0);\n  }\n\n  /**\n   * @dev Records the amount of rewards `_rewards` for the pools `poolIds`.\n   *\n   * Emits the event `PoolsUpdated` once the contract recorded the rewards successfully.\n   * Emits the event `PoolsUpdateFailed` once the input array lengths are not equal.\n   * Emits the event `PoolUpdateConflicted` when the pool is already updated in the period.\n   *\n   * Note: This method should be called once at the period ending.\n   *\n   */\n  function _recordRewards(address[] memory poolIds, uint256[] calldata rewards, uint256 period) internal {\n    if (poolIds.length != rewards.length) {\n      emit PoolsUpdateFailed(period, poolIds, rewards);\n      return;\n    }\n\n    uint256 rps;\n    uint256 count;\n    address poolId;\n    uint256 stakingTotal;\n    uint256[] memory aRps = new uint256[](poolIds.length);\n    uint256[] memory shares = new uint256[](poolIds.length);\n    address[] memory conflicted = new address[](poolIds.length);\n\n    for (uint i = 0; i < poolIds.length; i++) {\n      poolId = poolIds[i];\n      PoolFields storage _pool = _stakingPool[poolId];\n      stakingTotal = _getStakingTotal(poolId);\n\n      if (_accumulatedRps[poolId][period].lastPeriod == period) {\n        unchecked {\n          conflicted[count++] = poolId;\n        }\n        continue;\n      }\n\n      // Updates the pool shares if it is outdated\n      if (_pool.shares.lastPeriod < period) {\n        _pool.shares = PeriodWrapper(stakingTotal, period);\n      }\n\n      // The rps is 0 if no one stakes for the pool\n      rps = _pool.shares.inner == 0 ? 0 : (rewards[i] * 1e18) / _pool.shares.inner;\n      aRps[i - count] = _pool.aRps += rps;\n      _accumulatedRps[poolId][period] = PeriodWrapper(_pool.aRps, period);\n      _pool.shares.inner = stakingTotal;\n      shares[i - count] = _pool.shares.inner;\n      poolIds[i - count] = poolId;\n    }\n\n    if (count > 0) {\n      assembly {\n        mstore(conflicted, count)\n        mstore(poolIds, sub(mload(poolIds), count))\n      }\n      emit PoolsUpdateConflicted(period, conflicted);\n    }\n\n    if (poolIds.length > 0) {\n      emit PoolsUpdated(period, poolIds, aRps, shares);\n    }\n  }\n\n  /**\n   * @dev Returns the current period.\n   */\n  function _currentPeriod() internal view virtual returns (uint256);\n}\n"
    },
    "contracts/ronin/staking/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../libraries/Math.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"./StakingCallback.sol\";\n\ncontract Staking is IStaking, StakingCallback, Initializable {\n  constructor() {\n    _disableInitializers();\n  }\n\n  receive() external payable onlyContract(ContractType.VALIDATOR) {}\n\n  fallback() external payable onlyContract(ContractType.VALIDATOR) {}\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __validatorContract,\n    uint256 __minValidatorStakingAmount,\n    uint256 __maxCommissionRate,\n    uint256 __cooldownSecsToUndelegate,\n    uint256 __waitingSecsToRevoke\n  ) external initializer {\n    _setContract(ContractType.VALIDATOR, __validatorContract);\n    _setMinValidatorStakingAmount(__minValidatorStakingAmount);\n    _setCommissionRateRange(0, __maxCommissionRate);\n    _setCooldownSecsToUndelegate(__cooldownSecsToUndelegate);\n    _setWaitingSecsToRevoke(__waitingSecsToRevoke);\n  }\n\n  /**\n   * @dev Initializes the contract storage V2.\n   */\n  function initializeV2() external reinitializer(2) {\n    _setContract(ContractType.VALIDATOR, ______deprecatedValidator);\n    delete ______deprecatedValidator;\n  }\n\n  /**\n   * @dev Initializes the contract storage V3.\n   */\n  function initializeV3(address __profileContract) external reinitializer(3) {\n    _setContract(ContractType.PROFILE, __profileContract);\n  }\n\n  /**\n   * @inheritdoc IStaking\n   */\n  function execRecordRewards(\n    address[] calldata poolIds,\n    uint256[] calldata rewards,\n    uint256 period\n  ) external payable override onlyContract(ContractType.VALIDATOR) {\n    _recordRewards(poolIds, rewards, period);\n  }\n\n  /**\n   * @inheritdoc IStaking\n   */\n  function execDeductStakingAmount(\n    address poolId,\n    uint256 amount\n  ) external override onlyContract(ContractType.VALIDATOR) returns (uint256 actualDeductingAmount_) {\n    actualDeductingAmount_ = _deductStakingAmount(_poolDetail[poolId], amount);\n    address payable validatorContractAddr = payable(msg.sender);\n    if (!_unsafeSendRON(validatorContractAddr, actualDeductingAmount_)) {\n      emit StakingAmountDeductFailed(poolId, validatorContractAddr, actualDeductingAmount_, address(this).balance);\n    }\n  }\n\n  /**\n   * @inheritdoc RewardCalculation\n   */\n  function _currentPeriod() internal view virtual override returns (uint256) {\n    return IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod();\n  }\n\n  /**\n   * @inheritdoc CandidateStaking\n   */\n  function _deductStakingAmount(\n    PoolDetail storage _pool,\n    uint256 amount\n  ) internal override returns (uint256 actualDeductingAmount_) {\n    actualDeductingAmount_ = Math.min(_pool.stakingAmount, amount);\n\n    _pool.stakingAmount -= actualDeductingAmount_;\n    _changeDelegatingAmount(\n      _pool,\n      _pool.__shadowedPoolAdmin,\n      _pool.stakingAmount,\n      Math.subNonNegative(_pool.stakingTotal, actualDeductingAmount_)\n    );\n    emit Unstaked(_pool.pid, actualDeductingAmount_);\n  }\n}\n"
    },
    "contracts/ronin/staking/StakingCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../../interfaces/IProfile.sol\";\nimport \"../../interfaces/staking/IStakingCallback.sol\";\nimport \"./CandidateStaking.sol\";\nimport \"./DelegatorStaking.sol\";\n\npragma solidity ^0.8.9;\n\nabstract contract StakingCallback is CandidateStaking, DelegatorStaking, IStakingCallback {\n  /**\n   * @dev Requirements:\n   * - Only Profile contract can call this method.\n   */\n  function execChangeAdminAddress(\n    address poolAddr,\n    address newAdminAddr\n  ) external override onlyContract(ContractType.PROFILE) {\n    PoolDetail storage _pool = _poolDetail[poolAddr];\n\n    _adminOfActivePoolMapping[_pool.__shadowedPoolAdmin] = address(0);\n    _pool.__shadowedPoolAdmin = newAdminAddr;\n    _adminOfActivePoolMapping[newAdminAddr] = poolAddr;\n  }\n}\n"
    },
    "contracts/ronin/validator/CandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../interfaces/validator/ICandidateManager.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport { HasStakingDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\nabstract contract CandidateManager is\n  ICandidateManager,\n  PercentageConsumer,\n  GlobalConfigConsumer,\n  HasContracts,\n  HasStakingDeprecated\n{\n  /// @dev Maximum number of validator candidate\n  uint256 private _maxValidatorCandidate;\n\n  /// @dev The array of candidate ids\n  address[] internal _candidateIds;\n  /// @dev Mapping from candidate id => bitwise negation of validator index in `_candidates`\n  mapping(address => uint256) internal _candidateIndex;\n  /// @dev Mapping from candidate id => their info\n  mapping(address => ValidatorCandidate) internal _candidateInfo;\n\n  /**\n   * @dev The minimum offset in day from current date to the effective date of a new commission schedule.\n   * Value of 1 means the change gets affected at the beginning of the following day.\n   **/\n  uint256 internal _minEffectiveDaysOnwards;\n  /// @dev Mapping from candidate consensus id => schedule commission change.\n  mapping(address => CommissionSchedule) internal _candidateCommissionChangeSchedule;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] private ______gap;\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function maxValidatorCandidate() public view override returns (uint256) {\n    return _maxValidatorCandidate;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function minEffectiveDaysOnward() external view override returns (uint256) {\n    return _minEffectiveDaysOnwards;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function setMaxValidatorCandidate(uint256 _number) external override onlyAdmin {\n    _setMaxValidatorCandidate(_number);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external override onlyAdmin {\n    _setMinEffectiveDaysOnwards(_numOfDays);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function isValidatorCandidate(TConsensus consensus) external view override returns (bool) {\n    return _isValidatorCandidateById(__css2cid(consensus));\n  }\n\n  function _isValidatorCandidateById(address cid) internal view returns (bool) {\n    return _candidateIndex[cid] != 0;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCandidateInfos() external view override returns (ValidatorCandidate[] memory list) {\n    list = new ValidatorCandidate[](_candidateIds.length);\n    for (uint i; i < list.length; ) {\n      list[i] = _candidateInfo[_candidateIds[i]];\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCandidateInfo(TConsensus consensus) external view override returns (ValidatorCandidate memory) {\n    address validatorId = __css2cid(consensus);\n    if (!_isValidatorCandidateById(validatorId)) revert ErrNonExistentCandidate();\n    return _candidateInfo[validatorId];\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getValidatorCandidates() public view override returns (address[] memory) {\n    return _candidateIds;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCommissionChangeSchedule(\n    TConsensus consensus\n  ) external view override returns (CommissionSchedule memory) {\n    return _candidateCommissionChangeSchedule[__css2cid(consensus)];\n  }\n\n  /**\n   * @dev Removes unsastisfied candidates, the ones who have insufficient minimum candidate staking amount,\n   * or the ones who requested to renounce their candidate role.\n   *\n   * Emits the event `CandidatesRevoked` when a candidate is revoked.\n   *\n   */\n  function _syncCandidateSet(uint256 _nextPeriod) internal returns (address[] memory _unsatisfiedCandidates) {\n    IStaking _staking = IStaking(getContract(ContractType.STAKING));\n    uint256 _waitingSecsToRevoke = _staking.waitingSecsToRevoke();\n    uint256 _minStakingAmount = _staking.minValidatorStakingAmount();\n    uint256[] memory _selfStakings = _staking.getManySelfStakingsById(_candidateIds);\n\n    uint256 _length = _candidateIds.length;\n    uint256 _unsatisfiedCount;\n    _unsatisfiedCandidates = new address[](_length);\n\n    {\n      uint256 _i;\n      address cid;\n      ValidatorCandidate storage _info;\n      while (_i < _length) {\n        cid = _candidateIds[_i];\n        _info = _candidateInfo[cid];\n\n        // Checks for under-balance status of candidates\n        bool _hasTopupDeadline = _info.topupDeadline != 0;\n        if (_selfStakings[_i] < _minStakingAmount) {\n          // Updates deadline on the first time unsatisfied the staking amount condition\n          if (!_hasTopupDeadline) {\n            uint256 _topupDeadline = block.timestamp + _waitingSecsToRevoke;\n            _info.topupDeadline = _topupDeadline;\n            emit CandidateTopupDeadlineUpdated(cid, _topupDeadline);\n          }\n        } else if (_hasTopupDeadline) {\n          // Removes the deadline if the staking amount condition is satisfied\n          delete _info.topupDeadline;\n          emit CandidateTopupDeadlineUpdated(cid, 0);\n        }\n\n        // Removes unsastisfied candidates\n        bool _revokingActivated = (_info.revokingTimestamp != 0 && _info.revokingTimestamp <= block.timestamp) ||\n          _emergencyExitLockedFundReleased(cid);\n        bool _topupDeadlineMissed = _info.topupDeadline != 0 && _info.topupDeadline <= block.timestamp;\n        if (_revokingActivated || _topupDeadlineMissed) {\n          _selfStakings[_i] = _selfStakings[--_length];\n          unchecked {\n            _unsatisfiedCandidates[_unsatisfiedCount++] = cid;\n          }\n          _removeCandidate(cid);\n          continue;\n        }\n\n        // Checks for schedule of commission change and updates commission rate\n        uint256 _scheduleTimestamp = _candidateCommissionChangeSchedule[cid].effectiveTimestamp;\n        if (_scheduleTimestamp != 0 && _scheduleTimestamp <= block.timestamp) {\n          uint256 _commisionRate = _candidateCommissionChangeSchedule[cid].commissionRate;\n          delete _candidateCommissionChangeSchedule[cid];\n          _info.commissionRate = _commisionRate;\n          emit CommissionRateUpdated(cid, _commisionRate);\n        }\n\n        unchecked {\n          _i++;\n        }\n      }\n    }\n\n    assembly {\n      mstore(_unsatisfiedCandidates, _unsatisfiedCount)\n    }\n\n    if (_unsatisfiedCount > 0) {\n      emit CandidatesRevoked(_unsatisfiedCandidates);\n      _staking.execDeprecatePools(_unsatisfiedCandidates, _nextPeriod);\n    }\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function isCandidateAdmin(TConsensus consensusAddr, address admin) external view override returns (bool) {\n    return _isCandidateAdminById(__css2cid(consensusAddr), admin);\n  }\n\n  function _isCandidateAdminById(address candidateId, address admin) internal view returns (bool) {\n    return _candidateInfo[candidateId].__shadowedAdmin == admin;\n  }\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function _setMaxValidatorCandidate(uint256 _threshold) internal {\n    _maxValidatorCandidate = _threshold;\n    emit MaxValidatorCandidateUpdated(_threshold);\n  }\n\n  /**\n   * @dev Sets the minimum number of days onwards to the effective date of commission rate change.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function _setMinEffectiveDaysOnwards(uint256 _numOfDays) internal {\n    if (_numOfDays < 1) revert ErrInvalidMinEffectiveDaysOnwards();\n    _minEffectiveDaysOnwards = _numOfDays;\n    emit MinEffectiveDaysOnwardsUpdated(_numOfDays);\n  }\n\n  /**\n   * @dev Removes the candidate.\n   */\n  function _removeCandidate(address _addr) internal virtual {\n    uint256 idx = _candidateIndex[_addr];\n    if (idx == 0) {\n      return;\n    }\n\n    delete _candidateInfo[_addr];\n    delete _candidateIndex[_addr];\n    delete _candidateCommissionChangeSchedule[_addr];\n\n    address lastCid = _candidateIds[_candidateIds.length - 1];\n    if (lastCid != _addr) {\n      _candidateIndex[lastCid] = idx;\n      _candidateIds[~idx] = lastCid;\n    }\n\n    _candidateIds.pop();\n  }\n\n  /**\n   * @dev Sets timestamp to revoke a candidate.\n   */\n  function _setRevokingTimestamp(ValidatorCandidate storage _candidate, uint256 timestamp) internal {\n    address cid = __css2cid(_candidate.__shadowedConsensus);\n    if (!_isValidatorCandidateById(cid)) revert ErrNonExistentCandidate();\n    _candidate.revokingTimestamp = timestamp;\n    emit CandidateRevokingTimestampUpdated(cid, timestamp);\n  }\n\n  /**\n   * @dev Returns a flag indicating whether the fund is unlocked.\n   */\n  function _emergencyExitLockedFundReleased(address _consensusAddr) internal virtual returns (bool);\n\n  /**\n   * @dev Returns whether the validator id is a trusted org or not.\n   */\n  function _isTrustedOrg(address validatorId) internal virtual returns (bool);\n\n  /// @dev See {RoninValidatorSet-__css2cid}\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n\n  /// @dev See {RoninValidatorSet-__css2cidBatch}\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view virtual returns (address[] memory);\n}\n"
    },
    "contracts/ronin/validator/CandidateManagerCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/validator/ICandidateManagerCallback.sol\";\nimport \"./CandidateManager.sol\";\n\nabstract contract CandidateManagerCallback is ICandidateManagerCallback, CandidateManager {\n  //                                             //\n  // ----------- Staking's Callbacks ----------- //\n  //                                             //\n\n  /**\n   * @inheritdoc ICandidateManagerCallback\n   */\n  function execApplyValidatorCandidate(\n    address candidateAdmin,\n    address cid,\n    address payable treasuryAddr,\n    uint256 commissionRate\n  ) external override onlyContract(ContractType.STAKING) {\n    uint256 length = _candidateIds.length;\n    if (length >= maxValidatorCandidate()) revert ErrExceedsMaxNumberOfCandidate();\n    if (_isValidatorCandidateById(cid)) revert ErrExistentCandidate();\n    if (commissionRate > _MAX_PERCENTAGE) revert ErrInvalidCommissionRate();\n\n    for (uint i; i < length; ) {\n      ValidatorCandidate storage existentInfo = _candidateInfo[_candidateIds[i]];\n      if (candidateAdmin == existentInfo.__shadowedAdmin) revert ErrExistentCandidateAdmin(candidateAdmin);\n      if (treasuryAddr == existentInfo.__shadowedTreasury) revert ErrExistentTreasury(treasuryAddr);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    _candidateIndex[cid] = ~length;\n    _candidateIds.push(cid);\n\n    ValidatorCandidate storage _info = _candidateInfo[cid];\n    _info.__shadowedAdmin = candidateAdmin;\n    _info.__shadowedConsensus = TConsensus.wrap(cid);\n    _info.__shadowedTreasury = treasuryAddr;\n    _info.commissionRate = commissionRate;\n    emit CandidateGranted(cid, treasuryAddr, candidateAdmin);\n  }\n\n  /**\n   * @inheritdoc ICandidateManagerCallback\n   */\n  function execRequestRenounceCandidate(\n    address cid,\n    uint256 secsLeft\n  ) external override onlyContract(ContractType.STAKING) {\n    if (_isTrustedOrg(cid)) revert ErrTrustedOrgCannotRenounce();\n\n    ValidatorCandidate storage _info = _candidateInfo[cid];\n    if (_info.revokingTimestamp != 0) revert ErrAlreadyRequestedRevokingCandidate();\n    _setRevokingTimestamp(_info, block.timestamp + secsLeft);\n  }\n\n  /**\n   * @inheritdoc ICandidateManagerCallback\n   */\n  function execRequestUpdateCommissionRate(\n    address cid,\n    uint256 effectiveDaysOnwards,\n    uint256 commissionRate\n  ) external override onlyContract(ContractType.STAKING) {\n    if (_candidateCommissionChangeSchedule[cid].effectiveTimestamp != 0) {\n      revert ErrAlreadyRequestedUpdatingCommissionRate();\n    }\n    if (commissionRate > _MAX_PERCENTAGE) revert ErrInvalidCommissionRate();\n    if (effectiveDaysOnwards < _minEffectiveDaysOnwards) revert ErrInvalidEffectiveDaysOnwards();\n\n    CommissionSchedule storage _schedule = _candidateCommissionChangeSchedule[cid];\n    uint256 effectiveTimestamp = ((block.timestamp / PERIOD_DURATION) + effectiveDaysOnwards) * PERIOD_DURATION;\n    _schedule.effectiveTimestamp = effectiveTimestamp;\n    _schedule.commissionRate = commissionRate;\n\n    emit CommissionRateUpdateScheduled(cid, effectiveTimestamp, commissionRate);\n  }\n\n  //                                             //\n  // ----------- Profile's Callbacks ----------- //\n  //                                             //\n\n  /**\n   * @inheritdoc ICandidateManagerCallback\n   */\n  function execChangeConsensusAddress(\n    address cid,\n    TConsensus newConsensusAddr\n  ) external override onlyContract(ContractType.PROFILE) {\n    _candidateInfo[cid].__shadowedConsensus = newConsensusAddr;\n  }\n\n  /**\n   * @inheritdoc ICandidateManagerCallback\n   */\n  function execChangeAdminAddress(address cid, address newAdmin) external onlyContract(ContractType.PROFILE) {\n    _candidateInfo[cid].__shadowedAdmin = newAdmin;\n  }\n\n  /**\n   * @inheritdoc ICandidateManagerCallback\n   */\n  function execChangeTreasuryAddress(\n    address cid,\n    address payable newTreasury\n  ) external onlyContract(ContractType.PROFILE) {\n    _candidateInfo[cid].__shadowedTreasury = newTreasury;\n  }\n}\n"
    },
    "contracts/ronin/validator/CoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport \"../../interfaces/IStakingVesting.sol\";\nimport \"../../interfaces/IMaintenance.sol\";\nimport \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../interfaces/IFastFinalityTracking.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../interfaces/slash-indicator/ISlashIndicator.sol\";\nimport \"../../interfaces/validator/ICoinbaseExecution.sol\";\nimport \"../../libraries/EnumFlags.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasStakingVestingDeprecated, HasBridgeTrackingDeprecated, HasMaintenanceDeprecated, HasSlashIndicatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"../../precompile-usages/PCUSortValidators.sol\";\nimport \"../../precompile-usages/PCUPickValidatorSet.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\nimport { EmergencyExit } from \"./EmergencyExit.sol\";\nimport { TPoolId } from \"../../udvts/Types.sol\";\nimport { ErrCallerMustBeCoinbase } from \"../../utils/CommonErrors.sol\";\n\nabstract contract CoinbaseExecution is\n  ICoinbaseExecution,\n  RONTransferHelper,\n  PCUSortValidators,\n  PCUPickValidatorSet,\n  HasContracts,\n  HasStakingVestingDeprecated,\n  HasBridgeTrackingDeprecated,\n  HasMaintenanceDeprecated,\n  HasSlashIndicatorDeprecated,\n  EmergencyExit\n{\n  using EnumFlags for EnumFlags.ValidatorFlag;\n\n  modifier onlyCoinbase() {\n    _requireCoinbase();\n    _;\n  }\n\n  modifier whenEpochEnding() {\n    if (!epochEndingAt(block.number)) revert ErrAtEndOfEpochOnly();\n    _;\n  }\n\n  modifier oncePerEpoch() {\n    if (epochOf(_lastUpdatedBlock) >= epochOf(block.number)) revert ErrAlreadyWrappedEpoch();\n    _lastUpdatedBlock = block.number;\n    _;\n  }\n\n  function _requireCoinbase() private view {\n    if (msg.sender != block.coinbase) revert ErrCallerMustBeCoinbase();\n  }\n\n  /**\n   * @inheritdoc ICoinbaseExecution\n   */\n  function submitBlockReward() external payable override onlyCoinbase {\n    address id = __css2cid(TConsensus.wrap(msg.sender));\n\n    bool requestForBlockProducer = _isBlockProducerById(id) &&\n      !_isJailedById(id) &&\n      !_miningRewardDeprecatedById(id, currentPeriod());\n\n    (, uint256 blockProducerBonus, , uint256 fastFinalityRewardPercentage) = IStakingVesting(\n      getContract(ContractType.STAKING_VESTING)\n    ).requestBonus({ forBlockProducer: requestForBlockProducer, forBridgeOperator: false });\n\n    // Deprecates reward for non-validator or slashed validator\n    if (!requestForBlockProducer) {\n      _totalDeprecatedReward += msg.value;\n      emit BlockRewardDeprecated(id, msg.value, BlockRewardDeprecatedType.UNAVAILABILITY);\n      return;\n    }\n\n    emit BlockRewardSubmitted(id, msg.value, blockProducerBonus);\n\n    uint256 period = currentPeriod();\n    uint256 reward = msg.value + blockProducerBonus;\n    uint256 rewardFastFinality = (reward * fastFinalityRewardPercentage) / _MAX_PERCENTAGE; // reward for fast finality\n    uint256 rewardProducingBlock = reward - rewardFastFinality; // reward for producing blocks\n    uint256 cutOffReward;\n\n    // Add fast finality reward to total reward for current epoch, then split it later in the {wrapUpEpoch} method.\n    _totalFastFinalityReward += rewardFastFinality;\n\n    if (_miningRewardBailoutCutOffAtPeriod[msg.sender][period]) {\n      (, , , uint256 cutOffPercentage) = ISlashIndicator(getContract(ContractType.SLASH_INDICATOR))\n        .getCreditScoreConfigs();\n      cutOffReward = (rewardProducingBlock * cutOffPercentage) / _MAX_PERCENTAGE;\n      _totalDeprecatedReward += cutOffReward;\n      emit BlockRewardDeprecated(id, cutOffReward, BlockRewardDeprecatedType.AFTER_BAILOUT);\n    }\n\n    rewardProducingBlock -= cutOffReward;\n    (uint256 minRate, uint256 maxRate) = IStaking(getContract(ContractType.STAKING)).getCommissionRateRange();\n    uint256 rate = Math.max(Math.min(_candidateInfo[id].commissionRate, maxRate), minRate);\n    uint256 miningAmount = (rate * rewardProducingBlock) / _MAX_PERCENTAGE;\n    _miningReward[id] += miningAmount;\n    _delegatingReward[id] += (rewardProducingBlock - miningAmount);\n  }\n\n  /**\n   * @inheritdoc ICoinbaseExecution\n   */\n  function wrapUpEpoch() external payable virtual override onlyCoinbase whenEpochEnding oncePerEpoch {\n    uint256 newPeriod = _computePeriod(block.timestamp);\n    bool periodEnding = _isPeriodEnding(newPeriod);\n\n    address[] memory currValidatorIds = getValidators();\n    address[] memory revokedCandidateIds;\n    uint256 epoch = epochOf(block.number);\n    uint256 nextEpoch = epoch + 1;\n    uint256 lastPeriod = currentPeriod();\n\n    _syncFastFinalityReward(epoch, currValidatorIds);\n\n    if (periodEnding) {\n      (\n        uint256 totalDelegatingReward,\n        uint256[] memory delegatingRewards\n      ) = _distributeRewardToTreasuriesAndCalculateTotalDelegatingReward(lastPeriod, currValidatorIds);\n      _settleAndTransferDelegatingRewards(lastPeriod, currValidatorIds, totalDelegatingReward, delegatingRewards);\n      _tryRecycleLockedFundsFromEmergencyExits();\n      _recycleDeprecatedRewards();\n\n      ISlashIndicator slashIndicatorContract = ISlashIndicator(getContract(ContractType.SLASH_INDICATOR));\n      slashIndicatorContract.execUpdateCreditScores(currValidatorIds, lastPeriod);\n      (currValidatorIds, revokedCandidateIds) = _syncValidatorSet(newPeriod);\n      if (revokedCandidateIds.length > 0) {\n        slashIndicatorContract.execResetCreditScores(revokedCandidateIds);\n      }\n      _currentPeriodStartAtBlock = block.number + 1;\n    }\n    _revampRoles(newPeriod, nextEpoch, currValidatorIds);\n    emit WrappedUpEpoch(lastPeriod, epoch, periodEnding);\n    _periodOf[nextEpoch] = newPeriod;\n    _lastUpdatedPeriod = newPeriod;\n  }\n\n  /**\n   * @dev This method calculate and update reward of each `validators` accordingly their fast finality voting performance\n   * in the `epoch`. The leftover reward is added to the {_totalDeprecatedReward} and is recycled later to the\n   * {StakingVesting} contract.\n   *\n   * Requirements:\n   * - This method is only called once each epoch.\n   */\n  function _syncFastFinalityReward(uint256 epoch, address[] memory validatorIds) private {\n    uint256[] memory voteCounts = IFastFinalityTracking(getContract(ContractType.FAST_FINALITY_TRACKING))\n      .getManyFinalityVoteCounts(epoch, validatorIds);\n    uint256 divisor = _numberOfBlocksInEpoch * validatorIds.length;\n    uint256 iReward;\n    uint256 totalReward = _totalFastFinalityReward;\n    uint256 totalDispensedReward = 0;\n\n    for (uint i; i < validatorIds.length; ) {\n      iReward = (totalReward * voteCounts[i]) / divisor;\n      _fastFinalityReward[validatorIds[i]] += iReward;\n      totalDispensedReward += iReward;\n      unchecked {\n        ++i;\n      }\n    }\n\n    _totalDeprecatedReward += (totalReward - totalDispensedReward);\n    delete _totalFastFinalityReward;\n  }\n\n  /**\n   * @dev This loops over all current validators to:\n   * - Update delegating reward for and calculate total delegating rewards to be sent to the staking contract,\n   * - Distribute the reward of block producers and bridge operators to their treasury addresses,\n   * - Update the total deprecated reward if the two previous conditions do not satisfy.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _distributeRewardToTreasuriesAndCalculateTotalDelegatingReward(\n    uint256 lastPeriod,\n    address[] memory currValidatorIds\n  ) private returns (uint256 totalDelegatingReward, uint256[] memory delegatingRewards) {\n    address vId; // validator id\n    address payable treasury;\n    delegatingRewards = new uint256[](currValidatorIds.length);\n\n    for (uint _i; _i < currValidatorIds.length; ) {\n      vId = currValidatorIds[_i];\n      treasury = _candidateInfo[vId].__shadowedTreasury;\n\n      if (!_isJailedById(vId) && !_miningRewardDeprecatedById(vId, lastPeriod)) {\n        totalDelegatingReward += _delegatingReward[vId];\n        delegatingRewards[_i] = _delegatingReward[vId];\n        _distributeMiningReward(vId, treasury);\n        _distributeFastFinalityReward(vId, treasury);\n      } else {\n        _totalDeprecatedReward += _miningReward[vId] + _delegatingReward[vId] + _fastFinalityReward[vId];\n      }\n\n      delete _delegatingReward[vId];\n      delete _miningReward[vId];\n      delete _fastFinalityReward[vId];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @dev Distributes bonus of staking vesting and mining fee for the block producer.\n   *\n   * Emits the `MiningRewardDistributed` once the reward is distributed successfully.\n   * Emits the `MiningRewardDistributionFailed` once the contract fails to distribute reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _distributeMiningReward(address cid, address payable treasury) private {\n    uint256 amount = _miningReward[cid];\n    if (amount > 0) {\n      if (_unsafeSendRONLimitGas(treasury, amount, DEFAULT_ADDITION_GAS)) {\n        emit MiningRewardDistributed(cid, treasury, amount);\n        return;\n      }\n\n      emit MiningRewardDistributionFailed(cid, treasury, amount, address(this).balance);\n    }\n  }\n\n  function _distributeFastFinalityReward(address cid, address payable treasury) private {\n    uint256 amount = _fastFinalityReward[cid];\n    if (amount > 0) {\n      if (_unsafeSendRONLimitGas(treasury, amount, DEFAULT_ADDITION_GAS)) {\n        emit FastFinalityRewardDistributed(cid, treasury, amount);\n        return;\n      }\n\n      emit FastFinalityRewardDistributionFailed(cid, treasury, amount, address(this).balance);\n    }\n  }\n\n  /**\n   * @dev Helper function to settle rewards for delegators of `currValidatorIds` at the end of each period,\n   * then transfer the rewards from this contract to the staking contract, in order to finalize a period.\n   *\n   * Emits the `StakingRewardDistributed` once the reward is distributed successfully.\n   * Emits the `StakingRewardDistributionFailed` once the contract fails to distribute reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _settleAndTransferDelegatingRewards(\n    uint256 period,\n    address[] memory currValidatorIds,\n    uint256 totalDelegatingReward,\n    uint256[] memory delegatingRewards\n  ) private {\n    IStaking _staking = IStaking(getContract(ContractType.STAKING));\n    if (totalDelegatingReward > 0) {\n      if (_unsafeSendRON(payable(address(_staking)), totalDelegatingReward)) {\n        _staking.execRecordRewards(currValidatorIds, delegatingRewards, period);\n        emit StakingRewardDistributed(totalDelegatingReward, currValidatorIds, delegatingRewards);\n        return;\n      }\n\n      emit StakingRewardDistributionFailed(\n        totalDelegatingReward,\n        currValidatorIds,\n        delegatingRewards,\n        address(this).balance\n      );\n    }\n  }\n\n  /**\n   * @dev Transfer the deprecated rewards e.g. the rewards that get deprecated when validator is slashed/maintained,\n   * to the staking vesting contract\n   *\n   * Note: This method should be called once in the end of each period.\n   */\n  function _recycleDeprecatedRewards() private {\n    uint256 withdrawAmount = _totalDeprecatedReward;\n\n    if (withdrawAmount != 0) {\n      address withdrawTarget = getContract(ContractType.STAKING_VESTING);\n\n      delete _totalDeprecatedReward;\n\n      (bool _success, ) = withdrawTarget.call{ value: withdrawAmount }(\n        abi.encodeWithSelector(IStakingVesting.receiveRON.selector)\n      );\n\n      if (_success) {\n        emit DeprecatedRewardRecycled(withdrawTarget, withdrawAmount);\n      } else {\n        emit DeprecatedRewardRecycleFailed(withdrawTarget, withdrawAmount, address(this).balance);\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the validator set based on the validator candidates from the Staking contract.\n   *\n   * Emits the `ValidatorSetUpdated` event.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _syncValidatorSet(\n    uint256 newPeriod\n  ) private returns (address[] memory newValidatorIds, address[] memory unsatisfiedCandidates) {\n    unsatisfiedCandidates = _syncCandidateSet(newPeriod);\n    uint256[] memory weights = IStaking(getContract(ContractType.STAKING)).getManyStakingTotalsById(_candidateIds);\n    uint256[] memory trustedWeights = IRoninTrustedOrganization(getContract(ContractType.RONIN_TRUSTED_ORGANIZATION))\n      .getConsensusWeightsById(_candidateIds);\n    uint256 newValidatorCount;\n    (newValidatorIds, newValidatorCount) = _pcPickValidatorSet(\n      _candidateIds,\n      weights,\n      trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n    _setNewValidatorSet(newValidatorIds, newValidatorCount, newPeriod);\n  }\n\n  /**\n   * @dev Private helper function helps writing the new validator set into the contract storage.\n   *\n   * Emits the `ValidatorSetUpdated` event.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _setNewValidatorSet(\n    address[] memory _newValidators,\n    uint256 _newValidatorCount,\n    uint256 _newPeriod\n  ) private {\n    // Remove exceeding validators in the current set\n    for (uint256 _i = _newValidatorCount; _i < _validatorCount; ) {\n      delete _validatorMap[_validatorIds[_i]];\n      delete _validatorIds[_i];\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // Remove flag for all validator in the current set\n    for (uint _i; _i < _newValidatorCount; ) {\n      delete _validatorMap[_validatorIds[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // Update new validator set and set flag correspondingly.\n    for (uint256 _i; _i < _newValidatorCount; ) {\n      address _newValidator = _newValidators[_i];\n      _validatorMap[_newValidator] = EnumFlags.ValidatorFlag.Both;\n      _validatorIds[_i] = _newValidator;\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    _validatorCount = _newValidatorCount;\n    emit ValidatorSetUpdated(_newPeriod, _newValidators);\n  }\n\n  /**\n   * @dev Activate/Deactivate the validators from producing blocks, based on their in jail status and maintenance status.\n   *\n   * Requirements:\n   * - This method is called at the end of each epoch\n   *\n   * Emits the `BlockProducerSetUpdated` event.\n   * Emits the `BridgeOperatorSetUpdated` event.\n   *\n   */\n  function _revampRoles(uint256 _newPeriod, uint256 _nextEpoch, address[] memory currValidatorIds) private {\n    bool[] memory _maintainedList = IMaintenance(getContract(ContractType.MAINTENANCE)).checkManyMaintainedById(\n      currValidatorIds,\n      block.number + 1\n    );\n\n    for (uint _i; _i < currValidatorIds.length; ) {\n      address validatorId = currValidatorIds[_i];\n      bool emergencyExitRequested = block.timestamp <= _emergencyExitJailedTimestamp[validatorId];\n      bool isProducerBefore = _isBlockProducerById(validatorId);\n      bool isProducerAfter = !(_isJailedAtBlockById(validatorId, block.number + 1) ||\n        _maintainedList[_i] ||\n        emergencyExitRequested);\n\n      if (!isProducerBefore && isProducerAfter) {\n        _validatorMap[validatorId] = _validatorMap[validatorId].addFlag(EnumFlags.ValidatorFlag.BlockProducer);\n      } else if (isProducerBefore && !isProducerAfter) {\n        _validatorMap[validatorId] = _validatorMap[validatorId].removeFlag(EnumFlags.ValidatorFlag.BlockProducer);\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n    emit BlockProducerSetUpdated(_newPeriod, _nextEpoch, getBlockProducers());\n  }\n\n  /**\n   * @dev Override `CandidateManager-_isTrustedOrg`.\n   */\n  function _isTrustedOrg(address validatorId) internal view override returns (bool) {\n    return\n      IRoninTrustedOrganization(getContract(ContractType.RONIN_TRUSTED_ORGANIZATION)).getConsensusWeightById(\n        validatorId\n      ) > 0;\n  }\n}\n"
    },
    "contracts/ronin/validator/EmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../interfaces/IRoninGovernanceAdmin.sol\";\nimport \"../../interfaces/validator/IEmergencyExit.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\nimport \"./CandidateManagerCallback.sol\";\n\nabstract contract EmergencyExit is IEmergencyExit, RONTransferHelper, CandidateManagerCallback, CommonStorage {\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function emergencyExitLockedAmount() external view returns (uint256) {\n    return _emergencyExitLockedAmount;\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function emergencyExpiryDuration() external view returns (uint256) {\n    return _emergencyExpiryDuration;\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function execRequestEmergencyExit(address cid, uint256 secLeftToRevoke) external onlyContract(ContractType.STAKING) {\n    EmergencyExitInfo storage _info = _exitInfo[cid];\n    if (_info.recyclingAt != 0) revert ErrAlreadyRequestedEmergencyExit();\n\n    uint256 revokingTimestamp = block.timestamp + secLeftToRevoke;\n    _setRevokingTimestamp(_candidateInfo[cid], revokingTimestamp);\n    _emergencyExitJailedTimestamp[cid] = revokingTimestamp;\n\n    uint256 deductedAmount = IStaking(msg.sender).execDeductStakingAmount(cid, _emergencyExitLockedAmount);\n    if (deductedAmount > 0) {\n      uint256 recyclingAt = block.timestamp + _emergencyExpiryDuration;\n      _lockedConsensusList.push(cid);\n      _info.lockedAmount = deductedAmount;\n      _info.recyclingAt = recyclingAt;\n      IRoninGovernanceAdmin(_getAdmin()).createEmergencyExitPoll(\n        cid,\n        _candidateInfo[cid].__shadowedTreasury,\n        block.timestamp,\n        recyclingAt\n      );\n    }\n    emit EmergencyExitRequested(cid, deductedAmount);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function setEmergencyExitLockedAmount(uint256 amount) external onlyAdmin {\n    _setEmergencyExitLockedAmount(amount);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function setEmergencyExpiryDuration(uint256 duration) external onlyAdmin {\n    _setEmergencyExpiryDuration(duration);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(address cid, address payable recipient) external onlyAdmin {\n    if (_exitInfo[cid].recyclingAt == 0) {\n      revert ErrLockedFundReleaseInfoNotFound(cid);\n    }\n\n    uint256 length = _lockedConsensusList.length;\n    uint256 index = length;\n\n    for (uint i; i < length; ) {\n      if (_lockedConsensusList[i] == cid) {\n        index = i;\n        break;\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    // The locked amount might be recycled\n    if (index == length) {\n      revert ErrLockedFundMightBeRecycled(cid);\n    }\n\n    uint256 amount = _exitInfo[cid].lockedAmount;\n    if (amount > 0) {\n      delete _exitInfo[cid];\n      if (length > 1) {\n        _lockedConsensusList[index] = _lockedConsensusList[length - 1];\n      }\n      _lockedConsensusList.pop();\n\n      _lockedFundReleased[cid] = true;\n      if (_unsafeSendRONLimitGas(recipient, amount, DEFAULT_ADDITION_GAS)) {\n        emit EmergencyExitLockedFundReleased(cid, recipient, amount);\n        return;\n      }\n\n      emit EmergencyExitLockedFundReleasingFailed(cid, recipient, amount, address(this).balance);\n    }\n  }\n\n  /**\n   * @dev Tries to recycle the locked funds from emergency exit requests.\n   */\n  function _tryRecycleLockedFundsFromEmergencyExits() internal {\n    uint256 length = _lockedConsensusList.length;\n\n    uint256 i;\n    address addr;\n    EmergencyExitInfo storage _info;\n\n    while (i < length) {\n      addr = _lockedConsensusList[i];\n      _info = _exitInfo[addr];\n\n      if (_info.recyclingAt <= block.timestamp) {\n        _totalDeprecatedReward += _info.lockedAmount;\n\n        delete _exitInfo[addr];\n        if (--length > 0) {\n          _lockedConsensusList[i] = _lockedConsensusList[length];\n        }\n        _lockedConsensusList.pop();\n        continue;\n      }\n\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /**\n   * @dev Override `CandidateManager-_emergencyExitLockedFundReleased`.\n   */\n  function _emergencyExitLockedFundReleased(address cid) internal virtual override returns (bool) {\n    return _lockedFundReleased[cid];\n  }\n\n  /**\n   * @dev Override `CandidateManager-_removeCandidate`.\n   */\n  function _removeCandidate(address cid) internal override {\n    delete _lockedFundReleased[cid];\n    super._removeCandidate(cid);\n  }\n\n  /// @dev See {RoninValidatorSet-__css2cid}\n  function __css2cid(\n    TConsensus consensusAddr\n  ) internal view virtual override(CandidateManager, CommonStorage) returns (address);\n\n  /// @dev See {RoninValidatorSet-__css2cidBatch}\n  function __css2cidBatch(\n    TConsensus[] memory consensusAddrs\n  ) internal view virtual override(CandidateManager, CommonStorage) returns (address[] memory);\n\n  /**\n   * @dev See `setEmergencyExitLockedAmount.\n   */\n  function _setEmergencyExitLockedAmount(uint256 amount) internal {\n    _emergencyExitLockedAmount = amount;\n    emit EmergencyExitLockedAmountUpdated(amount);\n  }\n\n  /**\n   * @dev See `setEmergencyExpiryDuration`.\n   */\n  function _setEmergencyExpiryDuration(uint256 duration) internal {\n    _emergencyExpiryDuration = duration;\n    emit EmergencyExpiryDurationUpdated(duration);\n  }\n}\n"
    },
    "contracts/ronin/validator/RoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"./CoinbaseExecution.sol\";\nimport \"./SlashingExecution.sol\";\n\ncontract RoninValidatorSet is Initializable, CoinbaseExecution, SlashingExecution {\n  constructor() {\n    _disableInitializers();\n  }\n\n  fallback() external payable {\n    _fallback();\n  }\n\n  receive() external payable {\n    _fallback();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __slashIndicatorContract,\n    address __stakingContract,\n    address __stakingVestingContract,\n    address __maintenanceContract,\n    address __roninTrustedOrganizationContract,\n    address /* __bridgeTrackingContract */,\n    uint256 __maxValidatorNumber,\n    uint256 __maxValidatorCandidate,\n    uint256 __maxPrioritizedValidatorNumber,\n    uint256 __minEffectiveDaysOnwards,\n    uint256 __numberOfBlocksInEpoch,\n    // __emergencyExitConfigs[0]: emergencyExitLockedAmount\n    // __emergencyExitConfigs[1]: emergencyExpiryDuration\n    uint256[2] calldata __emergencyExitConfigs\n  ) external initializer {\n    _setContract(ContractType.SLASH_INDICATOR, __slashIndicatorContract);\n    _setContract(ContractType.STAKING, __stakingContract);\n    _setContract(ContractType.STAKING_VESTING, __stakingVestingContract);\n    _setContract(ContractType.MAINTENANCE, __maintenanceContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, __roninTrustedOrganizationContract);\n\n    _setMaxValidatorNumber(__maxValidatorNumber);\n    _setMaxValidatorCandidate(__maxValidatorCandidate);\n    _setMaxPrioritizedValidatorNumber(__maxPrioritizedValidatorNumber);\n    _setMinEffectiveDaysOnwards(__minEffectiveDaysOnwards);\n    _setEmergencyExitLockedAmount(__emergencyExitConfigs[0]);\n    _setEmergencyExpiryDuration(__emergencyExitConfigs[1]);\n    _numberOfBlocksInEpoch = __numberOfBlocksInEpoch;\n  }\n\n  function initializeV2() external reinitializer(2) {\n    _setContract(ContractType.STAKING, ______deprecatedStakingContract);\n    _setContract(ContractType.MAINTENANCE, ______deprecatedMaintenance);\n    _setContract(ContractType.SLASH_INDICATOR, ______deprecatedSlashIndicator);\n    _setContract(ContractType.STAKING_VESTING, ______deprecatedStakingVesting);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, ______deprecatedTrustedOrg);\n\n    delete ______deprecatedStakingContract;\n    delete ______deprecatedMaintenance;\n    delete ______deprecatedSlashIndicator;\n    delete ______deprecatedStakingVesting;\n    delete ______deprecatedBridgeTracking;\n    delete ______deprecatedTrustedOrg;\n  }\n\n  function initializeV3(address fastFinalityTrackingContract) external reinitializer(3) {\n    _setContract(ContractType.FAST_FINALITY_TRACKING, fastFinalityTrackingContract);\n  }\n\n  function initializeV4(address profileContract) external reinitializer(4) {\n    _setContract(ContractType.PROFILE, profileContract);\n  }\n\n  /**\n   * @dev Only receives RON from staking vesting contract (for topping up bonus), and from staking contract (for transferring\n   * deducting amount on slashing).\n   */\n  function _fallback() internal view {\n    if (msg.sender != getContract(ContractType.STAKING_VESTING) && msg.sender != getContract(ContractType.STAKING)) {\n      revert ErrUnauthorizedReceiveRON();\n    }\n  }\n\n  /**\n   * @dev Convert consensus address to corresponding id from the Profile contract.\n   */\n  function __css2cid(TConsensus consensusAddr) internal view override(EmergencyExit, CommonStorage) returns (address) {\n    return IProfile(getContract(ContractType.PROFILE)).getConsensus2Id(consensusAddr);\n  }\n\n  /**\n   * @dev Convert many consensus addresses to corresponding ids from the Profile contract.\n   */\n  function __css2cidBatch(\n    TConsensus[] memory consensusAddrs\n  ) internal view override(EmergencyExit, CommonStorage) returns (address[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyConsensus2Id(consensusAddrs);\n  }\n}\n"
    },
    "contracts/ronin/validator/SlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../interfaces/validator/ISlashingExecution.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasSlashIndicatorDeprecated, HasStakingDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\n\nabstract contract SlashingExecution is\n  ISlashingExecution,\n  HasContracts,\n  HasSlashIndicatorDeprecated,\n  HasStakingDeprecated,\n  CommonStorage\n{\n  /**\n   * @inheritdoc ISlashingExecution\n   */\n  function execSlash(\n    address validatorId,\n    uint256 newJailedUntil,\n    uint256 slashAmount,\n    bool cannotBailout\n  ) external override onlyContract(ContractType.SLASH_INDICATOR) {\n    uint256 period = currentPeriod();\n    _miningRewardDeprecatedAtPeriod[validatorId][period] = true;\n\n    _totalDeprecatedReward += _miningReward[validatorId] + _delegatingReward[validatorId];\n\n    delete _miningReward[validatorId];\n    delete _delegatingReward[validatorId];\n\n    _blockProducerJailedBlock[validatorId] = Math.max(newJailedUntil, _blockProducerJailedBlock[validatorId]);\n\n    if (slashAmount > 0) {\n      uint256 _actualAmount = IStaking(getContract(ContractType.STAKING)).execDeductStakingAmount(\n        validatorId,\n        slashAmount\n      );\n      _totalDeprecatedReward += _actualAmount;\n    }\n\n    if (cannotBailout) {\n      _cannotBailoutUntilBlock[validatorId] = Math.max(newJailedUntil, _cannotBailoutUntilBlock[validatorId]);\n    }\n\n    emit ValidatorPunished(validatorId, period, _blockProducerJailedBlock[validatorId], slashAmount, true, false);\n  }\n\n  /**\n   * @inheritdoc ISlashingExecution\n   */\n  function execBailOut(\n    address validatorId,\n    uint256 period\n  ) external override onlyContract(ContractType.SLASH_INDICATOR) {\n    if (block.number <= _cannotBailoutUntilBlock[validatorId]) revert ErrCannotBailout(validatorId);\n\n    // Note: Removing rewards of validator in `bailOut` function is not needed, since the rewards have been\n    // removed previously in the `slash` function.\n    _miningRewardBailoutCutOffAtPeriod[validatorId][period] = true;\n    _miningRewardDeprecatedAtPeriod[validatorId][period] = false;\n    _blockProducerJailedBlock[validatorId] = block.number - 1;\n\n    emit ValidatorUnjailed(validatorId, period);\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/CommonStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../interfaces/validator/info-fragments/ICommonInfo.sol\";\nimport \"./JailingStorage.sol\";\nimport \"./TimingStorage.sol\";\nimport \"./ValidatorInfoStorageV2.sol\";\n\nabstract contract CommonStorage is ICommonInfo, TimingStorage, JailingStorage, ValidatorInfoStorageV2 {\n  /// @dev Mapping from consensus address => pending reward from producing block\n  mapping(address => uint256) internal _miningReward;\n  /// @dev Mapping from consensus address => pending reward from delegating\n  mapping(address => uint256) internal _delegatingReward;\n\n  /// @dev The total reward for fast finality\n  uint256 internal _totalFastFinalityReward;\n  /// @dev Mapping from consensus address => pending reward for fast finality\n  mapping(address => uint256) internal _fastFinalityReward;\n\n  /// @dev The deprecated reward that has not been withdrawn by admin\n  uint256 internal _totalDeprecatedReward;\n\n  /// @dev The amount of RON to lock from a consensus address.\n  uint256 internal _emergencyExitLockedAmount;\n  /// @dev The duration that an emergency request is expired and the fund will be recycled.\n  uint256 internal _emergencyExpiryDuration;\n  /// @dev The address list of consensus addresses that being locked fund.\n  address[] internal _lockedConsensusList;\n  /// @dev Mapping from consensus => request exist info\n  mapping(address => EmergencyExitInfo) internal _exitInfo;\n  /// @dev Mapping from consensus => flag indicating whether the locked fund is released\n  mapping(address => bool) internal _lockedFundReleased;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[44] private ______gap;\n\n  /**\n   * @inheritdoc ICommonInfo\n   */\n  function getEmergencyExitInfo(TConsensus consensus) external view override returns (EmergencyExitInfo memory _info) {\n    _info = _exitInfo[__css2cid(consensus)];\n    if (_info.recyclingAt == 0) revert NonExistentRecyclingInfo();\n  }\n\n  /**\n   * @inheritdoc ICommonInfo\n   */\n  function totalDeprecatedReward() external view override returns (uint256) {\n    return _totalDeprecatedReward;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochOf(\n    uint256 _block\n  ) public view virtual override(ITimingInfo, JailingStorage, TimingStorage) returns (uint256) {\n    return TimingStorage.epochOf(_block);\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriod() public view virtual override(ITimingInfo, JailingStorage, TimingStorage) returns (uint256) {\n    return TimingStorage.currentPeriod();\n  }\n\n  /// @dev See {RoninValidatorSet-__css2cid}\n  function __css2cid(\n    TConsensus consensusAddr\n  ) internal view virtual override(JailingStorage, ValidatorInfoStorageV2) returns (address);\n\n  /// @dev See {RoninValidatorSet-__css2cidBatch}\n  function __css2cidBatch(\n    TConsensus[] memory consensusAddrs\n  ) internal view virtual override(JailingStorage, ValidatorInfoStorageV2) returns (address[] memory);\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/JailingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../interfaces/validator/info-fragments/IJailingInfo.sol\";\n\nabstract contract JailingStorage is IJailingInfo {\n  /// @dev Mapping from candidate id => period number => block producer has no pending reward.\n  mapping(address => mapping(uint256 => bool)) internal _miningRewardDeprecatedAtPeriod;\n  /// @dev Mapping from candidate id => period number => whether the block producer get cut off reward, due to bailout.\n  mapping(address => mapping(uint256 => bool)) internal _miningRewardBailoutCutOffAtPeriod;\n  /// @dev Mapping from candidate id => period number => block operator has no pending reward.\n  mapping(address => mapping(uint256 => bool)) internal ______deprecatedBridgeRewardDeprecatedAtPeriod;\n\n  /// @dev Mapping from candidate id => the last block that the block producer is jailed.\n  mapping(address => uint256) internal _blockProducerJailedBlock;\n  /// @dev Mapping from candidate id => the last timestamp that the bridge operator is jailed.\n  mapping(address => uint256) internal _emergencyExitJailedTimestamp;\n  /// @dev Mapping from candidate id => the last block that the block producer cannot bailout.\n  mapping(address => uint256) internal _cannotBailoutUntilBlock;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] private ______gap;\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkJailed(TConsensus consensus) external view override returns (bool) {\n    address candidateId = __css2cid(consensus);\n    return _isJailedAtBlockById(candidateId, block.number);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkJailedAtBlock(TConsensus addr, uint256 blockNum) external view override returns (bool) {\n    address candidateId = __css2cid(addr);\n    return _isJailedAtBlockById(candidateId, blockNum);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function getJailedTimeLeft(\n    TConsensus consensus\n  ) external view override returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_) {\n    return _getJailedTimeLeftAtBlockById(__css2cid(consensus), block.number);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function getJailedTimeLeftAtBlock(\n    TConsensus consensus,\n    uint256 _blockNum\n  ) external view override returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_) {\n    return _getJailedTimeLeftAtBlockById(__css2cid(consensus), _blockNum);\n  }\n\n  function _getJailedTimeLeftAtBlockById(\n    address candidateId,\n    uint256 blockNum\n  ) internal view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_) {\n    uint256 jailedBlock = _blockProducerJailedBlock[candidateId];\n    if (jailedBlock < blockNum) {\n      return (false, 0, 0);\n    }\n\n    isJailed_ = true;\n    blockLeft_ = jailedBlock - blockNum + 1;\n    epochLeft_ = epochOf(jailedBlock) - epochOf(blockNum) + 1;\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkManyJailed(TConsensus[] calldata consensusList) external view override returns (bool[] memory) {\n    return _checkManyJailedById(__css2cidBatch(consensusList));\n  }\n\n  function checkManyJailedById(address[] calldata candidateIds) external view override returns (bool[] memory) {\n    return _checkManyJailedById(candidateIds);\n  }\n\n  function _checkManyJailedById(address[] memory candidateIds) internal view returns (bool[] memory result) {\n    result = new bool[](candidateIds.length);\n    for (uint256 i; i < candidateIds.length; ) {\n      result[i] = _isJailedById(candidateIds[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkMiningRewardDeprecated(TConsensus consensus) external view override returns (bool) {\n    uint256 period = currentPeriod();\n    return _miningRewardDeprecatedById(__css2cid(consensus), period);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkMiningRewardDeprecatedAtPeriod(\n    TConsensus consensus,\n    uint256 period\n  ) external view override returns (bool) {\n    return _miningRewardDeprecatedById(__css2cid(consensus), period);\n  }\n\n  /**\n   * @dev See `ITimingInfo-epochOf`\n   */\n  function epochOf(uint256 _block) public view virtual returns (uint256);\n\n  /**\n   * @dev See `ITimingInfo-currentPeriod`\n   */\n  function currentPeriod() public view virtual returns (uint256);\n\n  /**\n   * @dev Returns whether the reward of the validator is put in jail (cannot join the set of validators) during the current period.\n   */\n  function _isJailedById(address validatorId) internal view returns (bool) {\n    return _isJailedAtBlockById(validatorId, block.number);\n  }\n\n  /**\n   * @dev Returns whether the reward of the validator is put in jail (cannot join the set of validators) at a specific block.\n   */\n  function _isJailedAtBlockById(address validatorId, uint256 blockNum) internal view returns (bool) {\n    return blockNum <= _blockProducerJailedBlock[validatorId];\n  }\n\n  /**\n   * @dev Returns whether the block producer has no pending reward in that period.\n   */\n  function _miningRewardDeprecatedById(address validatorId, uint256 period) internal view returns (bool) {\n    return _miningRewardDeprecatedAtPeriod[validatorId][period];\n  }\n\n  /// @dev See {RoninValidatorSet-__css2cid}\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n\n  /// @dev See {RoninValidatorSet-__css2cidBatch}\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view virtual returns (address[] memory);\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/TimingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../../interfaces/validator/info-fragments/ITimingInfo.sol\";\n\nabstract contract TimingStorage is ITimingInfo, GlobalConfigConsumer {\n  /// @dev The number of blocks in a epoch\n  uint256 internal _numberOfBlocksInEpoch;\n  /// @dev The last updated block\n  uint256 internal _lastUpdatedBlock;\n  /// @dev The last updated period\n  uint256 internal _lastUpdatedPeriod;\n  /// @dev The starting block of the last updated period\n  uint256 internal _currentPeriodStartAtBlock;\n\n  /// @dev Mapping from epoch index => period index\n  mapping(uint256 => uint256) internal _periodOf;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[49] private ______gap;\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function getLastUpdatedBlock() external view override returns (uint256) {\n    return _lastUpdatedBlock;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochOf(uint256 _block) public view virtual override returns (uint256) {\n    return _block / _numberOfBlocksInEpoch + 1;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber) {\n    return (_epoch <= epochOf(block.number) || _periodOf[_epoch] > 0, _periodOf[_epoch]);\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function isPeriodEnding() external view override returns (bool) {\n    return _isPeriodEnding(_computePeriod(block.timestamp));\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochEndingAt(uint256 _block) public view virtual override returns (bool) {\n    return _block % _numberOfBlocksInEpoch == _numberOfBlocksInEpoch - 1;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriod() public view virtual override returns (uint256) {\n    return _lastUpdatedPeriod;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriodStartAtBlock() public view override returns (uint256) {\n    return _currentPeriodStartAtBlock;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function numberOfBlocksInEpoch() public view virtual override returns (uint256 _numberOfBlocks) {\n    return _numberOfBlocksInEpoch;\n  }\n\n  /**\n   * @dev See `ITimingInfo-isPeriodEnding`\n   */\n  function _isPeriodEnding(uint256 _newPeriod) internal view virtual returns (bool) {\n    return _newPeriod > _lastUpdatedPeriod;\n  }\n\n  /**\n   * @dev Returns the calculated period.\n   */\n  function _computePeriod(uint256 _timestamp) internal pure returns (uint256) {\n    return _timestamp / PERIOD_DURATION;\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/ValidatorInfoStorageV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\nimport { HasTrustedOrgDeprecated } from \"../../../utils/DeprecatedSlots.sol\";\nimport \"../../../extensions/collections/HasContracts.sol\";\nimport \"../../../interfaces/validator/info-fragments/IValidatorInfoV2.sol\";\nimport \"../../../interfaces/IProfile.sol\";\nimport { TConsensus } from \"../../../udvts/Types.sol\";\n\nabstract contract ValidatorInfoStorageV2 is IValidatorInfoV2, HasContracts, HasTrustedOrgDeprecated {\n  using EnumFlags for EnumFlags.ValidatorFlag;\n\n  /// @dev The maximum number of validator.\n  uint256 internal _maxValidatorNumber;\n\n  /// @dev The total of validators\n  uint256 internal _validatorCount;\n  /// @dev Mapping from validator index => validator id address\n  mapping(uint256 => address) internal _validatorIds;\n  /// @dev Mapping from validator id => flag indicating the validator ability: producing block, operating bridge\n  mapping(address => EnumFlags.ValidatorFlag) internal _validatorMap;\n  /// @dev The number of slot that is reserved for prioritized validators\n  uint256 internal _maxPrioritizedValidatorNumber;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  function validatorCount() external view returns (uint256) {\n    return _validatorCount;\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function getValidators() public view override returns (address[] memory validatorList_) {\n    validatorList_ = new address[](_validatorCount);\n    address iValidator;\n    for (uint i; i < validatorList_.length; ) {\n      iValidator = _validatorIds[i];\n      validatorList_[i] = iValidator;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function getBlockProducers() public view override returns (address[] memory result) {\n    result = new address[](_validatorCount);\n    uint256 count = 0;\n    for (uint i; i < result.length; ) {\n      address validatorId = _validatorIds[i];\n      if (_isBlockProducerById(validatorId)) {\n        result[count++] = validatorId;\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    assembly {\n      mstore(result, count)\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function isBlockProducer(TConsensus consensusAddr) public view override returns (bool) {\n    return _isBlockProducerById(__css2cid(consensusAddr));\n  }\n\n  function _isBlockProducerById(address id) internal view returns (bool) {\n    return _validatorMap[id].hasFlag(EnumFlags.ValidatorFlag.BlockProducer);\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function totalBlockProducer() external view returns (uint256 total) {\n    unchecked {\n      for (uint i; i < _validatorCount; i++) {\n        if (_isBlockProducerById(_validatorIds[i])) {\n          total++;\n        }\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function maxValidatorNumber() external view override returns (uint256 _maximumValidatorNumber) {\n    return _maxValidatorNumber;\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function maxPrioritizedValidatorNumber() external view override returns (uint256 _maximumPrioritizedValidatorNumber) {\n    return _maxPrioritizedValidatorNumber;\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function setMaxValidatorNumber(uint256 _max) external override onlyAdmin {\n    _setMaxValidatorNumber(_max);\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _number) external override onlyAdmin {\n    _setMaxPrioritizedValidatorNumber(_number);\n  }\n\n  /**\n   * @dev See `IValidatorInfoV2-setMaxValidatorNumber`\n   */\n  function _setMaxValidatorNumber(uint256 _number) internal {\n    _maxValidatorNumber = _number;\n    emit MaxValidatorNumberUpdated(_number);\n  }\n\n  /**\n   * @dev See `IValidatorInfoV2-setMaxPrioritizedValidatorNumber`\n   */\n  function _setMaxPrioritizedValidatorNumber(uint256 _number) internal {\n    if (_number > _maxValidatorNumber) revert ErrInvalidMaxPrioritizedValidatorNumber();\n    _maxPrioritizedValidatorNumber = _number;\n    emit MaxPrioritizedValidatorNumberUpdated(_number);\n  }\n\n  /// @dev See {RoninValidatorSet-__css2cid}\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n\n  /// @dev See {RoninValidatorSet-__css2cidBatch}\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view virtual returns (address[] memory);\n}\n"
    },
    "contracts/types/operations/LibTUint256Slot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { TUint256Slot } from \"../Types.sol\";\n\n/**\n * @title LibTUint256Slot\n * @dev Library for handling unsigned 256-bit integers.\n */\nlibrary LibTUint256Slot {\n  /// @dev value is equal to bytes4(keccak256(\"Panic(uint256)\"))\n  /// @dev see: https://github.com/foundry-rs/forge-std/blob/master/src/StdError.sol\n  uint256 private constant PANIC_ERROR_SIGNATURE = 0x4e487b71;\n  /// @dev error code for {Arithmetic over/underflow} error\n  uint256 private constant ARITHMETIC_ERROR_CODE = 0x11;\n  /// @dev error code for {Division or modulo by 0} error\n  uint256 private constant DIVISION_ERROR_CODE = 0x12;\n\n  /**\n   * @dev Loads the value of the TUint256Slot variable.\n   * @param self The TUint256Slot variable.\n   * @return val The loaded value.\n   */\n  function load(TUint256Slot self) internal view returns (uint256 val) {\n    assembly {\n      val := sload(self)\n    }\n  }\n\n  /**\n   * @dev Stores a value into the TUint256Slot variable.\n   * @param self The TUint256Slot variable.\n   * @param other The value to be stored.\n   */\n  function store(TUint256Slot self, uint256 other) internal {\n    assembly {\n      sstore(self, other)\n    }\n  }\n\n  /**\n   * @dev Multiplies the TUint256Slot variable by a given value.\n   * @param self The TUint256Slot variable.\n   * @param other The value to multiply by.\n   * @return res The resulting value after multiplication.\n   */\n  function mul(TUint256Slot self, uint256 other) internal view returns (uint256 res) {\n    assembly {\n      let storedVal := sload(self)\n      if iszero(iszero(storedVal)) {\n        res := mul(storedVal, other)\n\n        // Overflow check\n        if iszero(eq(other, div(res, storedVal))) {\n          // Store 4 bytes the function selector of Panic(uint256)\n          // Equivalent to revert Panic(uint256)\n          mstore(0x00, PANIC_ERROR_SIGNATURE)\n          // Store 4 bytes of division error code in the next slot\n          mstore(0x20, ARITHMETIC_ERROR_CODE)\n          // Revert 36 bytes of error starting from 0x1c\n          revert(0x1c, 0x24)\n        }\n      }\n    }\n  }\n\n  /**\n   * @dev Divides the TUint256Slot variable by a given value.\n   * @param self The TUint256Slot variable.\n   * @param other The value to divide by.\n   * @return res The resulting value after division.\n   */\n  function div(TUint256Slot self, uint256 other) internal view returns (uint256 res) {\n    assembly {\n      let storedVal := sload(self)\n      // revert if divide by zero\n      if iszero(other) {\n        // Store 4 bytes the function selector of Panic(uint256)\n        // Equivalent to revert Panic(uint256)\n        mstore(0x00, PANIC_ERROR_SIGNATURE)\n        // Store 4 bytes of division error code in the next slot\n        mstore(0x20, DIVISION_ERROR_CODE)\n        // Revert 36 bytes of error starting from 0x1c\n        revert(0x1c, 0x24)\n      }\n      res := div(storedVal, other)\n    }\n  }\n\n  /**\n   * @dev Subtracts a given value from the TUint256Slot variable.\n   * @param self The TUint256Slot variable.\n   * @param other The value to subtract.\n   * @return res The resulting value after subtraction.\n   */\n  function sub(TUint256Slot self, uint256 other) internal view returns (uint256 res) {\n    assembly {\n      let storedVal := sload(self)\n\n      // Underflow check\n      if lt(storedVal, other) {\n        // Store 4 bytes the function selector of Panic(uint256)\n        // Equivalent to revert Panic(uint256)\n        mstore(0x00, PANIC_ERROR_SIGNATURE)\n        // Store 4 bytes of division error code in the next slot\n        mstore(0x20, ARITHMETIC_ERROR_CODE)\n        // Revert 36 bytes of error starting from 0x1c\n        revert(0x1c, 0x24)\n      }\n\n      res := sub(storedVal, other)\n    }\n  }\n\n  /**\n   * @dev Adds a given value to the TUint256Slot variable.\n   * @param self The TUint256Slot variable.\n   * @param other The value to add.\n   * @return res The resulting value after addition.\n   */\n  function add(TUint256Slot self, uint256 other) internal view returns (uint256 res) {\n    assembly {\n      let storedVal := sload(self)\n      res := add(storedVal, other)\n\n      // Overflow check\n      if lt(res, other) {\n        // Store 4 bytes the function selector of Panic(uint256)\n        // Equivalent to revert Panic(uint256)\n        mstore(0x00, PANIC_ERROR_SIGNATURE)\n        // Store 4 bytes of division error code in the next slot\n        mstore(0x20, ARITHMETIC_ERROR_CODE)\n        // Revert 36 bytes of error starting from 0x1c\n        revert(0x1c, 0x24)\n      }\n    }\n  }\n\n  /**\n   * @dev Increments the TUint256Slot variable by 1 and returns the new value.\n   * @param self The TUint256Slot variable.\n   * @return res The resulting value after incrementing.\n   */\n  function preIncrement(TUint256Slot self) internal returns (uint256 res) {\n    res = addAssign(self, 1);\n  }\n\n  /**\n   * @dev Increments the TUint256Slot variable by 1 and returns the original value.\n   * @param self The TUint256Slot variable.\n   * @return res The original value before incrementing.\n   */\n  function postIncrement(TUint256Slot self) internal returns (uint256 res) {\n    res = load(self);\n    store(self, res + 1);\n  }\n\n  /**\n   * @dev Decrements the TUint256Slot variable by 1 and returns the new value.\n   * @param self The TUint256Slot variable.\n   * @return res The resulting value after decrementing.\n   */\n  function preDecrement(TUint256Slot self) internal returns (uint256 res) {\n    res = subAssign(self, 1);\n  }\n\n  /**\n   * @dev Decrements the TUint256Slot variable by 1 and returns the new value.\n   * @param self The TUint256Slot variable.\n   * @return res The resulting value before decrementing.\n   */\n  function postDecrement(TUint256Slot self) internal returns (uint256 res) {\n    res = load(self);\n    store(self, res - 1);\n  }\n\n  /**\n   * @dev Adds a given value to the TUint256Slot variable and stores the result.\n   * @param self The TUint256Slot variable.\n   * @param other The value to add.\n   * @return res The resulting value after addition and storage.\n   */\n  function addAssign(TUint256Slot self, uint256 other) internal returns (uint256 res) {\n    store(self, res = add(self, other));\n  }\n\n  /**\n   * @dev Subtracts a given value from the TUint256Slot variable and stores the result.\n   * @param self The TUint256Slot variable.\n   * @param other The value to subtract.\n   * @return res The resulting value after subtraction and storage.\n   */\n  function subAssign(TUint256Slot self, uint256 other) internal returns (uint256 res) {\n    store(self, res = sub(self, other));\n  }\n}\n"
    },
    "contracts/types/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { LibTUint256Slot } from \"./operations/LibTUint256Slot.sol\";\n\ntype TUint256Slot is bytes32;\n\nusing {\n  LibTUint256Slot.add,\n  LibTUint256Slot.sub,\n  LibTUint256Slot.mul,\n  LibTUint256Slot.div,\n  LibTUint256Slot.load,\n  LibTUint256Slot.store,\n  LibTUint256Slot.addAssign,\n  LibTUint256Slot.subAssign,\n  LibTUint256Slot.preDecrement,\n  LibTUint256Slot.postDecrement,\n  LibTUint256Slot.preIncrement,\n  LibTUint256Slot.postIncrement\n} for TUint256Slot global;\n"
    },
    "contracts/udvts/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ntype TPoolId is address;\ntype TConsensus is address;\n\nusing { TPoolIdEq as == } for TPoolId global;\nusing { TConsensusEq as == } for TConsensus global;\n\nfunction TPoolIdEq(TPoolId a, TPoolId b) pure returns (bool) {\n  return TPoolId.unwrap(a) == TPoolId.unwrap(b);\n}\n\nfunction TConsensusEq(TConsensus a, TConsensus b) pure returns (bool) {\n  return TConsensus.unwrap(a) == TConsensus.unwrap(b);\n}\n"
    },
    "contracts/utils/CommonErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ContractType } from \"./ContractType.sol\";\nimport { RoleAccess } from \"./RoleAccess.sol\";\n\nerror ErrSyncTooFarPeriod(uint256 period, uint256 latestRewardedPeriod);\n\n/**\n * @dev Error raised when a bridge operator update operation fails.\n * @param bridgeOperator The address of the bridge operator that failed to update.\n */\nerror ErrBridgeOperatorUpdateFailed(address bridgeOperator);\n\n/**\n * @dev Error thrown when an address is expected to be an already created externally owned account (EOA).\n * This error indicates that the provided address is invalid for certain contract operations that require already created EOA.\n */\nerror ErrAddressIsNotCreatedEOA(address addr, bytes32 codehash);\n\n/**\n * @dev Error thrown when attempting to add a bridge operator that already exists in the contract.\n * This error indicates that the provided bridge operator address is already registered as a bridge operator in the contract.\n */\nerror ErrBridgeOperatorAlreadyExisted(address bridgeOperator);\n\n/**\n * @dev The error indicating an unsupported interface.\n * @param interfaceId The bytes4 interface identifier that is not supported.\n * @param addr The address where the unsupported interface was encountered.\n */\nerror ErrUnsupportedInterface(bytes4 interfaceId, address addr);\n\n/**\n * @dev Error thrown when the return data from a callback function is invalid.\n * @param callbackFnSig The signature of the callback function that returned invalid data.\n * @param register The address of the register where the callback function was invoked.\n * @param returnData The invalid return data received from the callback function.\n */\nerror ErrInvalidReturnData(bytes4 callbackFnSig, address register, bytes returnData);\n\n/**\n * @dev Error of set to non-contract.\n */\nerror ErrZeroCodeContract(address addr);\n\n/**\n * @dev Error indicating that arguments are invalid.\n */\nerror ErrInvalidArguments(bytes4 msgSig);\n\n/**\n * @dev Error indicating that given address is null when it should not.\n */\nerror ErrZeroAddress(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the provided threshold is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that the invalid threshold applies to.\n */\nerror ErrInvalidThreshold(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a function can only be called by the contract itself.\n * @param msgSig The function signature (bytes4) that can only be called by the contract itself.\n */\nerror ErrOnlySelfCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n * @param expectedRole The role required to perform the function.\n */\nerror ErrUnauthorized(bytes4 msgSig, RoleAccess expectedRole);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n */\nerror ErrUnauthorizedCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4).\n * @param expectedContractType The contract type required to perform the function.\n * @param actual The actual address that called to the function.\n */\nerror ErrUnexpectedInternalCall(bytes4 msgSig, ContractType expectedContractType, address actual);\n\n/**\n * @dev Error indicating that an array is empty when it should contain elements.\n */\nerror ErrEmptyArray();\n\n/**\n * @dev Error indicating a mismatch in the length of input parameters or arrays for a specific function.\n * @param msgSig The function signature (bytes4) that has a length mismatch.\n */\nerror ErrLengthMismatch(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a proxy call to an external contract has failed.\n * @param msgSig The function signature (bytes4) of the proxy call that failed.\n * @param extCallSig The function signature (bytes4) of the external contract call that failed.\n */\nerror ErrProxyCallFailed(bytes4 msgSig, bytes4 extCallSig);\n\n/**\n * @dev Error indicating that a function tried to call a precompiled contract that is not allowed.\n * @param msgSig The function signature (bytes4) that attempted to call a precompiled contract.\n */\nerror ErrCallPrecompiled(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a native token transfer has failed.\n * @param msgSig The function signature (bytes4) of the token transfer that failed.\n */\nerror ErrNativeTransferFailed(bytes4 msgSig);\n\n/**\n * @dev Error indicating that an order is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid order.\n */\nerror ErrInvalidOrder(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the chain ID is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid chain ID.\n * @param actual Current chain ID that executing function.\n * @param expected Expected chain ID required for the tx to success.\n */\nerror ErrInvalidChainId(bytes4 msgSig, uint256 actual, uint256 expected);\n\n/**\n * @dev Error indicating that a vote type is not supported.\n * @param msgSig The function signature (bytes4) of the operation that encountered an unsupported vote type.\n */\nerror ErrUnsupportedVoteType(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the proposal nonce is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid proposal nonce.\n */\nerror ErrInvalidProposalNonce(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a voter has already voted.\n * @param voter The address of the voter who has already voted.\n */\nerror ErrAlreadyVoted(address voter);\n\n/**\n * @dev Error indicating that a signature is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid signature.\n */\nerror ErrInvalidSignatures(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a relay call has failed.\n * @param msgSig The function signature (bytes4) of the relay call that failed.\n */\nerror ErrRelayFailed(bytes4 msgSig);\n/**\n * @dev Error indicating that a vote weight is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid vote weight.\n */\nerror ErrInvalidVoteWeight(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a query was made for an outdated bridge operator set.\n */\nerror ErrQueryForOutdatedBridgeOperatorSet();\n\n/**\n * @dev Error indicating that a request is invalid.\n */\nerror ErrInvalidRequest();\n\n/**\n * @dev Error indicating that a token standard is invalid.\n */\nerror ErrInvalidTokenStandard();\n\n/**\n * @dev Error indicating that a token is not supported.\n */\nerror ErrUnsupportedToken();\n\n/**\n * @dev Error indicating that a receipt kind is invalid.\n */\nerror ErrInvalidReceiptKind();\n\n/**\n * @dev Error indicating that a receipt is invalid.\n */\nerror ErrInvalidReceipt();\n\n/**\n * @dev Error indicating that an address is not payable.\n */\nerror ErrNonpayableAddress(address);\n\n/**\n * @dev Error indicating that the period is already processed, i.e. scattered reward.\n */\nerror ErrPeriodAlreadyProcessed(uint256 requestingPeriod, uint256 latestPeriod);\n\n/**\n * @dev Error thrown when an invalid vote hash is provided.\n */\nerror ErrInvalidVoteHash();\n\n/**\n * @dev Error thrown when querying for an empty vote.\n */\nerror ErrQueryForEmptyVote();\n\n/**\n * @dev Error thrown when querying for an expired vote.\n */\nerror ErrQueryForExpiredVote();\n\n/**\n * @dev Error thrown when querying for a non-existent vote.\n */\nerror ErrQueryForNonExistentVote();\n\n/**\n * @dev Error indicating that the method is only called once per block.\n */\nerror ErrOncePerBlock();\n\n/**\n * @dev Error of method caller must be coinbase\n */\nerror ErrCallerMustBeCoinbase();\n"
    },
    "contracts/utils/ContractType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum ContractType {\n  /*  0 */ UNKNOWN,\n  /*  1 */ PAUSE_ENFORCER,\n  /*  2 */ BRIDGE,\n  /*  3 */ BRIDGE_TRACKING,\n  /*  4 */ GOVERNANCE_ADMIN,\n  /*  5 */ MAINTENANCE,\n  /*  6 */ SLASH_INDICATOR,\n  /*  7 */ STAKING_VESTING,\n  /*  8 */ VALIDATOR,\n  /*  9 */ STAKING,\n  /* 10 */ RONIN_TRUSTED_ORGANIZATION,\n  /* 11 */ BRIDGE_MANAGER,\n  /* 12 */ BRIDGE_SLASH,\n  /* 13 */ BRIDGE_REWARD,\n  /* 14 */ FAST_FINALITY_TRACKING,\n  /* 15 */ PROFILE\n}\n"
    },
    "contracts/utils/DeprecatedSlots.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Deprecated Contracts\n * @dev These abstract contracts are deprecated and should not be used in new implementations.\n * They provide functionality related to various aspects of a smart contract but have been marked\n * as deprecated to indicate that they are no longer actively maintained or recommended for use.\n * The purpose of these contracts is to preserve the slots for already deployed contracts.\n */\ncontract HasSlashIndicatorDeprecated {\n  /// @custom:deprecated Previously `_slashIndicatorContract` (non-zero value)\n  address internal ______deprecatedSlashIndicator;\n}\n\ncontract HasStakingVestingDeprecated {\n  /// @custom:deprecated Previously `_stakingVestingContract` (non-zero value)\n  address internal ______deprecatedStakingVesting;\n}\n\ncontract HasBridgeDeprecated {\n  /// @custom:deprecated Previously `_bridgeContract` (non-zero value)\n  address internal ______deprecatedBridge;\n}\n\ncontract HasValidatorDeprecated {\n  /// @custom:deprecated Previously `_validatorContract` (non-zero value)\n  address internal ______deprecatedValidator;\n}\n\ncontract HasStakingDeprecated {\n  /// @custom:deprecated Previously `_stakingContract` (non-zero value)\n  address internal ______deprecatedStakingContract;\n}\n\ncontract HasMaintenanceDeprecated {\n  /// @custom:deprecated Previously `_maintenanceContract` (non-zero value)\n  address internal ______deprecatedMaintenance;\n}\n\ncontract HasTrustedOrgDeprecated {\n  /// @custom:deprecated Previously `_trustedOrgContract` (non-zero value)\n  address internal ______deprecatedTrustedOrg;\n}\n\ncontract HasGovernanceAdminDeprecated {\n  /// @custom:deprecated Previously `_governanceAdminContract` (non-zero value)\n  address internal ______deprecatedGovernanceAdmin;\n}\n\ncontract HasBridgeTrackingDeprecated {\n  /// @custom:deprecated Previously `_bridgeTrackingContract` (non-zero value)\n  address internal ______deprecatedBridgeTracking;\n}\n"
    },
    "contracts/utils/IdentityGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { AddressArrayUtils } from \"../libraries/AddressArrayUtils.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { TransparentUpgradeableProxyV2 } from \"../extensions/TransparentUpgradeableProxyV2.sol\";\nimport { ErrAddressIsNotCreatedEOA, ErrZeroAddress, ErrOnlySelfCall, ErrZeroCodeContract, ErrUnsupportedInterface } from \"./CommonErrors.sol\";\n\nabstract contract IdentityGuard {\n  using AddressArrayUtils for address[];\n\n  /// @dev value is equal to keccak256(abi.encode())\n  /// @dev see: https://eips.ethereum.org/EIPS/eip-1052\n  bytes32 internal constant CREATED_ACCOUNT_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n  /**\n   * @dev Modifier to restrict functions to only be called by this contract.\n   * @dev Reverts if the caller is not this contract.\n   */\n  modifier onlySelfCall() virtual {\n    _requireSelfCall();\n    _;\n  }\n\n  /**\n   * @dev Modifier to ensure that the elements in the `arr` array are non-duplicates.\n   * It calls the internal `_checkDuplicate` function to perform the duplicate check.\n   *\n   * Requirements:\n   * - The elements in the `arr` array must not contain any duplicates.\n   */\n  modifier nonDuplicate(address[] memory arr) virtual {\n    _requireNonDuplicate(arr);\n    _;\n  }\n\n  /**\n   * @dev Internal method to check the method caller.\n   * @dev Reverts if the method caller is not this contract.\n   */\n  function _requireSelfCall() internal view virtual {\n    if (msg.sender != address(this)) revert ErrOnlySelfCall(msg.sig);\n  }\n\n  /**\n   * @dev Internal function to check if a contract address has code.\n   * @param addr The address of the contract to check.\n   * @dev Throws an error if the contract address has no code.\n   */\n  function _requireHasCode(address addr) internal view {\n    if (addr.code.length == 0) revert ErrZeroCodeContract(addr);\n  }\n\n  /**\n   * @dev Checks if an address is zero and reverts if it is.\n   * @param addr The address to check.\n   */\n  function _requireNonZeroAddress(address addr) internal pure {\n    if (addr == address(0)) revert ErrZeroAddress(msg.sig);\n  }\n\n  /**\n   * @dev Check if arr is empty and revert if it is.\n   * Checks if an array contains any duplicate addresses and reverts if duplicates are found.\n   * @param arr The array of addresses to check.\n   */\n  function _requireNonDuplicate(address[] memory arr) internal pure {\n    if (arr.hasDuplicate()) revert AddressArrayUtils.ErrDuplicated(msg.sig);\n  }\n\n  /**\n   * @dev Internal function to require that the provided address is a created externally owned account (EOA).\n   * This internal function is used to ensure that the provided address is a valid externally owned account (EOA).\n   * It checks the codehash of the address against a predefined constant to confirm that the address is a created EOA.\n   * @notice This method only works with non-state EOA accounts\n   */\n  function _requireCreatedEOA(address addr) internal view {\n    _requireNonZeroAddress(addr);\n    bytes32 codehash = addr.codehash;\n    if (codehash != CREATED_ACCOUNT_HASH) revert ErrAddressIsNotCreatedEOA(addr, codehash);\n  }\n\n  /**\n   * @dev Internal function to require that the specified contract supports the given interface. This method handle in\n   * both case that the callee is either or not the proxy admin of the caller. If the contract does not support the\n   * interface `interfaceId` or EIP165, a revert with the corresponding error message is triggered.\n   *\n   * @param contractAddr The address of the contract to check for interface support.\n   * @param interfaceId The interface ID to check for support.\n   */\n  function _requireSupportsInterface(address contractAddr, bytes4 interfaceId) internal view {\n    bytes memory supportsInterfaceParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n    (bool success, bytes memory returnOrRevertData) = contractAddr.staticcall(supportsInterfaceParams);\n    if (!success) {\n      (success, returnOrRevertData) = contractAddr.staticcall(\n        abi.encodeCall(TransparentUpgradeableProxyV2.functionDelegateCall, (supportsInterfaceParams))\n      );\n      if (!success) revert ErrUnsupportedInterface(interfaceId, contractAddr);\n    }\n    if (!abi.decode(returnOrRevertData, (bool))) revert ErrUnsupportedInterface(interfaceId, contractAddr);\n  }\n}\n"
    },
    "contracts/utils/RoleAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum RoleAccess {\n  /* 0 */ UNKNOWN,\n  /* 1 */ ADMIN,\n  /* 2 */ COINBASE,\n  /* 3 */ GOVERNOR,\n  /* 4 */ CANDIDATE_ADMIN,\n  /* 5 */ WITHDRAWAL_MIGRATOR,\n  /* 6 */ __DEPRECATED_BRIDGE_OPERATOR,\n  /* 7 */ BLOCK_PRODUCER,\n  /* 8 */ VALIDATOR_CANDIDATE,\n  /* 9 */ CONSENSUS,\n  /* 10 */ TREASURY\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}