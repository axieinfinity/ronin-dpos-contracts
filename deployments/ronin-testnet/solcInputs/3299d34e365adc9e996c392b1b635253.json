{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/extensions/collections/HasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { HasProxyAdmin } from \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasContracts.sol\";\nimport { ErrUnexpectedInternalCall } from \"../../utils/CommonErrors.sol\";\n\n/**\n * @title HasContracts\n * @dev A contract that provides functionality to manage multiple contracts with different roles.\n */\nabstract contract HasContracts is HasProxyAdmin, IHasContracts {\n  /// @dev value is equal to keccak256(\"@ronin.dpos.collections.HasContracts.slot\") - 1\n  bytes32 private constant _STORAGE_SLOT = 0xdea3103d22025c269050bea94c0c84688877f12fa22b7e6d2d5d78a9a49aa1cb;\n\n  /**\n   * @dev Modifier to restrict access to functions only to contracts with a specific role.\n   * @param contractType The contract type that allowed to call\n   */\n  modifier onlyContract(ContractType contractType) virtual {\n    _requireContract(contractType);\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function setContract(ContractType contractType, address addr) external virtual onlyAdmin {\n    _requireHasCode(addr);\n    _setContract(contractType, addr);\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function getContract(ContractType contractType) public view returns (address contract_) {\n    contract_ = _getContractMap()[uint8(contractType)];\n    if (contract_ == address(0)) revert ErrContractTypeNotFound(contractType);\n  }\n\n  /**\n   * @dev Internal function to set the address of a contract with a specific role.\n   * @param contractType The contract type of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function _setContract(ContractType contractType, address addr) internal virtual {\n    _getContractMap()[uint8(contractType)] = addr;\n    emit ContractUpdated(contractType, addr);\n  }\n\n  /**\n   * @dev Internal function to check if a contract address has code.\n   * @param addr The address of the contract to check.\n   * @dev Throws an error if the contract address has no code.\n   */\n  function _requireHasCode(address addr) internal view {\n    if (addr.code.length == 0) revert ErrZeroCodeContract(addr);\n  }\n\n  /**\n   * @dev Internal function to access the mapping of contract addresses with roles.\n   * @return contracts_ The mapping of contract addresses with roles.\n   */\n  function _getContractMap() private pure returns (mapping(uint8 => address) storage contracts_) {\n    assembly {\n      contracts_.slot := _STORAGE_SLOT\n    }\n  }\n\n  /**\n   * @dev Internal function to check if the calling contract has a specific role.\n   * @param contractType The contract type that the calling contract must have.\n   * @dev Throws an error if the calling contract does not have the specified role.\n   */\n  function _requireContract(ContractType contractType) private view {\n    if (msg.sender != getContract(contractType)) {\n      revert ErrUnexpectedInternalCall(msg.sig, contractType, msg.sender);\n    }\n  }\n}\n"
    },
    "contracts/extensions/collections/HasProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../utils/CommonErrors.sol\";\n\nabstract contract HasProxyAdmin {\n  // bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  modifier onlyAdmin() {\n    _requireAdmin();\n    _;\n  }\n\n  /**\n   * @dev Returns proxy admin.\n   */\n  function _getAdmin() internal view returns (address) {\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  function _requireAdmin() internal view {\n    if (msg.sender != _getAdmin()) revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\n  }\n}\n"
    },
    "contracts/extensions/consumers/GlobalConfigConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nabstract contract GlobalConfigConsumer {\n  /// @dev The addition amount of gas sending along in external calls. Total gas stipend is added with default 2300 gas.\n  uint256 public constant DEFAULT_ADDITION_GAS = 1200;\n  /// @dev The length of a period in second.\n  uint256 public constant PERIOD_DURATION = 1 days;\n}\n"
    },
    "contracts/extensions/consumers/PercentageConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract PercentageConsumer {\n  uint256 internal constant _MAX_PERCENTAGE = 100_00;\n}\n"
    },
    "contracts/extensions/RONTransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nabstract contract RONTransferHelper {\n  /// @dev Error of sender has insufficient balance.\n  error ErrInsufficientBalance(bytes4 msgSig, uint256 currentBalance, uint256 sendAmount);\n  /// @dev Error of recipient not accepting RON when transfer RON.\n  error ErrRecipientRevert(bytes4 msgSig);\n\n  /**\n   * @dev See `_sendRON`.\n   * Reverts if the recipient does not receive RON.\n   */\n  function _transferRON(address payable _recipient, uint256 _amount) internal {\n    if (!_sendRON(_recipient, _amount)) revert ErrRecipientRevert(msg.sig);\n  }\n\n  /**\n   * @dev Send `_amount` RON to the address `_recipient`.\n   * Returns whether the recipient receives RON or not.\n   * Reverts once the contract balance is insufficient.\n   *\n   * Note: consider using `ReentrancyGuard` before calling this function.\n   *\n   */\n  function _sendRON(address payable _recipient, uint256 _amount) internal returns (bool _success) {\n    if (address(this).balance < _amount) revert ErrInsufficientBalance(msg.sig, address(this).balance, _amount);\n    return _unsafeSendRON(_recipient, _amount);\n  }\n\n  /**\n   * @dev Unsafe send `_amount` RON to the address `_recipient`. If the sender's balance is insufficient,\n   * the call does not revert.\n   *\n   * Note:\n   * - Does not assert whether the balance of sender is sufficient.\n   * - Does not assert whether the recipient accepts RON.\n   * - Consider using `ReentrancyGuard` before calling this function.\n   *\n   */\n  function _unsafeSendRON(address payable _recipient, uint256 _amount) internal returns (bool _success) {\n    (_success, ) = _recipient.call{ value: _amount }(\"\");\n  }\n\n  /**\n   * @dev Same purpose with {_unsafeSendRON(address,uin256)} but containing gas limit stipend forwarded in the call.\n   */\n  function _unsafeSendRON(address payable _recipient, uint256 _amount, uint256 _gas) internal returns (bool _success) {\n    (_success, ) = _recipient.call{ value: _amount, gas: _gas }(\"\");\n  }\n}\n"
    },
    "contracts/interfaces/collections/IHasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { ContractType } from \"../../utils/ContractType.sol\";\n\ninterface IHasContracts {\n  /// @dev Error of invalid role.\n  error ErrContractTypeNotFound(ContractType contractType);\n  /// @dev Error of set to non-contract.\n  error ErrZeroCodeContract(address addr);\n\n  /// @dev Emitted when a contract is updated.\n  event ContractUpdated(ContractType indexed contractType, address indexed addr);\n\n  /**\n   * @dev Returns the address of a contract with a specific role.\n   * Throws an error if no contract is set for the specified role.\n   *\n   * @param contractType The role of the contract to retrieve.\n   * @return contract_ The address of the contract with the specified role.\n   */\n  function getContract(ContractType contractType) external view returns (address contract_);\n\n  /**\n   * @dev Sets the address of a contract with a specific role.\n   * Emits the event {ContractUpdated}.\n   * @param contractType The role of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function setContract(ContractType contractType, address addr) external;\n}\n"
    },
    "contracts/interfaces/consumers/PeriodWrapperConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PeriodWrapperConsumer {\n  struct PeriodWrapper {\n    // Inner value.\n    uint256 inner;\n    // Last period number that the info updated.\n    uint256 lastPeriod;\n  }\n}\n"
    },
    "contracts/interfaces/IBridgeTracking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBridgeTracking {\n  struct Request {\n    VoteKind kind;\n    uint256 id;\n  }\n\n  enum VoteKind {\n    Deposit,\n    Withdrawal,\n    MainchainWithdrawal\n  }\n\n  /**\n   * @dev Returns the total number of votes at the specific period `_period`.\n   */\n  function totalVotes(uint256 _period) external view returns (uint256);\n\n  /**\n   * @dev Returns the total number of ballots at the specific period `_period`.\n   */\n  function totalBallots(uint256 _period) external view returns (uint256);\n\n  /**\n   * @dev Returns the total number of ballots of bridge operators at the specific period `_period`.\n   */\n  function getManyTotalBallots(\n    uint256 _period,\n    address[] calldata _bridgeOperators\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the total number of ballots of a bridge operator at the specific period `_period`.\n   */\n  function totalBallotsOf(uint256 _period, address _bridgeOperator) external view returns (uint256);\n\n  /**\n   * @dev Handles the request once it is approved.\n   *\n   * Requirements:\n   * - The method caller is the bridge contract.\n   *\n   */\n  function handleVoteApproved(VoteKind _kind, uint256 _requestId) external;\n\n  /**\n   * @dev Records vote for a receipt and a operator.\n   *\n   * Requirements:\n   * - The method caller is the bridge contract.\n   *\n   */\n  function recordVote(VoteKind _kind, uint256 _requestId, address _operator) external;\n}\n"
    },
    "contracts/interfaces/IMaintenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IMaintenance {\n  /**\n   * @dev Error thrown when attempting to schedule an already scheduled event.\n   */\n  error ErrAlreadyScheduled();\n\n  /**\n   * @dev Error thrown when referring to a non-existent schedule.\n   */\n  error ErrUnexistedSchedule();\n\n  /**\n   * @dev Error thrown when the end block of a schedule is out of range.\n   */\n  error ErrEndBlockOutOfRange();\n\n  /**\n   * @dev Error thrown when the start block of a schedule is out of range.\n   */\n  error ErrStartBlockOutOfRange();\n\n  /**\n   * @dev Error thrown when attempting to initiate maintenance while already in maintenance mode.\n   */\n  error ErrAlreadyOnMaintenance();\n\n  /**\n   * @dev Error thrown when attempting an action before the cooldown period has ended.\n   */\n  error ErrCooldownTimeNotYetEnded();\n\n  /**\n   * @dev Error thrown when the total number of schedules exceeds the limit.\n   */\n  error ErrTotalOfSchedulesExceeded();\n\n  /**\n   * @dev Error thrown when an invalid maintenance duration is specified.\n   */\n  error ErrInvalidMaintenanceDuration();\n\n  /**\n   * @dev Error thrown when an invalid maintenance duration configuration is provided.\n   */\n  error ErrInvalidMaintenanceDurationConfig();\n\n  /**\n   * @dev Error thrown when an invalid offset is specified to start the schedule configurations.\n   */\n  error ErrInvalidOffsetToStartScheduleConfigs();\n\n  struct Schedule {\n    uint256 from;\n    uint256 to;\n    uint256 lastUpdatedBlock;\n    uint256 requestTimestamp;\n  }\n\n  /// @dev Emitted when a maintenance is scheduled.\n  event MaintenanceScheduled(address indexed consensusAddr, Schedule);\n  /// @dev Emitted when a schedule of maintenance is cancelled.\n  event MaintenanceScheduleCancelled(address indexed consensusAddr);\n  /// @dev Emitted when the maintenance config is updated.\n  event MaintenanceConfigUpdated(\n    uint256 minMaintenanceDurationInBlock,\n    uint256 maxMaintenanceDurationInBlock,\n    uint256 minOffsetToStartSchedule,\n    uint256 maxOffsetToStartSchedule,\n    uint256 maxSchedules,\n    uint256 cooldownSecsToMaintain\n  );\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr` maintained at the block number `_block`.\n   */\n  function checkMaintained(address _consensusAddr, uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr` maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks.\n   */\n  function checkMaintainedInBlockRange(\n    address _consensusAddr,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool);\n\n  /**\n   * @dev Returns the bool array indicating the validators maintained at block number `_block` or not.\n   */\n  function checkManyMaintained(address[] calldata _addrList, uint256 _block) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns a bool array indicating the validators maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks or not.\n   */\n  function checkManyMaintainedInBlockRange(\n    address[] calldata _addrList,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr` has scheduled.\n   */\n  function checkScheduled(address _consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `_consensusAddr`\n   */\n  function checkCooldownEnds(address _consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns the detailed schedule of the validator `_consensusAddr`.\n   */\n  function getSchedule(address _consensusAddr) external view returns (Schedule memory);\n\n  /**\n   * @dev Returns the total of current schedules.\n   */\n  function totalSchedules() external view returns (uint256 _count);\n\n  /**\n   * @dev Sets the duration restriction, start time restriction, and max allowed for maintenance.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The max duration is larger than the min duration.\n   * - The max offset is larger than the min offset.\n   *\n   * Emits the event `MaintenanceConfigUpdated`.\n   *\n   */\n  function setMaintenanceConfig(\n    uint256 _minMaintenanceDurationInBlock,\n    uint256 _maxMaintenanceDurationInBlock,\n    uint256 _minOffsetToStartSchedule,\n    uint256 _maxOffsetToStartSchedule,\n    uint256 _maxSchedules,\n    uint256 _cooldownSecsToMaintain\n  ) external;\n\n  /**\n   * @dev Returns the min duration for maintenance in block.\n   */\n  function minMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the max duration for maintenance in block.\n   */\n  function maxMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev The offset to the min block number that the schedule can start\n   */\n  function minOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev The offset to the max block number that the schedule can start\n   */\n  function maxOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev Returns the max number of scheduled maintenances.\n   */\n  function maxSchedules() external view returns (uint256);\n\n  /**\n   * @dev Schedules for maintenance from `_startedAtBlock` to `_startedAtBlock`.\n   *\n   * Requirements:\n   * - The candidate `_consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `_consensusAddr`.\n   * - The candidate `_consensusAddr` has no schedule yet or the previous is done.\n   * - The total number of schedules is not larger than `maxSchedules()`.\n   * - The start block must be at least `minOffsetToStartSchedule()` and at most `maxOffsetToStartSchedule()` blocks from the current block.\n   * - The end block is larger than the start block.\n   * - The scheduled duration is larger than the `minMaintenanceDurationInBlock()` and less than the `maxMaintenanceDurationInBlock()`.\n   * - The start block is at the start of an epoch.\n   * - The end block is at the end of an epoch.\n   *\n   * Emits the event `MaintenanceScheduled`.\n   *\n   */\n  function schedule(address _consensusAddr, uint256 _startedAtBlock, uint256 _endedAtBlock) external;\n\n  /**\n   * @dev Cancel the schedule of maintenance for the `_consensusAddr`.\n   *\n   * Requirements:\n   * - The candidate `_consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `_consensusAddr`.\n   * - A schedule for the `_consensusAddr` must be existent and not executed yet.\n   *\n   * Emits the event `MaintenanceScheduleCancelled`.\n   */\n  function cancelSchedule(address _consensusAddr) external;\n}\n"
    },
    "contracts/interfaces/IQuorum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IQuorum {\n  /// @dev Emitted when the threshold is updated\n  event ThresholdUpdated(\n    uint256 indexed nonce,\n    uint256 indexed numerator,\n    uint256 indexed denominator,\n    uint256 previousNumerator,\n    uint256 previousDenominator\n  );\n\n  /**\n   * @dev Returns the threshold.\n   */\n  function getThreshold() external view returns (uint256 _num, uint256 _denom);\n\n  /**\n   * @dev Checks whether the `_voteWeight` passes the threshold.\n   */\n  function checkThreshold(uint256 _voteWeight) external view returns (bool);\n\n  /**\n   * @dev Returns the minimum vote weight to pass the threshold.\n   */\n  function minimumVoteWeight() external view returns (uint256);\n\n  /**\n   * @dev Sets the threshold.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `ThresholdUpdated` event.\n   *\n   */\n  function setThreshold(\n    uint256 _numerator,\n    uint256 _denominator\n  ) external returns (uint256 _previousNum, uint256 _previousDenom);\n}\n"
    },
    "contracts/interfaces/IRoninGovernanceAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../libraries/BridgeOperatorsBallot.sol\";\n\ninterface IRoninGovernanceAdmin {\n  /**\n   * @dev Error thrown when an invalid vote hash is provided.\n   */\n  error ErrInvalidVoteHash();\n\n  /**\n   * @dev Error thrown when querying for an empty vote.\n   */\n  error ErrQueryForEmptyVote();\n\n  /**\n   * @dev Error thrown when querying for an expired vote.\n   */\n  error ErrQueryForExpiredVote();\n\n  /**\n   * @dev Error thrown when querying for a non-existent vote.\n   */\n  error ErrQueryForNonExistentVote();\n\n  /// @dev Emitted when the bridge operators are approved.\n  event BridgeOperatorsApproved(uint256 _period, uint256 _epoch, address[] _operators);\n  /// @dev Emitted when an emergency exit poll is created.\n  event EmergencyExitPollCreated(\n    bytes32 _voteHash,\n    address _consensusAddr,\n    address _recipientAfterUnlockedFund,\n    uint256 _requestedAt,\n    uint256 _expiredAt\n  );\n  /// @dev Emitted when an emergency exit poll is approved.\n  event EmergencyExitPollApproved(bytes32 _voteHash);\n  /// @dev Emitted when an emergency exit poll is expired.\n  event EmergencyExitPollExpired(bytes32 _voteHash);\n  /// @dev Emitted when an emergency exit poll is voted.\n  event EmergencyExitPollVoted(bytes32 indexed _voteHash, address indexed _voter);\n\n  /**\n   * @dev Returns the last voted block of the bridge voter.\n   */\n  function lastVotedBlock(address _bridgeVoter) external view returns (uint256);\n\n  /**\n   * @dev Returns the synced bridge operator set info.\n   */\n  function lastSyncedBridgeOperatorSetInfo()\n    external\n    view\n    returns (BridgeOperatorsBallot.BridgeOperatorSet memory _bridgeOperatorSetInfo);\n\n  /**\n   * @dev Create a vote to agree that an emergency exit is valid and should return the locked funds back.a\n   *\n   * Requirements:\n   * - The method caller is validator contract.\n   *\n   */\n  function createEmergencyExitPoll(\n    address _consensusAddr,\n    address _recipientAfterUnlockedFund,\n    uint256 _requestedAt,\n    uint256 _expiredAt\n  ) external;\n}\n"
    },
    "contracts/interfaces/IRoninTrustedOrganization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IQuorum.sol\";\n\ninterface IRoninTrustedOrganization is IQuorum {\n  /**\n   * @dev Error indicating that a query for a duplicate entry was made.\n   */\n  error ErrQueryForDupplicated();\n\n  /**\n   * @dev Error indicating that a query was made for a non-existent consensus address.\n   */\n  error ErrQueryForNonExistentConsensusAddress();\n\n  /**\n   * @dev Error indicating that a bridge voter has already been added.\n   * @param voter The address of the bridge voter that is already added.\n   */\n  error ErrBridgeVoterIsAlreadyAdded(address voter);\n\n  /**\n   * @dev Error indicating that a governor address has already been added.\n   * @param addr The address of the governor that is already added.\n   */\n  error ErrGovernorAddressIsAlreadyAdded(address addr);\n\n  /**\n   * @dev Error indicating that a consensus address is not added.\n   * @param addr The address of the consensus contract that is not added.\n   */\n  error ErrConsensusAddressIsNotAdded(address addr);\n\n  /**\n   * @dev Error indicating that a consensus address is already added.\n   * @param addr The address of the consensus contract that is already added.\n   */\n  error ErrConsensusAddressIsAlreadyAdded(address addr);\n\n  struct TrustedOrganization {\n    // Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n    address consensusAddr;\n    // Address to voting proposal\n    address governor;\n    // Address to voting bridge operators\n    address bridgeVoter;\n    // Its Weight\n    uint256 weight;\n    // The block that the organization was added\n    uint256 addedBlock;\n  }\n\n  /// @dev Emitted when the trusted organization is added.\n  event TrustedOrganizationsAdded(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is updated.\n  event TrustedOrganizationsUpdated(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is removed.\n  event TrustedOrganizationsRemoved(address[] orgs);\n\n  /**\n   * @dev Adds a list of addresses into the trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   * - The field `addedBlock` should be blank.\n   *\n   * Emits the event `TrustedOrganizationAdded` once an organization is added.\n   *\n   */\n  function addTrustedOrganizations(TrustedOrganization[] calldata) external;\n\n  /**\n   * @dev Updates weights for a list of existent trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   *\n   * Emits the `TrustedOrganizationUpdated` event.\n   *\n   */\n  function updateTrustedOrganizations(TrustedOrganization[] calldata _list) external;\n\n  /**\n   * @dev Removes a list of addresses from the trusted organization.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `TrustedOrganizationRemoved` once an organization is removed.\n   *\n   * @param _consensusAddrs The list of consensus addresses linked to corresponding trusted organization that to be removed.\n   */\n  function removeTrustedOrganizations(address[] calldata _consensusAddrs) external;\n\n  /**\n   * @dev Returns total weights.\n   */\n  function totalWeights() external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a consensus.\n   */\n  function getConsensusWeight(address _consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a governor.\n   */\n  function getGovernorWeight(address _governor) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a bridge voter.\n   */\n  function getBridgeVoterWeight(address _addr) external view returns (uint256);\n\n  /**\n   * @dev Returns the weights of a list of consensus addresses.\n   */\n  function getConsensusWeights(address[] calldata _list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of governor addresses.\n   */\n  function getGovernorWeights(address[] calldata _list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of bridge voter addresses.\n   */\n  function getBridgeVoterWeights(address[] calldata _list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns total weights of the consensus list.\n   */\n  function sumConsensusWeights(address[] calldata _list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns total weights of the governor list.\n   */\n  function sumGovernorWeights(address[] calldata _list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns total weights of the bridge voter list.\n   */\n  function sumBridgeVoterWeights(address[] calldata _list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns the trusted organization at `_index`.\n   */\n  function getTrustedOrganizationAt(uint256 _index) external view returns (TrustedOrganization memory);\n\n  /**\n   * @dev Returns the number of trusted organizations.\n   */\n  function countTrustedOrganizations() external view returns (uint256);\n\n  /**\n   * @dev Returns all of the trusted organizations.\n   */\n  function getAllTrustedOrganizations() external view returns (TrustedOrganization[] memory);\n\n  /**\n   * @dev Returns the trusted organization by consensus address.\n   *\n   * Reverts once the consensus address is non-existent.\n   */\n  function getTrustedOrganization(address _consensusAddr) external view returns (TrustedOrganization memory);\n}\n"
    },
    "contracts/interfaces/IStakingVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IStakingVesting {\n  /**\n   * @dev Error thrown when attempting to send a bonus that has already been sent.\n   */\n  error ErrBonusAlreadySent();\n\n  /// @dev Emitted when the block bonus for block producer is transferred.\n  event BonusTransferred(\n    uint256 indexed blockNumber,\n    address indexed recipient,\n    uint256 blockProducerAmount,\n    uint256 bridgeOperatorAmount\n  );\n  /// @dev Emitted when the transfer of block bonus for block producer is failed.\n  event BonusTransferFailed(\n    uint256 indexed blockNumber,\n    address indexed recipient,\n    uint256 blockProducerAmount,\n    uint256 bridgeOperatorAmount,\n    uint256 contractBalance\n  );\n  /// @dev Emitted when the block bonus for block producer is updated\n  event BlockProducerBonusPerBlockUpdated(uint256);\n  /// @dev Emitted when the block bonus for bridge operator is updated\n  event BridgeOperatorBonusPerBlockUpdated(uint256);\n\n  /**\n   * @dev Returns the bonus amount for the block producer at `_block`.\n   */\n  function blockProducerBlockBonus(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Returns the bonus amount for the bridge validator at `_block`.\n   */\n  function bridgeOperatorBlockBonus(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Receives RON from any address.\n   */\n  function receiveRON() external payable;\n\n  /**\n   * @dev Returns the last block number that the staking vesting is sent.\n   */\n  function lastBlockSendingBonus() external view returns (uint256);\n\n  /**\n   * @dev Transfers the staking vesting for the block producer and the bridge operator whenever a new block is mined.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   * - The method must be called only once per block.\n   *\n   * Emits the event `BonusTransferred` or `BonusTransferFailed`.\n   *\n   * Notes:\n   * - The method does not revert when the contract balance is insufficient to send bonus. This assure the submit reward method\n   * will not be reverted, and the underlying nodes does not hang.\n   *\n   * @param _forBlockProducer Indicates whether requesting the bonus for the block procucer, in case of being in jail or relevance.\n   * @param _forBridgeOperator Indicates whether requesting the bonus for the bridge operator.\n   *\n   * @return _success Whether the transfer is successfully. This returns false mostly because this contract is out of balance.\n   * @return _blockProducerBonus The amount of bonus actually sent for the block producer, returns 0 when the transfer is failed.\n   * @return _bridgeOperatorBonus The amount of bonus actually sent for the bridge operator, returns 0 when the transfer is failed.\n   *\n   */\n  function requestBonus(\n    bool _forBlockProducer,\n    bool _forBridgeOperator\n  ) external returns (bool _success, uint256 _blockProducerBonus, uint256 _bridgeOperatorBonus);\n\n  /**\n   * @dev Sets the bonus amount per block for block producer.\n   *\n   * Emits the event `BlockProducerBonusPerBlockUpdated`.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   */\n  function setBlockProducerBonusPerBlock(uint256 _amount) external;\n\n  /**\n   * @dev Sets the bonus amount per block for bridge operator.\n   *\n   * Emits the event `BridgeOperatorBonusPerBlockUpdated`.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   */\n  function setBridgeOperatorBonusPerBlock(uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/IBaseSlash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IBaseSlash {\n  enum SlashType {\n    UNKNOWN,\n    UNAVAILABILITY_TIER_1,\n    UNAVAILABILITY_TIER_2,\n    DOUBLE_SIGNING,\n    BRIDGE_VOTING,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_1,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_2,\n    UNAVAILABILITY_TIER_3\n  }\n\n  /// @dev Emitted when the validator is slashed.\n  event Slashed(address indexed validator, SlashType slashType, uint256 period);\n}\n"
    },
    "contracts/interfaces/slash-indicator/ICreditScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ICreditScore {\n  /**\n   * @dev Error thrown when an invalid credit score configuration is provided.\n   */\n  error ErrInvalidCreditScoreConfig();\n\n  /**\n   * @dev Error thrown when an invalid cut-off percentage configuration is provided.\n   */\n  error ErrInvalidCutOffPercentageConfig();\n\n  /**\n   * @dev Error thrown when the caller's credit score is insufficient to bail out a situation.\n   */\n  error ErrInsufficientCreditScoreToBailOut();\n\n  /**\n   * @dev Error thrown when a validator has previously bailed out.\n   */\n  error ErrValidatorHasBailedOutPreviously();\n\n  /**\n   * @dev Error thrown when the caller must be jailed in the current period.\n   */\n  error ErrCallerMustBeJailedInTheCurrentPeriod();\n\n  /// @dev Emitted when the configs to credit score is updated. See the method `setCreditScoreConfigs` for param details.\n  event CreditScoreConfigsUpdated(\n    uint256 gainCreditScore,\n    uint256 maxCreditScore,\n    uint256 bailOutCostMultiplier,\n    uint256 cutOffPercentageAfterBailout\n  );\n  /// @dev Emitted the credit score of validators is updated.\n  event CreditScoresUpdated(address[] validators, uint256[] creditScores);\n  /// @dev Emitted when a validator bailed out of jail.\n  event BailedOut(address indexed validator, uint256 period, uint256 usedCreditScore);\n\n  /**\n   * @dev Updates the credit score for the validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function updateCreditScores(address[] calldata _validators, uint256 _period) external;\n\n  /**\n   * @dev Resets the credit score for the revoked validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function execResetCreditScores(address[] calldata _validators) external;\n\n  /**\n   * @dev A slashed validator use this method to get out of jail.\n   *\n   * Requirements:\n   * - The `_consensusAddr` must be a validator.\n   * - Only validator's admin can call this method.\n   *\n   * Emits the event `BailedOut`.\n   *\n   */\n  function bailOut(address _consensusAddr) external;\n\n  /**\n   * @dev Sets the configs to credit score.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CreditScoreConfigsUpdated`.\n   *\n   * @param _gainScore The score to gain per period.\n   * @param _maxScore The max number of credit score that a validator can hold.\n   * @param _bailOutMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @param _cutOffPercentage The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) external;\n\n  /**\n   * @dev Returns the configs related to credit score.\n   *\n   * @return _gainCreditScore The score to gain per period.\n   * @return _maxCreditScore The max number of credit score that a validator can hold.\n   * @return _bailOutCostMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @return _cutOffPercentageAfterBailout The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function getCreditScoreConfigs()\n    external\n    view\n    returns (\n      uint256 _gainCreditScore,\n      uint256 _maxCreditScore,\n      uint256 _bailOutCostMultiplier,\n      uint256 _cutOffPercentageAfterBailout\n    );\n\n  /**\n   * @dev Returns the current credit score of the validator.\n   */\n  function getCreditScore(address _validator) external view returns (uint256);\n\n  /**\n   * @dev Returns the current credit score of a list of validators.\n   */\n  function getManyCreditScores(address[] calldata _validators) external view returns (uint256[] memory _resultList);\n\n  /**\n   * @dev Returns the whether the `_validator` has been bailed out at the `_period`.\n   */\n  function checkBailedOutAtPeriod(address _validator, uint256 _period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashBridgeOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashBridgeOperator is IBaseSlash {\n  /**\n   * @dev Error thrown when invalid ratios are provided.\n   */\n  error ErrInvalidRatios();\n\n  /**\n   * @dev Emitted when the configs to slash bridge operator is updated. See the method\n   * `getBridgeOperatorSlashingConfigs` for param details.\n   */\n  event BridgeOperatorSlashingConfigsUpdated(\n    uint256 missingVotesRatioTier1,\n    uint256 missingVotesRatioTier2,\n    uint256 jailDurationForMissingVotesRatioTier2,\n    uint256 skipBridgeOperatorSlashingThreshold\n  );\n\n  /**\n   * @dev Acknowledges bridge operator slash and emit `Slashed` event correspondingly.\n   * @param _tier The tier of the slash, in value of {1, 2}, corresponding to `SlashType.BRIDGE_OPERATOR_MISSING_VOTE_TIER_1`\n   * and `SlashType.BRIDGE_OPERATOR_MISSING_VOTE_TIER_2`\n   *\n   * Requirements:\n   * - Only validator contract can invoke this method.\n   * - Should be called only at the end of period.\n   * - Should be called only when there is slash of bridge operator.\n   *\n   * Emits the event `Slashed`.\n   */\n  function execSlashBridgeOperator(address _consensusAddr, uint256 _tier, uint256 _period) external;\n\n  /**\n   * @dev Returns the configs related to bridge operator slashing.\n   *\n   * @return _missingVotesRatioTier1 The bridge reward will be deprecated if (s)he missed more than this ratio.\n   * @return _missingVotesRatioTier2 The bridge reward and mining reward will be deprecated and the corresponding\n   * block producer will be put in jail if (s)he misses more than this ratio.\n   * @return _jailDurationForMissingVotesRatioTier2 The number of blocks to jail the corresponding block producer when\n   * its bridge operator is slashed tier-2.\n   * @return _skipBridgeOperatorSlashingThreshold The threshold to skip slashing the bridge operator in case the total\n   * number of votes in the bridge is too small.\n   *\n   */\n  function getBridgeOperatorSlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _missingVotesRatioTier1,\n      uint256 _missingVotesRatioTier2,\n      uint256 _jailDurationForMissingVotesRatioTier2,\n      uint256 _skipBridgeOperatorSlashingThreshold\n    );\n\n  /**\n   * @dev Sets the configs to slash bridge operators.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeOperatorSlashingConfigsUpdated`.\n   *\n   * @param _ratioTier1 The bridge reward will be deprecated if (s)he missed more than this ratio. Values 0-10,000 map\n   * to 0%-100%.\n   * @param _ratioTier2 The bridge reward and mining reward will be deprecated and the corresponding block producer will\n   * be put in jail if (s)he misses more than this ratio. Values 0-10,000 map to 0%-100%.\n   * @param _jailDurationTier2 The number of blocks to jail the corresponding block producer when its bridge operator is\n   * slashed tier-2.\n   * @param _skipSlashingThreshold The threshold to skip slashing the bridge operator in case the total number of votes\n   * in the bridge is too small.\n   *\n   */\n  function setBridgeOperatorSlashingConfigs(\n    uint256 _ratioTier1,\n    uint256 _ratioTier2,\n    uint256 _jailDurationTier2,\n    uint256 _skipSlashingThreshold\n  ) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashBridgeVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashBridgeVoting is IBaseSlash {\n  /**\n   * @dev Error thrown when an invalid slash is encountered.\n   */\n  error ErrInvalidSlash();\n\n  /**\n   * @dev Emitted when the configs to slash bridge voting is updated. See the method `getBridgeVotingSlashingConfigs` for param\n   * details.\n   */\n  event BridgeVotingSlashingConfigsUpdated(uint256 bridgeVotingThreshold, uint256 bridgeVotingSlashAmount);\n\n  /**\n   * @dev Slashes for bridge voter governance.\n   *\n   * Emits the event `Slashed`.\n   */\n  function slashBridgeVoting(address _consensusAddr) external;\n\n  /**\n   * @dev Returns the configs related to bridge voting slashing.\n   *\n   * @return _bridgeVotingThreshold The threshold to slash when a trusted organization does not vote for bridge\n   * operators.\n   * @return _bridgeVotingSlashAmount The amount of RON to slash bridge voting.\n   *\n   */\n  function getBridgeVotingSlashingConfigs()\n    external\n    view\n    returns (uint256 _bridgeVotingThreshold, uint256 _bridgeVotingSlashAmount);\n\n  /**\n   * @dev Sets the configs to slash bridge voting.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeVotingSlashingConfigsUpdated`.\n   *\n   * @param _threshold The threshold to slash when a trusted organization does not vote for bridge operators.\n   * @param _slashAmount The amount of RON to slash bridge voting.\n   *\n   */\n  function setBridgeVotingSlashingConfigs(uint256 _threshold, uint256 _slashAmount) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashDoubleSign is IBaseSlash {\n  /**\n   * @dev Error thrown when evidence has already been submitted.\n   */\n  error ErrEvidenceAlreadySubmitted();\n\n  /**\n   * @dev Emitted when the configs to slash double sign is updated. See the method `getDoubleSignSlashingConfigs`\n   * for param details.\n   */\n  event DoubleSignSlashingConfigsUpdated(\n    uint256 slashDoubleSignAmount,\n    uint256 doubleSigningJailUntilBlock,\n    uint256 doubleSigningOffsetLimitBlock\n  );\n\n  /**\n   * @dev Slashes for double signing.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` if the double signing evidence of the two headers valid.\n   */\n  function slashDoubleSign(address _validatorAddr, bytes calldata _header1, bytes calldata _header2) external;\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return _slashDoubleSignAmount The amount of RON to slash double sign.\n   * @return _doubleSigningJailUntilBlock The block number that the punished validator will be jailed until, due to\n   * double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function getDoubleSignSlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _slashDoubleSignAmount,\n      uint256 _doubleSigningJailUntilBlock,\n      uint256 _doubleSigningOffsetLimitBlock\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `DoubleSignSlashingConfigsUpdated`.\n   *\n   * @param _slashAmount The amount of RON to slash double sign.\n   * @param _jailUntilBlock The block number that the punished validator will be jailed until, due to double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _doubleSigningOffsetLimitBlock\n  ) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashIndicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashDoubleSign.sol\";\nimport \"./ISlashBridgeVoting.sol\";\nimport \"./ISlashBridgeOperator.sol\";\nimport \"./ISlashUnavailability.sol\";\nimport \"./ICreditScore.sol\";\n\ninterface ISlashIndicator is\n  ISlashDoubleSign,\n  ISlashBridgeVoting,\n  ISlashBridgeOperator,\n  ISlashUnavailability,\n  ICreditScore\n{}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashUnavailability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\n\ninterface ISlashUnavailability is IBaseSlash {\n  /**\n   * @dev Error thrown when attempting to slash a validator twice or slash more than one validator in one block.\n   */\n  error ErrCannotSlashAValidatorTwiceOrSlashMoreThanOneValidatorInOneBlock();\n\n  /**\n   * @dev Emitted when the configs to slash bridge operator is updated. See the method `getUnavailabilitySlashingConfigs`\n   * for param details.\n   */\n  event UnavailabilitySlashingConfigsUpdated(\n    uint256 unavailabilityTier1Threshold,\n    uint256 unavailabilityTier2Threshold,\n    uint256 slashAmountForUnavailabilityTier2Threshold,\n    uint256 jailDurationForUnavailabilityTier2Threshold\n  );\n\n  /**\n   * @dev Returns the last block that a block producer is slashed for unavailability.\n   */\n  function lastUnavailabilitySlashedBlock() external view returns (uint256);\n\n  /**\n   * @dev Slashes for unavailability by increasing the counter of block producer `_consensusAddr`.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` when the threshold is reached.\n   *\n   */\n  function slashUnavailability(address _consensusAddr) external;\n\n  /**\n   * @dev Returns the current unavailability indicator of a block producer.\n   */\n  function currentUnavailabilityIndicator(address _validator) external view returns (uint256);\n\n  /**\n   * @dev Returns the unavailability indicator in the period `_period` of a block producer.\n   */\n  function getUnavailabilityIndicator(address _validator, uint256 _period) external view returns (uint256);\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return _unavailabilityTier1Threshold The mining reward will be deprecated, if (s)he missed more than this\n   * threshold. This threshold is applied for tier-1 and tier-3 slash.\n   * @return _unavailabilityTier2Threshold  The mining reward will be deprecated, (s)he will be put in jailed, and will\n   * be deducted self-staking if (s)he misses more than this threshold. This threshold is applied for tier-2 slash.\n   * @return _slashAmountForUnavailabilityTier2Threshold The amount of RON to deduct from self-staking of a block\n   * producer when (s)he is slashed with tier-2 or tier-3.\n   * @return _jailDurationForUnavailabilityTier2Threshold The number of blocks to jail a block producer when (s)he is\n   * slashed with tier-2 or tier-3.\n   *\n   */\n  function getUnavailabilitySlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _unavailabilityTier1Threshold,\n      uint256 _unavailabilityTier2Threshold,\n      uint256 _slashAmountForUnavailabilityTier2Threshold,\n      uint256 _jailDurationForUnavailabilityTier2Threshold\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeOperatorSlashingConfigsUpdated`.\n   *\n   * @param _tier1Threshold The mining reward will be deprecated, if (s)he missed more than this threshold.\n   * @param _tier2Threshold The mining reward will be deprecated, (s)he will be put in jailed, and will be deducted\n   * self-staking if (s)he misses more than this threshold.\n   * @param _slashAmountForTier2Threshold The amount of RON to deduct from self-staking of a block producer when (s)he\n   * is slashed tier-2.\n   * @param _jailDurationForTier2Threshold The number of blocks to jail a block producer when (s)he is slashed tier-2.\n   *\n   */\n  function setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) external;\n}\n"
    },
    "contracts/interfaces/staking/IBaseStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IBaseStaking {\n  struct PoolDetail {\n    // Address of the pool i.e. consensus address of the validator\n    address addr;\n    // Pool admin address\n    address admin;\n    // Self-staking amount\n    uint256 stakingAmount;\n    // Total number of RON staking for the pool\n    uint256 stakingTotal;\n    // Mapping from delegator => delegating amount\n    mapping(address => uint256) delegatingAmount;\n    // Mapping from delegator => the last timestamp that delegator staked\n    mapping(address => uint256) lastDelegatingTimestamp;\n  }\n\n  /// @dev Emitted when the minium number of seconds to undelegate is updated.\n  event CooldownSecsToUndelegateUpdated(uint256 minSecs);\n  /// @dev Emitted when the number of seconds that a candidate must wait to be revoked.\n  event WaitingSecsToRevokeUpdated(uint256 secs);\n\n  /// @dev Error of cannot transfer RON.\n  error ErrCannotTransferRON();\n  /// @dev Error of receiving zero message value.\n  error ErrZeroValue();\n  /// @dev Error of pool admin is not allowed to call.\n  error ErrPoolAdminForbidden();\n  /// @dev Error of no one is allowed to call but the pool's admin.\n  error ErrOnlyPoolAdminAllowed();\n  /// @dev Error of admin of any active pool cannot delegate.\n  error ErrAdminOfAnyActivePoolForbidden(address admin);\n  /// @dev Error of querying inactive pool.\n  error ErrInactivePool(address poolAddr);\n  /// @dev Error of length of input arrays are not of the same.\n  error ErrInvalidArrays();\n\n  /**\n   * @dev Returns whether the `_poolAdminAddr` is currently active.\n   */\n  function isAdminOfActivePool(address _poolAdminAddr) external view returns (bool);\n\n  /**\n   * @dev Returns the consensus address corresponding to the pool admin.\n   */\n  function getPoolAddressOf(address _poolAdminAddr) external view returns (address);\n\n  /**\n   * @dev Returns the staking pool detail.\n   */\n  function getPoolDetail(address) external view returns (address _admin, uint256 _stakingAmount, uint256 _stakingTotal);\n\n  /**\n   * @dev Returns the self-staking amounts of the pools.\n   */\n  function getManySelfStakings(address[] calldata) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns The cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n   */\n  function cooldownSecsToUndelegate() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of seconds that a candidate must wait for the renounce request gets affected.\n   */\n  function waitingSecsToRevoke() external view returns (uint256);\n\n  /**\n   * @dev Sets the cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CooldownSecsToUndelegateUpdated`.\n   *\n   */\n  function setCooldownSecsToUndelegate(uint256 _cooldownSecs) external;\n\n  /**\n   * @dev Sets the number of seconds that a candidate must wait to be revoked.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `WaitingSecsToRevokeUpdated`.\n   *\n   */\n  function setWaitingSecsToRevoke(uint256 _secs) external;\n}\n"
    },
    "contracts/interfaces/staking/ICandidateStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IRewardPool.sol\";\n\ninterface ICandidateStaking is IRewardPool {\n  /// @dev Emitted when the minimum staking amount for being a validator is updated.\n  event MinValidatorStakingAmountUpdated(uint256 threshold);\n  /// @dev Emitted when the commission rate range is updated.\n  event CommissionRateRangeUpdated(uint256 minRate, uint256 maxRate);\n\n  /// @dev Emitted when the pool admin staked for themself.\n  event Staked(address indexed consensuAddr, uint256 amount);\n  /// @dev Emitted when the pool admin unstaked the amount of RON from themself.\n  event Unstaked(address indexed consensuAddr, uint256 amount);\n\n  /// @dev Emitted when the validator pool is approved.\n  event PoolApproved(address indexed validator, address indexed admin);\n  /// @dev Emitted when the validator pool is deprecated.\n  event PoolsDeprecated(address[] validator);\n  /// @dev Emitted when the staking amount transfer failed.\n  event StakingAmountTransferFailed(\n    address indexed validator,\n    address indexed admin,\n    uint256 amount,\n    uint256 contractBalance\n  );\n  /// @dev Emitted when the staking amount deducted failed, e.g. when the validator gets slashed.\n  event StakingAmountDeductFailed(\n    address indexed validator,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Error of cannot transfer RON to specified target.\n  error ErrCannotInitTransferRON(address addr, string extraInfo);\n  /// @dev Error of three interaction addresses must be of the same in applying for validator candidate.\n  error ErrThreeInteractionAddrsNotEqual();\n  /// @dev Error of unstaking zero amount.\n  error ErrUnstakeZeroAmount();\n  /// @dev Error of invalid staking amount left after deducted.\n  error ErrStakingAmountLeft();\n  /// @dev Error of insufficient staking amount for unstaking.\n  error ErrInsufficientStakingAmount();\n  /// @dev Error of unstaking too early.\n  error ErrUnstakeTooEarly();\n  /// @dev Error of setting commission rate exceeds max allowed.\n  error ErrInvalidCommissionRate();\n\n  /**\n   * @dev Returns the minimum threshold for being a validator candidate.\n   */\n  function minValidatorStakingAmount() external view returns (uint256);\n\n  /**\n   * @dev Returns the commission rate range that the candidate can set.\n   */\n  function getCommissionRateRange() external view returns (uint256 _minRange, uint256 _maxRange);\n\n  /**\n   * @dev Sets the minimum threshold for being a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinValidatorStakingAmountUpdated` event.\n   *\n   */\n  function setMinValidatorStakingAmount(uint256) external;\n\n  /**\n   * @dev Sets the commission rate range that a candidate can set.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `CommissionRateRangeUpdated` event.\n   *\n   */\n  function setCommissionRateRange(uint256 _minRate, uint256 _maxRate) external;\n\n  /**\n   * @dev Proposes a candidate to become a validator.\n   *\n   * Requirements:\n   * - The method caller is able to receive RON.\n   * - The treasury is able to receive RON.\n   * - The amount is larger than or equal to the minimum validator staking amount `minValidatorStakingAmount()`.\n   *\n   * Emits the event `PoolApproved`.\n   *\n   * @param _candidateAdmin the candidate admin will be stored in the validator contract, used for calling function that affects\n   * to its candidate, e.g. scheduling maintenance.\n   *\n   */\n  function applyValidatorCandidate(\n    address _candidateAdmin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    address _bridgeOperatorAddr,\n    uint256 _commissionRate\n  ) external payable;\n\n  /**\n   * @dev Deprecates the pool.\n   * - Deduct self-staking amount of the pool admin to zero.\n   * - Transfer the deducted amount to the pool admin.\n   * - Deactivate the pool admin address in the mapping of active pool admins\n   *\n   * Requirements:\n   * - The method caller is validator contract.\n   *\n   * Emits the event `PoolsDeprecated` and `Unstaked` events.\n   * Emits the event `StakingAmountTransferFailed` if the contract cannot transfer RON back to the pool admin.\n   *\n   */\n  function execDeprecatePools(address[] calldata _pools, uint256 _period) external;\n\n  /**\n   * @dev Self-delegates to the validator candidate `_consensusAddr`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   * - The `msg.value` is larger than 0.\n   *\n   * Emits the event `Staked`.\n   *\n   */\n  function stake(address _consensusAddr) external payable;\n\n  /**\n   * @dev Unstakes from the validator candidate `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   * Emits the event `Unstaked`.\n   *\n   */\n  function unstake(address _consensusAddr, uint256 _amount) external;\n\n  /**\n   * @dev Pool admin requests update validator commission rate. The request will be forwarded to the candidate manager\n   * contract, and the value is getting updated in {ICandidateManager-execRequestUpdateCommissionRate}.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   * - The `_effectiveDaysOnwards` must be equal to or larger than the {CandidateManager-_minEffectiveDaysOnwards}.\n   * - The `_rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdated`.\n   *\n   */\n  function requestUpdateCommissionRate(\n    address _consensusAddr,\n    uint256 _effectiveDaysOnwards,\n    uint256 _commissionRate\n  ) external;\n\n  /**\n   * @dev Renounces being a validator candidate and takes back the delegating/staking amount.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   */\n  function requestRenounce(address _consensusAddr) external;\n\n  /**\n   * @dev Renounces being a validator candidate and takes back the delegating/staking amount.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   */\n  function requestEmergencyExit(address _consensusAddr) external;\n}\n"
    },
    "contracts/interfaces/staking/IDelegatorStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IRewardPool.sol\";\n\ninterface IDelegatorStaking is IRewardPool {\n  /// @dev Emitted when the delegator staked for a validator candidate.\n  event Delegated(address indexed delegator, address indexed consensuAddr, uint256 amount);\n  /// @dev Emitted when the delegator unstaked from a validator candidate.\n  event Undelegated(address indexed delegator, address indexed consensuAddr, uint256 amount);\n\n  /// @dev Error of undelegating zero amount.\n  error ErrUndelegateZeroAmount();\n  /// @dev Error of undelegating insufficient amount.\n  error ErrInsufficientDelegatingAmount();\n  /// @dev Error of undelegating too early.\n  error ErrUndelegateTooEarly();\n\n  /**\n   * @dev Stakes for a validator candidate `_consensusAddr`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is not the pool admin.\n   *\n   * Emits the `Delegated` event.\n   *\n   */\n  function delegate(address _consensusAddr) external payable;\n\n  /**\n   * @dev Unstakes from a validator candidate `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   *\n   * Emits the `Undelegated` event.\n   *\n   */\n  function undelegate(address _consensusAddr, uint256 _amount) external;\n\n  /**\n   * @dev Bulk unstakes from a list of candidates.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   *\n   * Emits the events `Undelegated`.\n   *\n   */\n  function bulkUndelegate(address[] calldata _consensusAddrs, uint256[] calldata _amounts) external;\n\n  /**\n   * @dev Unstakes an amount of RON from the `_consensusAddrSrc` and stake for `_consensusAddrDst`.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   * - The consensus address `_consensusAddrDst` is a validator candidate.\n   *\n   * Emits the `Undelegated` event and the `Delegated` event.\n   *\n   */\n  function redelegate(address _consensusAddrSrc, address _consensusAddrDst, uint256 _amount) external;\n\n  /**\n   * @dev Returns the claimable reward of the user `_user`.\n   */\n  function getRewards(\n    address _user,\n    address[] calldata _poolAddrList\n  ) external view returns (uint256[] memory _rewards);\n\n  /**\n   * @dev Claims the reward of method caller.\n   *\n   * Emits the `RewardClaimed` event.\n   *\n   */\n  function claimRewards(address[] calldata _consensusAddrList) external returns (uint256 _amount);\n\n  /**\n   * @dev Claims the rewards and delegates them to the consensus address.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   * - The consensus address `_consensusAddrDst` is a validator candidate.\n   *\n   * Emits the `RewardClaimed` event and the `Delegated` event.\n   *\n   */\n  function delegateRewards(\n    address[] calldata _consensusAddrList,\n    address _consensusAddrDst\n  ) external returns (uint256 _amount);\n}\n"
    },
    "contracts/interfaces/staking/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/consumers/PeriodWrapperConsumer.sol\";\n\ninterface IRewardPool is PeriodWrapperConsumer {\n  struct UserRewardFields {\n    // Recorded reward amount.\n    uint256 debited;\n    // The last accumulated of the amount rewards per share (one unit staking) that the info updated.\n    uint256 aRps;\n    // Lowest staking amount in the period.\n    uint256 lowestAmount;\n    // Last period number that the info updated.\n    uint256 lastPeriod;\n  }\n\n  struct PoolFields {\n    // Accumulated of the amount rewards per share (one unit staking).\n    uint256 aRps;\n    // The staking total to share reward of the current period.\n    PeriodWrapper shares;\n  }\n\n  /// @dev Emitted when the fields to calculate pending reward for the user is updated.\n  event UserRewardUpdated(address indexed poolAddr, address indexed user, uint256 debited);\n  /// @dev Emitted when the user claimed their reward\n  event RewardClaimed(address indexed poolAddr, address indexed user, uint256 amount);\n\n  /// @dev Emitted when the pool shares are updated\n  event PoolSharesUpdated(uint256 indexed period, address indexed poolAddr, uint256 shares);\n  /// @dev Emitted when the pools are updated\n  event PoolsUpdated(uint256 indexed period, address[] poolAddrs, uint256[] aRps, uint256[] shares);\n  /// @dev Emitted when the contract fails when updating the pools\n  event PoolsUpdateFailed(uint256 indexed period, address[] poolAddrs, uint256[] rewards);\n  /// @dev Emitted when the contract fails when updating the pools that already set\n  event PoolsUpdateConflicted(uint256 indexed period, address[] poolAddrs);\n\n  /// @dev Error of invalid pool share.\n  error ErrInvalidPoolShare();\n\n  /**\n   * @dev Returns the reward amount that user claimable.\n   */\n  function getReward(address _poolAddr, address _user) external view returns (uint256);\n\n  /**\n   * @dev Returns the staking amount of an user.\n   */\n  function getStakingAmount(address _poolAddr, address _user) external view returns (uint256);\n\n  /**\n   * @dev Returns the staking amounts of the users.\n   */\n  function getManyStakingAmounts(\n    address[] calldata _poolAddrs,\n    address[] calldata _userList\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the total staking amount of all users for a pool.\n   */\n  function getStakingTotal(address _poolAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the total staking amounts of all users for the pools `_poolAddrs`.\n   */\n  function getManyStakingTotals(address[] calldata _poolAddrs) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/interfaces/staking/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseStaking.sol\";\nimport \"./ICandidateStaking.sol\";\nimport \"./IDelegatorStaking.sol\";\n\ninterface IStaking is IRewardPool, IBaseStaking, ICandidateStaking, IDelegatorStaking {\n  /**\n   * @dev Records the amount of rewards `_rewards` for the pools `_consensusAddrs`.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   *\n   * Emits the event `PoolsUpdated` once the contract recorded the rewards successfully.\n   * Emits the event `PoolsUpdateFailed` once the input array lengths are not equal.\n   * Emits the event `PoolsUpdateConflicted` when there are some pools which already updated in the period.\n   *\n   * Note: This method should be called once at the period ending.\n   *\n   */\n  function execRecordRewards(\n    address[] calldata _consensusAddrs,\n    uint256[] calldata _rewards,\n    uint256 _period\n  ) external payable;\n\n  /**\n   * @dev Deducts from staking amount of the validator `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   *\n   * Emits the event `Unstaked`.\n   *\n   */\n  function execDeductStakingAmount(\n    address _consensusAddr,\n    uint256 _amount\n  ) external returns (uint256 _actualDeductingAmount);\n}\n"
    },
    "contracts/interfaces/validator/ICandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ICandidateManager {\n  struct ValidatorCandidate {\n    // Admin of the candidate\n    address admin;\n    // Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n    address consensusAddr;\n    // Address that receives mining reward of the validator\n    address payable treasuryAddr;\n    // Address of the bridge operator corresponding to the candidate\n    address bridgeOperatorAddr;\n    // The percentage of reward that validators can be received, the rest goes to the delegators.\n    // Values in range [0; 100_00] stands for 0-100%\n    uint256 commissionRate;\n    // The timestamp that scheduled to revoke the candidate (no schedule=0)\n    uint256 revokingTimestamp;\n    // The deadline that the candidate must top up staking amount to keep it larger than or equal to the threshold (no deadline=0)\n    uint256 topupDeadline;\n  }\n\n  struct CommissionSchedule {\n    // The timestamp that the commission schedule gets affected (no schedule=0).\n    uint256 effectiveTimestamp;\n    // The new commission rate. Value is in range [0; 100_00], stands for 0-100%\n    uint256 commissionRate;\n  }\n\n  /// @dev Emitted when the maximum number of validator candidates is updated.\n  event MaxValidatorCandidateUpdated(uint256 threshold);\n  /// @dev Emitted when the min offset to the effective date of commission rate change is updated.\n  event MinEffectiveDaysOnwardsUpdated(uint256 numOfDays);\n  /// @dev Emitted when the validator candidate is granted.\n  event CandidateGranted(\n    address indexed consensusAddr,\n    address indexed treasuryAddr,\n    address indexed admin,\n    address bridgeOperator\n  );\n  /// @dev Emitted when the revoking timestamp of a candidate is updated.\n  event CandidateRevokingTimestampUpdated(address indexed consensusAddr, uint256 revokingTimestamp);\n  /// @dev Emitted when the topup deadline of a candidate is updated.\n  event CandidateTopupDeadlineUpdated(address indexed consensusAddr, uint256 topupDeadline);\n  /// @dev Emitted when the validator candidate is revoked.\n  event CandidatesRevoked(address[] consensusAddrs);\n\n  /// @dev Emitted when a schedule for updating commission rate is set.\n  event CommissionRateUpdateScheduled(address indexed consensusAddr, uint256 effectiveTimestamp, uint256 rate);\n  /// @dev Emitted when the commission rate of a validator is updated.\n  event CommissionRateUpdated(address indexed consensusAddr, uint256 rate);\n\n  /// @dev Error of exceeding maximum number of candidates.\n  error ErrExceedsMaxNumberOfCandidate();\n  /// @dev Error of querying for already existent candidate.\n  error ErrExistentCandidate();\n  /// @dev Error of querying for non-existent candidate.\n  error ErrNonExistentCandidate();\n  /// @dev Error of candidate admin already exists.\n  error ErrExistentCandidateAdmin(address _candidateAdminAddr);\n  /// @dev Error of treasury already exists.\n  error ErrExistentTreasury(address _treasuryAddr);\n  /// @dev Error of bridge operator already exists.\n  error ErrExistentBridgeOperator(address _bridgeOperatorAddr);\n  /// @dev Error of invalid commission rate.\n  error ErrInvalidCommissionRate();\n  /// @dev Error of invalid effective days onwards.\n  error ErrInvalidEffectiveDaysOnwards();\n  /// @dev Error of invalid min effective days onwards.\n  error ErrInvalidMinEffectiveDaysOnwards();\n  /// @dev Error of already requested revoking candidate before.\n  error ErrAlreadyRequestedRevokingCandidate();\n  /// @dev Error of commission change schedule exists.\n  error ErrAlreadyRequestedUpdatingCommissionRate();\n  /// @dev Error of trusted org cannot renounce.\n  error ErrTrustedOrgCannotRenounce();\n\n  /**\n   * @dev Returns the maximum number of validator candidate.\n   */\n  function maxValidatorCandidate() external view returns (uint256);\n\n  /**\n   * @dev Returns the minimum number of days to the effective date of commission rate change.\n   */\n  function minEffectiveDaysOnwards() external view returns (uint256);\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function setMaxValidatorCandidate(uint256) external;\n\n  /**\n   * @dev Sets the minimum number of days to the effective date of commision rate change.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external;\n\n  /**\n   * @dev Grants a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateGranted`.\n   *\n   */\n  function execApplyValidatorCandidate(\n    address _admin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    address _bridgeOperatorAddr,\n    uint256 _commissionRate\n  ) external;\n\n  /**\n   * @dev Requests to revoke a validator candidate in next `_secsLeft` seconds.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateRevokingTimestampUpdated`.\n   *\n   */\n  function execRequestRenounceCandidate(address, uint256 _secsLeft) external;\n\n  /**\n   * @dev Fallback function of `CandidateStaking-requestUpdateCommissionRate`.\n   *\n   * Requirements:\n   * - The method caller is the staking contract.\n   * - The `_effectiveTimestamp` must be the beginning of a UTC day, and at least from 7 days onwards\n   * - The `_rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdateScheduled`.\n   *\n   */\n  function execRequestUpdateCommissionRate(address _consensusAddr, uint256 _effectiveTimestamp, uint256 _rate) external;\n\n  /**\n   * @dev Returns whether the address is a validator (candidate).\n   */\n  function isValidatorCandidate(address _addr) external view returns (bool);\n\n  /**\n   * @dev Returns the validator candidate.\n   */\n  function getValidatorCandidates() external view returns (address[] memory);\n\n  /**\n   * @dev Returns all candidate info.\n   */\n  function getCandidateInfos() external view returns (ValidatorCandidate[] memory);\n\n  /**\n   * @dev Returns the info of a candidate.\n   */\n  function getCandidateInfo(address _candidate) external view returns (ValidatorCandidate memory);\n\n  /**\n   * @dev Returns whether the address is the candidate admin.\n   */\n  function isCandidateAdmin(address _candidate, address _admin) external view returns (bool);\n\n  /**\n   * @dev Returns the schedule of changing commission rate of a candidate address.\n   */\n  function getCommissionChangeSchedule(address _candidate) external view returns (CommissionSchedule memory);\n}\n"
    },
    "contracts/interfaces/validator/ICoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashingExecution.sol\";\n\ninterface ICoinbaseExecution is ISlashingExecution {\n  enum BlockRewardDeprecatedType {\n    UNKNOWN,\n    UNAVAILABILITY,\n    AFTER_BAILOUT\n  }\n\n  /// @dev Emitted when the validator set is updated\n  event ValidatorSetUpdated(uint256 indexed period, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated, to mirror the in-jail and maintaining status of the validator.\n  event BlockProducerSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] consensusAddrs);\n  /// @dev Emitted when the bridge operator set is updated.\n  event BridgeOperatorSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] bridgeOperators);\n\n  /// @dev Emitted when the reward of the block producer is deprecated.\n  event BlockRewardDeprecated(\n    address indexed coinbaseAddr,\n    uint256 rewardAmount,\n    BlockRewardDeprecatedType deprecatedType\n  );\n  /// @dev Emitted when the block reward is submitted.\n  event BlockRewardSubmitted(address indexed coinbaseAddr, uint256 submittedAmount, uint256 bonusAmount);\n\n  /// @dev Emitted when the block producer reward is distributed.\n  event MiningRewardDistributed(address indexed consensusAddr, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the block producer reward.\n  event MiningRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the bridge operator reward is distributed.\n  event BridgeOperatorRewardDistributed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipientAddr,\n    uint256 amount\n  );\n  /// @dev Emitted when the contract fails when distributing the bridge operator reward.\n  event BridgeOperatorRewardDistributionFailed(\n    address indexed consensusAddr,\n    address indexed bridgeOperator,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the amount of RON reward is distributed to staking contract.\n  event StakingRewardDistributed(uint256 totalAmount, address[] consensusAddrs, uint256[] amounts);\n  /// @dev Emitted when the contracts fails when distributing the amount of RON to the staking contract.\n  event StakingRewardDistributionFailed(\n    uint256 totalAmount,\n    address[] consensusAddrs,\n    uint256[] amounts,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the epoch is wrapped up.\n  event WrappedUpEpoch(uint256 indexed periodNumber, uint256 indexed epochNumber, bool periodEnding);\n  /// @dev Emitted when the bridge tracking contract's response is incorrect\n  event BridgeTrackingIncorrectlyResponded();\n\n  /// @dev Error of method caller must be coinbase\n  error ErrCallerMustBeCoinbase();\n  /// @dev Error of only allowed at the end of epoch\n  error ErrAtEndOfEpochOnly();\n  /// @dev Error of query for already wrapped up epoch\n  error ErrAlreadyWrappedEpoch();\n\n  /**\n   * @dev Submits reward of the current block.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDeprecated` if the coinbase is slashed or no longer be a block producer.\n   * Emits the event `BlockRewardSubmitted` for the valid call.\n   *\n   */\n  function submitBlockReward() external payable;\n\n  /**\n   * @dev Wraps up the current epoch.\n   *\n   * Requirements:\n   * - The method must be called when the current epoch is ending.\n   * - The epoch is not wrapped yet.\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDistributed` when some validator has reward distributed.\n   * Emits the event `StakingRewardDistributed` when some staking pool has reward distributed.\n   * Emits the event `BlockProducerSetUpdated` when the epoch is wrapped up.\n   * Emits the event `BridgeOperatorSetUpdated` when the epoch is wrapped up at period ending.\n   * Emits the event `ValidatorSetUpdated` when the epoch is wrapped up at period ending, and the validator set gets updated.\n   * Emits the event `WrappedUpEpoch`.\n   *\n   */\n  function wrapUpEpoch() external payable;\n}\n"
    },
    "contracts/interfaces/validator/IEmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IEmergencyExit {\n  /// @dev Emitted when the fund is locked from an emergency exit request\n  event EmergencyExitRequested(address indexed consensusAddr, uint256 lockedAmount);\n  /// @dev Emitted when the fund that locked from an emergency exit request is transferred to the recipient.\n  event EmergencyExitLockedFundReleased(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount\n  );\n  /// @dev Emitted when the fund that locked from an emergency exit request is failed to transferred back.\n  event EmergencyExitLockedFundReleasingFailed(\n    address indexed consensusAddr,\n    address indexed recipient,\n    uint256 unlockedAmount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the emergency exit locked amount is updated.\n  event EmergencyExitLockedAmountUpdated(uint256 amount);\n  /// @dev Emitted when the emergency expiry duration is updated.\n  event EmergencyExpiryDurationUpdated(uint256 amount);\n\n  /// @dev Error of already requested emergency exit before.\n  error ErrAlreadyRequestedEmergencyExit();\n\n  /**\n   * @dev Returns the amount of RON to lock from a consensus address.\n   */\n  function emergencyExitLockedAmount() external returns (uint256);\n\n  /**\n   * @dev Returns the duration that an emergency request is expired and the fund will be recycled.\n   */\n  function emergencyExpiryDuration() external returns (uint256);\n\n  /**\n   * @dev Sets the amount of RON to lock from a consensus address.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedAmountUpdated`.\n   *\n   */\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external;\n\n  /**\n   * @dev Sets the duration that an emergency request is expired and the fund will be recycled.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExpiryDurationUpdated`.\n   *\n   */\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external;\n\n  /**\n   * @dev Unlocks fund for emergency exit request.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedFundReleased` if the fund is successfully unlocked.\n   * Emits the event `EmergencyExitLockedFundReleasingFailed` if the fund is failed to unlock.\n   *\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(address _consensusAddr, address payable _recipient) external;\n\n  /**\n   * @dev Fallback function of `IStaking-requestEmergencyExit`.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   */\n  function execEmergencyExit(address _consensusAddr, uint256 _secLeftToRevoke) external;\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ICommonInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IJailingInfo.sol\";\nimport \"./ITimingInfo.sol\";\nimport \"./IValidatorInfo.sol\";\n\ninterface ICommonInfo is ITimingInfo, IJailingInfo, IValidatorInfo {\n  struct EmergencyExitInfo {\n    uint256 lockedAmount;\n    // The timestamp that this locked amount will be recycled to staking vesting contract\n    uint256 recyclingAt;\n  }\n\n  /// @dev Emitted when the deprecated reward is withdrawn.\n  event DeprecatedRewardRecycled(address indexed recipientAddr, uint256 amount);\n  /// @dev Emitted when the deprecated reward withdrawal is failed\n  event DeprecatedRewardRecycleFailed(address indexed recipientAddr, uint256 amount, uint256 balance);\n\n  /// @dev Error thrown when receives RON from neither staking vesting contract nor staking contract\n  error ErrUnauthorizedReceiveRON();\n  /// @dev Error thrown when queries for a non existent info.\n  error NonExistentRecyclingInfo();\n\n  /**\n   * @dev Returns the total deprecated reward, which includes reward that is not sent for slashed validators and unsastified bridge operators\n   */\n  function totalDeprecatedReward() external view returns (uint256);\n\n  /**\n   * @dev Returns the emergency exit request.\n   */\n  function getEmergencyExitInfo(address _consensusAddr) external view returns (EmergencyExitInfo memory);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IJailingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IJailingInfo {\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkJailed(address) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeft(\n    address _addr\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) at a specific block.\n   */\n  function checkJailedAtBlock(address _addr, uint256 _blockNum) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail at a specific block and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeftAtBlock(\n    address _addr,\n    uint256 _blockNum\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validators are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkManyJailed(address[] calldata) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during the current period.\n   */\n  function checkMiningRewardDeprecated(address _blockProducer) external view returns (bool);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during a specific period.\n   */\n  function checkMiningRewardDeprecatedAtPeriod(address _blockProducer, uint256 _period) external view returns (bool);\n\n  /**\n   * @dev Returns whether the incoming reward of the validator with `_consensusAddr` is deprecated in the latest wrapped up period.\n   */\n  function checkBridgeRewardDeprecatedAtLatestPeriod(address _consensusAddr) external view returns (bool _result);\n\n  /**\n   * @dev Returns whether the incoming reward of the validator with `_consensusAddr` is deprecated in the  `_period`.\n   */\n  function checkBridgeRewardDeprecatedAtPeriod(\n    address _consensusAddr,\n    uint256 _period\n  ) external view returns (bool _result);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ITimingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ITimingInfo {\n  /**\n   * @dev Returns the block that validator set was updated.\n   */\n  function getLastUpdatedBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of blocks in a epoch.\n   */\n  function numberOfBlocksInEpoch() external view returns (uint256 _numberOfBlocks);\n\n  /**\n   * @dev Returns the epoch index from the block number.\n   */\n  function epochOf(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Returns whether the epoch ending is at the block number `_block`.\n   */\n  function epochEndingAt(uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Tries to get the period index from the epoch number.\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber);\n\n  /**\n   * @dev Returns whether the period ending at the current block number.\n   */\n  function isPeriodEnding() external view returns (bool);\n\n  /**\n   * @dev Returns the period index from the current block.\n   */\n  function currentPeriod() external view returns (uint256);\n\n  /**\n   * @dev Returns the block number that the current period starts at.\n   */\n  function currentPeriodStartAtBlock() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IValidatorInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\n\ninterface IValidatorInfo {\n  /**\n   * @dev Error thrown when an invalid maximum prioritized validator number is provided.\n   */\n  error ErrInvalidMaxPrioritizedValidatorNumber();\n\n  /// @dev Emitted when the number of max validator is updated.\n  event MaxValidatorNumberUpdated(uint256);\n  /// @dev Emitted when the number of reserved slots for prioritized validators is updated.\n  event MaxPrioritizedValidatorNumberUpdated(uint256);\n\n  /**\n   * @dev Returns the maximum number of validators in the epoch.\n   */\n  function maxValidatorNumber() external view returns (uint256 _maximumValidatorNumber);\n\n  /**\n   * @dev Returns the number of reserved slots for prioritized validators.\n   */\n  function maxPrioritizedValidatorNumber() external view returns (uint256 _maximumPrioritizedValidatorNumber);\n\n  /**\n   * @dev Returns the current validator list.\n   */\n  function getValidators()\n    external\n    view\n    returns (\n      address[] memory _validatorList,\n      address[] memory _bridgeOperators,\n      EnumFlags.ValidatorFlag[] memory _flags\n    );\n\n  /**\n   * @dev Returns whether the address is either a bridge operator or a block producer.\n   */\n  function isValidator(address _addr) external view returns (bool);\n\n  /**\n   * @dev Returns the current block producer list.\n   */\n  function getBlockProducers() external view returns (address[] memory);\n\n  /**\n   * @dev Returns whether the address is block producer or not.\n   */\n  function isBlockProducer(address _addr) external view returns (bool);\n\n  /**\n   * @dev Returns total numbers of the block producers.\n   */\n  function totalBlockProducers() external view returns (uint256);\n\n  /**\n   * @dev Returns the current on-working bridge operator list.\n   * @param bridgeOperatorList The list of working bridge operators.\n   * @param validatorList The list of corresponding validators.\n   */\n  function getBridgeOperators()\n    external\n    view\n    returns (address[] memory bridgeOperatorList, address[] memory validatorList);\n\n  /**\n   * @dev Returns the bridge operator list corresponding to validator address list.\n   */\n  function getBridgeOperatorsOf(\n    address[] memory _validatorAddrs\n  ) external view returns (address[] memory bridgeOperatorList);\n\n  /**\n   * @dev Returns whether the address is bridge operator.\n   */\n  function isBridgeOperator(address _addr) external view returns (bool isOperator);\n\n  /**\n   * @dev Returns whether the consensus address is operating the bridge or not.\n   */\n  function isOperatingBridge(address _consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns total numbers of the bridge operators.\n   */\n  function totalBridgeOperators() external view returns (uint256);\n\n  /**\n   * @dev Updates the max validator number\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxValidatorNumberUpdated`\n   *\n   */\n  function setMaxValidatorNumber(uint256 _maxValidatorNumber) external;\n\n  /**\n   * @dev Updates the number of reserved slots for prioritized validators\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxPrioritizedValidatorNumberUpdated`\n   *\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _maxPrioritizedValidatorNumber) external;\n}\n"
    },
    "contracts/interfaces/validator/IRoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ICandidateManager.sol\";\nimport \"./info-fragments/ICommonInfo.sol\";\nimport \"./ICoinbaseExecution.sol\";\nimport \"./ISlashingExecution.sol\";\nimport \"./IEmergencyExit.sol\";\n\ninterface IRoninValidatorSet is\n  ICandidateManager,\n  ICommonInfo,\n  ISlashingExecution,\n  ICoinbaseExecution,\n  IEmergencyExit\n{}\n"
    },
    "contracts/interfaces/validator/ISlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISlashingExecution {\n  /// @dev Emitted when the validator is punished.\n  event ValidatorPunished(\n    address indexed consensusAddr,\n    uint256 indexed period,\n    uint256 jailedUntil,\n    uint256 deductedStakingAmount,\n    bool blockProducerRewardDeprecated,\n    bool bridgeOperatorRewardDeprecated\n  );\n  /// @dev Emitted when the validator get out of jail by bailout.\n  event ValidatorUnjailed(address indexed validator, uint256 period);\n\n  /// @dev Error of cannot bailout due to high tier slash.\n  error ErrCannotBailout(address validator);\n\n  /**\n   * @dev Finalize the slash request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorPunished`.\n   *\n   */\n  function execSlash(\n    address _validatorAddr,\n    uint256 _newJailedUntil,\n    uint256 _slashAmount,\n    bool _cannotBailout\n  ) external;\n\n  /**\n   * @dev Finalize the bailout request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorUnjailed`.\n   *\n   */\n  function execBailOut(address _validatorAddr, uint256 _period) external;\n}\n"
    },
    "contracts/libraries/BridgeOperatorsBallot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../utils/CommonErrors.sol\";\n\nlibrary BridgeOperatorsBallot {\n  /**\n   * @dev Error thrown when an invalid order of the bridge operator is detected.\n   */\n  error ErrInvalidOrderOfBridgeOperator();\n\n  struct BridgeOperatorSet {\n    uint256 period;\n    uint256 epoch;\n    address[] operators;\n  }\n\n  // keccak256(\"BridgeOperatorsBallot(uint256 period,uint256 epoch,address[] operators)\");\n  bytes32 public constant BRIDGE_OPERATORS_BALLOT_TYPEHASH =\n    0xd679a49e9e099fa9ed83a5446aaec83e746b03ec6723d6f5efb29d37d7f0b78a;\n\n  /**\n   * @dev Verifies whether the ballot is valid or not.\n   *\n   * Requirements:\n   * - The ballot is not for an empty operator set.\n   * - The operator address list is in order.\n   *\n   */\n  function verifyBallot(BridgeOperatorSet calldata _ballot) internal pure {\n    if (_ballot.operators.length == 0) revert ErrEmptyArray();\n\n    address _addr = _ballot.operators[0];\n    for (uint _i = 1; _i < _ballot.operators.length; ) {\n      if (_addr >= _ballot.operators[_i]) revert ErrInvalidOrderOfBridgeOperator();\n      _addr = _ballot.operators[_i];\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @dev Returns hash of the ballot.\n   */\n  function hash(BridgeOperatorSet memory self) internal pure returns (bytes32 digest_) {\n    bytes32 operatorsHash;\n    address[] memory operators = self.operators;\n\n    // return keccak256(abi.encode(BRIDGE_OPERATORS_BALLOT_TYPEHASH, _ballot.period, _ballot.epoch, _operatorsHash));\n    assembly {\n      operatorsHash := keccak256(add(operators, 32), mul(mload(operators), 32))\n      let ptr := mload(0x40)\n      mstore(ptr, BRIDGE_OPERATORS_BALLOT_TYPEHASH)\n      mstore(add(ptr, 0x20), mload(self)) // _ballot.period\n      mstore(add(ptr, 0x40), mload(add(self, 0x20))) // _ballot.epoch\n      mstore(add(ptr, 0x60), operatorsHash)\n      digest_ := keccak256(ptr, 0x80)\n    }\n  }\n}\n"
    },
    "contracts/libraries/EnumFlags.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This library implements checking flag of an enumerated value.\n * The originated idea is inherited from [Enum.HashFlag(Enum)](https://learn.microsoft.com/en-us/dotnet/api/system.enum.hasflag?view=net-6.0) method of C#.\n */\nlibrary EnumFlags {\n  enum ValidatorFlag {\n    None, // bit(00)\n    BlockProducer, // bit(01)\n    BridgeOperator, // bit(10)\n    Both // bit(11)\n  }\n\n  function isNone(ValidatorFlag _value) internal pure returns (bool) {\n    return uint8(_value) == 0;\n  }\n\n  /**\n   * @dev Checks if `_value` has `_flag`.\n   */\n  function hasFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (bool) {\n    return (uint8(_value) & uint8(_flag)) != 0;\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after adding `_flag`.\n   */\n  function addFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) | uint8(_flag));\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after remove `_flag`.\n   */\n  function removeFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) & ~uint8(_flag));\n  }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary Math {\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns whether the number `c` is in range of [a; b].\n   */\n  function inRange(uint256 c, uint256 a, uint256 b) internal pure returns (bool) {\n    return a <= c && c <= b;\n  }\n\n  /**\n   * @dev Returns whether two inclusive ranges [x1;x2] and [y1;y2] overlap.\n   */\n  function twoRangeOverlap(uint256 x1, uint256 x2, uint256 y1, uint256 y2) internal pure returns (bool) {\n    return x1 <= y2 && y1 <= x2;\n  }\n\n  /**\n   * @dev Returns value of a + b; in case result is larger than upperbound, upperbound is returned.\n   */\n  function addWithUpperbound(uint256 a, uint256 b, uint256 upperbound) internal pure returns (uint256) {\n    return min(a + b, upperbound);\n  }\n\n  /**\n   * @dev Returns value of a - b; in case of negative result, 0 is returned.\n   */\n  function subNonNegative(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a - b : 0;\n  }\n\n  /**\n   * @dev Returns value of `a + zeroable` if zerobale is not 0; otherwise, return 0.\n   */\n  function addIfNonZero(uint256 a, uint256 zeroable) internal pure returns (uint256) {\n    return zeroable != 0 ? a + zeroable : 0;\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUPickValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUPickValidatorSet is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of picking validator set\n  function precompilePickValidatorSetAddress() public view virtual returns (address) {\n    return address(0x68);\n  }\n\n  /**\n   * @dev Sorts and arranges to return a new validator set.\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcPickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) internal view virtual returns (address[] memory _result, uint256 _newValidatorCount) {\n    address _smc = precompilePickValidatorSetAddress();\n    bytes memory _payload = abi.encodeWithSignature(\n      \"pickValidatorSet(address[],uint256[],uint256[],uint256,uint256)\",\n      _candidates,\n      _weights,\n      _trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n    bool _success = true;\n\n    uint256 _payloadLength = _payload.length;\n    uint256 _resultLength = 0x20 * _candidates.length + 0x40;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _result, _resultLength)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n\n      _result := add(_result, 0x20)\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n\n    _newValidatorCount = _result.length;\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUSortValidators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUSortValidators is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of sorting validators\n  function precompileSortValidatorsAddress() public view virtual returns (address) {\n    return address(0x66);\n  }\n\n  /**\n   * @dev Sorts candidates descending by their weights by calling precompile contract.\n   *\n   * Note: This function is marked as virtual for being wrapping in mock contract for testing purpose.\n   */\n  function _pcSortCandidates(\n    address[] memory _candidates,\n    uint256[] memory _weights\n  ) internal view virtual returns (address[] memory _result) {\n    address _smc = precompileSortValidatorsAddress();\n    bool _success = true;\n\n    bytes memory _payload = abi.encodeWithSignature(\"sortValidators(address[],uint256[])\", _candidates, _weights);\n    uint256 _payloadLength = _payload.length;\n    uint256 _resultLength = 0x20 * _candidates.length + 0x40;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _result, _resultLength)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n\n      _result := add(_result, 0x20)\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n  }\n}\n"
    },
    "contracts/precompile-usages/PrecompiledUsage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PrecompiledUsage {\n  /// @dev Error of call to precompile fails.\n  error ErrCallPrecompiled();\n}\n"
    },
    "contracts/ronin/validator/CandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../interfaces/validator/ICandidateManager.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport { HasStakingDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\nabstract contract CandidateManager is\n  ICandidateManager,\n  PercentageConsumer,\n  GlobalConfigConsumer,\n  HasContracts,\n  HasStakingDeprecated\n{\n  /// @dev Maximum number of validator candidate\n  uint256 private _maxValidatorCandidate;\n\n  /// @dev The validator candidate array\n  address[] internal _candidates;\n  /// @dev Mapping from candidate consensus address => bitwise negation of validator index in `_candidates`\n  mapping(address => uint256) internal _candidateIndex;\n  /// @dev Mapping from candidate consensus address => their info\n  mapping(address => ValidatorCandidate) internal _candidateInfo;\n\n  /**\n   * @dev The minimum offset in day from current date to the effective date of a new commission schedule.\n   * Value of 1 means the change gets affected at the beginning of the following day.\n   **/\n  uint256 internal _minEffectiveDaysOnwards;\n  /// @dev Mapping from candidate consensus address => schedule commission change.\n  mapping(address => CommissionSchedule) internal _candidateCommissionChangeSchedule;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] private ______gap;\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function maxValidatorCandidate() public view override returns (uint256) {\n    return _maxValidatorCandidate;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function minEffectiveDaysOnwards() external view override returns (uint256) {\n    return _minEffectiveDaysOnwards;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function setMaxValidatorCandidate(uint256 _number) external override onlyAdmin {\n    _setMaxValidatorCandidate(_number);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external override onlyAdmin {\n    _setMinEffectiveDaysOnwards(_numOfDays);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function execApplyValidatorCandidate(\n    address _candidateAdmin,\n    address _consensusAddr,\n    address payable _treasuryAddr,\n    address _bridgeOperatorAddr,\n    uint256 _commissionRate\n  ) external override onlyContract(ContractType.STAKING) {\n    uint256 _length = _candidates.length;\n    if (_length >= maxValidatorCandidate()) revert ErrExceedsMaxNumberOfCandidate();\n    if (isValidatorCandidate(_consensusAddr)) revert ErrExistentCandidate();\n    if (_commissionRate > _MAX_PERCENTAGE) revert ErrInvalidCommissionRate();\n\n    for (uint _i; _i < _candidates.length; ) {\n      ValidatorCandidate storage existentInfo = _candidateInfo[_candidates[_i]];\n      if (_candidateAdmin == existentInfo.admin) revert ErrExistentCandidateAdmin(_candidateAdmin);\n      if (_treasuryAddr == existentInfo.treasuryAddr) revert ErrExistentTreasury(_treasuryAddr);\n      if (_bridgeOperatorAddr == existentInfo.bridgeOperatorAddr) revert ErrExistentBridgeOperator(_bridgeOperatorAddr);\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    _candidateIndex[_consensusAddr] = ~_length;\n    _candidates.push(_consensusAddr);\n\n    ValidatorCandidate storage _info = _candidateInfo[_consensusAddr];\n    _info.admin = _candidateAdmin;\n    _info.consensusAddr = _consensusAddr;\n    _info.treasuryAddr = _treasuryAddr;\n    _info.bridgeOperatorAddr = _bridgeOperatorAddr;\n    _info.commissionRate = _commissionRate;\n    emit CandidateGranted(_consensusAddr, _treasuryAddr, _candidateAdmin, _bridgeOperatorAddr);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function execRequestRenounceCandidate(\n    address _consensusAddr,\n    uint256 _secsLeft\n  ) external override onlyContract(ContractType.STAKING) {\n    if (_isTrustedOrg(_consensusAddr)) revert ErrTrustedOrgCannotRenounce();\n\n    ValidatorCandidate storage _info = _candidateInfo[_consensusAddr];\n    if (_info.revokingTimestamp != 0) revert ErrAlreadyRequestedRevokingCandidate();\n    _setRevokingTimestamp(_info, block.timestamp + _secsLeft);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function execRequestUpdateCommissionRate(\n    address _consensusAddr,\n    uint256 _effectiveDaysOnwards,\n    uint256 _commissionRate\n  ) external override onlyContract(ContractType.STAKING) {\n    if (_candidateCommissionChangeSchedule[_consensusAddr].effectiveTimestamp != 0) {\n      revert ErrAlreadyRequestedUpdatingCommissionRate();\n    }\n    if (_commissionRate > _MAX_PERCENTAGE) revert ErrInvalidCommissionRate();\n    if (_effectiveDaysOnwards < _minEffectiveDaysOnwards) revert ErrInvalidEffectiveDaysOnwards();\n\n    CommissionSchedule storage _schedule = _candidateCommissionChangeSchedule[_consensusAddr];\n    uint256 _effectiveTimestamp = ((block.timestamp / PERIOD_DURATION) + _effectiveDaysOnwards) * PERIOD_DURATION;\n    _schedule.effectiveTimestamp = _effectiveTimestamp;\n    _schedule.commissionRate = _commissionRate;\n\n    emit CommissionRateUpdateScheduled(_consensusAddr, _effectiveTimestamp, _commissionRate);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function isValidatorCandidate(address _addr) public view override returns (bool) {\n    return _candidateIndex[_addr] != 0;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCandidateInfos() external view override returns (ValidatorCandidate[] memory _list) {\n    _list = new ValidatorCandidate[](_candidates.length);\n    for (uint _i; _i < _list.length; ) {\n      _list[_i] = _candidateInfo[_candidates[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCandidateInfo(address _candidate) external view override returns (ValidatorCandidate memory) {\n    if (!isValidatorCandidate(_candidate)) revert ErrNonExistentCandidate();\n    return _candidateInfo[_candidate];\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getValidatorCandidates() public view override returns (address[] memory) {\n    return _candidates;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCommissionChangeSchedule(address _candidate) external view override returns (CommissionSchedule memory) {\n    return _candidateCommissionChangeSchedule[_candidate];\n  }\n\n  /**\n   * @dev Removes unsastisfied candidates, the ones who have insufficient minimum candidate staking amount,\n   * or the ones who requested to renounce their candidate role.\n   *\n   * Emits the event `CandidatesRevoked` when a candidate is revoked.\n   *\n   */\n  function _syncCandidateSet(uint256 _nextPeriod) internal returns (address[] memory _unsatisfiedCandidates) {\n    IStaking _staking = IStaking(getContract(ContractType.STAKING));\n    uint256 _waitingSecsToRevoke = _staking.waitingSecsToRevoke();\n    uint256 _minStakingAmount = _staking.minValidatorStakingAmount();\n    uint256[] memory _selfStakings = _staking.getManySelfStakings(_candidates);\n\n    uint256 _length = _candidates.length;\n    uint256 _unsatisfiedCount;\n    _unsatisfiedCandidates = new address[](_length);\n\n    {\n      uint256 _i;\n      address _addr;\n      ValidatorCandidate storage _info;\n      while (_i < _length) {\n        _addr = _candidates[_i];\n        _info = _candidateInfo[_addr];\n\n        // Checks for under-balance status of candidates\n        bool _hasTopupDeadline = _info.topupDeadline != 0;\n        if (_selfStakings[_i] < _minStakingAmount) {\n          // Updates deadline on the first time unsatisfied the staking amount condition\n          if (!_hasTopupDeadline) {\n            uint256 _topupDeadline = block.timestamp + _waitingSecsToRevoke;\n            _info.topupDeadline = _topupDeadline;\n            emit CandidateTopupDeadlineUpdated(_addr, _topupDeadline);\n          }\n        } else if (_hasTopupDeadline) {\n          // Removes the deadline if the staking amount condition is satisfied\n          delete _info.topupDeadline;\n          emit CandidateTopupDeadlineUpdated(_addr, 0);\n        }\n\n        // Removes unsastisfied candidates\n        bool _revokingActivated = (_info.revokingTimestamp != 0 && _info.revokingTimestamp <= block.timestamp) ||\n          _emergencyExitLockedFundReleased(_addr);\n        bool _topupDeadlineMissed = _info.topupDeadline != 0 && _info.topupDeadline <= block.timestamp;\n        if (_revokingActivated || _topupDeadlineMissed) {\n          _selfStakings[_i] = _selfStakings[--_length];\n          unchecked {\n            _unsatisfiedCandidates[_unsatisfiedCount++] = _addr;\n          }\n          _removeCandidate(_addr);\n          continue;\n        }\n\n        // Checks for schedule of commission change and updates commission rate\n        uint256 _scheduleTimestamp = _candidateCommissionChangeSchedule[_addr].effectiveTimestamp;\n        if (_scheduleTimestamp != 0 && _scheduleTimestamp <= block.timestamp) {\n          uint256 _commisionRate = _candidateCommissionChangeSchedule[_addr].commissionRate;\n          delete _candidateCommissionChangeSchedule[_addr];\n          _info.commissionRate = _commisionRate;\n          emit CommissionRateUpdated(_addr, _commisionRate);\n        }\n\n        unchecked {\n          _i++;\n        }\n      }\n    }\n\n    assembly {\n      mstore(_unsatisfiedCandidates, _unsatisfiedCount)\n    }\n\n    if (_unsatisfiedCount > 0) {\n      emit CandidatesRevoked(_unsatisfiedCandidates);\n      _staking.execDeprecatePools(_unsatisfiedCandidates, _nextPeriod);\n    }\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function isCandidateAdmin(address _candidate, address _admin) external view override returns (bool) {\n    return _candidateInfo[_candidate].admin == _admin;\n  }\n\n  /**\n   * @dev Override `ValidatorInfoStorage-_bridgeOperatorOf`.\n   */\n  function _bridgeOperatorOf(address _consensusAddr) internal view virtual returns (address) {\n    return _candidateInfo[_consensusAddr].bridgeOperatorAddr;\n  }\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function _setMaxValidatorCandidate(uint256 _threshold) internal {\n    _maxValidatorCandidate = _threshold;\n    emit MaxValidatorCandidateUpdated(_threshold);\n  }\n\n  /**\n   * @dev Sets the minimum number of days onwards to the effective date of commission rate change.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function _setMinEffectiveDaysOnwards(uint256 _numOfDays) internal {\n    if (_numOfDays < 1) revert ErrInvalidMinEffectiveDaysOnwards();\n    _minEffectiveDaysOnwards = _numOfDays;\n    emit MinEffectiveDaysOnwardsUpdated(_numOfDays);\n  }\n\n  /**\n   * @dev Removes the candidate.\n   */\n  function _removeCandidate(address _addr) internal virtual {\n    uint256 _idx = _candidateIndex[_addr];\n    if (_idx == 0) {\n      return;\n    }\n\n    delete _candidateInfo[_addr];\n    delete _candidateIndex[_addr];\n    delete _candidateCommissionChangeSchedule[_addr];\n\n    address _lastCandidate = _candidates[_candidates.length - 1];\n    if (_lastCandidate != _addr) {\n      _candidateIndex[_lastCandidate] = _idx;\n      _candidates[~_idx] = _lastCandidate;\n    }\n\n    _candidates.pop();\n  }\n\n  /**\n   * @dev Sets timestamp to revoke a candidate.\n   */\n  function _setRevokingTimestamp(ValidatorCandidate storage _candidate, uint256 _timestamp) internal {\n    if (!isValidatorCandidate(_candidate.consensusAddr)) revert ErrNonExistentCandidate();\n    _candidate.revokingTimestamp = _timestamp;\n    emit CandidateRevokingTimestampUpdated(_candidate.consensusAddr, _timestamp);\n  }\n\n  /**\n   * @dev Returns a flag indicating whether the fund is unlocked.\n   */\n  function _emergencyExitLockedFundReleased(address _consensusAddr) internal virtual returns (bool);\n\n  /**\n   * @dev Returns whether the consensus address is a trusted org or not.\n   */\n  function _isTrustedOrg(address _consensusAddr) internal virtual returns (bool);\n}\n"
    },
    "contracts/ronin/validator/CoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../interfaces/IStakingVesting.sol\";\nimport \"../../interfaces/IMaintenance.sol\";\nimport \"../../interfaces/IBridgeTracking.sol\";\nimport \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../interfaces/slash-indicator/ISlashIndicator.sol\";\nimport \"../../interfaces/validator/ICoinbaseExecution.sol\";\nimport \"../../libraries/EnumFlags.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasStakingVestingDeprecated, HasBridgeTrackingDeprecated, HasMaintenanceDeprecated, HasSlashIndicatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"../../precompile-usages/PCUSortValidators.sol\";\nimport \"../../precompile-usages/PCUPickValidatorSet.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\nimport \"./CandidateManager.sol\";\nimport \"./EmergencyExit.sol\";\n\nabstract contract CoinbaseExecution is\n  ICoinbaseExecution,\n  RONTransferHelper,\n  PCUSortValidators,\n  PCUPickValidatorSet,\n  HasContracts,\n  HasStakingVestingDeprecated,\n  HasBridgeTrackingDeprecated,\n  HasMaintenanceDeprecated,\n  HasSlashIndicatorDeprecated,\n  EmergencyExit\n{\n  using EnumFlags for EnumFlags.ValidatorFlag;\n\n  modifier onlyCoinbase() {\n    _requireCoinbase();\n    _;\n  }\n\n  modifier whenEpochEnding() {\n    if (!epochEndingAt(block.number)) revert ErrAtEndOfEpochOnly();\n    _;\n  }\n\n  modifier oncePerEpoch() {\n    if (epochOf(_lastUpdatedBlock) >= epochOf(block.number)) revert ErrAlreadyWrappedEpoch();\n    _lastUpdatedBlock = block.number;\n    _;\n  }\n\n  function _requireCoinbase() private view {\n    if (msg.sender != block.coinbase) revert ErrCallerMustBeCoinbase();\n  }\n\n  /**\n   * @inheritdoc ICoinbaseExecution\n   */\n  function submitBlockReward() external payable override onlyCoinbase {\n    bool _requestForBlockProducer = isBlockProducer(msg.sender) &&\n      !_jailed(msg.sender) &&\n      !_miningRewardDeprecated(msg.sender, currentPeriod());\n\n    (, uint256 _blockProducerBonus, uint256 _bridgeOperatorBonus) = IStakingVesting(\n      getContract(ContractType.STAKING_VESTING)\n    ).requestBonus({ _forBlockProducer: _requestForBlockProducer, _forBridgeOperator: true });\n\n    _totalBridgeReward += _bridgeOperatorBonus;\n\n    // Deprecates reward for non-validator or slashed validator\n    if (!_requestForBlockProducer) {\n      _totalDeprecatedReward += msg.value;\n      emit BlockRewardDeprecated(msg.sender, msg.value, BlockRewardDeprecatedType.UNAVAILABILITY);\n      return;\n    }\n\n    emit BlockRewardSubmitted(msg.sender, msg.value, _blockProducerBonus);\n\n    uint256 _period = currentPeriod();\n    uint256 _reward = msg.value + _blockProducerBonus;\n    uint256 _cutOffReward;\n    if (_miningRewardBailoutCutOffAtPeriod[msg.sender][_period]) {\n      (, , , uint256 _cutOffPercentage) = ISlashIndicator(getContract(ContractType.SLASH_INDICATOR))\n        .getCreditScoreConfigs();\n      _cutOffReward = (_reward * _cutOffPercentage) / _MAX_PERCENTAGE;\n      _totalDeprecatedReward += _cutOffReward;\n      emit BlockRewardDeprecated(msg.sender, _cutOffReward, BlockRewardDeprecatedType.AFTER_BAILOUT);\n    }\n\n    _reward -= _cutOffReward;\n    (uint256 _minRate, uint256 _maxRate) = IStaking(getContract(ContractType.STAKING)).getCommissionRateRange();\n    uint256 _rate = Math.max(Math.min(_candidateInfo[msg.sender].commissionRate, _maxRate), _minRate);\n    uint256 _miningAmount = (_rate * _reward) / _MAX_PERCENTAGE;\n    _miningReward[msg.sender] += _miningAmount;\n\n    uint256 _delegatingAmount = _reward - _miningAmount;\n    _delegatingReward[msg.sender] += _delegatingAmount;\n  }\n\n  /**\n   * @inheritdoc ICoinbaseExecution\n   */\n  function wrapUpEpoch() external payable virtual override onlyCoinbase whenEpochEnding oncePerEpoch {\n    uint256 _newPeriod = _computePeriod(block.timestamp);\n    bool _periodEnding = _isPeriodEnding(_newPeriod);\n\n    (address[] memory _currentValidators, , ) = getValidators();\n    address[] memory _revokedCandidates;\n    uint256 _epoch = epochOf(block.number);\n    uint256 _nextEpoch = _epoch + 1;\n    uint256 _lastPeriod = currentPeriod();\n\n    if (_periodEnding) {\n      _syncBridgeOperatingReward(_lastPeriod);\n      (\n        uint256 _totalDelegatingReward,\n        uint256[] memory _delegatingRewards\n      ) = _distributeRewardToTreasuriesAndCalculateTotalDelegatingReward(_lastPeriod, _currentValidators);\n      _settleAndTransferDelegatingRewards(_lastPeriod, _currentValidators, _totalDelegatingReward, _delegatingRewards);\n      _tryRecycleLockedFundsFromEmergencyExits();\n      _recycleDeprecatedRewards();\n      ISlashIndicator _slashIndicatorContract = ISlashIndicator(getContract(ContractType.SLASH_INDICATOR));\n      _slashIndicatorContract.updateCreditScores(_currentValidators, _lastPeriod);\n      (_currentValidators, _revokedCandidates) = _syncValidatorSet(_newPeriod);\n      if (_revokedCandidates.length > 0) {\n        _slashIndicatorContract.execResetCreditScores(_revokedCandidates);\n      }\n      _currentPeriodStartAtBlock = block.number + 1;\n    }\n    _revampRoles(_newPeriod, _nextEpoch, _currentValidators);\n    emit WrappedUpEpoch(_lastPeriod, _epoch, _periodEnding);\n    _periodOf[_nextEpoch] = _newPeriod;\n    _lastUpdatedPeriod = _newPeriod;\n  }\n\n  /**\n   * @dev This loop over the all current validators to sync the bridge operating reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _syncBridgeOperatingReward(uint256 _lastPeriod) internal {\n    IBridgeTracking _bridgeTrackingContract = IBridgeTracking(getContract(ContractType.BRIDGE_TRACKING));\n    uint256 _totalBridgeBallots = _bridgeTrackingContract.totalBallots(_lastPeriod);\n    uint256 _totalBridgeVotes = _bridgeTrackingContract.totalVotes(_lastPeriod);\n\n    (\n      address[] memory _currentWorkingBridgeOperators,\n      address[] memory _currentValidatorsOperatingBridge\n    ) = getBridgeOperators();\n\n    uint256[] memory _bridgeBallots = _bridgeTrackingContract.getManyTotalBallots(\n      _lastPeriod,\n      _currentWorkingBridgeOperators\n    );\n\n    if (\n      !_validateBridgeTrackingResponse(_totalBridgeBallots, _totalBridgeVotes, _bridgeBallots) || _totalBridgeVotes == 0\n    ) {\n      // Shares equally in case the bridge has nothing to vote or bridge tracking response is incorrect\n      for (uint256 _i; _i < _currentValidatorsOperatingBridge.length; ) {\n        _bridgeOperatingReward[_currentValidatorsOperatingBridge[_i]] =\n          _totalBridgeReward /\n          _currentValidatorsOperatingBridge.length;\n\n        unchecked {\n          ++_i;\n        }\n      }\n      return;\n    }\n\n    (\n      uint256 _missingVotesRatioTier1,\n      uint256 _missingVotesRatioTier2,\n      uint256 _jailDurationForMissingVotesRatioTier2,\n      uint256 _skipBridgeOperatorSlashingThreshold\n    ) = ISlashIndicator(getContract(ContractType.SLASH_INDICATOR)).getBridgeOperatorSlashingConfigs();\n\n    // Slashes the bridge reward if the total of votes exceeds the slashing threshold.\n    bool _shouldSlash = _totalBridgeVotes > _skipBridgeOperatorSlashingThreshold;\n    for (uint256 _i; _i < _currentValidatorsOperatingBridge.length; ) {\n      // Shares the bridge operators reward proportionally.\n      _bridgeOperatingReward[_currentValidatorsOperatingBridge[_i]] =\n        (_totalBridgeReward * _bridgeBallots[_i]) /\n        _totalBridgeBallots;\n      if (_shouldSlash) {\n        _slashBridgeOperatorBasedOnPerformance(\n          _lastPeriod,\n          _currentValidatorsOperatingBridge[_i],\n          _MAX_PERCENTAGE - (_bridgeBallots[_i] * _MAX_PERCENTAGE) / _totalBridgeVotes,\n          _jailDurationForMissingVotesRatioTier2,\n          _missingVotesRatioTier1,\n          _missingVotesRatioTier2\n        );\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @dev Returns whether the responses from bridge tracking are correct.\n   */\n  function _validateBridgeTrackingResponse(\n    uint256 _totalBridgeBallots,\n    uint256 _totalBridgeVotes,\n    uint256[] memory _bridgeBallots\n  ) private returns (bool _valid) {\n    _valid = true;\n    uint256 _sumBallots;\n    for (uint _i; _i < _bridgeBallots.length; ) {\n      if (_bridgeBallots[_i] > _totalBridgeVotes) {\n        _valid = false;\n        break;\n      }\n      _sumBallots += _bridgeBallots[_i];\n\n      unchecked {\n        ++_i;\n      }\n    }\n    _valid = _valid && (_sumBallots <= _totalBridgeBallots);\n    if (!_valid) {\n      emit BridgeTrackingIncorrectlyResponded();\n    }\n  }\n\n  /**\n   * @dev Slashes the validator on the corresponding bridge operator performance. Updates the status of the deprecated reward. Not update the reward amount.\n   *\n   * Consider validating the bridge tracking response by using the method `_validateBridgeTrackingResponse` before calling this function.\n   */\n  function _slashBridgeOperatorBasedOnPerformance(\n    uint256 _period,\n    address _validator,\n    uint256 _missedRatio,\n    uint256 _jailDurationTier2,\n    uint256 _ratioTier1,\n    uint256 _ratioTier2\n  ) internal {\n    ISlashIndicator _slashIndicatorContract = ISlashIndicator(getContract(ContractType.SLASH_INDICATOR));\n    if (_missedRatio >= _ratioTier2) {\n      _bridgeRewardDeprecatedAtPeriod[_validator][_period] = true;\n      _miningRewardDeprecatedAtPeriod[_validator][_period] = true;\n\n      uint256 _newJailUntilBlock = Math.addIfNonZero(block.number, _jailDurationTier2);\n      _blockProducerJailedBlock[_validator] = Math.max(_newJailUntilBlock, _blockProducerJailedBlock[_validator]);\n      _cannotBailoutUntilBlock[_validator] = Math.max(_newJailUntilBlock, _cannotBailoutUntilBlock[_validator]);\n\n      _slashIndicatorContract.execSlashBridgeOperator(_validator, 2, _period);\n      emit ValidatorPunished(_validator, _period, _blockProducerJailedBlock[_validator], 0, true, true);\n    } else if (_missedRatio >= _ratioTier1) {\n      _bridgeRewardDeprecatedAtPeriod[_validator][_period] = true;\n      _slashIndicatorContract.execSlashBridgeOperator(_validator, 1, _period);\n      emit ValidatorPunished(_validator, _period, _blockProducerJailedBlock[_validator], 0, false, true);\n    }\n  }\n\n  /**\n   * @dev This loops over all current validators to:\n   * - Update delegating reward for and calculate total delegating rewards to be sent to the staking contract,\n   * - Distribute the reward of block producers and bridge operators to their treasury addresses,\n   * - Update the total deprecated reward if the two previous conditions do not sastify.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _distributeRewardToTreasuriesAndCalculateTotalDelegatingReward(\n    uint256 _lastPeriod,\n    address[] memory _currentValidators\n  ) private returns (uint256 _totalDelegatingReward, uint256[] memory _delegatingRewards) {\n    address _consensusAddr;\n    address payable _treasury;\n    _delegatingRewards = new uint256[](_currentValidators.length);\n    for (uint _i; _i < _currentValidators.length; ) {\n      _consensusAddr = _currentValidators[_i];\n      _treasury = _candidateInfo[_consensusAddr].treasuryAddr;\n\n      if (!_bridgeRewardDeprecated(_consensusAddr, _lastPeriod)) {\n        _distributeBridgeOperatingReward(_consensusAddr, _candidateInfo[_consensusAddr].bridgeOperatorAddr, _treasury);\n      } else {\n        _totalDeprecatedReward += _bridgeOperatingReward[_consensusAddr];\n      }\n\n      if (!_jailed(_consensusAddr) && !_miningRewardDeprecated(_consensusAddr, _lastPeriod)) {\n        _totalDelegatingReward += _delegatingReward[_consensusAddr];\n        _delegatingRewards[_i] = _delegatingReward[_consensusAddr];\n        _distributeMiningReward(_consensusAddr, _treasury);\n      } else {\n        _totalDeprecatedReward += _miningReward[_consensusAddr] + _delegatingReward[_consensusAddr];\n      }\n\n      delete _delegatingReward[_consensusAddr];\n      delete _miningReward[_consensusAddr];\n      delete _bridgeOperatingReward[_consensusAddr];\n\n      unchecked {\n        ++_i;\n      }\n    }\n    delete _totalBridgeReward;\n  }\n\n  /**\n   * @dev Distributes bonus of staking vesting and mining fee for the block producer.\n   *\n   * Emits the `MiningRewardDistributed` once the reward is distributed successfully.\n   * Emits the `MiningRewardDistributionFailed` once the contract fails to distribute reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _distributeMiningReward(address _consensusAddr, address payable _treasury) private {\n    uint256 _amount = _miningReward[_consensusAddr];\n    if (_amount > 0) {\n      if (_unsafeSendRON(_treasury, _amount, DEFAULT_ADDITION_GAS)) {\n        emit MiningRewardDistributed(_consensusAddr, _treasury, _amount);\n        return;\n      }\n\n      emit MiningRewardDistributionFailed(_consensusAddr, _treasury, _amount, address(this).balance);\n    }\n  }\n\n  /**\n   * @dev Distribute bonus of staking vesting for the bridge operator.\n   *\n   * Emits the `BridgeOperatorRewardDistributed` once the reward is distributed successfully.\n   * Emits the `BridgeOperatorRewardDistributionFailed` once the contract fails to distribute reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _distributeBridgeOperatingReward(\n    address _consensusAddr,\n    address _bridgeOperator,\n    address payable _treasury\n  ) private {\n    uint256 _amount = _bridgeOperatingReward[_consensusAddr];\n    if (_amount > 0) {\n      if (_unsafeSendRON(_treasury, _amount, DEFAULT_ADDITION_GAS)) {\n        emit BridgeOperatorRewardDistributed(_consensusAddr, _bridgeOperator, _treasury, _amount);\n        return;\n      }\n\n      emit BridgeOperatorRewardDistributionFailed(\n        _consensusAddr,\n        _bridgeOperator,\n        _treasury,\n        _amount,\n        address(this).balance\n      );\n    }\n  }\n\n  /**\n   * @dev Helper function to settle rewards for delegators of `_currentValidators` at the end of each period,\n   * then transfer the rewards from this contract to the staking contract, in order to finalize a period.\n   *\n   * Emits the `StakingRewardDistributed` once the reward is distributed successfully.\n   * Emits the `StakingRewardDistributionFailed` once the contract fails to distribute reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _settleAndTransferDelegatingRewards(\n    uint256 _period,\n    address[] memory _currentValidators,\n    uint256 _totalDelegatingReward,\n    uint256[] memory _delegatingRewards\n  ) private {\n    IStaking _staking = IStaking(getContract(ContractType.STAKING));\n    if (_totalDelegatingReward > 0) {\n      if (_unsafeSendRON(payable(address(_staking)), _totalDelegatingReward)) {\n        _staking.execRecordRewards(_currentValidators, _delegatingRewards, _period);\n        emit StakingRewardDistributed(_totalDelegatingReward, _currentValidators, _delegatingRewards);\n        return;\n      }\n\n      emit StakingRewardDistributionFailed(\n        _totalDelegatingReward,\n        _currentValidators,\n        _delegatingRewards,\n        address(this).balance\n      );\n    }\n  }\n\n  /**\n   * @dev Transfer the deprecated rewards e.g. the rewards that get deprecated when validator is slashed/maintained,\n   * to the staking vesting contract\n   *\n   * Note: This method should be called once in the end of each period.\n   */\n  function _recycleDeprecatedRewards() private {\n    uint256 _withdrawAmount = _totalDeprecatedReward;\n\n    if (_withdrawAmount != 0) {\n      address _withdrawTarget = getContract(ContractType.STAKING_VESTING);\n\n      delete _totalDeprecatedReward;\n\n      (bool _success, ) = _withdrawTarget.call{ value: _withdrawAmount }(\n        abi.encodeWithSelector(IStakingVesting.receiveRON.selector)\n      );\n\n      if (_success) {\n        emit DeprecatedRewardRecycled(_withdrawTarget, _withdrawAmount);\n      } else {\n        emit DeprecatedRewardRecycleFailed(_withdrawTarget, _withdrawAmount, address(this).balance);\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the validator set based on the validator candidates from the Staking contract.\n   *\n   * Emits the `ValidatorSetUpdated` event.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _syncValidatorSet(\n    uint256 _newPeriod\n  ) private returns (address[] memory _newValidators, address[] memory _unsastifiedCandidates) {\n    _unsastifiedCandidates = _syncCandidateSet(_newPeriod);\n    uint256[] memory _weights = IStaking(getContract(ContractType.STAKING)).getManyStakingTotals(_candidates);\n    uint256[] memory _trustedWeights = IRoninTrustedOrganization(getContract(ContractType.RONIN_TRUSTED_ORGANIZATION))\n      .getConsensusWeights(_candidates);\n    uint256 _newValidatorCount;\n    (_newValidators, _newValidatorCount) = _pcPickValidatorSet(\n      _candidates,\n      _weights,\n      _trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n    _setNewValidatorSet(_newValidators, _newValidatorCount, _newPeriod);\n  }\n\n  /**\n   * @dev Private helper function helps writing the new validator set into the contract storage.\n   *\n   * Emits the `ValidatorSetUpdated` event.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _setNewValidatorSet(\n    address[] memory _newValidators,\n    uint256 _newValidatorCount,\n    uint256 _newPeriod\n  ) private {\n    // Remove exceeding validators in the current set\n    for (uint256 _i = _newValidatorCount; _i < validatorCount; ) {\n      delete _validatorMap[_validators[_i]];\n      delete _validators[_i];\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // Remove flag for all validator in the current set\n    for (uint _i; _i < _newValidatorCount; ) {\n      delete _validatorMap[_validators[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // Update new validator set and set flag correspondingly.\n    for (uint256 _i; _i < _newValidatorCount; ) {\n      address _newValidator = _newValidators[_i];\n      _validatorMap[_newValidator] = EnumFlags.ValidatorFlag.Both;\n      _validators[_i] = _newValidator;\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    validatorCount = _newValidatorCount;\n    emit ValidatorSetUpdated(_newPeriod, _newValidators);\n  }\n\n  /**\n   * @dev Activate/Deactivate the validators from producing blocks, based on their in jail status and maintenance status.\n   *\n   * Requirements:\n   * - This method is called at the end of each epoch\n   *\n   * Emits the `BlockProducerSetUpdated` event.\n   * Emits the `BridgeOperatorSetUpdated` event.\n   *\n   */\n  function _revampRoles(uint256 _newPeriod, uint256 _nextEpoch, address[] memory _currentValidators) private {\n    bool[] memory _maintainedList = IMaintenance(getContract(ContractType.MAINTENANCE)).checkManyMaintained(\n      _currentValidators,\n      block.number + 1\n    );\n\n    for (uint _i; _i < _currentValidators.length; ) {\n      address _validator = _currentValidators[_i];\n      bool _emergencyExitRequested = block.timestamp <= _emergencyExitJailedTimestamp[_validator];\n      bool _isProducerBefore = isBlockProducer(_validator);\n      bool _isProducerAfter = !(_jailedAtBlock(_validator, block.number + 1) ||\n        _maintainedList[_i] ||\n        _emergencyExitRequested);\n\n      if (!_isProducerBefore && _isProducerAfter) {\n        _validatorMap[_validator] = _validatorMap[_validator].addFlag(EnumFlags.ValidatorFlag.BlockProducer);\n      } else if (_isProducerBefore && !_isProducerAfter) {\n        _validatorMap[_validator] = _validatorMap[_validator].removeFlag(EnumFlags.ValidatorFlag.BlockProducer);\n      }\n\n      bool _isBridgeOperatorBefore = isOperatingBridge(_validator);\n      bool _isBridgeOperatorAfter = !_emergencyExitRequested;\n      if (!_isBridgeOperatorBefore && _isBridgeOperatorAfter) {\n        _validatorMap[_validator] = _validatorMap[_validator].addFlag(EnumFlags.ValidatorFlag.BridgeOperator);\n      } else if (_isBridgeOperatorBefore && !_isBridgeOperatorAfter) {\n        _validatorMap[_validator] = _validatorMap[_validator].removeFlag(EnumFlags.ValidatorFlag.BridgeOperator);\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    (address[] memory _bridgeOperators, ) = getBridgeOperators();\n    emit BlockProducerSetUpdated(_newPeriod, _nextEpoch, getBlockProducers());\n    emit BridgeOperatorSetUpdated(_newPeriod, _nextEpoch, _bridgeOperators);\n  }\n\n  /**\n   * @dev Override `CandidateManager-_isTrustedOrg`.\n   */\n  function _isTrustedOrg(address _consensusAddr) internal view override returns (bool) {\n    return\n      IRoninTrustedOrganization(getContract(ContractType.RONIN_TRUSTED_ORGANIZATION)).getConsensusWeight(\n        _consensusAddr\n      ) > 0;\n  }\n}\n"
    },
    "contracts/ronin/validator/EmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../interfaces/IRoninGovernanceAdmin.sol\";\nimport \"../../interfaces/validator/IEmergencyExit.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\nimport \"./CandidateManager.sol\";\n\nabstract contract EmergencyExit is IEmergencyExit, RONTransferHelper, CandidateManager, CommonStorage {\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function emergencyExitLockedAmount() external view returns (uint256) {\n    return _emergencyExitLockedAmount;\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function emergencyExpiryDuration() external view returns (uint256) {\n    return _emergencyExpiryDuration;\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function execEmergencyExit(\n    address _consensusAddr,\n    uint256 _secLeftToRevoke\n  ) external onlyContract(ContractType.STAKING) {\n    EmergencyExitInfo storage _info = _exitInfo[_consensusAddr];\n    if (_info.recyclingAt != 0) revert ErrAlreadyRequestedEmergencyExit();\n\n    uint256 _revokingTimestamp = block.timestamp + _secLeftToRevoke;\n    _setRevokingTimestamp(_candidateInfo[_consensusAddr], _revokingTimestamp);\n    _emergencyExitJailedTimestamp[_consensusAddr] = _revokingTimestamp;\n    _bridgeRewardDeprecatedAtPeriod[_consensusAddr][currentPeriod()] = true;\n\n    uint256 _deductedAmount = IStaking(msg.sender).execDeductStakingAmount(_consensusAddr, _emergencyExitLockedAmount);\n    if (_deductedAmount > 0) {\n      uint256 _recyclingAt = block.timestamp + _emergencyExpiryDuration;\n      _lockedConsensusList.push(_consensusAddr);\n      _info.lockedAmount = _deductedAmount;\n      _info.recyclingAt = _recyclingAt;\n      IRoninGovernanceAdmin(_getAdmin()).createEmergencyExitPoll(\n        _consensusAddr,\n        _candidateInfo[_consensusAddr].treasuryAddr,\n        block.timestamp,\n        _recyclingAt\n      );\n    }\n    emit EmergencyExitRequested(_consensusAddr, _deductedAmount);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external onlyAdmin {\n    _setEmergencyExitLockedAmount(_emergencyExitLockedAmount);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external onlyAdmin {\n    _setEmergencyExpiryDuration(_emergencyExpiryDuration);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(\n    address _consensusAddr,\n    address payable _recipient\n  ) external onlyAdmin {\n    if (_exitInfo[_consensusAddr].recyclingAt == 0) {\n      return;\n    }\n\n    uint256 _length = _lockedConsensusList.length;\n    uint256 _index = _length;\n\n    for (uint _i; _i < _length; ) {\n      if (_lockedConsensusList[_i] == _consensusAddr) {\n        _index = _i;\n        break;\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // The locked amount might be recycled\n    if (_index == _length) {\n      return;\n    }\n\n    uint256 _amount = _exitInfo[_consensusAddr].lockedAmount;\n    if (_amount > 0) {\n      delete _exitInfo[_consensusAddr];\n      if (_length > 1) {\n        _lockedConsensusList[_index] = _lockedConsensusList[_length - 1];\n      }\n      _lockedConsensusList.pop();\n\n      _lockedFundReleased[_consensusAddr] = true;\n      if (_unsafeSendRON(_recipient, _amount, DEFAULT_ADDITION_GAS)) {\n        emit EmergencyExitLockedFundReleased(_consensusAddr, _recipient, _amount);\n        return;\n      }\n\n      emit EmergencyExitLockedFundReleasingFailed(_consensusAddr, _recipient, _amount, address(this).balance);\n    }\n  }\n\n  /**\n   * @dev Tries to recycle the locked funds from emergency exit requests.\n   */\n  function _tryRecycleLockedFundsFromEmergencyExits() internal {\n    uint256 _length = _lockedConsensusList.length;\n\n    uint256 _i;\n    address _addr;\n    EmergencyExitInfo storage _info;\n\n    while (_i < _length) {\n      _addr = _lockedConsensusList[_i];\n      _info = _exitInfo[_addr];\n\n      if (_info.recyclingAt <= block.timestamp) {\n        _totalDeprecatedReward += _info.lockedAmount;\n\n        delete _exitInfo[_addr];\n        if (--_length > 0) {\n          _lockedConsensusList[_i] = _lockedConsensusList[_length];\n        }\n        _lockedConsensusList.pop();\n        continue;\n      }\n\n      unchecked {\n        _i++;\n      }\n    }\n  }\n\n  /**\n   * @dev Override `CandidateManager-_emergencyExitLockedFundReleased`.\n   */\n  function _emergencyExitLockedFundReleased(address _consensusAddr) internal virtual override returns (bool) {\n    return _lockedFundReleased[_consensusAddr];\n  }\n\n  /**\n   * @dev Override `CandidateManager-_removeCandidate`.\n   */\n  function _removeCandidate(address _consensusAddr) internal override {\n    delete _lockedFundReleased[_consensusAddr];\n    super._removeCandidate(_consensusAddr);\n  }\n\n  /**\n   * @dev Override `ValidatorInfoStorage-_bridgeOperatorOf`.\n   */\n  function _bridgeOperatorOf(\n    address _consensusAddr\n  ) internal view virtual override(CandidateManager, ValidatorInfoStorage) returns (address) {\n    return CandidateManager._bridgeOperatorOf(_consensusAddr);\n  }\n\n  /**\n   * @dev See `setEmergencyExitLockedAmount.\n   */\n  function _setEmergencyExitLockedAmount(uint256 _amount) internal {\n    _emergencyExitLockedAmount = _amount;\n    emit EmergencyExitLockedAmountUpdated(_amount);\n  }\n\n  /**\n   * @dev See `setEmergencyExpiryDuration`.\n   */\n  function _setEmergencyExpiryDuration(uint256 _duration) internal {\n    _emergencyExpiryDuration = _duration;\n    emit EmergencyExpiryDurationUpdated(_duration);\n  }\n}\n"
    },
    "contracts/ronin/validator/RoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"./CoinbaseExecution.sol\";\nimport \"./SlashingExecution.sol\";\n\ncontract RoninValidatorSet is Initializable, CoinbaseExecution, SlashingExecution {\n  constructor() {\n    _disableInitializers();\n  }\n\n  fallback() external payable {\n    _fallback();\n  }\n\n  receive() external payable {\n    _fallback();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __slashIndicatorContract,\n    address __stakingContract,\n    address __stakingVestingContract,\n    address __maintenanceContract,\n    address __roninTrustedOrganizationContract,\n    address __bridgeTrackingContract,\n    uint256 __maxValidatorNumber,\n    uint256 __maxValidatorCandidate,\n    uint256 __maxPrioritizedValidatorNumber,\n    uint256 __minEffectiveDaysOnwards,\n    uint256 __numberOfBlocksInEpoch,\n    // __emergencyExitConfigs[0]: emergencyExitLockedAmount\n    // __emergencyExitConfigs[1]: emergencyExpiryDuration\n    uint256[2] calldata __emergencyExitConfigs\n  ) external initializer {\n    _setContract(ContractType.SLASH_INDICATOR, __slashIndicatorContract);\n    _setContract(ContractType.STAKING, __stakingContract);\n    _setContract(ContractType.STAKING_VESTING, __stakingVestingContract);\n    _setContract(ContractType.MAINTENANCE, __maintenanceContract);\n    _setContract(ContractType.BRIDGE_TRACKING, __bridgeTrackingContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, __roninTrustedOrganizationContract);\n\n    _setMaxValidatorNumber(__maxValidatorNumber);\n    _setMaxValidatorCandidate(__maxValidatorCandidate);\n    _setMaxPrioritizedValidatorNumber(__maxPrioritizedValidatorNumber);\n    _setMinEffectiveDaysOnwards(__minEffectiveDaysOnwards);\n    _setEmergencyExitLockedAmount(__emergencyExitConfigs[0]);\n    _setEmergencyExpiryDuration(__emergencyExitConfigs[1]);\n    _numberOfBlocksInEpoch = __numberOfBlocksInEpoch;\n  }\n\n  function initializeV2() external reinitializer(2) {\n    _setContract(ContractType.STAKING, ______deprecatedStakingContract);\n    _setContract(ContractType.MAINTENANCE, ______deprecatedMaintenance);\n    _setContract(ContractType.SLASH_INDICATOR, ______deprecatedSlashIndicator);\n    _setContract(ContractType.STAKING_VESTING, ______deprecatedStakingVesting);\n    _setContract(ContractType.BRIDGE_TRACKING, ______deprecatedBridgeTracking);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, ______deprecatedTrustedOrg);\n\n    delete ______deprecatedStakingContract;\n    delete ______deprecatedMaintenance;\n    delete ______deprecatedSlashIndicator;\n    delete ______deprecatedStakingVesting;\n    delete ______deprecatedBridgeTracking;\n    delete ______deprecatedTrustedOrg;\n  }\n\n  /**\n   * @dev Only receives RON from staking vesting contract (for topping up bonus), and from staking contract (for transferring\n   * deducting amount on slashing).\n   */\n  function _fallback() internal view {\n    if (msg.sender != getContract(ContractType.STAKING_VESTING) && msg.sender != getContract(ContractType.STAKING)) {\n      revert ErrUnauthorizedReceiveRON();\n    }\n  }\n\n  /**\n   * @dev Override `ValidatorInfoStorage-_bridgeOperatorOf`.\n   */\n  function _bridgeOperatorOf(\n    address _consensusAddr\n  ) internal view override(EmergencyExit, ValidatorInfoStorage) returns (address) {\n    return super._bridgeOperatorOf(_consensusAddr);\n  }\n}\n"
    },
    "contracts/ronin/validator/SlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../interfaces/validator/ISlashingExecution.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasSlashIndicatorDeprecated, HasStakingDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\n\nabstract contract SlashingExecution is\n  ISlashingExecution,\n  HasContracts,\n  HasSlashIndicatorDeprecated,\n  HasStakingDeprecated,\n  CommonStorage\n{\n  /**\n   * @inheritdoc ISlashingExecution\n   */\n  function execSlash(\n    address _validatorAddr,\n    uint256 _newJailedUntil,\n    uint256 _slashAmount,\n    bool _cannotBailout\n  ) external override onlyContract(ContractType.SLASH_INDICATOR) {\n    uint256 _period = currentPeriod();\n    _miningRewardDeprecatedAtPeriod[_validatorAddr][_period] = true;\n\n    _totalDeprecatedReward += _miningReward[_validatorAddr] + _delegatingReward[_validatorAddr];\n\n    delete _miningReward[_validatorAddr];\n    delete _delegatingReward[_validatorAddr];\n\n    _blockProducerJailedBlock[_validatorAddr] = Math.max(_newJailedUntil, _blockProducerJailedBlock[_validatorAddr]);\n\n    if (_slashAmount > 0) {\n      uint256 _actualAmount = IStaking(getContract(ContractType.STAKING)).execDeductStakingAmount(\n        _validatorAddr,\n        _slashAmount\n      );\n      _totalDeprecatedReward += _actualAmount;\n    }\n\n    if (_cannotBailout) {\n      _cannotBailoutUntilBlock[_validatorAddr] = Math.max(_newJailedUntil, _cannotBailoutUntilBlock[_validatorAddr]);\n    }\n\n    emit ValidatorPunished(\n      _validatorAddr,\n      _period,\n      _blockProducerJailedBlock[_validatorAddr],\n      _slashAmount,\n      true,\n      false\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashingExecution\n   */\n  function execBailOut(\n    address _validatorAddr,\n    uint256 _period\n  ) external override onlyContract(ContractType.SLASH_INDICATOR) {\n    if (block.number <= _cannotBailoutUntilBlock[_validatorAddr]) revert ErrCannotBailout(_validatorAddr);\n\n    // Note: Removing rewards of validator in `bailOut` function is not needed, since the rewards have been\n    // removed previously in the `slash` function.\n    _miningRewardBailoutCutOffAtPeriod[_validatorAddr][_period] = true;\n    _miningRewardDeprecatedAtPeriod[_validatorAddr][_period] = false;\n    _blockProducerJailedBlock[_validatorAddr] = block.number - 1;\n\n    emit ValidatorUnjailed(_validatorAddr, _period);\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/CommonStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../interfaces/validator/info-fragments/ICommonInfo.sol\";\nimport \"./JailingStorage.sol\";\nimport \"./TimingStorage.sol\";\nimport \"./ValidatorInfoStorage.sol\";\n\nabstract contract CommonStorage is ICommonInfo, TimingStorage, JailingStorage, ValidatorInfoStorage {\n  /// @dev Mapping from consensus address => pending reward from producing block\n  mapping(address => uint256) internal _miningReward;\n  /// @dev Mapping from consensus address => pending reward from delegating\n  mapping(address => uint256) internal _delegatingReward;\n\n  /// @dev The total reward for bridge operators\n  uint256 internal _totalBridgeReward;\n  /// @dev Mapping from consensus address => pending reward for being bridge operator\n  mapping(address => uint256) internal _bridgeOperatingReward;\n\n  /// @dev The deprecated reward that has not been withdrawn by admin\n  uint256 internal _totalDeprecatedReward;\n\n  /// @dev The amount of RON to lock from a consensus address.\n  uint256 internal _emergencyExitLockedAmount;\n  /// @dev The duration that an emergency request is expired and the fund will be recycled.\n  uint256 internal _emergencyExpiryDuration;\n  /// @dev The address list of consensus addresses that being locked fund.\n  address[] internal _lockedConsensusList;\n  /// @dev Mapping from consensus => request exist info\n  mapping(address => EmergencyExitInfo) internal _exitInfo;\n  /// @dev Mapping from consensus => flag indicating whether the locked fund is released\n  mapping(address => bool) internal _lockedFundReleased;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[44] private ______gap;\n\n  /**\n   * @inheritdoc ICommonInfo\n   */\n  function getEmergencyExitInfo(\n    address _consensusAddr\n  ) external view override returns (EmergencyExitInfo memory _info) {\n    _info = _exitInfo[_consensusAddr];\n    if (_info.recyclingAt == 0) revert NonExistentRecyclingInfo();\n  }\n\n  /**\n   * @inheritdoc ICommonInfo\n   */\n  function totalDeprecatedReward() external view override returns (uint256) {\n    return _totalDeprecatedReward;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochOf(\n    uint256 _block\n  ) public view virtual override(ITimingInfo, JailingStorage, TimingStorage) returns (uint256) {\n    return TimingStorage.epochOf(_block);\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriod() public view virtual override(ITimingInfo, JailingStorage, TimingStorage) returns (uint256) {\n    return TimingStorage.currentPeriod();\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/JailingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../interfaces/validator/info-fragments/IJailingInfo.sol\";\nimport \"./TimingStorage.sol\";\n\nabstract contract JailingStorage is IJailingInfo {\n  /// @dev Mapping from consensus address => period number => block producer has no pending reward.\n  mapping(address => mapping(uint256 => bool)) internal _miningRewardDeprecatedAtPeriod;\n  /// @dev Mapping from consensus address => period number => whether the block producer get cut off reward, due to bailout.\n  mapping(address => mapping(uint256 => bool)) internal _miningRewardBailoutCutOffAtPeriod;\n  /// @dev Mapping from consensus address => period number => block operator has no pending reward.\n  mapping(address => mapping(uint256 => bool)) internal _bridgeRewardDeprecatedAtPeriod;\n\n  /// @dev Mapping from consensus address => the last block that the block producer is jailed.\n  mapping(address => uint256) internal _blockProducerJailedBlock;\n  /// @dev Mapping from consensus address => the last timestamp that the bridge operator is jailed.\n  mapping(address => uint256) internal _emergencyExitJailedTimestamp;\n  /// @dev Mapping from consensus address => the last block that the block producer cannot bailout.\n  mapping(address => uint256) internal _cannotBailoutUntilBlock;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] private ______gap;\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkJailed(address _addr) external view override returns (bool) {\n    return checkJailedAtBlock(_addr, block.number);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function getJailedTimeLeft(\n    address _addr\n  ) external view override returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_) {\n    return getJailedTimeLeftAtBlock(_addr, block.number);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkJailedAtBlock(address _addr, uint256 _blockNum) public view override returns (bool) {\n    return _jailedAtBlock(_addr, _blockNum);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function getJailedTimeLeftAtBlock(\n    address _addr,\n    uint256 _blockNum\n  ) public view override returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_) {\n    uint256 _jailedBlock = _blockProducerJailedBlock[_addr];\n    if (_jailedBlock < _blockNum) {\n      return (false, 0, 0);\n    }\n\n    isJailed_ = true;\n    blockLeft_ = _jailedBlock - _blockNum + 1;\n    epochLeft_ = epochOf(_jailedBlock) - epochOf(_blockNum) + 1;\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkManyJailed(address[] calldata _addrList) external view override returns (bool[] memory _result) {\n    _result = new bool[](_addrList.length);\n    for (uint256 _i; _i < _addrList.length; ) {\n      _result[_i] = _jailed(_addrList[_i]);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkMiningRewardDeprecated(address _blockProducer) external view override returns (bool _result) {\n    uint256 _period = currentPeriod();\n    return _miningRewardDeprecated(_blockProducer, _period);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkMiningRewardDeprecatedAtPeriod(\n    address _blockProducer,\n    uint256 _period\n  ) external view override returns (bool _result) {\n    return _miningRewardDeprecated(_blockProducer, _period);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   *\n   * @dev Because the information of deprecating bridge reward of a period is only determined at the end of that period, this\n   * method will return the deprecating info of the latest period. A method for querying that info of current period is no need.\n   */\n  function checkBridgeRewardDeprecatedAtLatestPeriod(\n    address _consensusAddr\n  ) external view override returns (bool _result) {\n    uint256 _period = currentPeriod() - 1;\n    return _bridgeRewardDeprecated(_consensusAddr, _period);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkBridgeRewardDeprecatedAtPeriod(\n    address _consensusAddr,\n    uint256 _period\n  ) external view override returns (bool _result) {\n    return _bridgeRewardDeprecated(_consensusAddr, _period);\n  }\n\n  /**\n   * @dev See `ITimingInfo-epochOf`\n   */\n  function epochOf(uint256 _block) public view virtual returns (uint256);\n\n  /**\n   * @dev See `ITimingInfo-currentPeriod`\n   */\n  function currentPeriod() public view virtual returns (uint256);\n\n  /**\n   * @dev Returns whether the reward of the validator is put in jail (cannot join the set of validators) during the current period.\n   */\n  function _jailed(address _validatorAddr) internal view returns (bool) {\n    return _jailedAtBlock(_validatorAddr, block.number);\n  }\n\n  /**\n   * @dev Returns whether the reward of the validator is put in jail (cannot join the set of validators) at a specific block.\n   */\n  function _jailedAtBlock(address _validatorAddr, uint256 _blockNum) internal view returns (bool) {\n    return _blockNum <= _blockProducerJailedBlock[_validatorAddr];\n  }\n\n  /**\n   * @dev Returns whether the block producer has no pending reward in that period.\n   */\n  function _miningRewardDeprecated(address _validatorAddr, uint256 _period) internal view returns (bool) {\n    return _miningRewardDeprecatedAtPeriod[_validatorAddr][_period];\n  }\n\n  /**\n   * @dev Returns whether the bridge operator has no pending reward in the period.\n   */\n  function _bridgeRewardDeprecated(address _validatorAddr, uint256 _period) internal view returns (bool) {\n    return _bridgeRewardDeprecatedAtPeriod[_validatorAddr][_period];\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/TimingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../../interfaces/validator/info-fragments/ITimingInfo.sol\";\n\nabstract contract TimingStorage is ITimingInfo, GlobalConfigConsumer {\n  /// @dev The number of blocks in a epoch\n  uint256 internal _numberOfBlocksInEpoch;\n  /// @dev The last updated block\n  uint256 internal _lastUpdatedBlock;\n  /// @dev The last updated period\n  uint256 internal _lastUpdatedPeriod;\n  /// @dev The starting block of the last updated period\n  uint256 internal _currentPeriodStartAtBlock;\n\n  /// @dev Mapping from epoch index => period index\n  mapping(uint256 => uint256) internal _periodOf;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[49] private ______gap;\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function getLastUpdatedBlock() external view override returns (uint256) {\n    return _lastUpdatedBlock;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochOf(uint256 _block) public view virtual override returns (uint256) {\n    return _block / _numberOfBlocksInEpoch + 1;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber) {\n    return (_epoch <= epochOf(block.number) || _periodOf[_epoch] > 0, _periodOf[_epoch]);\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function isPeriodEnding() external view override returns (bool) {\n    return _isPeriodEnding(_computePeriod(block.timestamp));\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochEndingAt(uint256 _block) public view virtual override returns (bool) {\n    return _block % _numberOfBlocksInEpoch == _numberOfBlocksInEpoch - 1;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriod() public view virtual override returns (uint256) {\n    return _lastUpdatedPeriod;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriodStartAtBlock() public view override returns (uint256) {\n    return _currentPeriodStartAtBlock;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function numberOfBlocksInEpoch() public view virtual override returns (uint256 _numberOfBlocks) {\n    return _numberOfBlocksInEpoch;\n  }\n\n  /**\n   * @dev See `ITimingInfo-isPeriodEnding`\n   */\n  function _isPeriodEnding(uint256 _newPeriod) internal view virtual returns (bool) {\n    return _newPeriod > _lastUpdatedPeriod;\n  }\n\n  /**\n   * @dev Returns the calculated period.\n   */\n  function _computePeriod(uint256 _timestamp) internal pure returns (uint256) {\n    return _timestamp / PERIOD_DURATION;\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/ValidatorInfoStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\nimport { HasTrustedOrgDeprecated } from \"../../../utils/DeprecatedSlots.sol\";\nimport \"../../../extensions/collections/HasContracts.sol\";\nimport \"../../../interfaces/validator/info-fragments/IValidatorInfo.sol\";\n\nabstract contract ValidatorInfoStorage is IValidatorInfo, HasContracts, HasTrustedOrgDeprecated {\n  using EnumFlags for EnumFlags.ValidatorFlag;\n\n  /// @dev The maximum number of validator.\n  uint256 internal _maxValidatorNumber;\n\n  /// @dev The total of validators\n  uint256 public validatorCount;\n  /// @dev Mapping from validator index => validator address\n  mapping(uint256 => address) internal _validators;\n  /// @dev Mapping from address => flag indicating the validator ability: producing block, operating bridge\n  mapping(address => EnumFlags.ValidatorFlag) internal _validatorMap;\n  /// @dev The number of slot that is reserved for prioritized validators\n  uint256 internal _maxPrioritizedValidatorNumber;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function getValidators()\n    public\n    view\n    override\n    returns (\n      address[] memory _validatorList,\n      address[] memory _bridgeOperators,\n      EnumFlags.ValidatorFlag[] memory _flags\n    )\n  {\n    _validatorList = new address[](validatorCount);\n    _bridgeOperators = new address[](validatorCount);\n    _flags = new EnumFlags.ValidatorFlag[](validatorCount);\n    for (uint _i; _i < _validatorList.length; ) {\n      address _validator = _validators[_i];\n      _validatorList[_i] = _validator;\n      _bridgeOperators[_i] = _bridgeOperatorOf(_validator);\n      _flags[_i] = _validatorMap[_validator];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function isValidator(address _addr) public view override returns (bool) {\n    return !_validatorMap[_addr].isNone();\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function getBlockProducers() public view override returns (address[] memory _result) {\n    _result = new address[](validatorCount);\n    uint256 _count = 0;\n    for (uint _i; _i < _result.length; ) {\n      if (isBlockProducer(_validators[_i])) {\n        _result[_count++] = _validators[_i];\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    assembly {\n      mstore(_result, _count)\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function isBlockProducer(address _addr) public view override returns (bool) {\n    return _validatorMap[_addr].hasFlag(EnumFlags.ValidatorFlag.BlockProducer);\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function totalBlockProducers() external view returns (uint256 _total) {\n    unchecked {\n      for (uint _i; _i < validatorCount; _i++) {\n        if (isBlockProducer(_validators[_i])) {\n          _total++;\n        }\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function getBridgeOperators()\n    public\n    view\n    override\n    returns (address[] memory _bridgeOperatorList, address[] memory _validatorList)\n  {\n    uint256 _length = validatorCount;\n    _bridgeOperatorList = new address[](_length);\n    _validatorList = new address[](_length);\n    uint256 _count = 0;\n    unchecked {\n      for (uint _i; _i < _length; ++_i) {\n        if (isOperatingBridge(_validators[_i])) {\n          address __validator = _validators[_i];\n          _bridgeOperatorList[_count] = _bridgeOperatorOf(__validator);\n          _validatorList[_count++] = __validator;\n        }\n      }\n    }\n\n    assembly {\n      mstore(_bridgeOperatorList, _count)\n      mstore(_validatorList, _count)\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function getBridgeOperatorsOf(\n    address[] memory _validatorAddrs\n  ) public view override returns (address[] memory _bridgeOperatorList) {\n    _bridgeOperatorList = new address[](_validatorAddrs.length);\n    for (uint _i; _i < _bridgeOperatorList.length; ) {\n      _bridgeOperatorList[_i] = _bridgeOperatorOf(_validatorAddrs[_i]);\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function isBridgeOperator(address _bridgeOperatorAddr) external view override returns (bool _isOperator) {\n    for (uint _i; _i < validatorCount; ) {\n      if (_bridgeOperatorOf(_validators[_i]) == _bridgeOperatorAddr && isOperatingBridge(_validators[_i])) {\n        _isOperator = true;\n        break;\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function isOperatingBridge(address _consensusAddr) public view override returns (bool) {\n    return _validatorMap[_consensusAddr].hasFlag(EnumFlags.ValidatorFlag.BridgeOperator);\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function maxValidatorNumber() external view override returns (uint256 _maximumValidatorNumber) {\n    return _maxValidatorNumber;\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function maxPrioritizedValidatorNumber() external view override returns (uint256 _maximumPrioritizedValidatorNumber) {\n    return _maxPrioritizedValidatorNumber;\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function totalBridgeOperators() public view returns (uint256 _total) {\n    unchecked {\n      for (uint _i; _i < validatorCount; _i++) {\n        if (isOperatingBridge(_validators[_i])) {\n          _total++;\n        }\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function setMaxValidatorNumber(uint256 _max) external override onlyAdmin {\n    _setMaxValidatorNumber(_max);\n  }\n\n  /**\n   * @inheritdoc IValidatorInfo\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _number) external override onlyAdmin {\n    _setMaxPrioritizedValidatorNumber(_number);\n  }\n\n  /**\n   * @dev Returns the bridge operator of a consensus address.\n   */\n  function _bridgeOperatorOf(address _consensusAddr) internal view virtual returns (address);\n\n  /**\n   * @dev See `IValidatorInfo-setMaxValidatorNumber`\n   */\n  function _setMaxValidatorNumber(uint256 _number) internal {\n    _maxValidatorNumber = _number;\n    emit MaxValidatorNumberUpdated(_number);\n  }\n\n  /**\n   * @dev See `IValidatorInfo-setMaxPrioritizedValidatorNumber`\n   */\n  function _setMaxPrioritizedValidatorNumber(uint256 _number) internal {\n    if (_number > _maxValidatorNumber) revert ErrInvalidMaxPrioritizedValidatorNumber();\n    _maxPrioritizedValidatorNumber = _number;\n    emit MaxPrioritizedValidatorNumberUpdated(_number);\n  }\n}\n"
    },
    "contracts/utils/CommonErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ContractType } from \"./ContractType.sol\";\nimport { RoleAccess } from \"./RoleAccess.sol\";\n\n/**\n * @dev Error indicating that the provided threshold is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that the invalid threshold applies to.\n */\nerror ErrInvalidThreshold(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a function can only be called by the contract itself.\n * @param msgSig The function signature (bytes4) that can only be called by the contract itself.\n */\nerror ErrOnlySelfCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n * @param expectedRole The role required to perform the function.\n */\nerror ErrUnauthorized(bytes4 msgSig, RoleAccess expectedRole);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4).\n * @param expectedContractType The contract type required to perform the function.\n * @param actual The actual address that called to the function.\n */\nerror ErrUnexpectedInternalCall(bytes4 msgSig, ContractType expectedContractType, address actual);\n\n/**\n * @dev Error indicating that an array is empty when it should contain elements.\n */\nerror ErrEmptyArray();\n\n/**\n * @dev Error indicating a mismatch in the length of input parameters or arrays for a specific function.\n * @param msgSig The function signature (bytes4) that has a length mismatch.\n */\nerror ErrLengthMismatch(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a proxy call to an external contract has failed.\n * @param msgSig The function signature (bytes4) of the proxy call that failed.\n * @param extCallSig The function signature (bytes4) of the external contract call that failed.\n */\nerror ErrProxyCallFailed(bytes4 msgSig, bytes4 extCallSig);\n\n/**\n * @dev Error indicating that a function tried to call a precompiled contract that is not allowed.\n * @param msgSig The function signature (bytes4) that attempted to call a precompiled contract.\n */\nerror ErrCallPrecompiled(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a native token transfer has failed.\n * @param msgSig The function signature (bytes4) of the token transfer that failed.\n */\nerror ErrNativeTransferFailed(bytes4 msgSig);\n\n/**\n * @dev Error indicating that an order is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid order.\n */\nerror ErrInvalidOrder(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the chain ID is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid chain ID.\n * @param actual Current chain ID that executing function.\n * @param expected Expected chain ID required for the tx to success.\n */\nerror ErrInvalidChainId(bytes4 msgSig, uint256 actual, uint256 expected);\n\n/**\n * @dev Error indicating that a vote type is not supported.\n * @param msgSig The function signature (bytes4) of the operation that encountered an unsupported vote type.\n */\nerror ErrUnsupportedVoteType(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the proposal nonce is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid proposal nonce.\n */\nerror ErrInvalidProposalNonce(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a voter has already voted.\n * @param voter The address of the voter who has already voted.\n */\nerror ErrAlreadyVoted(address voter);\n\n/**\n * @dev Error indicating that a signature is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid signature.\n */\nerror ErrInvalidSignatures(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a relay call has failed.\n * @param msgSig The function signature (bytes4) of the relay call that failed.\n */\nerror ErrRelayFailed(bytes4 msgSig);\n/**\n * @dev Error indicating that a vote weight is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid vote weight.\n */\nerror ErrInvalidVoteWeight(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a query was made for an outdated bridge operator set.\n */\nerror ErrQueryForOutdatedBridgeOperatorSet();\n\n/**\n * @dev Error indicating that a request is invalid.\n */\nerror ErrInvalidRequest();\n\n/**\n * @dev Error indicating that a token standard is invalid.\n */\nerror ErrInvalidTokenStandard();\n\n/**\n * @dev Error indicating that a token is not supported.\n */\nerror ErrUnsupportedToken();\n\n/**\n * @dev Error indicating that a receipt kind is invalid.\n */\nerror ErrInvalidReceiptKind();\n\n/**\n * @dev Error indicating that a receipt is invalid.\n */\nerror ErrInvalidReceipt();\n"
    },
    "contracts/utils/ContractType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum ContractType {\n  /*  0 */ UNKNOWN,\n  /*  1 */ PAUSE_ENFORCER,\n  /*  2 */ BRIDGE,\n  /*  3 */ BRIDGE_TRACKING,\n  /*  4 */ GOVERNANCE_ADMIN,\n  /*  5 */ MAINTENANCE,\n  /*  6 */ SLASH_INDICATOR,\n  /*  7 */ STAKING_VESTING,\n  /*  8 */ VALIDATOR,\n  /*  9 */ STAKING,\n  /* 10 */ RONIN_TRUSTED_ORGANIZATION\n}\n"
    },
    "contracts/utils/DeprecatedSlots.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Deprecated Contracts\n * @dev These abstract contracts are deprecated and should not be used in new implementations.\n * They provide functionality related to various aspects of a smart contract but have been marked\n * as deprecated to indicate that they are no longer actively maintained or recommended for use.\n * The purpose of these contracts is to preserve the slots for already deployed contracts.\n */\ncontract HasSlashIndicatorDeprecated {\n  /// @custom:deprecated Previously `_slashIndicatorContract` (non-zero value)\n  address internal ______deprecatedSlashIndicator;\n}\n\ncontract HasStakingVestingDeprecated {\n  /// @custom:deprecated Previously `_stakingVestingContract` (non-zero value)\n  address internal ______deprecatedStakingVesting;\n}\n\ncontract HasBridgeDeprecated {\n  /// @custom:deprecated Previously `_bridgeContract` (non-zero value)\n  address internal ______deprecatedBridge;\n}\n\ncontract HasValidatorDeprecated {\n  /// @custom:deprecated Previously `_validatorContract` (non-zero value)\n  address internal ______deprecatedValidator;\n}\n\ncontract HasStakingDeprecated {\n  /// @custom:deprecated Previously `_stakingContract` (non-zero value)\n  address internal ______deprecatedStakingContract;\n}\n\ncontract HasMaintenanceDeprecated {\n  /// @custom:deprecated Previously `_maintenanceContract` (non-zero value)\n  address internal ______deprecatedMaintenance;\n}\n\ncontract HasTrustedOrgDeprecated {\n  /// @custom:deprecated Previously `_trustedOrgContract` (non-zero value)\n  address internal ______deprecatedTrustedOrg;\n}\n\ncontract HasGovernanceAdminDeprecated {\n  /// @custom:deprecated Previously `_governanceAdminContract` (non-zero value)\n  address internal ______deprecatedGovernanceAdmin;\n}\n\ncontract HasBridgeTrackingDeprecated {\n  /// @custom:deprecated Previously `_bridgeTrackingContract` (non-zero value)\n  address internal ______deprecatedBridgeTracking;\n}\n"
    },
    "contracts/utils/RoleAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum RoleAccess {\n  /* 0 */ UNKNOWN,\n  /* 1 */ ADMIN,\n  /* 2 */ COINBASE,\n  /* 3 */ GOVERNOR,\n  /* 4 */ CANDIDATE_ADMIN,\n  /* 5 */ WITHDRAWAL_MIGRATOR,\n  /* 6 */ BRIDGE_OPERATOR,\n  /* 7 */ BLOCK_PRODUCER,\n  /* 8 */ VALIDATOR_CANDIDATE\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    },
    "remappings": [
      "@ronin/contracts/=./contracts/",
      "bridge-operator-governance/=contracts/extensions/bridge-operator-governance/",
      "collections/=contracts/extensions/collections/",
      "consumers/=contracts/extensions/consumers/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "forwarder/=contracts/extensions/forwarder/",
      "sequential-governance/=contracts/extensions/sequential-governance/",
      "slash-indicator/=contracts/interfaces/slash-indicator/",
      "staking/=contracts/interfaces/staking/",
      "validator/=contracts/interfaces/validator/",
      "version-control/=contracts/extensions/version-control/"
    ]
  }
}